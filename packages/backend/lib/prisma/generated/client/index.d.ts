
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model Size
 * 
 */
export type Size = $Result.DefaultSelection<Prisma.$SizePayload>
/**
 * Model Source
 * 
 */
export type Source = $Result.DefaultSelection<Prisma.$SourcePayload>
/**
 * Model Language
 * 
 */
export type Language = $Result.DefaultSelection<Prisma.$LanguagePayload>
/**
 * Model Biome
 * 
 */
export type Biome = $Result.DefaultSelection<Prisma.$BiomePayload>
/**
 * Model Type
 * 
 */
export type Type = $Result.DefaultSelection<Prisma.$TypePayload>
/**
 * Model Alignment
 * 
 */
export type Alignment = $Result.DefaultSelection<Prisma.$AlignmentPayload>
/**
 * Model CreatureSpeed
 * 
 */
export type CreatureSpeed = $Result.DefaultSelection<Prisma.$CreatureSpeedPayload>
/**
 * Model CreatureStats
 * 
 */
export type CreatureStats = $Result.DefaultSelection<Prisma.$CreatureStatsPayload>
/**
 * Model CreatureStatDetail
 * 
 */
export type CreatureStatDetail = $Result.DefaultSelection<Prisma.$CreatureStatDetailPayload>
/**
 * Model CreatureSkills
 * 
 */
export type CreatureSkills = $Result.DefaultSelection<Prisma.$CreatureSkillsPayload>
/**
 * Model CreatureSkillDetail
 * 
 */
export type CreatureSkillDetail = $Result.DefaultSelection<Prisma.$CreatureSkillDetailPayload>
/**
 * Model SkillMetadata
 * 
 */
export type SkillMetadata = $Result.DefaultSelection<Prisma.$SkillMetadataPayload>
/**
 * Model Creature
 * 
 */
export type Creature = $Result.DefaultSelection<Prisma.$CreaturePayload>
/**
 * Model CreatureSenses
 * 
 */
export type CreatureSenses = $Result.DefaultSelection<Prisma.$CreatureSensesPayload>
/**
 * Model Action
 * 
 */
export type Action = $Result.DefaultSelection<Prisma.$ActionPayload>
/**
 * Model Trait
 * 
 */
export type Trait = $Result.DefaultSelection<Prisma.$TraitPayload>
/**
 * Model CreatureRace
 * 
 */
export type CreatureRace = $Result.DefaultSelection<Prisma.$CreatureRacePayload>
/**
 * Model DamageType
 * 
 */
export type DamageType = $Result.DefaultSelection<Prisma.$DamageTypePayload>
/**
 * Model ChallengeRatingMetadata
 * 
 */
export type ChallengeRatingMetadata = $Result.DefaultSelection<Prisma.$ChallengeRatingMetadataPayload>
/**
 * Model GenrationRequest
 * 
 */
export type GenrationRequest = $Result.DefaultSelection<Prisma.$GenrationRequestPayload>
/**
 * Model GPTMessageHistory
 * 
 */
export type GPTMessageHistory = $Result.DefaultSelection<Prisma.$GPTMessageHistoryPayload>
/**
 * Model GPTMessage
 * 
 */
export type GPTMessage = $Result.DefaultSelection<Prisma.$GPTMessagePayload>
/**
 * Model Adventure
 * 
 */
export type Adventure = $Result.DefaultSelection<Prisma.$AdventurePayload>
/**
 * Model Keyword
 * 
 */
export type Keyword = $Result.DefaultSelection<Prisma.$KeywordPayload>
/**
 * Model Genre
 * 
 */
export type Genre = $Result.DefaultSelection<Prisma.$GenrePayload>
/**
 * Model MagicItem
 * 
 */
export type MagicItem = $Result.DefaultSelection<Prisma.$MagicItemPayload>
/**
 * Model MagicItemRarity
 * 
 */
export type MagicItemRarity = $Result.DefaultSelection<Prisma.$MagicItemRarityPayload>
/**
 * Model MagicItemType
 * 
 */
export type MagicItemType = $Result.DefaultSelection<Prisma.$MagicItemTypePayload>
/**
 * Model AttunementCondition
 * 
 */
export type AttunementCondition = $Result.DefaultSelection<Prisma.$AttunementConditionPayload>
/**
 * Model MagicItemAttunement
 * 
 */
export type MagicItemAttunement = $Result.DefaultSelection<Prisma.$MagicItemAttunementPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const Ability: {
  STRENGTH: 'STRENGTH',
  DEXTERITY: 'DEXTERITY',
  CONSTITUTION: 'CONSTITUTION',
  INTELLIGENCE: 'INTELLIGENCE',
  WISDOM: 'WISDOM',
  CHARISMA: 'CHARISMA'
};

export type Ability = (typeof Ability)[keyof typeof Ability]


export const Skill: {
  ATHLETICS: 'ATHLETICS',
  ACROBATICS: 'ACROBATICS',
  SLEIGHT_OF_HAND: 'SLEIGHT_OF_HAND',
  STEALTH: 'STEALTH',
  ARCANA: 'ARCANA',
  HISTORY: 'HISTORY',
  INVESTIGATION: 'INVESTIGATION',
  NATURE: 'NATURE',
  RELIGION: 'RELIGION',
  ANIMAL_HANDLING: 'ANIMAL_HANDLING',
  INSIGHT: 'INSIGHT',
  MEDICINE: 'MEDICINE',
  PERCEPTION: 'PERCEPTION',
  SURVIVAL: 'SURVIVAL',
  DECEPTION: 'DECEPTION',
  INTIMIDATION: 'INTIMIDATION',
  PERFORMANCE: 'PERFORMANCE',
  PERSUASION: 'PERSUASION'
};

export type Skill = (typeof Skill)[keyof typeof Skill]


export const ChallengeRatingEnum: {
  CR_0: 'CR_0',
  CR_1_8: 'CR_1_8',
  CR_1_4: 'CR_1_4',
  CR_1_2: 'CR_1_2',
  CR_1: 'CR_1',
  CR_2: 'CR_2',
  CR_3: 'CR_3',
  CR_4: 'CR_4',
  CR_5: 'CR_5',
  CR_6: 'CR_6',
  CR_7: 'CR_7',
  CR_8: 'CR_8',
  CR_9: 'CR_9',
  CR_10: 'CR_10',
  CR_11: 'CR_11',
  CR_12: 'CR_12',
  CR_13: 'CR_13',
  CR_14: 'CR_14',
  CR_15: 'CR_15',
  CR_16: 'CR_16',
  CR_17: 'CR_17',
  CR_18: 'CR_18',
  CR_19: 'CR_19',
  CR_20: 'CR_20',
  CR_21: 'CR_21',
  CR_22: 'CR_22',
  CR_23: 'CR_23',
  CR_24: 'CR_24',
  CR_25: 'CR_25',
  CR_26: 'CR_26',
  CR_27: 'CR_27',
  CR_28: 'CR_28',
  CR_29: 'CR_29',
  CR_30: 'CR_30'
};

export type ChallengeRatingEnum = (typeof ChallengeRatingEnum)[keyof typeof ChallengeRatingEnum]


export const Gender: {
  HE: 'HE',
  SHE: 'SHE',
  IT: 'IT'
};

export type Gender = (typeof Gender)[keyof typeof Gender]

}

export type Ability = $Enums.Ability

export const Ability: typeof $Enums.Ability

export type Skill = $Enums.Skill

export const Skill: typeof $Enums.Skill

export type ChallengeRatingEnum = $Enums.ChallengeRatingEnum

export const ChallengeRatingEnum: typeof $Enums.ChallengeRatingEnum

export type Gender = $Enums.Gender

export const Gender: typeof $Enums.Gender

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Sizes
 * const sizes = await prisma.size.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Sizes
   * const sizes = await prisma.size.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb, ExtArgs, $Utils.Call<Prisma.TypeMapCb, {
    extArgs: ExtArgs
  }>, ClientOptions>

      /**
   * `prisma.size`: Exposes CRUD operations for the **Size** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Sizes
    * const sizes = await prisma.size.findMany()
    * ```
    */
  get size(): Prisma.SizeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.source`: Exposes CRUD operations for the **Source** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Sources
    * const sources = await prisma.source.findMany()
    * ```
    */
  get source(): Prisma.SourceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.language`: Exposes CRUD operations for the **Language** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Languages
    * const languages = await prisma.language.findMany()
    * ```
    */
  get language(): Prisma.LanguageDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.biome`: Exposes CRUD operations for the **Biome** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Biomes
    * const biomes = await prisma.biome.findMany()
    * ```
    */
  get biome(): Prisma.BiomeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.type`: Exposes CRUD operations for the **Type** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Types
    * const types = await prisma.type.findMany()
    * ```
    */
  get type(): Prisma.TypeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.alignment`: Exposes CRUD operations for the **Alignment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Alignments
    * const alignments = await prisma.alignment.findMany()
    * ```
    */
  get alignment(): Prisma.AlignmentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.creatureSpeed`: Exposes CRUD operations for the **CreatureSpeed** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CreatureSpeeds
    * const creatureSpeeds = await prisma.creatureSpeed.findMany()
    * ```
    */
  get creatureSpeed(): Prisma.CreatureSpeedDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.creatureStats`: Exposes CRUD operations for the **CreatureStats** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CreatureStats
    * const creatureStats = await prisma.creatureStats.findMany()
    * ```
    */
  get creatureStats(): Prisma.CreatureStatsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.creatureStatDetail`: Exposes CRUD operations for the **CreatureStatDetail** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CreatureStatDetails
    * const creatureStatDetails = await prisma.creatureStatDetail.findMany()
    * ```
    */
  get creatureStatDetail(): Prisma.CreatureStatDetailDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.creatureSkills`: Exposes CRUD operations for the **CreatureSkills** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CreatureSkills
    * const creatureSkills = await prisma.creatureSkills.findMany()
    * ```
    */
  get creatureSkills(): Prisma.CreatureSkillsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.creatureSkillDetail`: Exposes CRUD operations for the **CreatureSkillDetail** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CreatureSkillDetails
    * const creatureSkillDetails = await prisma.creatureSkillDetail.findMany()
    * ```
    */
  get creatureSkillDetail(): Prisma.CreatureSkillDetailDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.skillMetadata`: Exposes CRUD operations for the **SkillMetadata** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SkillMetadata
    * const skillMetadata = await prisma.skillMetadata.findMany()
    * ```
    */
  get skillMetadata(): Prisma.SkillMetadataDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.creature`: Exposes CRUD operations for the **Creature** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Creatures
    * const creatures = await prisma.creature.findMany()
    * ```
    */
  get creature(): Prisma.CreatureDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.creatureSenses`: Exposes CRUD operations for the **CreatureSenses** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CreatureSenses
    * const creatureSenses = await prisma.creatureSenses.findMany()
    * ```
    */
  get creatureSenses(): Prisma.CreatureSensesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.action`: Exposes CRUD operations for the **Action** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Actions
    * const actions = await prisma.action.findMany()
    * ```
    */
  get action(): Prisma.ActionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.trait`: Exposes CRUD operations for the **Trait** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Traits
    * const traits = await prisma.trait.findMany()
    * ```
    */
  get trait(): Prisma.TraitDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.creatureRace`: Exposes CRUD operations for the **CreatureRace** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CreatureRaces
    * const creatureRaces = await prisma.creatureRace.findMany()
    * ```
    */
  get creatureRace(): Prisma.CreatureRaceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.damageType`: Exposes CRUD operations for the **DamageType** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DamageTypes
    * const damageTypes = await prisma.damageType.findMany()
    * ```
    */
  get damageType(): Prisma.DamageTypeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.challengeRatingMetadata`: Exposes CRUD operations for the **ChallengeRatingMetadata** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ChallengeRatingMetadata
    * const challengeRatingMetadata = await prisma.challengeRatingMetadata.findMany()
    * ```
    */
  get challengeRatingMetadata(): Prisma.ChallengeRatingMetadataDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.genrationRequest`: Exposes CRUD operations for the **GenrationRequest** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more GenrationRequests
    * const genrationRequests = await prisma.genrationRequest.findMany()
    * ```
    */
  get genrationRequest(): Prisma.GenrationRequestDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.gPTMessageHistory`: Exposes CRUD operations for the **GPTMessageHistory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more GPTMessageHistories
    * const gPTMessageHistories = await prisma.gPTMessageHistory.findMany()
    * ```
    */
  get gPTMessageHistory(): Prisma.GPTMessageHistoryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.gPTMessage`: Exposes CRUD operations for the **GPTMessage** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more GPTMessages
    * const gPTMessages = await prisma.gPTMessage.findMany()
    * ```
    */
  get gPTMessage(): Prisma.GPTMessageDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.adventure`: Exposes CRUD operations for the **Adventure** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Adventures
    * const adventures = await prisma.adventure.findMany()
    * ```
    */
  get adventure(): Prisma.AdventureDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.keyword`: Exposes CRUD operations for the **Keyword** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Keywords
    * const keywords = await prisma.keyword.findMany()
    * ```
    */
  get keyword(): Prisma.KeywordDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.genre`: Exposes CRUD operations for the **Genre** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Genres
    * const genres = await prisma.genre.findMany()
    * ```
    */
  get genre(): Prisma.GenreDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.magicItem`: Exposes CRUD operations for the **MagicItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MagicItems
    * const magicItems = await prisma.magicItem.findMany()
    * ```
    */
  get magicItem(): Prisma.MagicItemDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.magicItemRarity`: Exposes CRUD operations for the **MagicItemRarity** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MagicItemRarities
    * const magicItemRarities = await prisma.magicItemRarity.findMany()
    * ```
    */
  get magicItemRarity(): Prisma.MagicItemRarityDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.magicItemType`: Exposes CRUD operations for the **MagicItemType** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MagicItemTypes
    * const magicItemTypes = await prisma.magicItemType.findMany()
    * ```
    */
  get magicItemType(): Prisma.MagicItemTypeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.attunementCondition`: Exposes CRUD operations for the **AttunementCondition** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AttunementConditions
    * const attunementConditions = await prisma.attunementCondition.findMany()
    * ```
    */
  get attunementCondition(): Prisma.AttunementConditionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.magicItemAttunement`: Exposes CRUD operations for the **MagicItemAttunement** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MagicItemAttunements
    * const magicItemAttunements = await prisma.magicItemAttunement.findMany()
    * ```
    */
  get magicItemAttunement(): Prisma.MagicItemAttunementDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.4.1
   * Query Engine version: 173f8d54f8d52e692c7e27e72a88314ec7aeff60
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Size: 'Size',
    Source: 'Source',
    Language: 'Language',
    Biome: 'Biome',
    Type: 'Type',
    Alignment: 'Alignment',
    CreatureSpeed: 'CreatureSpeed',
    CreatureStats: 'CreatureStats',
    CreatureStatDetail: 'CreatureStatDetail',
    CreatureSkills: 'CreatureSkills',
    CreatureSkillDetail: 'CreatureSkillDetail',
    SkillMetadata: 'SkillMetadata',
    Creature: 'Creature',
    CreatureSenses: 'CreatureSenses',
    Action: 'Action',
    Trait: 'Trait',
    CreatureRace: 'CreatureRace',
    DamageType: 'DamageType',
    ChallengeRatingMetadata: 'ChallengeRatingMetadata',
    GenrationRequest: 'GenrationRequest',
    GPTMessageHistory: 'GPTMessageHistory',
    GPTMessage: 'GPTMessage',
    Adventure: 'Adventure',
    Keyword: 'Keyword',
    Genre: 'Genre',
    MagicItem: 'MagicItem',
    MagicItemRarity: 'MagicItemRarity',
    MagicItemType: 'MagicItemType',
    AttunementCondition: 'AttunementCondition',
    MagicItemAttunement: 'MagicItemAttunement'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs, clientOptions: PrismaClientOptions }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], this['params']['clientOptions']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> = {
    meta: {
      modelProps: "size" | "source" | "language" | "biome" | "type" | "alignment" | "creatureSpeed" | "creatureStats" | "creatureStatDetail" | "creatureSkills" | "creatureSkillDetail" | "skillMetadata" | "creature" | "creatureSenses" | "action" | "trait" | "creatureRace" | "damageType" | "challengeRatingMetadata" | "genrationRequest" | "gPTMessageHistory" | "gPTMessage" | "adventure" | "keyword" | "genre" | "magicItem" | "magicItemRarity" | "magicItemType" | "attunementCondition" | "magicItemAttunement"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      Size: {
        payload: Prisma.$SizePayload<ExtArgs>
        fields: Prisma.SizeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SizeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SizePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SizeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SizePayload>
          }
          findFirst: {
            args: Prisma.SizeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SizePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SizeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SizePayload>
          }
          findMany: {
            args: Prisma.SizeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SizePayload>[]
          }
          create: {
            args: Prisma.SizeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SizePayload>
          }
          createMany: {
            args: Prisma.SizeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SizeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SizePayload>[]
          }
          delete: {
            args: Prisma.SizeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SizePayload>
          }
          update: {
            args: Prisma.SizeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SizePayload>
          }
          deleteMany: {
            args: Prisma.SizeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SizeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SizeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SizePayload>[]
          }
          upsert: {
            args: Prisma.SizeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SizePayload>
          }
          aggregate: {
            args: Prisma.SizeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSize>
          }
          groupBy: {
            args: Prisma.SizeGroupByArgs<ExtArgs>
            result: $Utils.Optional<SizeGroupByOutputType>[]
          }
          count: {
            args: Prisma.SizeCountArgs<ExtArgs>
            result: $Utils.Optional<SizeCountAggregateOutputType> | number
          }
        }
      }
      Source: {
        payload: Prisma.$SourcePayload<ExtArgs>
        fields: Prisma.SourceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SourceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SourcePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SourceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SourcePayload>
          }
          findFirst: {
            args: Prisma.SourceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SourcePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SourceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SourcePayload>
          }
          findMany: {
            args: Prisma.SourceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SourcePayload>[]
          }
          create: {
            args: Prisma.SourceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SourcePayload>
          }
          createMany: {
            args: Prisma.SourceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SourceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SourcePayload>[]
          }
          delete: {
            args: Prisma.SourceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SourcePayload>
          }
          update: {
            args: Prisma.SourceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SourcePayload>
          }
          deleteMany: {
            args: Prisma.SourceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SourceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SourceUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SourcePayload>[]
          }
          upsert: {
            args: Prisma.SourceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SourcePayload>
          }
          aggregate: {
            args: Prisma.SourceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSource>
          }
          groupBy: {
            args: Prisma.SourceGroupByArgs<ExtArgs>
            result: $Utils.Optional<SourceGroupByOutputType>[]
          }
          count: {
            args: Prisma.SourceCountArgs<ExtArgs>
            result: $Utils.Optional<SourceCountAggregateOutputType> | number
          }
        }
      }
      Language: {
        payload: Prisma.$LanguagePayload<ExtArgs>
        fields: Prisma.LanguageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LanguageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LanguagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LanguageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LanguagePayload>
          }
          findFirst: {
            args: Prisma.LanguageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LanguagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LanguageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LanguagePayload>
          }
          findMany: {
            args: Prisma.LanguageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LanguagePayload>[]
          }
          create: {
            args: Prisma.LanguageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LanguagePayload>
          }
          createMany: {
            args: Prisma.LanguageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LanguageCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LanguagePayload>[]
          }
          delete: {
            args: Prisma.LanguageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LanguagePayload>
          }
          update: {
            args: Prisma.LanguageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LanguagePayload>
          }
          deleteMany: {
            args: Prisma.LanguageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LanguageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.LanguageUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LanguagePayload>[]
          }
          upsert: {
            args: Prisma.LanguageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LanguagePayload>
          }
          aggregate: {
            args: Prisma.LanguageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLanguage>
          }
          groupBy: {
            args: Prisma.LanguageGroupByArgs<ExtArgs>
            result: $Utils.Optional<LanguageGroupByOutputType>[]
          }
          count: {
            args: Prisma.LanguageCountArgs<ExtArgs>
            result: $Utils.Optional<LanguageCountAggregateOutputType> | number
          }
        }
      }
      Biome: {
        payload: Prisma.$BiomePayload<ExtArgs>
        fields: Prisma.BiomeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BiomeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BiomePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BiomeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BiomePayload>
          }
          findFirst: {
            args: Prisma.BiomeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BiomePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BiomeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BiomePayload>
          }
          findMany: {
            args: Prisma.BiomeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BiomePayload>[]
          }
          create: {
            args: Prisma.BiomeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BiomePayload>
          }
          createMany: {
            args: Prisma.BiomeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BiomeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BiomePayload>[]
          }
          delete: {
            args: Prisma.BiomeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BiomePayload>
          }
          update: {
            args: Prisma.BiomeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BiomePayload>
          }
          deleteMany: {
            args: Prisma.BiomeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BiomeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BiomeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BiomePayload>[]
          }
          upsert: {
            args: Prisma.BiomeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BiomePayload>
          }
          aggregate: {
            args: Prisma.BiomeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBiome>
          }
          groupBy: {
            args: Prisma.BiomeGroupByArgs<ExtArgs>
            result: $Utils.Optional<BiomeGroupByOutputType>[]
          }
          count: {
            args: Prisma.BiomeCountArgs<ExtArgs>
            result: $Utils.Optional<BiomeCountAggregateOutputType> | number
          }
        }
      }
      Type: {
        payload: Prisma.$TypePayload<ExtArgs>
        fields: Prisma.TypeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TypeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TypePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TypeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TypePayload>
          }
          findFirst: {
            args: Prisma.TypeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TypePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TypeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TypePayload>
          }
          findMany: {
            args: Prisma.TypeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TypePayload>[]
          }
          create: {
            args: Prisma.TypeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TypePayload>
          }
          createMany: {
            args: Prisma.TypeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TypeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TypePayload>[]
          }
          delete: {
            args: Prisma.TypeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TypePayload>
          }
          update: {
            args: Prisma.TypeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TypePayload>
          }
          deleteMany: {
            args: Prisma.TypeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TypeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TypeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TypePayload>[]
          }
          upsert: {
            args: Prisma.TypeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TypePayload>
          }
          aggregate: {
            args: Prisma.TypeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateType>
          }
          groupBy: {
            args: Prisma.TypeGroupByArgs<ExtArgs>
            result: $Utils.Optional<TypeGroupByOutputType>[]
          }
          count: {
            args: Prisma.TypeCountArgs<ExtArgs>
            result: $Utils.Optional<TypeCountAggregateOutputType> | number
          }
        }
      }
      Alignment: {
        payload: Prisma.$AlignmentPayload<ExtArgs>
        fields: Prisma.AlignmentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AlignmentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlignmentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AlignmentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlignmentPayload>
          }
          findFirst: {
            args: Prisma.AlignmentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlignmentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AlignmentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlignmentPayload>
          }
          findMany: {
            args: Prisma.AlignmentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlignmentPayload>[]
          }
          create: {
            args: Prisma.AlignmentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlignmentPayload>
          }
          createMany: {
            args: Prisma.AlignmentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AlignmentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlignmentPayload>[]
          }
          delete: {
            args: Prisma.AlignmentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlignmentPayload>
          }
          update: {
            args: Prisma.AlignmentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlignmentPayload>
          }
          deleteMany: {
            args: Prisma.AlignmentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AlignmentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AlignmentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlignmentPayload>[]
          }
          upsert: {
            args: Prisma.AlignmentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlignmentPayload>
          }
          aggregate: {
            args: Prisma.AlignmentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAlignment>
          }
          groupBy: {
            args: Prisma.AlignmentGroupByArgs<ExtArgs>
            result: $Utils.Optional<AlignmentGroupByOutputType>[]
          }
          count: {
            args: Prisma.AlignmentCountArgs<ExtArgs>
            result: $Utils.Optional<AlignmentCountAggregateOutputType> | number
          }
        }
      }
      CreatureSpeed: {
        payload: Prisma.$CreatureSpeedPayload<ExtArgs>
        fields: Prisma.CreatureSpeedFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CreatureSpeedFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreatureSpeedPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CreatureSpeedFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreatureSpeedPayload>
          }
          findFirst: {
            args: Prisma.CreatureSpeedFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreatureSpeedPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CreatureSpeedFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreatureSpeedPayload>
          }
          findMany: {
            args: Prisma.CreatureSpeedFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreatureSpeedPayload>[]
          }
          create: {
            args: Prisma.CreatureSpeedCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreatureSpeedPayload>
          }
          createMany: {
            args: Prisma.CreatureSpeedCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CreatureSpeedCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreatureSpeedPayload>[]
          }
          delete: {
            args: Prisma.CreatureSpeedDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreatureSpeedPayload>
          }
          update: {
            args: Prisma.CreatureSpeedUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreatureSpeedPayload>
          }
          deleteMany: {
            args: Prisma.CreatureSpeedDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CreatureSpeedUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CreatureSpeedUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreatureSpeedPayload>[]
          }
          upsert: {
            args: Prisma.CreatureSpeedUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreatureSpeedPayload>
          }
          aggregate: {
            args: Prisma.CreatureSpeedAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCreatureSpeed>
          }
          groupBy: {
            args: Prisma.CreatureSpeedGroupByArgs<ExtArgs>
            result: $Utils.Optional<CreatureSpeedGroupByOutputType>[]
          }
          count: {
            args: Prisma.CreatureSpeedCountArgs<ExtArgs>
            result: $Utils.Optional<CreatureSpeedCountAggregateOutputType> | number
          }
        }
      }
      CreatureStats: {
        payload: Prisma.$CreatureStatsPayload<ExtArgs>
        fields: Prisma.CreatureStatsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CreatureStatsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreatureStatsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CreatureStatsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreatureStatsPayload>
          }
          findFirst: {
            args: Prisma.CreatureStatsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreatureStatsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CreatureStatsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreatureStatsPayload>
          }
          findMany: {
            args: Prisma.CreatureStatsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreatureStatsPayload>[]
          }
          create: {
            args: Prisma.CreatureStatsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreatureStatsPayload>
          }
          createMany: {
            args: Prisma.CreatureStatsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CreatureStatsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreatureStatsPayload>[]
          }
          delete: {
            args: Prisma.CreatureStatsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreatureStatsPayload>
          }
          update: {
            args: Prisma.CreatureStatsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreatureStatsPayload>
          }
          deleteMany: {
            args: Prisma.CreatureStatsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CreatureStatsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CreatureStatsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreatureStatsPayload>[]
          }
          upsert: {
            args: Prisma.CreatureStatsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreatureStatsPayload>
          }
          aggregate: {
            args: Prisma.CreatureStatsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCreatureStats>
          }
          groupBy: {
            args: Prisma.CreatureStatsGroupByArgs<ExtArgs>
            result: $Utils.Optional<CreatureStatsGroupByOutputType>[]
          }
          count: {
            args: Prisma.CreatureStatsCountArgs<ExtArgs>
            result: $Utils.Optional<CreatureStatsCountAggregateOutputType> | number
          }
        }
      }
      CreatureStatDetail: {
        payload: Prisma.$CreatureStatDetailPayload<ExtArgs>
        fields: Prisma.CreatureStatDetailFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CreatureStatDetailFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreatureStatDetailPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CreatureStatDetailFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreatureStatDetailPayload>
          }
          findFirst: {
            args: Prisma.CreatureStatDetailFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreatureStatDetailPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CreatureStatDetailFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreatureStatDetailPayload>
          }
          findMany: {
            args: Prisma.CreatureStatDetailFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreatureStatDetailPayload>[]
          }
          create: {
            args: Prisma.CreatureStatDetailCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreatureStatDetailPayload>
          }
          createMany: {
            args: Prisma.CreatureStatDetailCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CreatureStatDetailCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreatureStatDetailPayload>[]
          }
          delete: {
            args: Prisma.CreatureStatDetailDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreatureStatDetailPayload>
          }
          update: {
            args: Prisma.CreatureStatDetailUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreatureStatDetailPayload>
          }
          deleteMany: {
            args: Prisma.CreatureStatDetailDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CreatureStatDetailUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CreatureStatDetailUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreatureStatDetailPayload>[]
          }
          upsert: {
            args: Prisma.CreatureStatDetailUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreatureStatDetailPayload>
          }
          aggregate: {
            args: Prisma.CreatureStatDetailAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCreatureStatDetail>
          }
          groupBy: {
            args: Prisma.CreatureStatDetailGroupByArgs<ExtArgs>
            result: $Utils.Optional<CreatureStatDetailGroupByOutputType>[]
          }
          count: {
            args: Prisma.CreatureStatDetailCountArgs<ExtArgs>
            result: $Utils.Optional<CreatureStatDetailCountAggregateOutputType> | number
          }
        }
      }
      CreatureSkills: {
        payload: Prisma.$CreatureSkillsPayload<ExtArgs>
        fields: Prisma.CreatureSkillsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CreatureSkillsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreatureSkillsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CreatureSkillsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreatureSkillsPayload>
          }
          findFirst: {
            args: Prisma.CreatureSkillsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreatureSkillsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CreatureSkillsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreatureSkillsPayload>
          }
          findMany: {
            args: Prisma.CreatureSkillsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreatureSkillsPayload>[]
          }
          create: {
            args: Prisma.CreatureSkillsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreatureSkillsPayload>
          }
          createMany: {
            args: Prisma.CreatureSkillsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CreatureSkillsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreatureSkillsPayload>[]
          }
          delete: {
            args: Prisma.CreatureSkillsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreatureSkillsPayload>
          }
          update: {
            args: Prisma.CreatureSkillsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreatureSkillsPayload>
          }
          deleteMany: {
            args: Prisma.CreatureSkillsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CreatureSkillsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CreatureSkillsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreatureSkillsPayload>[]
          }
          upsert: {
            args: Prisma.CreatureSkillsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreatureSkillsPayload>
          }
          aggregate: {
            args: Prisma.CreatureSkillsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCreatureSkills>
          }
          groupBy: {
            args: Prisma.CreatureSkillsGroupByArgs<ExtArgs>
            result: $Utils.Optional<CreatureSkillsGroupByOutputType>[]
          }
          count: {
            args: Prisma.CreatureSkillsCountArgs<ExtArgs>
            result: $Utils.Optional<CreatureSkillsCountAggregateOutputType> | number
          }
        }
      }
      CreatureSkillDetail: {
        payload: Prisma.$CreatureSkillDetailPayload<ExtArgs>
        fields: Prisma.CreatureSkillDetailFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CreatureSkillDetailFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreatureSkillDetailPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CreatureSkillDetailFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreatureSkillDetailPayload>
          }
          findFirst: {
            args: Prisma.CreatureSkillDetailFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreatureSkillDetailPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CreatureSkillDetailFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreatureSkillDetailPayload>
          }
          findMany: {
            args: Prisma.CreatureSkillDetailFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreatureSkillDetailPayload>[]
          }
          create: {
            args: Prisma.CreatureSkillDetailCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreatureSkillDetailPayload>
          }
          createMany: {
            args: Prisma.CreatureSkillDetailCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CreatureSkillDetailCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreatureSkillDetailPayload>[]
          }
          delete: {
            args: Prisma.CreatureSkillDetailDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreatureSkillDetailPayload>
          }
          update: {
            args: Prisma.CreatureSkillDetailUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreatureSkillDetailPayload>
          }
          deleteMany: {
            args: Prisma.CreatureSkillDetailDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CreatureSkillDetailUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CreatureSkillDetailUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreatureSkillDetailPayload>[]
          }
          upsert: {
            args: Prisma.CreatureSkillDetailUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreatureSkillDetailPayload>
          }
          aggregate: {
            args: Prisma.CreatureSkillDetailAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCreatureSkillDetail>
          }
          groupBy: {
            args: Prisma.CreatureSkillDetailGroupByArgs<ExtArgs>
            result: $Utils.Optional<CreatureSkillDetailGroupByOutputType>[]
          }
          count: {
            args: Prisma.CreatureSkillDetailCountArgs<ExtArgs>
            result: $Utils.Optional<CreatureSkillDetailCountAggregateOutputType> | number
          }
        }
      }
      SkillMetadata: {
        payload: Prisma.$SkillMetadataPayload<ExtArgs>
        fields: Prisma.SkillMetadataFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SkillMetadataFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkillMetadataPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SkillMetadataFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkillMetadataPayload>
          }
          findFirst: {
            args: Prisma.SkillMetadataFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkillMetadataPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SkillMetadataFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkillMetadataPayload>
          }
          findMany: {
            args: Prisma.SkillMetadataFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkillMetadataPayload>[]
          }
          create: {
            args: Prisma.SkillMetadataCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkillMetadataPayload>
          }
          createMany: {
            args: Prisma.SkillMetadataCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SkillMetadataCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkillMetadataPayload>[]
          }
          delete: {
            args: Prisma.SkillMetadataDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkillMetadataPayload>
          }
          update: {
            args: Prisma.SkillMetadataUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkillMetadataPayload>
          }
          deleteMany: {
            args: Prisma.SkillMetadataDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SkillMetadataUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SkillMetadataUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkillMetadataPayload>[]
          }
          upsert: {
            args: Prisma.SkillMetadataUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkillMetadataPayload>
          }
          aggregate: {
            args: Prisma.SkillMetadataAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSkillMetadata>
          }
          groupBy: {
            args: Prisma.SkillMetadataGroupByArgs<ExtArgs>
            result: $Utils.Optional<SkillMetadataGroupByOutputType>[]
          }
          count: {
            args: Prisma.SkillMetadataCountArgs<ExtArgs>
            result: $Utils.Optional<SkillMetadataCountAggregateOutputType> | number
          }
        }
      }
      Creature: {
        payload: Prisma.$CreaturePayload<ExtArgs>
        fields: Prisma.CreatureFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CreatureFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreaturePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CreatureFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreaturePayload>
          }
          findFirst: {
            args: Prisma.CreatureFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreaturePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CreatureFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreaturePayload>
          }
          findMany: {
            args: Prisma.CreatureFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreaturePayload>[]
          }
          create: {
            args: Prisma.CreatureCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreaturePayload>
          }
          createMany: {
            args: Prisma.CreatureCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CreatureCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreaturePayload>[]
          }
          delete: {
            args: Prisma.CreatureDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreaturePayload>
          }
          update: {
            args: Prisma.CreatureUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreaturePayload>
          }
          deleteMany: {
            args: Prisma.CreatureDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CreatureUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CreatureUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreaturePayload>[]
          }
          upsert: {
            args: Prisma.CreatureUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreaturePayload>
          }
          aggregate: {
            args: Prisma.CreatureAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCreature>
          }
          groupBy: {
            args: Prisma.CreatureGroupByArgs<ExtArgs>
            result: $Utils.Optional<CreatureGroupByOutputType>[]
          }
          count: {
            args: Prisma.CreatureCountArgs<ExtArgs>
            result: $Utils.Optional<CreatureCountAggregateOutputType> | number
          }
        }
      }
      CreatureSenses: {
        payload: Prisma.$CreatureSensesPayload<ExtArgs>
        fields: Prisma.CreatureSensesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CreatureSensesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreatureSensesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CreatureSensesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreatureSensesPayload>
          }
          findFirst: {
            args: Prisma.CreatureSensesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreatureSensesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CreatureSensesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreatureSensesPayload>
          }
          findMany: {
            args: Prisma.CreatureSensesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreatureSensesPayload>[]
          }
          create: {
            args: Prisma.CreatureSensesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreatureSensesPayload>
          }
          createMany: {
            args: Prisma.CreatureSensesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CreatureSensesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreatureSensesPayload>[]
          }
          delete: {
            args: Prisma.CreatureSensesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreatureSensesPayload>
          }
          update: {
            args: Prisma.CreatureSensesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreatureSensesPayload>
          }
          deleteMany: {
            args: Prisma.CreatureSensesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CreatureSensesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CreatureSensesUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreatureSensesPayload>[]
          }
          upsert: {
            args: Prisma.CreatureSensesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreatureSensesPayload>
          }
          aggregate: {
            args: Prisma.CreatureSensesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCreatureSenses>
          }
          groupBy: {
            args: Prisma.CreatureSensesGroupByArgs<ExtArgs>
            result: $Utils.Optional<CreatureSensesGroupByOutputType>[]
          }
          count: {
            args: Prisma.CreatureSensesCountArgs<ExtArgs>
            result: $Utils.Optional<CreatureSensesCountAggregateOutputType> | number
          }
        }
      }
      Action: {
        payload: Prisma.$ActionPayload<ExtArgs>
        fields: Prisma.ActionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ActionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ActionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActionPayload>
          }
          findFirst: {
            args: Prisma.ActionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ActionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActionPayload>
          }
          findMany: {
            args: Prisma.ActionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActionPayload>[]
          }
          create: {
            args: Prisma.ActionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActionPayload>
          }
          createMany: {
            args: Prisma.ActionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ActionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActionPayload>[]
          }
          delete: {
            args: Prisma.ActionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActionPayload>
          }
          update: {
            args: Prisma.ActionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActionPayload>
          }
          deleteMany: {
            args: Prisma.ActionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ActionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ActionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActionPayload>[]
          }
          upsert: {
            args: Prisma.ActionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActionPayload>
          }
          aggregate: {
            args: Prisma.ActionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAction>
          }
          groupBy: {
            args: Prisma.ActionGroupByArgs<ExtArgs>
            result: $Utils.Optional<ActionGroupByOutputType>[]
          }
          count: {
            args: Prisma.ActionCountArgs<ExtArgs>
            result: $Utils.Optional<ActionCountAggregateOutputType> | number
          }
        }
      }
      Trait: {
        payload: Prisma.$TraitPayload<ExtArgs>
        fields: Prisma.TraitFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TraitFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TraitPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TraitFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TraitPayload>
          }
          findFirst: {
            args: Prisma.TraitFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TraitPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TraitFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TraitPayload>
          }
          findMany: {
            args: Prisma.TraitFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TraitPayload>[]
          }
          create: {
            args: Prisma.TraitCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TraitPayload>
          }
          createMany: {
            args: Prisma.TraitCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TraitCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TraitPayload>[]
          }
          delete: {
            args: Prisma.TraitDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TraitPayload>
          }
          update: {
            args: Prisma.TraitUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TraitPayload>
          }
          deleteMany: {
            args: Prisma.TraitDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TraitUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TraitUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TraitPayload>[]
          }
          upsert: {
            args: Prisma.TraitUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TraitPayload>
          }
          aggregate: {
            args: Prisma.TraitAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTrait>
          }
          groupBy: {
            args: Prisma.TraitGroupByArgs<ExtArgs>
            result: $Utils.Optional<TraitGroupByOutputType>[]
          }
          count: {
            args: Prisma.TraitCountArgs<ExtArgs>
            result: $Utils.Optional<TraitCountAggregateOutputType> | number
          }
        }
      }
      CreatureRace: {
        payload: Prisma.$CreatureRacePayload<ExtArgs>
        fields: Prisma.CreatureRaceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CreatureRaceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreatureRacePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CreatureRaceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreatureRacePayload>
          }
          findFirst: {
            args: Prisma.CreatureRaceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreatureRacePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CreatureRaceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreatureRacePayload>
          }
          findMany: {
            args: Prisma.CreatureRaceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreatureRacePayload>[]
          }
          create: {
            args: Prisma.CreatureRaceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreatureRacePayload>
          }
          createMany: {
            args: Prisma.CreatureRaceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CreatureRaceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreatureRacePayload>[]
          }
          delete: {
            args: Prisma.CreatureRaceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreatureRacePayload>
          }
          update: {
            args: Prisma.CreatureRaceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreatureRacePayload>
          }
          deleteMany: {
            args: Prisma.CreatureRaceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CreatureRaceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CreatureRaceUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreatureRacePayload>[]
          }
          upsert: {
            args: Prisma.CreatureRaceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreatureRacePayload>
          }
          aggregate: {
            args: Prisma.CreatureRaceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCreatureRace>
          }
          groupBy: {
            args: Prisma.CreatureRaceGroupByArgs<ExtArgs>
            result: $Utils.Optional<CreatureRaceGroupByOutputType>[]
          }
          count: {
            args: Prisma.CreatureRaceCountArgs<ExtArgs>
            result: $Utils.Optional<CreatureRaceCountAggregateOutputType> | number
          }
        }
      }
      DamageType: {
        payload: Prisma.$DamageTypePayload<ExtArgs>
        fields: Prisma.DamageTypeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DamageTypeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DamageTypePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DamageTypeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DamageTypePayload>
          }
          findFirst: {
            args: Prisma.DamageTypeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DamageTypePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DamageTypeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DamageTypePayload>
          }
          findMany: {
            args: Prisma.DamageTypeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DamageTypePayload>[]
          }
          create: {
            args: Prisma.DamageTypeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DamageTypePayload>
          }
          createMany: {
            args: Prisma.DamageTypeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DamageTypeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DamageTypePayload>[]
          }
          delete: {
            args: Prisma.DamageTypeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DamageTypePayload>
          }
          update: {
            args: Prisma.DamageTypeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DamageTypePayload>
          }
          deleteMany: {
            args: Prisma.DamageTypeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DamageTypeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DamageTypeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DamageTypePayload>[]
          }
          upsert: {
            args: Prisma.DamageTypeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DamageTypePayload>
          }
          aggregate: {
            args: Prisma.DamageTypeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDamageType>
          }
          groupBy: {
            args: Prisma.DamageTypeGroupByArgs<ExtArgs>
            result: $Utils.Optional<DamageTypeGroupByOutputType>[]
          }
          count: {
            args: Prisma.DamageTypeCountArgs<ExtArgs>
            result: $Utils.Optional<DamageTypeCountAggregateOutputType> | number
          }
        }
      }
      ChallengeRatingMetadata: {
        payload: Prisma.$ChallengeRatingMetadataPayload<ExtArgs>
        fields: Prisma.ChallengeRatingMetadataFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ChallengeRatingMetadataFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengeRatingMetadataPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ChallengeRatingMetadataFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengeRatingMetadataPayload>
          }
          findFirst: {
            args: Prisma.ChallengeRatingMetadataFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengeRatingMetadataPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ChallengeRatingMetadataFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengeRatingMetadataPayload>
          }
          findMany: {
            args: Prisma.ChallengeRatingMetadataFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengeRatingMetadataPayload>[]
          }
          create: {
            args: Prisma.ChallengeRatingMetadataCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengeRatingMetadataPayload>
          }
          createMany: {
            args: Prisma.ChallengeRatingMetadataCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ChallengeRatingMetadataCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengeRatingMetadataPayload>[]
          }
          delete: {
            args: Prisma.ChallengeRatingMetadataDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengeRatingMetadataPayload>
          }
          update: {
            args: Prisma.ChallengeRatingMetadataUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengeRatingMetadataPayload>
          }
          deleteMany: {
            args: Prisma.ChallengeRatingMetadataDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ChallengeRatingMetadataUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ChallengeRatingMetadataUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengeRatingMetadataPayload>[]
          }
          upsert: {
            args: Prisma.ChallengeRatingMetadataUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengeRatingMetadataPayload>
          }
          aggregate: {
            args: Prisma.ChallengeRatingMetadataAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateChallengeRatingMetadata>
          }
          groupBy: {
            args: Prisma.ChallengeRatingMetadataGroupByArgs<ExtArgs>
            result: $Utils.Optional<ChallengeRatingMetadataGroupByOutputType>[]
          }
          count: {
            args: Prisma.ChallengeRatingMetadataCountArgs<ExtArgs>
            result: $Utils.Optional<ChallengeRatingMetadataCountAggregateOutputType> | number
          }
        }
      }
      GenrationRequest: {
        payload: Prisma.$GenrationRequestPayload<ExtArgs>
        fields: Prisma.GenrationRequestFieldRefs
        operations: {
          findUnique: {
            args: Prisma.GenrationRequestFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GenrationRequestPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.GenrationRequestFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GenrationRequestPayload>
          }
          findFirst: {
            args: Prisma.GenrationRequestFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GenrationRequestPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.GenrationRequestFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GenrationRequestPayload>
          }
          findMany: {
            args: Prisma.GenrationRequestFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GenrationRequestPayload>[]
          }
          create: {
            args: Prisma.GenrationRequestCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GenrationRequestPayload>
          }
          createMany: {
            args: Prisma.GenrationRequestCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.GenrationRequestCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GenrationRequestPayload>[]
          }
          delete: {
            args: Prisma.GenrationRequestDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GenrationRequestPayload>
          }
          update: {
            args: Prisma.GenrationRequestUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GenrationRequestPayload>
          }
          deleteMany: {
            args: Prisma.GenrationRequestDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.GenrationRequestUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.GenrationRequestUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GenrationRequestPayload>[]
          }
          upsert: {
            args: Prisma.GenrationRequestUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GenrationRequestPayload>
          }
          aggregate: {
            args: Prisma.GenrationRequestAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGenrationRequest>
          }
          groupBy: {
            args: Prisma.GenrationRequestGroupByArgs<ExtArgs>
            result: $Utils.Optional<GenrationRequestGroupByOutputType>[]
          }
          count: {
            args: Prisma.GenrationRequestCountArgs<ExtArgs>
            result: $Utils.Optional<GenrationRequestCountAggregateOutputType> | number
          }
        }
      }
      GPTMessageHistory: {
        payload: Prisma.$GPTMessageHistoryPayload<ExtArgs>
        fields: Prisma.GPTMessageHistoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.GPTMessageHistoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GPTMessageHistoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.GPTMessageHistoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GPTMessageHistoryPayload>
          }
          findFirst: {
            args: Prisma.GPTMessageHistoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GPTMessageHistoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.GPTMessageHistoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GPTMessageHistoryPayload>
          }
          findMany: {
            args: Prisma.GPTMessageHistoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GPTMessageHistoryPayload>[]
          }
          create: {
            args: Prisma.GPTMessageHistoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GPTMessageHistoryPayload>
          }
          createMany: {
            args: Prisma.GPTMessageHistoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.GPTMessageHistoryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GPTMessageHistoryPayload>[]
          }
          delete: {
            args: Prisma.GPTMessageHistoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GPTMessageHistoryPayload>
          }
          update: {
            args: Prisma.GPTMessageHistoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GPTMessageHistoryPayload>
          }
          deleteMany: {
            args: Prisma.GPTMessageHistoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.GPTMessageHistoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.GPTMessageHistoryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GPTMessageHistoryPayload>[]
          }
          upsert: {
            args: Prisma.GPTMessageHistoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GPTMessageHistoryPayload>
          }
          aggregate: {
            args: Prisma.GPTMessageHistoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGPTMessageHistory>
          }
          groupBy: {
            args: Prisma.GPTMessageHistoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<GPTMessageHistoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.GPTMessageHistoryCountArgs<ExtArgs>
            result: $Utils.Optional<GPTMessageHistoryCountAggregateOutputType> | number
          }
        }
      }
      GPTMessage: {
        payload: Prisma.$GPTMessagePayload<ExtArgs>
        fields: Prisma.GPTMessageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.GPTMessageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GPTMessagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.GPTMessageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GPTMessagePayload>
          }
          findFirst: {
            args: Prisma.GPTMessageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GPTMessagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.GPTMessageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GPTMessagePayload>
          }
          findMany: {
            args: Prisma.GPTMessageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GPTMessagePayload>[]
          }
          create: {
            args: Prisma.GPTMessageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GPTMessagePayload>
          }
          createMany: {
            args: Prisma.GPTMessageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.GPTMessageCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GPTMessagePayload>[]
          }
          delete: {
            args: Prisma.GPTMessageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GPTMessagePayload>
          }
          update: {
            args: Prisma.GPTMessageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GPTMessagePayload>
          }
          deleteMany: {
            args: Prisma.GPTMessageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.GPTMessageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.GPTMessageUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GPTMessagePayload>[]
          }
          upsert: {
            args: Prisma.GPTMessageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GPTMessagePayload>
          }
          aggregate: {
            args: Prisma.GPTMessageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGPTMessage>
          }
          groupBy: {
            args: Prisma.GPTMessageGroupByArgs<ExtArgs>
            result: $Utils.Optional<GPTMessageGroupByOutputType>[]
          }
          count: {
            args: Prisma.GPTMessageCountArgs<ExtArgs>
            result: $Utils.Optional<GPTMessageCountAggregateOutputType> | number
          }
        }
      }
      Adventure: {
        payload: Prisma.$AdventurePayload<ExtArgs>
        fields: Prisma.AdventureFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AdventureFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdventurePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AdventureFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdventurePayload>
          }
          findFirst: {
            args: Prisma.AdventureFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdventurePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AdventureFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdventurePayload>
          }
          findMany: {
            args: Prisma.AdventureFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdventurePayload>[]
          }
          create: {
            args: Prisma.AdventureCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdventurePayload>
          }
          createMany: {
            args: Prisma.AdventureCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AdventureCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdventurePayload>[]
          }
          delete: {
            args: Prisma.AdventureDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdventurePayload>
          }
          update: {
            args: Prisma.AdventureUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdventurePayload>
          }
          deleteMany: {
            args: Prisma.AdventureDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AdventureUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AdventureUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdventurePayload>[]
          }
          upsert: {
            args: Prisma.AdventureUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdventurePayload>
          }
          aggregate: {
            args: Prisma.AdventureAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAdventure>
          }
          groupBy: {
            args: Prisma.AdventureGroupByArgs<ExtArgs>
            result: $Utils.Optional<AdventureGroupByOutputType>[]
          }
          count: {
            args: Prisma.AdventureCountArgs<ExtArgs>
            result: $Utils.Optional<AdventureCountAggregateOutputType> | number
          }
        }
      }
      Keyword: {
        payload: Prisma.$KeywordPayload<ExtArgs>
        fields: Prisma.KeywordFieldRefs
        operations: {
          findUnique: {
            args: Prisma.KeywordFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KeywordPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.KeywordFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KeywordPayload>
          }
          findFirst: {
            args: Prisma.KeywordFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KeywordPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.KeywordFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KeywordPayload>
          }
          findMany: {
            args: Prisma.KeywordFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KeywordPayload>[]
          }
          create: {
            args: Prisma.KeywordCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KeywordPayload>
          }
          createMany: {
            args: Prisma.KeywordCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.KeywordCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KeywordPayload>[]
          }
          delete: {
            args: Prisma.KeywordDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KeywordPayload>
          }
          update: {
            args: Prisma.KeywordUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KeywordPayload>
          }
          deleteMany: {
            args: Prisma.KeywordDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.KeywordUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.KeywordUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KeywordPayload>[]
          }
          upsert: {
            args: Prisma.KeywordUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KeywordPayload>
          }
          aggregate: {
            args: Prisma.KeywordAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateKeyword>
          }
          groupBy: {
            args: Prisma.KeywordGroupByArgs<ExtArgs>
            result: $Utils.Optional<KeywordGroupByOutputType>[]
          }
          count: {
            args: Prisma.KeywordCountArgs<ExtArgs>
            result: $Utils.Optional<KeywordCountAggregateOutputType> | number
          }
        }
      }
      Genre: {
        payload: Prisma.$GenrePayload<ExtArgs>
        fields: Prisma.GenreFieldRefs
        operations: {
          findUnique: {
            args: Prisma.GenreFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GenrePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.GenreFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GenrePayload>
          }
          findFirst: {
            args: Prisma.GenreFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GenrePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.GenreFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GenrePayload>
          }
          findMany: {
            args: Prisma.GenreFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GenrePayload>[]
          }
          create: {
            args: Prisma.GenreCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GenrePayload>
          }
          createMany: {
            args: Prisma.GenreCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.GenreCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GenrePayload>[]
          }
          delete: {
            args: Prisma.GenreDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GenrePayload>
          }
          update: {
            args: Prisma.GenreUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GenrePayload>
          }
          deleteMany: {
            args: Prisma.GenreDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.GenreUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.GenreUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GenrePayload>[]
          }
          upsert: {
            args: Prisma.GenreUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GenrePayload>
          }
          aggregate: {
            args: Prisma.GenreAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGenre>
          }
          groupBy: {
            args: Prisma.GenreGroupByArgs<ExtArgs>
            result: $Utils.Optional<GenreGroupByOutputType>[]
          }
          count: {
            args: Prisma.GenreCountArgs<ExtArgs>
            result: $Utils.Optional<GenreCountAggregateOutputType> | number
          }
        }
      }
      MagicItem: {
        payload: Prisma.$MagicItemPayload<ExtArgs>
        fields: Prisma.MagicItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MagicItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MagicItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MagicItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MagicItemPayload>
          }
          findFirst: {
            args: Prisma.MagicItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MagicItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MagicItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MagicItemPayload>
          }
          findMany: {
            args: Prisma.MagicItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MagicItemPayload>[]
          }
          create: {
            args: Prisma.MagicItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MagicItemPayload>
          }
          createMany: {
            args: Prisma.MagicItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MagicItemCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MagicItemPayload>[]
          }
          delete: {
            args: Prisma.MagicItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MagicItemPayload>
          }
          update: {
            args: Prisma.MagicItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MagicItemPayload>
          }
          deleteMany: {
            args: Prisma.MagicItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MagicItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MagicItemUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MagicItemPayload>[]
          }
          upsert: {
            args: Prisma.MagicItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MagicItemPayload>
          }
          aggregate: {
            args: Prisma.MagicItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMagicItem>
          }
          groupBy: {
            args: Prisma.MagicItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<MagicItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.MagicItemCountArgs<ExtArgs>
            result: $Utils.Optional<MagicItemCountAggregateOutputType> | number
          }
        }
      }
      MagicItemRarity: {
        payload: Prisma.$MagicItemRarityPayload<ExtArgs>
        fields: Prisma.MagicItemRarityFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MagicItemRarityFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MagicItemRarityPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MagicItemRarityFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MagicItemRarityPayload>
          }
          findFirst: {
            args: Prisma.MagicItemRarityFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MagicItemRarityPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MagicItemRarityFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MagicItemRarityPayload>
          }
          findMany: {
            args: Prisma.MagicItemRarityFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MagicItemRarityPayload>[]
          }
          create: {
            args: Prisma.MagicItemRarityCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MagicItemRarityPayload>
          }
          createMany: {
            args: Prisma.MagicItemRarityCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MagicItemRarityCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MagicItemRarityPayload>[]
          }
          delete: {
            args: Prisma.MagicItemRarityDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MagicItemRarityPayload>
          }
          update: {
            args: Prisma.MagicItemRarityUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MagicItemRarityPayload>
          }
          deleteMany: {
            args: Prisma.MagicItemRarityDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MagicItemRarityUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MagicItemRarityUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MagicItemRarityPayload>[]
          }
          upsert: {
            args: Prisma.MagicItemRarityUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MagicItemRarityPayload>
          }
          aggregate: {
            args: Prisma.MagicItemRarityAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMagicItemRarity>
          }
          groupBy: {
            args: Prisma.MagicItemRarityGroupByArgs<ExtArgs>
            result: $Utils.Optional<MagicItemRarityGroupByOutputType>[]
          }
          count: {
            args: Prisma.MagicItemRarityCountArgs<ExtArgs>
            result: $Utils.Optional<MagicItemRarityCountAggregateOutputType> | number
          }
        }
      }
      MagicItemType: {
        payload: Prisma.$MagicItemTypePayload<ExtArgs>
        fields: Prisma.MagicItemTypeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MagicItemTypeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MagicItemTypePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MagicItemTypeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MagicItemTypePayload>
          }
          findFirst: {
            args: Prisma.MagicItemTypeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MagicItemTypePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MagicItemTypeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MagicItemTypePayload>
          }
          findMany: {
            args: Prisma.MagicItemTypeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MagicItemTypePayload>[]
          }
          create: {
            args: Prisma.MagicItemTypeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MagicItemTypePayload>
          }
          createMany: {
            args: Prisma.MagicItemTypeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MagicItemTypeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MagicItemTypePayload>[]
          }
          delete: {
            args: Prisma.MagicItemTypeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MagicItemTypePayload>
          }
          update: {
            args: Prisma.MagicItemTypeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MagicItemTypePayload>
          }
          deleteMany: {
            args: Prisma.MagicItemTypeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MagicItemTypeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MagicItemTypeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MagicItemTypePayload>[]
          }
          upsert: {
            args: Prisma.MagicItemTypeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MagicItemTypePayload>
          }
          aggregate: {
            args: Prisma.MagicItemTypeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMagicItemType>
          }
          groupBy: {
            args: Prisma.MagicItemTypeGroupByArgs<ExtArgs>
            result: $Utils.Optional<MagicItemTypeGroupByOutputType>[]
          }
          count: {
            args: Prisma.MagicItemTypeCountArgs<ExtArgs>
            result: $Utils.Optional<MagicItemTypeCountAggregateOutputType> | number
          }
        }
      }
      AttunementCondition: {
        payload: Prisma.$AttunementConditionPayload<ExtArgs>
        fields: Prisma.AttunementConditionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AttunementConditionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttunementConditionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AttunementConditionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttunementConditionPayload>
          }
          findFirst: {
            args: Prisma.AttunementConditionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttunementConditionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AttunementConditionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttunementConditionPayload>
          }
          findMany: {
            args: Prisma.AttunementConditionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttunementConditionPayload>[]
          }
          create: {
            args: Prisma.AttunementConditionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttunementConditionPayload>
          }
          createMany: {
            args: Prisma.AttunementConditionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AttunementConditionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttunementConditionPayload>[]
          }
          delete: {
            args: Prisma.AttunementConditionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttunementConditionPayload>
          }
          update: {
            args: Prisma.AttunementConditionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttunementConditionPayload>
          }
          deleteMany: {
            args: Prisma.AttunementConditionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AttunementConditionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AttunementConditionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttunementConditionPayload>[]
          }
          upsert: {
            args: Prisma.AttunementConditionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttunementConditionPayload>
          }
          aggregate: {
            args: Prisma.AttunementConditionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAttunementCondition>
          }
          groupBy: {
            args: Prisma.AttunementConditionGroupByArgs<ExtArgs>
            result: $Utils.Optional<AttunementConditionGroupByOutputType>[]
          }
          count: {
            args: Prisma.AttunementConditionCountArgs<ExtArgs>
            result: $Utils.Optional<AttunementConditionCountAggregateOutputType> | number
          }
        }
      }
      MagicItemAttunement: {
        payload: Prisma.$MagicItemAttunementPayload<ExtArgs>
        fields: Prisma.MagicItemAttunementFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MagicItemAttunementFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MagicItemAttunementPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MagicItemAttunementFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MagicItemAttunementPayload>
          }
          findFirst: {
            args: Prisma.MagicItemAttunementFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MagicItemAttunementPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MagicItemAttunementFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MagicItemAttunementPayload>
          }
          findMany: {
            args: Prisma.MagicItemAttunementFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MagicItemAttunementPayload>[]
          }
          create: {
            args: Prisma.MagicItemAttunementCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MagicItemAttunementPayload>
          }
          createMany: {
            args: Prisma.MagicItemAttunementCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MagicItemAttunementCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MagicItemAttunementPayload>[]
          }
          delete: {
            args: Prisma.MagicItemAttunementDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MagicItemAttunementPayload>
          }
          update: {
            args: Prisma.MagicItemAttunementUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MagicItemAttunementPayload>
          }
          deleteMany: {
            args: Prisma.MagicItemAttunementDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MagicItemAttunementUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MagicItemAttunementUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MagicItemAttunementPayload>[]
          }
          upsert: {
            args: Prisma.MagicItemAttunementUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MagicItemAttunementPayload>
          }
          aggregate: {
            args: Prisma.MagicItemAttunementAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMagicItemAttunement>
          }
          groupBy: {
            args: Prisma.MagicItemAttunementGroupByArgs<ExtArgs>
            result: $Utils.Optional<MagicItemAttunementGroupByOutputType>[]
          }
          count: {
            args: Prisma.MagicItemAttunementCountArgs<ExtArgs>
            result: $Utils.Optional<MagicItemAttunementCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    size?: SizeOmit
    source?: SourceOmit
    language?: LanguageOmit
    biome?: BiomeOmit
    type?: TypeOmit
    alignment?: AlignmentOmit
    creatureSpeed?: CreatureSpeedOmit
    creatureStats?: CreatureStatsOmit
    creatureStatDetail?: CreatureStatDetailOmit
    creatureSkills?: CreatureSkillsOmit
    creatureSkillDetail?: CreatureSkillDetailOmit
    skillMetadata?: SkillMetadataOmit
    creature?: CreatureOmit
    creatureSenses?: CreatureSensesOmit
    action?: ActionOmit
    trait?: TraitOmit
    creatureRace?: CreatureRaceOmit
    damageType?: DamageTypeOmit
    challengeRatingMetadata?: ChallengeRatingMetadataOmit
    genrationRequest?: GenrationRequestOmit
    gPTMessageHistory?: GPTMessageHistoryOmit
    gPTMessage?: GPTMessageOmit
    adventure?: AdventureOmit
    keyword?: KeywordOmit
    genre?: GenreOmit
    magicItem?: MagicItemOmit
    magicItemRarity?: MagicItemRarityOmit
    magicItemType?: MagicItemTypeOmit
    attunementCondition?: AttunementConditionOmit
    magicItemAttunement?: MagicItemAttunementOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type SizeCountOutputType
   */

  export type SizeCountOutputType = {
    creature: number
  }

  export type SizeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creature?: boolean | SizeCountOutputTypeCountCreatureArgs
  }

  // Custom InputTypes
  /**
   * SizeCountOutputType without action
   */
  export type SizeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SizeCountOutputType
     */
    select?: SizeCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SizeCountOutputType without action
   */
  export type SizeCountOutputTypeCountCreatureArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CreatureWhereInput
  }


  /**
   * Count Type SourceCountOutputType
   */

  export type SourceCountOutputType = {
    creatures: number
    magicItems: number
  }

  export type SourceCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creatures?: boolean | SourceCountOutputTypeCountCreaturesArgs
    magicItems?: boolean | SourceCountOutputTypeCountMagicItemsArgs
  }

  // Custom InputTypes
  /**
   * SourceCountOutputType without action
   */
  export type SourceCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SourceCountOutputType
     */
    select?: SourceCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SourceCountOutputType without action
   */
  export type SourceCountOutputTypeCountCreaturesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CreatureWhereInput
  }

  /**
   * SourceCountOutputType without action
   */
  export type SourceCountOutputTypeCountMagicItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MagicItemWhereInput
  }


  /**
   * Count Type LanguageCountOutputType
   */

  export type LanguageCountOutputType = {
    creatures_relation: number
  }

  export type LanguageCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creatures_relation?: boolean | LanguageCountOutputTypeCountCreatures_relationArgs
  }

  // Custom InputTypes
  /**
   * LanguageCountOutputType without action
   */
  export type LanguageCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LanguageCountOutputType
     */
    select?: LanguageCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * LanguageCountOutputType without action
   */
  export type LanguageCountOutputTypeCountCreatures_relationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CreatureWhereInput
  }


  /**
   * Count Type BiomeCountOutputType
   */

  export type BiomeCountOutputType = {
    creatures_relation: number
  }

  export type BiomeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creatures_relation?: boolean | BiomeCountOutputTypeCountCreatures_relationArgs
  }

  // Custom InputTypes
  /**
   * BiomeCountOutputType without action
   */
  export type BiomeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BiomeCountOutputType
     */
    select?: BiomeCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * BiomeCountOutputType without action
   */
  export type BiomeCountOutputTypeCountCreatures_relationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CreatureWhereInput
  }


  /**
   * Count Type TypeCountOutputType
   */

  export type TypeCountOutputType = {
    creatures: number
  }

  export type TypeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creatures?: boolean | TypeCountOutputTypeCountCreaturesArgs
  }

  // Custom InputTypes
  /**
   * TypeCountOutputType without action
   */
  export type TypeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TypeCountOutputType
     */
    select?: TypeCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TypeCountOutputType without action
   */
  export type TypeCountOutputTypeCountCreaturesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CreatureWhereInput
  }


  /**
   * Count Type AlignmentCountOutputType
   */

  export type AlignmentCountOutputType = {
    creatures: number
  }

  export type AlignmentCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creatures?: boolean | AlignmentCountOutputTypeCountCreaturesArgs
  }

  // Custom InputTypes
  /**
   * AlignmentCountOutputType without action
   */
  export type AlignmentCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AlignmentCountOutputType
     */
    select?: AlignmentCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AlignmentCountOutputType without action
   */
  export type AlignmentCountOutputTypeCountCreaturesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CreatureWhereInput
  }


  /**
   * Count Type CreatureStatsCountOutputType
   */

  export type CreatureStatsCountOutputType = {
    stats: number
  }

  export type CreatureStatsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    stats?: boolean | CreatureStatsCountOutputTypeCountStatsArgs
  }

  // Custom InputTypes
  /**
   * CreatureStatsCountOutputType without action
   */
  export type CreatureStatsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreatureStatsCountOutputType
     */
    select?: CreatureStatsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CreatureStatsCountOutputType without action
   */
  export type CreatureStatsCountOutputTypeCountStatsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CreatureStatDetailWhereInput
  }


  /**
   * Count Type CreatureSkillsCountOutputType
   */

  export type CreatureSkillsCountOutputType = {
    skills: number
  }

  export type CreatureSkillsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    skills?: boolean | CreatureSkillsCountOutputTypeCountSkillsArgs
  }

  // Custom InputTypes
  /**
   * CreatureSkillsCountOutputType without action
   */
  export type CreatureSkillsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreatureSkillsCountOutputType
     */
    select?: CreatureSkillsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CreatureSkillsCountOutputType without action
   */
  export type CreatureSkillsCountOutputTypeCountSkillsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CreatureSkillDetailWhereInput
  }


  /**
   * Count Type CreatureCountOutputType
   */

  export type CreatureCountOutputType = {
    resistances: number
    immunities: number
    vulnerabilities: number
    languages_relation: number
    biomes_relation: number
    actions_relation: number
    traits_relation: number
  }

  export type CreatureCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    resistances?: boolean | CreatureCountOutputTypeCountResistancesArgs
    immunities?: boolean | CreatureCountOutputTypeCountImmunitiesArgs
    vulnerabilities?: boolean | CreatureCountOutputTypeCountVulnerabilitiesArgs
    languages_relation?: boolean | CreatureCountOutputTypeCountLanguages_relationArgs
    biomes_relation?: boolean | CreatureCountOutputTypeCountBiomes_relationArgs
    actions_relation?: boolean | CreatureCountOutputTypeCountActions_relationArgs
    traits_relation?: boolean | CreatureCountOutputTypeCountTraits_relationArgs
  }

  // Custom InputTypes
  /**
   * CreatureCountOutputType without action
   */
  export type CreatureCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreatureCountOutputType
     */
    select?: CreatureCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CreatureCountOutputType without action
   */
  export type CreatureCountOutputTypeCountResistancesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DamageTypeWhereInput
  }

  /**
   * CreatureCountOutputType without action
   */
  export type CreatureCountOutputTypeCountImmunitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DamageTypeWhereInput
  }

  /**
   * CreatureCountOutputType without action
   */
  export type CreatureCountOutputTypeCountVulnerabilitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DamageTypeWhereInput
  }

  /**
   * CreatureCountOutputType without action
   */
  export type CreatureCountOutputTypeCountLanguages_relationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LanguageWhereInput
  }

  /**
   * CreatureCountOutputType without action
   */
  export type CreatureCountOutputTypeCountBiomes_relationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BiomeWhereInput
  }

  /**
   * CreatureCountOutputType without action
   */
  export type CreatureCountOutputTypeCountActions_relationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ActionWhereInput
  }

  /**
   * CreatureCountOutputType without action
   */
  export type CreatureCountOutputTypeCountTraits_relationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TraitWhereInput
  }


  /**
   * Count Type ActionCountOutputType
   */

  export type ActionCountOutputType = {
    creatures_relation: number
    creature_races_relation: number
  }

  export type ActionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creatures_relation?: boolean | ActionCountOutputTypeCountCreatures_relationArgs
    creature_races_relation?: boolean | ActionCountOutputTypeCountCreature_races_relationArgs
  }

  // Custom InputTypes
  /**
   * ActionCountOutputType without action
   */
  export type ActionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActionCountOutputType
     */
    select?: ActionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ActionCountOutputType without action
   */
  export type ActionCountOutputTypeCountCreatures_relationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CreatureWhereInput
  }

  /**
   * ActionCountOutputType without action
   */
  export type ActionCountOutputTypeCountCreature_races_relationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CreatureRaceWhereInput
  }


  /**
   * Count Type TraitCountOutputType
   */

  export type TraitCountOutputType = {
    creatures_relation: number
    creature_races_relation: number
  }

  export type TraitCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creatures_relation?: boolean | TraitCountOutputTypeCountCreatures_relationArgs
    creature_races_relation?: boolean | TraitCountOutputTypeCountCreature_races_relationArgs
  }

  // Custom InputTypes
  /**
   * TraitCountOutputType without action
   */
  export type TraitCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TraitCountOutputType
     */
    select?: TraitCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TraitCountOutputType without action
   */
  export type TraitCountOutputTypeCountCreatures_relationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CreatureWhereInput
  }

  /**
   * TraitCountOutputType without action
   */
  export type TraitCountOutputTypeCountCreature_races_relationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CreatureRaceWhereInput
  }


  /**
   * Count Type CreatureRaceCountOutputType
   */

  export type CreatureRaceCountOutputType = {
    traits_relation: number
    actions_relation: number
    creatures_relation: number
  }

  export type CreatureRaceCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    traits_relation?: boolean | CreatureRaceCountOutputTypeCountTraits_relationArgs
    actions_relation?: boolean | CreatureRaceCountOutputTypeCountActions_relationArgs
    creatures_relation?: boolean | CreatureRaceCountOutputTypeCountCreatures_relationArgs
  }

  // Custom InputTypes
  /**
   * CreatureRaceCountOutputType without action
   */
  export type CreatureRaceCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreatureRaceCountOutputType
     */
    select?: CreatureRaceCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CreatureRaceCountOutputType without action
   */
  export type CreatureRaceCountOutputTypeCountTraits_relationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TraitWhereInput
  }

  /**
   * CreatureRaceCountOutputType without action
   */
  export type CreatureRaceCountOutputTypeCountActions_relationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ActionWhereInput
  }

  /**
   * CreatureRaceCountOutputType without action
   */
  export type CreatureRaceCountOutputTypeCountCreatures_relationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CreatureWhereInput
  }


  /**
   * Count Type DamageTypeCountOutputType
   */

  export type DamageTypeCountOutputType = {
    resistant_creatures_relation: number
    immune_creatures_relation: number
    vulnerable_creatures_relation: number
  }

  export type DamageTypeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    resistant_creatures_relation?: boolean | DamageTypeCountOutputTypeCountResistant_creatures_relationArgs
    immune_creatures_relation?: boolean | DamageTypeCountOutputTypeCountImmune_creatures_relationArgs
    vulnerable_creatures_relation?: boolean | DamageTypeCountOutputTypeCountVulnerable_creatures_relationArgs
  }

  // Custom InputTypes
  /**
   * DamageTypeCountOutputType without action
   */
  export type DamageTypeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DamageTypeCountOutputType
     */
    select?: DamageTypeCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * DamageTypeCountOutputType without action
   */
  export type DamageTypeCountOutputTypeCountResistant_creatures_relationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CreatureWhereInput
  }

  /**
   * DamageTypeCountOutputType without action
   */
  export type DamageTypeCountOutputTypeCountImmune_creatures_relationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CreatureWhereInput
  }

  /**
   * DamageTypeCountOutputType without action
   */
  export type DamageTypeCountOutputTypeCountVulnerable_creatures_relationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CreatureWhereInput
  }


  /**
   * Count Type ChallengeRatingMetadataCountOutputType
   */

  export type ChallengeRatingMetadataCountOutputType = {
    creatures: number
  }

  export type ChallengeRatingMetadataCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creatures?: boolean | ChallengeRatingMetadataCountOutputTypeCountCreaturesArgs
  }

  // Custom InputTypes
  /**
   * ChallengeRatingMetadataCountOutputType without action
   */
  export type ChallengeRatingMetadataCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeRatingMetadataCountOutputType
     */
    select?: ChallengeRatingMetadataCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ChallengeRatingMetadataCountOutputType without action
   */
  export type ChallengeRatingMetadataCountOutputTypeCountCreaturesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CreatureWhereInput
  }


  /**
   * Count Type GPTMessageHistoryCountOutputType
   */

  export type GPTMessageHistoryCountOutputType = {
    messages_relation: number
  }

  export type GPTMessageHistoryCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    messages_relation?: boolean | GPTMessageHistoryCountOutputTypeCountMessages_relationArgs
  }

  // Custom InputTypes
  /**
   * GPTMessageHistoryCountOutputType without action
   */
  export type GPTMessageHistoryCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GPTMessageHistoryCountOutputType
     */
    select?: GPTMessageHistoryCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * GPTMessageHistoryCountOutputType without action
   */
  export type GPTMessageHistoryCountOutputTypeCountMessages_relationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GPTMessageWhereInput
  }


  /**
   * Count Type AdventureCountOutputType
   */

  export type AdventureCountOutputType = {
    keywords_relation: number
  }

  export type AdventureCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    keywords_relation?: boolean | AdventureCountOutputTypeCountKeywords_relationArgs
  }

  // Custom InputTypes
  /**
   * AdventureCountOutputType without action
   */
  export type AdventureCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdventureCountOutputType
     */
    select?: AdventureCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AdventureCountOutputType without action
   */
  export type AdventureCountOutputTypeCountKeywords_relationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: KeywordWhereInput
  }


  /**
   * Count Type KeywordCountOutputType
   */

  export type KeywordCountOutputType = {
    adventures_relation: number
  }

  export type KeywordCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    adventures_relation?: boolean | KeywordCountOutputTypeCountAdventures_relationArgs
  }

  // Custom InputTypes
  /**
   * KeywordCountOutputType without action
   */
  export type KeywordCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KeywordCountOutputType
     */
    select?: KeywordCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * KeywordCountOutputType without action
   */
  export type KeywordCountOutputTypeCountAdventures_relationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdventureWhereInput
  }


  /**
   * Count Type GenreCountOutputType
   */

  export type GenreCountOutputType = {
    keywords_relation: number
    adventures_relation: number
  }

  export type GenreCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    keywords_relation?: boolean | GenreCountOutputTypeCountKeywords_relationArgs
    adventures_relation?: boolean | GenreCountOutputTypeCountAdventures_relationArgs
  }

  // Custom InputTypes
  /**
   * GenreCountOutputType without action
   */
  export type GenreCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GenreCountOutputType
     */
    select?: GenreCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * GenreCountOutputType without action
   */
  export type GenreCountOutputTypeCountKeywords_relationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: KeywordWhereInput
  }

  /**
   * GenreCountOutputType without action
   */
  export type GenreCountOutputTypeCountAdventures_relationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdventureWhereInput
  }


  /**
   * Count Type MagicItemCountOutputType
   */

  export type MagicItemCountOutputType = {
    attunements_relation: number
  }

  export type MagicItemCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    attunements_relation?: boolean | MagicItemCountOutputTypeCountAttunements_relationArgs
  }

  // Custom InputTypes
  /**
   * MagicItemCountOutputType without action
   */
  export type MagicItemCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MagicItemCountOutputType
     */
    select?: MagicItemCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * MagicItemCountOutputType without action
   */
  export type MagicItemCountOutputTypeCountAttunements_relationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MagicItemAttunementWhereInput
  }


  /**
   * Count Type MagicItemRarityCountOutputType
   */

  export type MagicItemRarityCountOutputType = {
    magicItems: number
  }

  export type MagicItemRarityCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    magicItems?: boolean | MagicItemRarityCountOutputTypeCountMagicItemsArgs
  }

  // Custom InputTypes
  /**
   * MagicItemRarityCountOutputType without action
   */
  export type MagicItemRarityCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MagicItemRarityCountOutputType
     */
    select?: MagicItemRarityCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * MagicItemRarityCountOutputType without action
   */
  export type MagicItemRarityCountOutputTypeCountMagicItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MagicItemWhereInput
  }


  /**
   * Count Type MagicItemTypeCountOutputType
   */

  export type MagicItemTypeCountOutputType = {
    magicItems: number
  }

  export type MagicItemTypeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    magicItems?: boolean | MagicItemTypeCountOutputTypeCountMagicItemsArgs
  }

  // Custom InputTypes
  /**
   * MagicItemTypeCountOutputType without action
   */
  export type MagicItemTypeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MagicItemTypeCountOutputType
     */
    select?: MagicItemTypeCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * MagicItemTypeCountOutputType without action
   */
  export type MagicItemTypeCountOutputTypeCountMagicItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MagicItemWhereInput
  }


  /**
   * Count Type AttunementConditionCountOutputType
   */

  export type AttunementConditionCountOutputType = {
    magicItems: number
  }

  export type AttunementConditionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    magicItems?: boolean | AttunementConditionCountOutputTypeCountMagicItemsArgs
  }

  // Custom InputTypes
  /**
   * AttunementConditionCountOutputType without action
   */
  export type AttunementConditionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttunementConditionCountOutputType
     */
    select?: AttunementConditionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AttunementConditionCountOutputType without action
   */
  export type AttunementConditionCountOutputTypeCountMagicItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MagicItemAttunementWhereInput
  }


  /**
   * Models
   */

  /**
   * Model Size
   */

  export type AggregateSize = {
    _count: SizeCountAggregateOutputType | null
    _min: SizeMinAggregateOutputType | null
    _max: SizeMaxAggregateOutputType | null
  }

  export type SizeMinAggregateOutputType = {
    id: string | null
    name: string | null
  }

  export type SizeMaxAggregateOutputType = {
    id: string | null
    name: string | null
  }

  export type SizeCountAggregateOutputType = {
    id: number
    name: number
    _all: number
  }


  export type SizeMinAggregateInputType = {
    id?: true
    name?: true
  }

  export type SizeMaxAggregateInputType = {
    id?: true
    name?: true
  }

  export type SizeCountAggregateInputType = {
    id?: true
    name?: true
    _all?: true
  }

  export type SizeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Size to aggregate.
     */
    where?: SizeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sizes to fetch.
     */
    orderBy?: SizeOrderByWithRelationInput | SizeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SizeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sizes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sizes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Sizes
    **/
    _count?: true | SizeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SizeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SizeMaxAggregateInputType
  }

  export type GetSizeAggregateType<T extends SizeAggregateArgs> = {
        [P in keyof T & keyof AggregateSize]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSize[P]>
      : GetScalarType<T[P], AggregateSize[P]>
  }




  export type SizeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SizeWhereInput
    orderBy?: SizeOrderByWithAggregationInput | SizeOrderByWithAggregationInput[]
    by: SizeScalarFieldEnum[] | SizeScalarFieldEnum
    having?: SizeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SizeCountAggregateInputType | true
    _min?: SizeMinAggregateInputType
    _max?: SizeMaxAggregateInputType
  }

  export type SizeGroupByOutputType = {
    id: string
    name: string
    _count: SizeCountAggregateOutputType | null
    _min: SizeMinAggregateOutputType | null
    _max: SizeMaxAggregateOutputType | null
  }

  type GetSizeGroupByPayload<T extends SizeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SizeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SizeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SizeGroupByOutputType[P]>
            : GetScalarType<T[P], SizeGroupByOutputType[P]>
        }
      >
    >


  export type SizeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    creature?: boolean | Size$creatureArgs<ExtArgs>
    _count?: boolean | SizeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["size"]>

  export type SizeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
  }, ExtArgs["result"]["size"]>

  export type SizeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
  }, ExtArgs["result"]["size"]>

  export type SizeSelectScalar = {
    id?: boolean
    name?: boolean
  }

  export type SizeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name", ExtArgs["result"]["size"]>
  export type SizeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creature?: boolean | Size$creatureArgs<ExtArgs>
    _count?: boolean | SizeCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type SizeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type SizeIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $SizePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Size"
    objects: {
      creature: Prisma.$CreaturePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
    }, ExtArgs["result"]["size"]>
    composites: {}
  }

  type SizeGetPayload<S extends boolean | null | undefined | SizeDefaultArgs> = $Result.GetResult<Prisma.$SizePayload, S>

  type SizeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SizeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SizeCountAggregateInputType | true
    }

  export interface SizeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Size'], meta: { name: 'Size' } }
    /**
     * Find zero or one Size that matches the filter.
     * @param {SizeFindUniqueArgs} args - Arguments to find a Size
     * @example
     * // Get one Size
     * const size = await prisma.size.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SizeFindUniqueArgs>(args: SelectSubset<T, SizeFindUniqueArgs<ExtArgs>>): Prisma__SizeClient<$Result.GetResult<Prisma.$SizePayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Size that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SizeFindUniqueOrThrowArgs} args - Arguments to find a Size
     * @example
     * // Get one Size
     * const size = await prisma.size.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SizeFindUniqueOrThrowArgs>(args: SelectSubset<T, SizeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SizeClient<$Result.GetResult<Prisma.$SizePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Size that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SizeFindFirstArgs} args - Arguments to find a Size
     * @example
     * // Get one Size
     * const size = await prisma.size.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SizeFindFirstArgs>(args?: SelectSubset<T, SizeFindFirstArgs<ExtArgs>>): Prisma__SizeClient<$Result.GetResult<Prisma.$SizePayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Size that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SizeFindFirstOrThrowArgs} args - Arguments to find a Size
     * @example
     * // Get one Size
     * const size = await prisma.size.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SizeFindFirstOrThrowArgs>(args?: SelectSubset<T, SizeFindFirstOrThrowArgs<ExtArgs>>): Prisma__SizeClient<$Result.GetResult<Prisma.$SizePayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Sizes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SizeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Sizes
     * const sizes = await prisma.size.findMany()
     * 
     * // Get first 10 Sizes
     * const sizes = await prisma.size.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sizeWithIdOnly = await prisma.size.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SizeFindManyArgs>(args?: SelectSubset<T, SizeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SizePayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Size.
     * @param {SizeCreateArgs} args - Arguments to create a Size.
     * @example
     * // Create one Size
     * const Size = await prisma.size.create({
     *   data: {
     *     // ... data to create a Size
     *   }
     * })
     * 
     */
    create<T extends SizeCreateArgs>(args: SelectSubset<T, SizeCreateArgs<ExtArgs>>): Prisma__SizeClient<$Result.GetResult<Prisma.$SizePayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Sizes.
     * @param {SizeCreateManyArgs} args - Arguments to create many Sizes.
     * @example
     * // Create many Sizes
     * const size = await prisma.size.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SizeCreateManyArgs>(args?: SelectSubset<T, SizeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Sizes and returns the data saved in the database.
     * @param {SizeCreateManyAndReturnArgs} args - Arguments to create many Sizes.
     * @example
     * // Create many Sizes
     * const size = await prisma.size.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Sizes and only return the `id`
     * const sizeWithIdOnly = await prisma.size.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SizeCreateManyAndReturnArgs>(args?: SelectSubset<T, SizeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SizePayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Size.
     * @param {SizeDeleteArgs} args - Arguments to delete one Size.
     * @example
     * // Delete one Size
     * const Size = await prisma.size.delete({
     *   where: {
     *     // ... filter to delete one Size
     *   }
     * })
     * 
     */
    delete<T extends SizeDeleteArgs>(args: SelectSubset<T, SizeDeleteArgs<ExtArgs>>): Prisma__SizeClient<$Result.GetResult<Prisma.$SizePayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Size.
     * @param {SizeUpdateArgs} args - Arguments to update one Size.
     * @example
     * // Update one Size
     * const size = await prisma.size.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SizeUpdateArgs>(args: SelectSubset<T, SizeUpdateArgs<ExtArgs>>): Prisma__SizeClient<$Result.GetResult<Prisma.$SizePayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Sizes.
     * @param {SizeDeleteManyArgs} args - Arguments to filter Sizes to delete.
     * @example
     * // Delete a few Sizes
     * const { count } = await prisma.size.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SizeDeleteManyArgs>(args?: SelectSubset<T, SizeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sizes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SizeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Sizes
     * const size = await prisma.size.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SizeUpdateManyArgs>(args: SelectSubset<T, SizeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sizes and returns the data updated in the database.
     * @param {SizeUpdateManyAndReturnArgs} args - Arguments to update many Sizes.
     * @example
     * // Update many Sizes
     * const size = await prisma.size.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Sizes and only return the `id`
     * const sizeWithIdOnly = await prisma.size.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SizeUpdateManyAndReturnArgs>(args: SelectSubset<T, SizeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SizePayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Size.
     * @param {SizeUpsertArgs} args - Arguments to update or create a Size.
     * @example
     * // Update or create a Size
     * const size = await prisma.size.upsert({
     *   create: {
     *     // ... data to create a Size
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Size we want to update
     *   }
     * })
     */
    upsert<T extends SizeUpsertArgs>(args: SelectSubset<T, SizeUpsertArgs<ExtArgs>>): Prisma__SizeClient<$Result.GetResult<Prisma.$SizePayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Sizes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SizeCountArgs} args - Arguments to filter Sizes to count.
     * @example
     * // Count the number of Sizes
     * const count = await prisma.size.count({
     *   where: {
     *     // ... the filter for the Sizes we want to count
     *   }
     * })
    **/
    count<T extends SizeCountArgs>(
      args?: Subset<T, SizeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SizeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Size.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SizeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SizeAggregateArgs>(args: Subset<T, SizeAggregateArgs>): Prisma.PrismaPromise<GetSizeAggregateType<T>>

    /**
     * Group by Size.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SizeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SizeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SizeGroupByArgs['orderBy'] }
        : { orderBy?: SizeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SizeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSizeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Size model
   */
  readonly fields: SizeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Size.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SizeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    creature<T extends Size$creatureArgs<ExtArgs> = {}>(args?: Subset<T, Size$creatureArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CreaturePayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Size model
   */ 
  interface SizeFieldRefs {
    readonly id: FieldRef<"Size", 'String'>
    readonly name: FieldRef<"Size", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Size findUnique
   */
  export type SizeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Size
     */
    select?: SizeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Size
     */
    omit?: SizeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SizeInclude<ExtArgs> | null
    /**
     * Filter, which Size to fetch.
     */
    where: SizeWhereUniqueInput
  }

  /**
   * Size findUniqueOrThrow
   */
  export type SizeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Size
     */
    select?: SizeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Size
     */
    omit?: SizeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SizeInclude<ExtArgs> | null
    /**
     * Filter, which Size to fetch.
     */
    where: SizeWhereUniqueInput
  }

  /**
   * Size findFirst
   */
  export type SizeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Size
     */
    select?: SizeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Size
     */
    omit?: SizeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SizeInclude<ExtArgs> | null
    /**
     * Filter, which Size to fetch.
     */
    where?: SizeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sizes to fetch.
     */
    orderBy?: SizeOrderByWithRelationInput | SizeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sizes.
     */
    cursor?: SizeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sizes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sizes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sizes.
     */
    distinct?: SizeScalarFieldEnum | SizeScalarFieldEnum[]
  }

  /**
   * Size findFirstOrThrow
   */
  export type SizeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Size
     */
    select?: SizeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Size
     */
    omit?: SizeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SizeInclude<ExtArgs> | null
    /**
     * Filter, which Size to fetch.
     */
    where?: SizeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sizes to fetch.
     */
    orderBy?: SizeOrderByWithRelationInput | SizeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sizes.
     */
    cursor?: SizeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sizes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sizes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sizes.
     */
    distinct?: SizeScalarFieldEnum | SizeScalarFieldEnum[]
  }

  /**
   * Size findMany
   */
  export type SizeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Size
     */
    select?: SizeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Size
     */
    omit?: SizeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SizeInclude<ExtArgs> | null
    /**
     * Filter, which Sizes to fetch.
     */
    where?: SizeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sizes to fetch.
     */
    orderBy?: SizeOrderByWithRelationInput | SizeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Sizes.
     */
    cursor?: SizeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sizes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sizes.
     */
    skip?: number
    distinct?: SizeScalarFieldEnum | SizeScalarFieldEnum[]
  }

  /**
   * Size create
   */
  export type SizeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Size
     */
    select?: SizeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Size
     */
    omit?: SizeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SizeInclude<ExtArgs> | null
    /**
     * The data needed to create a Size.
     */
    data: XOR<SizeCreateInput, SizeUncheckedCreateInput>
  }

  /**
   * Size createMany
   */
  export type SizeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Sizes.
     */
    data: SizeCreateManyInput | SizeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Size createManyAndReturn
   */
  export type SizeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Size
     */
    select?: SizeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Size
     */
    omit?: SizeOmit<ExtArgs> | null
    /**
     * The data used to create many Sizes.
     */
    data: SizeCreateManyInput | SizeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Size update
   */
  export type SizeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Size
     */
    select?: SizeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Size
     */
    omit?: SizeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SizeInclude<ExtArgs> | null
    /**
     * The data needed to update a Size.
     */
    data: XOR<SizeUpdateInput, SizeUncheckedUpdateInput>
    /**
     * Choose, which Size to update.
     */
    where: SizeWhereUniqueInput
  }

  /**
   * Size updateMany
   */
  export type SizeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Sizes.
     */
    data: XOR<SizeUpdateManyMutationInput, SizeUncheckedUpdateManyInput>
    /**
     * Filter which Sizes to update
     */
    where?: SizeWhereInput
    /**
     * Limit how many Sizes to update.
     */
    limit?: number
  }

  /**
   * Size updateManyAndReturn
   */
  export type SizeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Size
     */
    select?: SizeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Size
     */
    omit?: SizeOmit<ExtArgs> | null
    /**
     * The data used to update Sizes.
     */
    data: XOR<SizeUpdateManyMutationInput, SizeUncheckedUpdateManyInput>
    /**
     * Filter which Sizes to update
     */
    where?: SizeWhereInput
    /**
     * Limit how many Sizes to update.
     */
    limit?: number
  }

  /**
   * Size upsert
   */
  export type SizeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Size
     */
    select?: SizeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Size
     */
    omit?: SizeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SizeInclude<ExtArgs> | null
    /**
     * The filter to search for the Size to update in case it exists.
     */
    where: SizeWhereUniqueInput
    /**
     * In case the Size found by the `where` argument doesn't exist, create a new Size with this data.
     */
    create: XOR<SizeCreateInput, SizeUncheckedCreateInput>
    /**
     * In case the Size was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SizeUpdateInput, SizeUncheckedUpdateInput>
  }

  /**
   * Size delete
   */
  export type SizeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Size
     */
    select?: SizeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Size
     */
    omit?: SizeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SizeInclude<ExtArgs> | null
    /**
     * Filter which Size to delete.
     */
    where: SizeWhereUniqueInput
  }

  /**
   * Size deleteMany
   */
  export type SizeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Sizes to delete
     */
    where?: SizeWhereInput
    /**
     * Limit how many Sizes to delete.
     */
    limit?: number
  }

  /**
   * Size.creature
   */
  export type Size$creatureArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Creature
     */
    select?: CreatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Creature
     */
    omit?: CreatureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreatureInclude<ExtArgs> | null
    where?: CreatureWhereInput
    orderBy?: CreatureOrderByWithRelationInput | CreatureOrderByWithRelationInput[]
    cursor?: CreatureWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CreatureScalarFieldEnum | CreatureScalarFieldEnum[]
  }

  /**
   * Size without action
   */
  export type SizeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Size
     */
    select?: SizeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Size
     */
    omit?: SizeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SizeInclude<ExtArgs> | null
  }


  /**
   * Model Source
   */

  export type AggregateSource = {
    _count: SourceCountAggregateOutputType | null
    _avg: SourceAvgAggregateOutputType | null
    _sum: SourceSumAggregateOutputType | null
    _min: SourceMinAggregateOutputType | null
    _max: SourceMaxAggregateOutputType | null
  }

  export type SourceAvgAggregateOutputType = {
    id: number | null
  }

  export type SourceSumAggregateOutputType = {
    id: number | null
  }

  export type SourceMinAggregateOutputType = {
    id: number | null
    short_name: string | null
    name: string | null
  }

  export type SourceMaxAggregateOutputType = {
    id: number | null
    short_name: string | null
    name: string | null
  }

  export type SourceCountAggregateOutputType = {
    id: number
    short_name: number
    name: number
    _all: number
  }


  export type SourceAvgAggregateInputType = {
    id?: true
  }

  export type SourceSumAggregateInputType = {
    id?: true
  }

  export type SourceMinAggregateInputType = {
    id?: true
    short_name?: true
    name?: true
  }

  export type SourceMaxAggregateInputType = {
    id?: true
    short_name?: true
    name?: true
  }

  export type SourceCountAggregateInputType = {
    id?: true
    short_name?: true
    name?: true
    _all?: true
  }

  export type SourceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Source to aggregate.
     */
    where?: SourceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sources to fetch.
     */
    orderBy?: SourceOrderByWithRelationInput | SourceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SourceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sources from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sources.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Sources
    **/
    _count?: true | SourceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SourceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SourceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SourceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SourceMaxAggregateInputType
  }

  export type GetSourceAggregateType<T extends SourceAggregateArgs> = {
        [P in keyof T & keyof AggregateSource]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSource[P]>
      : GetScalarType<T[P], AggregateSource[P]>
  }




  export type SourceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SourceWhereInput
    orderBy?: SourceOrderByWithAggregationInput | SourceOrderByWithAggregationInput[]
    by: SourceScalarFieldEnum[] | SourceScalarFieldEnum
    having?: SourceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SourceCountAggregateInputType | true
    _avg?: SourceAvgAggregateInputType
    _sum?: SourceSumAggregateInputType
    _min?: SourceMinAggregateInputType
    _max?: SourceMaxAggregateInputType
  }

  export type SourceGroupByOutputType = {
    id: number
    short_name: string
    name: string
    _count: SourceCountAggregateOutputType | null
    _avg: SourceAvgAggregateOutputType | null
    _sum: SourceSumAggregateOutputType | null
    _min: SourceMinAggregateOutputType | null
    _max: SourceMaxAggregateOutputType | null
  }

  type GetSourceGroupByPayload<T extends SourceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SourceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SourceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SourceGroupByOutputType[P]>
            : GetScalarType<T[P], SourceGroupByOutputType[P]>
        }
      >
    >


  export type SourceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    short_name?: boolean
    name?: boolean
    creatures?: boolean | Source$creaturesArgs<ExtArgs>
    magicItems?: boolean | Source$magicItemsArgs<ExtArgs>
    _count?: boolean | SourceCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["source"]>

  export type SourceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    short_name?: boolean
    name?: boolean
  }, ExtArgs["result"]["source"]>

  export type SourceSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    short_name?: boolean
    name?: boolean
  }, ExtArgs["result"]["source"]>

  export type SourceSelectScalar = {
    id?: boolean
    short_name?: boolean
    name?: boolean
  }

  export type SourceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "short_name" | "name", ExtArgs["result"]["source"]>
  export type SourceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creatures?: boolean | Source$creaturesArgs<ExtArgs>
    magicItems?: boolean | Source$magicItemsArgs<ExtArgs>
    _count?: boolean | SourceCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type SourceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type SourceIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $SourcePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Source"
    objects: {
      creatures: Prisma.$CreaturePayload<ExtArgs>[]
      magicItems: Prisma.$MagicItemPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      short_name: string
      name: string
    }, ExtArgs["result"]["source"]>
    composites: {}
  }

  type SourceGetPayload<S extends boolean | null | undefined | SourceDefaultArgs> = $Result.GetResult<Prisma.$SourcePayload, S>

  type SourceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SourceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SourceCountAggregateInputType | true
    }

  export interface SourceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Source'], meta: { name: 'Source' } }
    /**
     * Find zero or one Source that matches the filter.
     * @param {SourceFindUniqueArgs} args - Arguments to find a Source
     * @example
     * // Get one Source
     * const source = await prisma.source.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SourceFindUniqueArgs>(args: SelectSubset<T, SourceFindUniqueArgs<ExtArgs>>): Prisma__SourceClient<$Result.GetResult<Prisma.$SourcePayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Source that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SourceFindUniqueOrThrowArgs} args - Arguments to find a Source
     * @example
     * // Get one Source
     * const source = await prisma.source.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SourceFindUniqueOrThrowArgs>(args: SelectSubset<T, SourceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SourceClient<$Result.GetResult<Prisma.$SourcePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Source that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SourceFindFirstArgs} args - Arguments to find a Source
     * @example
     * // Get one Source
     * const source = await prisma.source.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SourceFindFirstArgs>(args?: SelectSubset<T, SourceFindFirstArgs<ExtArgs>>): Prisma__SourceClient<$Result.GetResult<Prisma.$SourcePayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Source that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SourceFindFirstOrThrowArgs} args - Arguments to find a Source
     * @example
     * // Get one Source
     * const source = await prisma.source.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SourceFindFirstOrThrowArgs>(args?: SelectSubset<T, SourceFindFirstOrThrowArgs<ExtArgs>>): Prisma__SourceClient<$Result.GetResult<Prisma.$SourcePayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Sources that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SourceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Sources
     * const sources = await prisma.source.findMany()
     * 
     * // Get first 10 Sources
     * const sources = await prisma.source.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sourceWithIdOnly = await prisma.source.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SourceFindManyArgs>(args?: SelectSubset<T, SourceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SourcePayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Source.
     * @param {SourceCreateArgs} args - Arguments to create a Source.
     * @example
     * // Create one Source
     * const Source = await prisma.source.create({
     *   data: {
     *     // ... data to create a Source
     *   }
     * })
     * 
     */
    create<T extends SourceCreateArgs>(args: SelectSubset<T, SourceCreateArgs<ExtArgs>>): Prisma__SourceClient<$Result.GetResult<Prisma.$SourcePayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Sources.
     * @param {SourceCreateManyArgs} args - Arguments to create many Sources.
     * @example
     * // Create many Sources
     * const source = await prisma.source.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SourceCreateManyArgs>(args?: SelectSubset<T, SourceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Sources and returns the data saved in the database.
     * @param {SourceCreateManyAndReturnArgs} args - Arguments to create many Sources.
     * @example
     * // Create many Sources
     * const source = await prisma.source.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Sources and only return the `id`
     * const sourceWithIdOnly = await prisma.source.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SourceCreateManyAndReturnArgs>(args?: SelectSubset<T, SourceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SourcePayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Source.
     * @param {SourceDeleteArgs} args - Arguments to delete one Source.
     * @example
     * // Delete one Source
     * const Source = await prisma.source.delete({
     *   where: {
     *     // ... filter to delete one Source
     *   }
     * })
     * 
     */
    delete<T extends SourceDeleteArgs>(args: SelectSubset<T, SourceDeleteArgs<ExtArgs>>): Prisma__SourceClient<$Result.GetResult<Prisma.$SourcePayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Source.
     * @param {SourceUpdateArgs} args - Arguments to update one Source.
     * @example
     * // Update one Source
     * const source = await prisma.source.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SourceUpdateArgs>(args: SelectSubset<T, SourceUpdateArgs<ExtArgs>>): Prisma__SourceClient<$Result.GetResult<Prisma.$SourcePayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Sources.
     * @param {SourceDeleteManyArgs} args - Arguments to filter Sources to delete.
     * @example
     * // Delete a few Sources
     * const { count } = await prisma.source.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SourceDeleteManyArgs>(args?: SelectSubset<T, SourceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sources.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SourceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Sources
     * const source = await prisma.source.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SourceUpdateManyArgs>(args: SelectSubset<T, SourceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sources and returns the data updated in the database.
     * @param {SourceUpdateManyAndReturnArgs} args - Arguments to update many Sources.
     * @example
     * // Update many Sources
     * const source = await prisma.source.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Sources and only return the `id`
     * const sourceWithIdOnly = await prisma.source.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SourceUpdateManyAndReturnArgs>(args: SelectSubset<T, SourceUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SourcePayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Source.
     * @param {SourceUpsertArgs} args - Arguments to update or create a Source.
     * @example
     * // Update or create a Source
     * const source = await prisma.source.upsert({
     *   create: {
     *     // ... data to create a Source
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Source we want to update
     *   }
     * })
     */
    upsert<T extends SourceUpsertArgs>(args: SelectSubset<T, SourceUpsertArgs<ExtArgs>>): Prisma__SourceClient<$Result.GetResult<Prisma.$SourcePayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Sources.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SourceCountArgs} args - Arguments to filter Sources to count.
     * @example
     * // Count the number of Sources
     * const count = await prisma.source.count({
     *   where: {
     *     // ... the filter for the Sources we want to count
     *   }
     * })
    **/
    count<T extends SourceCountArgs>(
      args?: Subset<T, SourceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SourceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Source.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SourceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SourceAggregateArgs>(args: Subset<T, SourceAggregateArgs>): Prisma.PrismaPromise<GetSourceAggregateType<T>>

    /**
     * Group by Source.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SourceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SourceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SourceGroupByArgs['orderBy'] }
        : { orderBy?: SourceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SourceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSourceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Source model
   */
  readonly fields: SourceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Source.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SourceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    creatures<T extends Source$creaturesArgs<ExtArgs> = {}>(args?: Subset<T, Source$creaturesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CreaturePayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    magicItems<T extends Source$magicItemsArgs<ExtArgs> = {}>(args?: Subset<T, Source$magicItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MagicItemPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Source model
   */ 
  interface SourceFieldRefs {
    readonly id: FieldRef<"Source", 'Int'>
    readonly short_name: FieldRef<"Source", 'String'>
    readonly name: FieldRef<"Source", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Source findUnique
   */
  export type SourceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Source
     */
    select?: SourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Source
     */
    omit?: SourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SourceInclude<ExtArgs> | null
    /**
     * Filter, which Source to fetch.
     */
    where: SourceWhereUniqueInput
  }

  /**
   * Source findUniqueOrThrow
   */
  export type SourceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Source
     */
    select?: SourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Source
     */
    omit?: SourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SourceInclude<ExtArgs> | null
    /**
     * Filter, which Source to fetch.
     */
    where: SourceWhereUniqueInput
  }

  /**
   * Source findFirst
   */
  export type SourceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Source
     */
    select?: SourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Source
     */
    omit?: SourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SourceInclude<ExtArgs> | null
    /**
     * Filter, which Source to fetch.
     */
    where?: SourceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sources to fetch.
     */
    orderBy?: SourceOrderByWithRelationInput | SourceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sources.
     */
    cursor?: SourceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sources from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sources.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sources.
     */
    distinct?: SourceScalarFieldEnum | SourceScalarFieldEnum[]
  }

  /**
   * Source findFirstOrThrow
   */
  export type SourceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Source
     */
    select?: SourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Source
     */
    omit?: SourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SourceInclude<ExtArgs> | null
    /**
     * Filter, which Source to fetch.
     */
    where?: SourceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sources to fetch.
     */
    orderBy?: SourceOrderByWithRelationInput | SourceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sources.
     */
    cursor?: SourceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sources from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sources.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sources.
     */
    distinct?: SourceScalarFieldEnum | SourceScalarFieldEnum[]
  }

  /**
   * Source findMany
   */
  export type SourceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Source
     */
    select?: SourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Source
     */
    omit?: SourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SourceInclude<ExtArgs> | null
    /**
     * Filter, which Sources to fetch.
     */
    where?: SourceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sources to fetch.
     */
    orderBy?: SourceOrderByWithRelationInput | SourceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Sources.
     */
    cursor?: SourceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sources from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sources.
     */
    skip?: number
    distinct?: SourceScalarFieldEnum | SourceScalarFieldEnum[]
  }

  /**
   * Source create
   */
  export type SourceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Source
     */
    select?: SourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Source
     */
    omit?: SourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SourceInclude<ExtArgs> | null
    /**
     * The data needed to create a Source.
     */
    data: XOR<SourceCreateInput, SourceUncheckedCreateInput>
  }

  /**
   * Source createMany
   */
  export type SourceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Sources.
     */
    data: SourceCreateManyInput | SourceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Source createManyAndReturn
   */
  export type SourceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Source
     */
    select?: SourceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Source
     */
    omit?: SourceOmit<ExtArgs> | null
    /**
     * The data used to create many Sources.
     */
    data: SourceCreateManyInput | SourceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Source update
   */
  export type SourceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Source
     */
    select?: SourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Source
     */
    omit?: SourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SourceInclude<ExtArgs> | null
    /**
     * The data needed to update a Source.
     */
    data: XOR<SourceUpdateInput, SourceUncheckedUpdateInput>
    /**
     * Choose, which Source to update.
     */
    where: SourceWhereUniqueInput
  }

  /**
   * Source updateMany
   */
  export type SourceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Sources.
     */
    data: XOR<SourceUpdateManyMutationInput, SourceUncheckedUpdateManyInput>
    /**
     * Filter which Sources to update
     */
    where?: SourceWhereInput
    /**
     * Limit how many Sources to update.
     */
    limit?: number
  }

  /**
   * Source updateManyAndReturn
   */
  export type SourceUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Source
     */
    select?: SourceSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Source
     */
    omit?: SourceOmit<ExtArgs> | null
    /**
     * The data used to update Sources.
     */
    data: XOR<SourceUpdateManyMutationInput, SourceUncheckedUpdateManyInput>
    /**
     * Filter which Sources to update
     */
    where?: SourceWhereInput
    /**
     * Limit how many Sources to update.
     */
    limit?: number
  }

  /**
   * Source upsert
   */
  export type SourceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Source
     */
    select?: SourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Source
     */
    omit?: SourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SourceInclude<ExtArgs> | null
    /**
     * The filter to search for the Source to update in case it exists.
     */
    where: SourceWhereUniqueInput
    /**
     * In case the Source found by the `where` argument doesn't exist, create a new Source with this data.
     */
    create: XOR<SourceCreateInput, SourceUncheckedCreateInput>
    /**
     * In case the Source was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SourceUpdateInput, SourceUncheckedUpdateInput>
  }

  /**
   * Source delete
   */
  export type SourceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Source
     */
    select?: SourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Source
     */
    omit?: SourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SourceInclude<ExtArgs> | null
    /**
     * Filter which Source to delete.
     */
    where: SourceWhereUniqueInput
  }

  /**
   * Source deleteMany
   */
  export type SourceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Sources to delete
     */
    where?: SourceWhereInput
    /**
     * Limit how many Sources to delete.
     */
    limit?: number
  }

  /**
   * Source.creatures
   */
  export type Source$creaturesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Creature
     */
    select?: CreatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Creature
     */
    omit?: CreatureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreatureInclude<ExtArgs> | null
    where?: CreatureWhereInput
    orderBy?: CreatureOrderByWithRelationInput | CreatureOrderByWithRelationInput[]
    cursor?: CreatureWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CreatureScalarFieldEnum | CreatureScalarFieldEnum[]
  }

  /**
   * Source.magicItems
   */
  export type Source$magicItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MagicItem
     */
    select?: MagicItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MagicItem
     */
    omit?: MagicItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MagicItemInclude<ExtArgs> | null
    where?: MagicItemWhereInput
    orderBy?: MagicItemOrderByWithRelationInput | MagicItemOrderByWithRelationInput[]
    cursor?: MagicItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MagicItemScalarFieldEnum | MagicItemScalarFieldEnum[]
  }

  /**
   * Source without action
   */
  export type SourceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Source
     */
    select?: SourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Source
     */
    omit?: SourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SourceInclude<ExtArgs> | null
  }


  /**
   * Model Language
   */

  export type AggregateLanguage = {
    _count: LanguageCountAggregateOutputType | null
    _avg: LanguageAvgAggregateOutputType | null
    _sum: LanguageSumAggregateOutputType | null
    _min: LanguageMinAggregateOutputType | null
    _max: LanguageMaxAggregateOutputType | null
  }

  export type LanguageAvgAggregateOutputType = {
    id: number | null
  }

  export type LanguageSumAggregateOutputType = {
    id: number | null
  }

  export type LanguageMinAggregateOutputType = {
    id: number | null
    name: string | null
  }

  export type LanguageMaxAggregateOutputType = {
    id: number | null
    name: string | null
  }

  export type LanguageCountAggregateOutputType = {
    id: number
    name: number
    _all: number
  }


  export type LanguageAvgAggregateInputType = {
    id?: true
  }

  export type LanguageSumAggregateInputType = {
    id?: true
  }

  export type LanguageMinAggregateInputType = {
    id?: true
    name?: true
  }

  export type LanguageMaxAggregateInputType = {
    id?: true
    name?: true
  }

  export type LanguageCountAggregateInputType = {
    id?: true
    name?: true
    _all?: true
  }

  export type LanguageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Language to aggregate.
     */
    where?: LanguageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Languages to fetch.
     */
    orderBy?: LanguageOrderByWithRelationInput | LanguageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LanguageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Languages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Languages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Languages
    **/
    _count?: true | LanguageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LanguageAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LanguageSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LanguageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LanguageMaxAggregateInputType
  }

  export type GetLanguageAggregateType<T extends LanguageAggregateArgs> = {
        [P in keyof T & keyof AggregateLanguage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLanguage[P]>
      : GetScalarType<T[P], AggregateLanguage[P]>
  }




  export type LanguageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LanguageWhereInput
    orderBy?: LanguageOrderByWithAggregationInput | LanguageOrderByWithAggregationInput[]
    by: LanguageScalarFieldEnum[] | LanguageScalarFieldEnum
    having?: LanguageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LanguageCountAggregateInputType | true
    _avg?: LanguageAvgAggregateInputType
    _sum?: LanguageSumAggregateInputType
    _min?: LanguageMinAggregateInputType
    _max?: LanguageMaxAggregateInputType
  }

  export type LanguageGroupByOutputType = {
    id: number
    name: string
    _count: LanguageCountAggregateOutputType | null
    _avg: LanguageAvgAggregateOutputType | null
    _sum: LanguageSumAggregateOutputType | null
    _min: LanguageMinAggregateOutputType | null
    _max: LanguageMaxAggregateOutputType | null
  }

  type GetLanguageGroupByPayload<T extends LanguageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LanguageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LanguageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LanguageGroupByOutputType[P]>
            : GetScalarType<T[P], LanguageGroupByOutputType[P]>
        }
      >
    >


  export type LanguageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    creatures_relation?: boolean | Language$creatures_relationArgs<ExtArgs>
    _count?: boolean | LanguageCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["language"]>

  export type LanguageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
  }, ExtArgs["result"]["language"]>

  export type LanguageSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
  }, ExtArgs["result"]["language"]>

  export type LanguageSelectScalar = {
    id?: boolean
    name?: boolean
  }

  export type LanguageOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name", ExtArgs["result"]["language"]>
  export type LanguageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creatures_relation?: boolean | Language$creatures_relationArgs<ExtArgs>
    _count?: boolean | LanguageCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type LanguageIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type LanguageIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $LanguagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Language"
    objects: {
      creatures_relation: Prisma.$CreaturePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
    }, ExtArgs["result"]["language"]>
    composites: {}
  }

  type LanguageGetPayload<S extends boolean | null | undefined | LanguageDefaultArgs> = $Result.GetResult<Prisma.$LanguagePayload, S>

  type LanguageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LanguageFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LanguageCountAggregateInputType | true
    }

  export interface LanguageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Language'], meta: { name: 'Language' } }
    /**
     * Find zero or one Language that matches the filter.
     * @param {LanguageFindUniqueArgs} args - Arguments to find a Language
     * @example
     * // Get one Language
     * const language = await prisma.language.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LanguageFindUniqueArgs>(args: SelectSubset<T, LanguageFindUniqueArgs<ExtArgs>>): Prisma__LanguageClient<$Result.GetResult<Prisma.$LanguagePayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Language that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LanguageFindUniqueOrThrowArgs} args - Arguments to find a Language
     * @example
     * // Get one Language
     * const language = await prisma.language.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LanguageFindUniqueOrThrowArgs>(args: SelectSubset<T, LanguageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LanguageClient<$Result.GetResult<Prisma.$LanguagePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Language that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LanguageFindFirstArgs} args - Arguments to find a Language
     * @example
     * // Get one Language
     * const language = await prisma.language.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LanguageFindFirstArgs>(args?: SelectSubset<T, LanguageFindFirstArgs<ExtArgs>>): Prisma__LanguageClient<$Result.GetResult<Prisma.$LanguagePayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Language that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LanguageFindFirstOrThrowArgs} args - Arguments to find a Language
     * @example
     * // Get one Language
     * const language = await prisma.language.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LanguageFindFirstOrThrowArgs>(args?: SelectSubset<T, LanguageFindFirstOrThrowArgs<ExtArgs>>): Prisma__LanguageClient<$Result.GetResult<Prisma.$LanguagePayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Languages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LanguageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Languages
     * const languages = await prisma.language.findMany()
     * 
     * // Get first 10 Languages
     * const languages = await prisma.language.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const languageWithIdOnly = await prisma.language.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LanguageFindManyArgs>(args?: SelectSubset<T, LanguageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LanguagePayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Language.
     * @param {LanguageCreateArgs} args - Arguments to create a Language.
     * @example
     * // Create one Language
     * const Language = await prisma.language.create({
     *   data: {
     *     // ... data to create a Language
     *   }
     * })
     * 
     */
    create<T extends LanguageCreateArgs>(args: SelectSubset<T, LanguageCreateArgs<ExtArgs>>): Prisma__LanguageClient<$Result.GetResult<Prisma.$LanguagePayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Languages.
     * @param {LanguageCreateManyArgs} args - Arguments to create many Languages.
     * @example
     * // Create many Languages
     * const language = await prisma.language.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LanguageCreateManyArgs>(args?: SelectSubset<T, LanguageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Languages and returns the data saved in the database.
     * @param {LanguageCreateManyAndReturnArgs} args - Arguments to create many Languages.
     * @example
     * // Create many Languages
     * const language = await prisma.language.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Languages and only return the `id`
     * const languageWithIdOnly = await prisma.language.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LanguageCreateManyAndReturnArgs>(args?: SelectSubset<T, LanguageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LanguagePayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Language.
     * @param {LanguageDeleteArgs} args - Arguments to delete one Language.
     * @example
     * // Delete one Language
     * const Language = await prisma.language.delete({
     *   where: {
     *     // ... filter to delete one Language
     *   }
     * })
     * 
     */
    delete<T extends LanguageDeleteArgs>(args: SelectSubset<T, LanguageDeleteArgs<ExtArgs>>): Prisma__LanguageClient<$Result.GetResult<Prisma.$LanguagePayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Language.
     * @param {LanguageUpdateArgs} args - Arguments to update one Language.
     * @example
     * // Update one Language
     * const language = await prisma.language.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LanguageUpdateArgs>(args: SelectSubset<T, LanguageUpdateArgs<ExtArgs>>): Prisma__LanguageClient<$Result.GetResult<Prisma.$LanguagePayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Languages.
     * @param {LanguageDeleteManyArgs} args - Arguments to filter Languages to delete.
     * @example
     * // Delete a few Languages
     * const { count } = await prisma.language.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LanguageDeleteManyArgs>(args?: SelectSubset<T, LanguageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Languages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LanguageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Languages
     * const language = await prisma.language.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LanguageUpdateManyArgs>(args: SelectSubset<T, LanguageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Languages and returns the data updated in the database.
     * @param {LanguageUpdateManyAndReturnArgs} args - Arguments to update many Languages.
     * @example
     * // Update many Languages
     * const language = await prisma.language.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Languages and only return the `id`
     * const languageWithIdOnly = await prisma.language.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends LanguageUpdateManyAndReturnArgs>(args: SelectSubset<T, LanguageUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LanguagePayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Language.
     * @param {LanguageUpsertArgs} args - Arguments to update or create a Language.
     * @example
     * // Update or create a Language
     * const language = await prisma.language.upsert({
     *   create: {
     *     // ... data to create a Language
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Language we want to update
     *   }
     * })
     */
    upsert<T extends LanguageUpsertArgs>(args: SelectSubset<T, LanguageUpsertArgs<ExtArgs>>): Prisma__LanguageClient<$Result.GetResult<Prisma.$LanguagePayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Languages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LanguageCountArgs} args - Arguments to filter Languages to count.
     * @example
     * // Count the number of Languages
     * const count = await prisma.language.count({
     *   where: {
     *     // ... the filter for the Languages we want to count
     *   }
     * })
    **/
    count<T extends LanguageCountArgs>(
      args?: Subset<T, LanguageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LanguageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Language.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LanguageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LanguageAggregateArgs>(args: Subset<T, LanguageAggregateArgs>): Prisma.PrismaPromise<GetLanguageAggregateType<T>>

    /**
     * Group by Language.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LanguageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LanguageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LanguageGroupByArgs['orderBy'] }
        : { orderBy?: LanguageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LanguageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLanguageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Language model
   */
  readonly fields: LanguageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Language.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LanguageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    creatures_relation<T extends Language$creatures_relationArgs<ExtArgs> = {}>(args?: Subset<T, Language$creatures_relationArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CreaturePayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Language model
   */ 
  interface LanguageFieldRefs {
    readonly id: FieldRef<"Language", 'Int'>
    readonly name: FieldRef<"Language", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Language findUnique
   */
  export type LanguageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Language
     */
    select?: LanguageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Language
     */
    omit?: LanguageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LanguageInclude<ExtArgs> | null
    /**
     * Filter, which Language to fetch.
     */
    where: LanguageWhereUniqueInput
  }

  /**
   * Language findUniqueOrThrow
   */
  export type LanguageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Language
     */
    select?: LanguageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Language
     */
    omit?: LanguageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LanguageInclude<ExtArgs> | null
    /**
     * Filter, which Language to fetch.
     */
    where: LanguageWhereUniqueInput
  }

  /**
   * Language findFirst
   */
  export type LanguageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Language
     */
    select?: LanguageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Language
     */
    omit?: LanguageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LanguageInclude<ExtArgs> | null
    /**
     * Filter, which Language to fetch.
     */
    where?: LanguageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Languages to fetch.
     */
    orderBy?: LanguageOrderByWithRelationInput | LanguageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Languages.
     */
    cursor?: LanguageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Languages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Languages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Languages.
     */
    distinct?: LanguageScalarFieldEnum | LanguageScalarFieldEnum[]
  }

  /**
   * Language findFirstOrThrow
   */
  export type LanguageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Language
     */
    select?: LanguageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Language
     */
    omit?: LanguageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LanguageInclude<ExtArgs> | null
    /**
     * Filter, which Language to fetch.
     */
    where?: LanguageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Languages to fetch.
     */
    orderBy?: LanguageOrderByWithRelationInput | LanguageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Languages.
     */
    cursor?: LanguageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Languages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Languages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Languages.
     */
    distinct?: LanguageScalarFieldEnum | LanguageScalarFieldEnum[]
  }

  /**
   * Language findMany
   */
  export type LanguageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Language
     */
    select?: LanguageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Language
     */
    omit?: LanguageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LanguageInclude<ExtArgs> | null
    /**
     * Filter, which Languages to fetch.
     */
    where?: LanguageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Languages to fetch.
     */
    orderBy?: LanguageOrderByWithRelationInput | LanguageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Languages.
     */
    cursor?: LanguageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Languages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Languages.
     */
    skip?: number
    distinct?: LanguageScalarFieldEnum | LanguageScalarFieldEnum[]
  }

  /**
   * Language create
   */
  export type LanguageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Language
     */
    select?: LanguageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Language
     */
    omit?: LanguageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LanguageInclude<ExtArgs> | null
    /**
     * The data needed to create a Language.
     */
    data: XOR<LanguageCreateInput, LanguageUncheckedCreateInput>
  }

  /**
   * Language createMany
   */
  export type LanguageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Languages.
     */
    data: LanguageCreateManyInput | LanguageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Language createManyAndReturn
   */
  export type LanguageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Language
     */
    select?: LanguageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Language
     */
    omit?: LanguageOmit<ExtArgs> | null
    /**
     * The data used to create many Languages.
     */
    data: LanguageCreateManyInput | LanguageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Language update
   */
  export type LanguageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Language
     */
    select?: LanguageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Language
     */
    omit?: LanguageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LanguageInclude<ExtArgs> | null
    /**
     * The data needed to update a Language.
     */
    data: XOR<LanguageUpdateInput, LanguageUncheckedUpdateInput>
    /**
     * Choose, which Language to update.
     */
    where: LanguageWhereUniqueInput
  }

  /**
   * Language updateMany
   */
  export type LanguageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Languages.
     */
    data: XOR<LanguageUpdateManyMutationInput, LanguageUncheckedUpdateManyInput>
    /**
     * Filter which Languages to update
     */
    where?: LanguageWhereInput
    /**
     * Limit how many Languages to update.
     */
    limit?: number
  }

  /**
   * Language updateManyAndReturn
   */
  export type LanguageUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Language
     */
    select?: LanguageSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Language
     */
    omit?: LanguageOmit<ExtArgs> | null
    /**
     * The data used to update Languages.
     */
    data: XOR<LanguageUpdateManyMutationInput, LanguageUncheckedUpdateManyInput>
    /**
     * Filter which Languages to update
     */
    where?: LanguageWhereInput
    /**
     * Limit how many Languages to update.
     */
    limit?: number
  }

  /**
   * Language upsert
   */
  export type LanguageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Language
     */
    select?: LanguageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Language
     */
    omit?: LanguageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LanguageInclude<ExtArgs> | null
    /**
     * The filter to search for the Language to update in case it exists.
     */
    where: LanguageWhereUniqueInput
    /**
     * In case the Language found by the `where` argument doesn't exist, create a new Language with this data.
     */
    create: XOR<LanguageCreateInput, LanguageUncheckedCreateInput>
    /**
     * In case the Language was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LanguageUpdateInput, LanguageUncheckedUpdateInput>
  }

  /**
   * Language delete
   */
  export type LanguageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Language
     */
    select?: LanguageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Language
     */
    omit?: LanguageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LanguageInclude<ExtArgs> | null
    /**
     * Filter which Language to delete.
     */
    where: LanguageWhereUniqueInput
  }

  /**
   * Language deleteMany
   */
  export type LanguageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Languages to delete
     */
    where?: LanguageWhereInput
    /**
     * Limit how many Languages to delete.
     */
    limit?: number
  }

  /**
   * Language.creatures_relation
   */
  export type Language$creatures_relationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Creature
     */
    select?: CreatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Creature
     */
    omit?: CreatureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreatureInclude<ExtArgs> | null
    where?: CreatureWhereInput
    orderBy?: CreatureOrderByWithRelationInput | CreatureOrderByWithRelationInput[]
    cursor?: CreatureWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CreatureScalarFieldEnum | CreatureScalarFieldEnum[]
  }

  /**
   * Language without action
   */
  export type LanguageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Language
     */
    select?: LanguageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Language
     */
    omit?: LanguageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LanguageInclude<ExtArgs> | null
  }


  /**
   * Model Biome
   */

  export type AggregateBiome = {
    _count: BiomeCountAggregateOutputType | null
    _avg: BiomeAvgAggregateOutputType | null
    _sum: BiomeSumAggregateOutputType | null
    _min: BiomeMinAggregateOutputType | null
    _max: BiomeMaxAggregateOutputType | null
  }

  export type BiomeAvgAggregateOutputType = {
    id: number | null
  }

  export type BiomeSumAggregateOutputType = {
    id: number | null
  }

  export type BiomeMinAggregateOutputType = {
    id: number | null
    short_name: string | null
    name: string | null
  }

  export type BiomeMaxAggregateOutputType = {
    id: number | null
    short_name: string | null
    name: string | null
  }

  export type BiomeCountAggregateOutputType = {
    id: number
    short_name: number
    name: number
    _all: number
  }


  export type BiomeAvgAggregateInputType = {
    id?: true
  }

  export type BiomeSumAggregateInputType = {
    id?: true
  }

  export type BiomeMinAggregateInputType = {
    id?: true
    short_name?: true
    name?: true
  }

  export type BiomeMaxAggregateInputType = {
    id?: true
    short_name?: true
    name?: true
  }

  export type BiomeCountAggregateInputType = {
    id?: true
    short_name?: true
    name?: true
    _all?: true
  }

  export type BiomeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Biome to aggregate.
     */
    where?: BiomeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Biomes to fetch.
     */
    orderBy?: BiomeOrderByWithRelationInput | BiomeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BiomeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Biomes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Biomes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Biomes
    **/
    _count?: true | BiomeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BiomeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BiomeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BiomeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BiomeMaxAggregateInputType
  }

  export type GetBiomeAggregateType<T extends BiomeAggregateArgs> = {
        [P in keyof T & keyof AggregateBiome]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBiome[P]>
      : GetScalarType<T[P], AggregateBiome[P]>
  }




  export type BiomeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BiomeWhereInput
    orderBy?: BiomeOrderByWithAggregationInput | BiomeOrderByWithAggregationInput[]
    by: BiomeScalarFieldEnum[] | BiomeScalarFieldEnum
    having?: BiomeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BiomeCountAggregateInputType | true
    _avg?: BiomeAvgAggregateInputType
    _sum?: BiomeSumAggregateInputType
    _min?: BiomeMinAggregateInputType
    _max?: BiomeMaxAggregateInputType
  }

  export type BiomeGroupByOutputType = {
    id: number
    short_name: string
    name: string
    _count: BiomeCountAggregateOutputType | null
    _avg: BiomeAvgAggregateOutputType | null
    _sum: BiomeSumAggregateOutputType | null
    _min: BiomeMinAggregateOutputType | null
    _max: BiomeMaxAggregateOutputType | null
  }

  type GetBiomeGroupByPayload<T extends BiomeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BiomeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BiomeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BiomeGroupByOutputType[P]>
            : GetScalarType<T[P], BiomeGroupByOutputType[P]>
        }
      >
    >


  export type BiomeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    short_name?: boolean
    name?: boolean
    creatures_relation?: boolean | Biome$creatures_relationArgs<ExtArgs>
    _count?: boolean | BiomeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["biome"]>

  export type BiomeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    short_name?: boolean
    name?: boolean
  }, ExtArgs["result"]["biome"]>

  export type BiomeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    short_name?: boolean
    name?: boolean
  }, ExtArgs["result"]["biome"]>

  export type BiomeSelectScalar = {
    id?: boolean
    short_name?: boolean
    name?: boolean
  }

  export type BiomeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "short_name" | "name", ExtArgs["result"]["biome"]>
  export type BiomeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creatures_relation?: boolean | Biome$creatures_relationArgs<ExtArgs>
    _count?: boolean | BiomeCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type BiomeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type BiomeIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $BiomePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Biome"
    objects: {
      creatures_relation: Prisma.$CreaturePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      short_name: string
      name: string
    }, ExtArgs["result"]["biome"]>
    composites: {}
  }

  type BiomeGetPayload<S extends boolean | null | undefined | BiomeDefaultArgs> = $Result.GetResult<Prisma.$BiomePayload, S>

  type BiomeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BiomeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BiomeCountAggregateInputType | true
    }

  export interface BiomeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Biome'], meta: { name: 'Biome' } }
    /**
     * Find zero or one Biome that matches the filter.
     * @param {BiomeFindUniqueArgs} args - Arguments to find a Biome
     * @example
     * // Get one Biome
     * const biome = await prisma.biome.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BiomeFindUniqueArgs>(args: SelectSubset<T, BiomeFindUniqueArgs<ExtArgs>>): Prisma__BiomeClient<$Result.GetResult<Prisma.$BiomePayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Biome that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BiomeFindUniqueOrThrowArgs} args - Arguments to find a Biome
     * @example
     * // Get one Biome
     * const biome = await prisma.biome.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BiomeFindUniqueOrThrowArgs>(args: SelectSubset<T, BiomeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BiomeClient<$Result.GetResult<Prisma.$BiomePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Biome that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BiomeFindFirstArgs} args - Arguments to find a Biome
     * @example
     * // Get one Biome
     * const biome = await prisma.biome.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BiomeFindFirstArgs>(args?: SelectSubset<T, BiomeFindFirstArgs<ExtArgs>>): Prisma__BiomeClient<$Result.GetResult<Prisma.$BiomePayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Biome that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BiomeFindFirstOrThrowArgs} args - Arguments to find a Biome
     * @example
     * // Get one Biome
     * const biome = await prisma.biome.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BiomeFindFirstOrThrowArgs>(args?: SelectSubset<T, BiomeFindFirstOrThrowArgs<ExtArgs>>): Prisma__BiomeClient<$Result.GetResult<Prisma.$BiomePayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Biomes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BiomeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Biomes
     * const biomes = await prisma.biome.findMany()
     * 
     * // Get first 10 Biomes
     * const biomes = await prisma.biome.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const biomeWithIdOnly = await prisma.biome.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BiomeFindManyArgs>(args?: SelectSubset<T, BiomeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BiomePayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Biome.
     * @param {BiomeCreateArgs} args - Arguments to create a Biome.
     * @example
     * // Create one Biome
     * const Biome = await prisma.biome.create({
     *   data: {
     *     // ... data to create a Biome
     *   }
     * })
     * 
     */
    create<T extends BiomeCreateArgs>(args: SelectSubset<T, BiomeCreateArgs<ExtArgs>>): Prisma__BiomeClient<$Result.GetResult<Prisma.$BiomePayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Biomes.
     * @param {BiomeCreateManyArgs} args - Arguments to create many Biomes.
     * @example
     * // Create many Biomes
     * const biome = await prisma.biome.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BiomeCreateManyArgs>(args?: SelectSubset<T, BiomeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Biomes and returns the data saved in the database.
     * @param {BiomeCreateManyAndReturnArgs} args - Arguments to create many Biomes.
     * @example
     * // Create many Biomes
     * const biome = await prisma.biome.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Biomes and only return the `id`
     * const biomeWithIdOnly = await prisma.biome.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BiomeCreateManyAndReturnArgs>(args?: SelectSubset<T, BiomeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BiomePayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Biome.
     * @param {BiomeDeleteArgs} args - Arguments to delete one Biome.
     * @example
     * // Delete one Biome
     * const Biome = await prisma.biome.delete({
     *   where: {
     *     // ... filter to delete one Biome
     *   }
     * })
     * 
     */
    delete<T extends BiomeDeleteArgs>(args: SelectSubset<T, BiomeDeleteArgs<ExtArgs>>): Prisma__BiomeClient<$Result.GetResult<Prisma.$BiomePayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Biome.
     * @param {BiomeUpdateArgs} args - Arguments to update one Biome.
     * @example
     * // Update one Biome
     * const biome = await prisma.biome.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BiomeUpdateArgs>(args: SelectSubset<T, BiomeUpdateArgs<ExtArgs>>): Prisma__BiomeClient<$Result.GetResult<Prisma.$BiomePayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Biomes.
     * @param {BiomeDeleteManyArgs} args - Arguments to filter Biomes to delete.
     * @example
     * // Delete a few Biomes
     * const { count } = await prisma.biome.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BiomeDeleteManyArgs>(args?: SelectSubset<T, BiomeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Biomes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BiomeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Biomes
     * const biome = await prisma.biome.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BiomeUpdateManyArgs>(args: SelectSubset<T, BiomeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Biomes and returns the data updated in the database.
     * @param {BiomeUpdateManyAndReturnArgs} args - Arguments to update many Biomes.
     * @example
     * // Update many Biomes
     * const biome = await prisma.biome.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Biomes and only return the `id`
     * const biomeWithIdOnly = await prisma.biome.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BiomeUpdateManyAndReturnArgs>(args: SelectSubset<T, BiomeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BiomePayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Biome.
     * @param {BiomeUpsertArgs} args - Arguments to update or create a Biome.
     * @example
     * // Update or create a Biome
     * const biome = await prisma.biome.upsert({
     *   create: {
     *     // ... data to create a Biome
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Biome we want to update
     *   }
     * })
     */
    upsert<T extends BiomeUpsertArgs>(args: SelectSubset<T, BiomeUpsertArgs<ExtArgs>>): Prisma__BiomeClient<$Result.GetResult<Prisma.$BiomePayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Biomes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BiomeCountArgs} args - Arguments to filter Biomes to count.
     * @example
     * // Count the number of Biomes
     * const count = await prisma.biome.count({
     *   where: {
     *     // ... the filter for the Biomes we want to count
     *   }
     * })
    **/
    count<T extends BiomeCountArgs>(
      args?: Subset<T, BiomeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BiomeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Biome.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BiomeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BiomeAggregateArgs>(args: Subset<T, BiomeAggregateArgs>): Prisma.PrismaPromise<GetBiomeAggregateType<T>>

    /**
     * Group by Biome.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BiomeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BiomeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BiomeGroupByArgs['orderBy'] }
        : { orderBy?: BiomeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BiomeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBiomeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Biome model
   */
  readonly fields: BiomeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Biome.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BiomeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    creatures_relation<T extends Biome$creatures_relationArgs<ExtArgs> = {}>(args?: Subset<T, Biome$creatures_relationArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CreaturePayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Biome model
   */ 
  interface BiomeFieldRefs {
    readonly id: FieldRef<"Biome", 'Int'>
    readonly short_name: FieldRef<"Biome", 'String'>
    readonly name: FieldRef<"Biome", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Biome findUnique
   */
  export type BiomeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Biome
     */
    select?: BiomeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Biome
     */
    omit?: BiomeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BiomeInclude<ExtArgs> | null
    /**
     * Filter, which Biome to fetch.
     */
    where: BiomeWhereUniqueInput
  }

  /**
   * Biome findUniqueOrThrow
   */
  export type BiomeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Biome
     */
    select?: BiomeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Biome
     */
    omit?: BiomeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BiomeInclude<ExtArgs> | null
    /**
     * Filter, which Biome to fetch.
     */
    where: BiomeWhereUniqueInput
  }

  /**
   * Biome findFirst
   */
  export type BiomeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Biome
     */
    select?: BiomeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Biome
     */
    omit?: BiomeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BiomeInclude<ExtArgs> | null
    /**
     * Filter, which Biome to fetch.
     */
    where?: BiomeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Biomes to fetch.
     */
    orderBy?: BiomeOrderByWithRelationInput | BiomeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Biomes.
     */
    cursor?: BiomeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Biomes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Biomes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Biomes.
     */
    distinct?: BiomeScalarFieldEnum | BiomeScalarFieldEnum[]
  }

  /**
   * Biome findFirstOrThrow
   */
  export type BiomeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Biome
     */
    select?: BiomeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Biome
     */
    omit?: BiomeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BiomeInclude<ExtArgs> | null
    /**
     * Filter, which Biome to fetch.
     */
    where?: BiomeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Biomes to fetch.
     */
    orderBy?: BiomeOrderByWithRelationInput | BiomeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Biomes.
     */
    cursor?: BiomeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Biomes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Biomes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Biomes.
     */
    distinct?: BiomeScalarFieldEnum | BiomeScalarFieldEnum[]
  }

  /**
   * Biome findMany
   */
  export type BiomeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Biome
     */
    select?: BiomeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Biome
     */
    omit?: BiomeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BiomeInclude<ExtArgs> | null
    /**
     * Filter, which Biomes to fetch.
     */
    where?: BiomeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Biomes to fetch.
     */
    orderBy?: BiomeOrderByWithRelationInput | BiomeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Biomes.
     */
    cursor?: BiomeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Biomes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Biomes.
     */
    skip?: number
    distinct?: BiomeScalarFieldEnum | BiomeScalarFieldEnum[]
  }

  /**
   * Biome create
   */
  export type BiomeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Biome
     */
    select?: BiomeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Biome
     */
    omit?: BiomeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BiomeInclude<ExtArgs> | null
    /**
     * The data needed to create a Biome.
     */
    data: XOR<BiomeCreateInput, BiomeUncheckedCreateInput>
  }

  /**
   * Biome createMany
   */
  export type BiomeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Biomes.
     */
    data: BiomeCreateManyInput | BiomeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Biome createManyAndReturn
   */
  export type BiomeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Biome
     */
    select?: BiomeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Biome
     */
    omit?: BiomeOmit<ExtArgs> | null
    /**
     * The data used to create many Biomes.
     */
    data: BiomeCreateManyInput | BiomeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Biome update
   */
  export type BiomeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Biome
     */
    select?: BiomeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Biome
     */
    omit?: BiomeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BiomeInclude<ExtArgs> | null
    /**
     * The data needed to update a Biome.
     */
    data: XOR<BiomeUpdateInput, BiomeUncheckedUpdateInput>
    /**
     * Choose, which Biome to update.
     */
    where: BiomeWhereUniqueInput
  }

  /**
   * Biome updateMany
   */
  export type BiomeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Biomes.
     */
    data: XOR<BiomeUpdateManyMutationInput, BiomeUncheckedUpdateManyInput>
    /**
     * Filter which Biomes to update
     */
    where?: BiomeWhereInput
    /**
     * Limit how many Biomes to update.
     */
    limit?: number
  }

  /**
   * Biome updateManyAndReturn
   */
  export type BiomeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Biome
     */
    select?: BiomeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Biome
     */
    omit?: BiomeOmit<ExtArgs> | null
    /**
     * The data used to update Biomes.
     */
    data: XOR<BiomeUpdateManyMutationInput, BiomeUncheckedUpdateManyInput>
    /**
     * Filter which Biomes to update
     */
    where?: BiomeWhereInput
    /**
     * Limit how many Biomes to update.
     */
    limit?: number
  }

  /**
   * Biome upsert
   */
  export type BiomeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Biome
     */
    select?: BiomeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Biome
     */
    omit?: BiomeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BiomeInclude<ExtArgs> | null
    /**
     * The filter to search for the Biome to update in case it exists.
     */
    where: BiomeWhereUniqueInput
    /**
     * In case the Biome found by the `where` argument doesn't exist, create a new Biome with this data.
     */
    create: XOR<BiomeCreateInput, BiomeUncheckedCreateInput>
    /**
     * In case the Biome was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BiomeUpdateInput, BiomeUncheckedUpdateInput>
  }

  /**
   * Biome delete
   */
  export type BiomeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Biome
     */
    select?: BiomeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Biome
     */
    omit?: BiomeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BiomeInclude<ExtArgs> | null
    /**
     * Filter which Biome to delete.
     */
    where: BiomeWhereUniqueInput
  }

  /**
   * Biome deleteMany
   */
  export type BiomeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Biomes to delete
     */
    where?: BiomeWhereInput
    /**
     * Limit how many Biomes to delete.
     */
    limit?: number
  }

  /**
   * Biome.creatures_relation
   */
  export type Biome$creatures_relationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Creature
     */
    select?: CreatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Creature
     */
    omit?: CreatureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreatureInclude<ExtArgs> | null
    where?: CreatureWhereInput
    orderBy?: CreatureOrderByWithRelationInput | CreatureOrderByWithRelationInput[]
    cursor?: CreatureWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CreatureScalarFieldEnum | CreatureScalarFieldEnum[]
  }

  /**
   * Biome without action
   */
  export type BiomeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Biome
     */
    select?: BiomeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Biome
     */
    omit?: BiomeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BiomeInclude<ExtArgs> | null
  }


  /**
   * Model Type
   */

  export type AggregateType = {
    _count: TypeCountAggregateOutputType | null
    _avg: TypeAvgAggregateOutputType | null
    _sum: TypeSumAggregateOutputType | null
    _min: TypeMinAggregateOutputType | null
    _max: TypeMaxAggregateOutputType | null
  }

  export type TypeAvgAggregateOutputType = {
    id: number | null
  }

  export type TypeSumAggregateOutputType = {
    id: number | null
  }

  export type TypeMinAggregateOutputType = {
    id: number | null
    name: string | null
  }

  export type TypeMaxAggregateOutputType = {
    id: number | null
    name: string | null
  }

  export type TypeCountAggregateOutputType = {
    id: number
    name: number
    _all: number
  }


  export type TypeAvgAggregateInputType = {
    id?: true
  }

  export type TypeSumAggregateInputType = {
    id?: true
  }

  export type TypeMinAggregateInputType = {
    id?: true
    name?: true
  }

  export type TypeMaxAggregateInputType = {
    id?: true
    name?: true
  }

  export type TypeCountAggregateInputType = {
    id?: true
    name?: true
    _all?: true
  }

  export type TypeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Type to aggregate.
     */
    where?: TypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Types to fetch.
     */
    orderBy?: TypeOrderByWithRelationInput | TypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Types from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Types.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Types
    **/
    _count?: true | TypeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TypeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TypeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TypeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TypeMaxAggregateInputType
  }

  export type GetTypeAggregateType<T extends TypeAggregateArgs> = {
        [P in keyof T & keyof AggregateType]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateType[P]>
      : GetScalarType<T[P], AggregateType[P]>
  }




  export type TypeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TypeWhereInput
    orderBy?: TypeOrderByWithAggregationInput | TypeOrderByWithAggregationInput[]
    by: TypeScalarFieldEnum[] | TypeScalarFieldEnum
    having?: TypeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TypeCountAggregateInputType | true
    _avg?: TypeAvgAggregateInputType
    _sum?: TypeSumAggregateInputType
    _min?: TypeMinAggregateInputType
    _max?: TypeMaxAggregateInputType
  }

  export type TypeGroupByOutputType = {
    id: number
    name: string
    _count: TypeCountAggregateOutputType | null
    _avg: TypeAvgAggregateOutputType | null
    _sum: TypeSumAggregateOutputType | null
    _min: TypeMinAggregateOutputType | null
    _max: TypeMaxAggregateOutputType | null
  }

  type GetTypeGroupByPayload<T extends TypeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TypeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TypeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TypeGroupByOutputType[P]>
            : GetScalarType<T[P], TypeGroupByOutputType[P]>
        }
      >
    >


  export type TypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    creatures?: boolean | Type$creaturesArgs<ExtArgs>
    _count?: boolean | TypeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["type"]>

  export type TypeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
  }, ExtArgs["result"]["type"]>

  export type TypeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
  }, ExtArgs["result"]["type"]>

  export type TypeSelectScalar = {
    id?: boolean
    name?: boolean
  }

  export type TypeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name", ExtArgs["result"]["type"]>
  export type TypeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creatures?: boolean | Type$creaturesArgs<ExtArgs>
    _count?: boolean | TypeCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TypeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type TypeIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $TypePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Type"
    objects: {
      creatures: Prisma.$CreaturePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
    }, ExtArgs["result"]["type"]>
    composites: {}
  }

  type TypeGetPayload<S extends boolean | null | undefined | TypeDefaultArgs> = $Result.GetResult<Prisma.$TypePayload, S>

  type TypeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TypeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TypeCountAggregateInputType | true
    }

  export interface TypeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Type'], meta: { name: 'Type' } }
    /**
     * Find zero or one Type that matches the filter.
     * @param {TypeFindUniqueArgs} args - Arguments to find a Type
     * @example
     * // Get one Type
     * const type = await prisma.type.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TypeFindUniqueArgs>(args: SelectSubset<T, TypeFindUniqueArgs<ExtArgs>>): Prisma__TypeClient<$Result.GetResult<Prisma.$TypePayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Type that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TypeFindUniqueOrThrowArgs} args - Arguments to find a Type
     * @example
     * // Get one Type
     * const type = await prisma.type.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TypeFindUniqueOrThrowArgs>(args: SelectSubset<T, TypeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TypeClient<$Result.GetResult<Prisma.$TypePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Type that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TypeFindFirstArgs} args - Arguments to find a Type
     * @example
     * // Get one Type
     * const type = await prisma.type.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TypeFindFirstArgs>(args?: SelectSubset<T, TypeFindFirstArgs<ExtArgs>>): Prisma__TypeClient<$Result.GetResult<Prisma.$TypePayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Type that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TypeFindFirstOrThrowArgs} args - Arguments to find a Type
     * @example
     * // Get one Type
     * const type = await prisma.type.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TypeFindFirstOrThrowArgs>(args?: SelectSubset<T, TypeFindFirstOrThrowArgs<ExtArgs>>): Prisma__TypeClient<$Result.GetResult<Prisma.$TypePayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Types that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TypeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Types
     * const types = await prisma.type.findMany()
     * 
     * // Get first 10 Types
     * const types = await prisma.type.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const typeWithIdOnly = await prisma.type.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TypeFindManyArgs>(args?: SelectSubset<T, TypeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TypePayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Type.
     * @param {TypeCreateArgs} args - Arguments to create a Type.
     * @example
     * // Create one Type
     * const Type = await prisma.type.create({
     *   data: {
     *     // ... data to create a Type
     *   }
     * })
     * 
     */
    create<T extends TypeCreateArgs>(args: SelectSubset<T, TypeCreateArgs<ExtArgs>>): Prisma__TypeClient<$Result.GetResult<Prisma.$TypePayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Types.
     * @param {TypeCreateManyArgs} args - Arguments to create many Types.
     * @example
     * // Create many Types
     * const type = await prisma.type.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TypeCreateManyArgs>(args?: SelectSubset<T, TypeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Types and returns the data saved in the database.
     * @param {TypeCreateManyAndReturnArgs} args - Arguments to create many Types.
     * @example
     * // Create many Types
     * const type = await prisma.type.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Types and only return the `id`
     * const typeWithIdOnly = await prisma.type.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TypeCreateManyAndReturnArgs>(args?: SelectSubset<T, TypeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TypePayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Type.
     * @param {TypeDeleteArgs} args - Arguments to delete one Type.
     * @example
     * // Delete one Type
     * const Type = await prisma.type.delete({
     *   where: {
     *     // ... filter to delete one Type
     *   }
     * })
     * 
     */
    delete<T extends TypeDeleteArgs>(args: SelectSubset<T, TypeDeleteArgs<ExtArgs>>): Prisma__TypeClient<$Result.GetResult<Prisma.$TypePayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Type.
     * @param {TypeUpdateArgs} args - Arguments to update one Type.
     * @example
     * // Update one Type
     * const type = await prisma.type.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TypeUpdateArgs>(args: SelectSubset<T, TypeUpdateArgs<ExtArgs>>): Prisma__TypeClient<$Result.GetResult<Prisma.$TypePayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Types.
     * @param {TypeDeleteManyArgs} args - Arguments to filter Types to delete.
     * @example
     * // Delete a few Types
     * const { count } = await prisma.type.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TypeDeleteManyArgs>(args?: SelectSubset<T, TypeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Types.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TypeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Types
     * const type = await prisma.type.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TypeUpdateManyArgs>(args: SelectSubset<T, TypeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Types and returns the data updated in the database.
     * @param {TypeUpdateManyAndReturnArgs} args - Arguments to update many Types.
     * @example
     * // Update many Types
     * const type = await prisma.type.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Types and only return the `id`
     * const typeWithIdOnly = await prisma.type.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TypeUpdateManyAndReturnArgs>(args: SelectSubset<T, TypeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TypePayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Type.
     * @param {TypeUpsertArgs} args - Arguments to update or create a Type.
     * @example
     * // Update or create a Type
     * const type = await prisma.type.upsert({
     *   create: {
     *     // ... data to create a Type
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Type we want to update
     *   }
     * })
     */
    upsert<T extends TypeUpsertArgs>(args: SelectSubset<T, TypeUpsertArgs<ExtArgs>>): Prisma__TypeClient<$Result.GetResult<Prisma.$TypePayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Types.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TypeCountArgs} args - Arguments to filter Types to count.
     * @example
     * // Count the number of Types
     * const count = await prisma.type.count({
     *   where: {
     *     // ... the filter for the Types we want to count
     *   }
     * })
    **/
    count<T extends TypeCountArgs>(
      args?: Subset<T, TypeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TypeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Type.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TypeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TypeAggregateArgs>(args: Subset<T, TypeAggregateArgs>): Prisma.PrismaPromise<GetTypeAggregateType<T>>

    /**
     * Group by Type.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TypeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TypeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TypeGroupByArgs['orderBy'] }
        : { orderBy?: TypeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TypeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTypeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Type model
   */
  readonly fields: TypeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Type.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TypeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    creatures<T extends Type$creaturesArgs<ExtArgs> = {}>(args?: Subset<T, Type$creaturesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CreaturePayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Type model
   */ 
  interface TypeFieldRefs {
    readonly id: FieldRef<"Type", 'Int'>
    readonly name: FieldRef<"Type", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Type findUnique
   */
  export type TypeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Type
     */
    select?: TypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Type
     */
    omit?: TypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TypeInclude<ExtArgs> | null
    /**
     * Filter, which Type to fetch.
     */
    where: TypeWhereUniqueInput
  }

  /**
   * Type findUniqueOrThrow
   */
  export type TypeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Type
     */
    select?: TypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Type
     */
    omit?: TypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TypeInclude<ExtArgs> | null
    /**
     * Filter, which Type to fetch.
     */
    where: TypeWhereUniqueInput
  }

  /**
   * Type findFirst
   */
  export type TypeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Type
     */
    select?: TypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Type
     */
    omit?: TypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TypeInclude<ExtArgs> | null
    /**
     * Filter, which Type to fetch.
     */
    where?: TypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Types to fetch.
     */
    orderBy?: TypeOrderByWithRelationInput | TypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Types.
     */
    cursor?: TypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Types from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Types.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Types.
     */
    distinct?: TypeScalarFieldEnum | TypeScalarFieldEnum[]
  }

  /**
   * Type findFirstOrThrow
   */
  export type TypeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Type
     */
    select?: TypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Type
     */
    omit?: TypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TypeInclude<ExtArgs> | null
    /**
     * Filter, which Type to fetch.
     */
    where?: TypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Types to fetch.
     */
    orderBy?: TypeOrderByWithRelationInput | TypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Types.
     */
    cursor?: TypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Types from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Types.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Types.
     */
    distinct?: TypeScalarFieldEnum | TypeScalarFieldEnum[]
  }

  /**
   * Type findMany
   */
  export type TypeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Type
     */
    select?: TypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Type
     */
    omit?: TypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TypeInclude<ExtArgs> | null
    /**
     * Filter, which Types to fetch.
     */
    where?: TypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Types to fetch.
     */
    orderBy?: TypeOrderByWithRelationInput | TypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Types.
     */
    cursor?: TypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Types from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Types.
     */
    skip?: number
    distinct?: TypeScalarFieldEnum | TypeScalarFieldEnum[]
  }

  /**
   * Type create
   */
  export type TypeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Type
     */
    select?: TypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Type
     */
    omit?: TypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TypeInclude<ExtArgs> | null
    /**
     * The data needed to create a Type.
     */
    data: XOR<TypeCreateInput, TypeUncheckedCreateInput>
  }

  /**
   * Type createMany
   */
  export type TypeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Types.
     */
    data: TypeCreateManyInput | TypeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Type createManyAndReturn
   */
  export type TypeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Type
     */
    select?: TypeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Type
     */
    omit?: TypeOmit<ExtArgs> | null
    /**
     * The data used to create many Types.
     */
    data: TypeCreateManyInput | TypeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Type update
   */
  export type TypeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Type
     */
    select?: TypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Type
     */
    omit?: TypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TypeInclude<ExtArgs> | null
    /**
     * The data needed to update a Type.
     */
    data: XOR<TypeUpdateInput, TypeUncheckedUpdateInput>
    /**
     * Choose, which Type to update.
     */
    where: TypeWhereUniqueInput
  }

  /**
   * Type updateMany
   */
  export type TypeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Types.
     */
    data: XOR<TypeUpdateManyMutationInput, TypeUncheckedUpdateManyInput>
    /**
     * Filter which Types to update
     */
    where?: TypeWhereInput
    /**
     * Limit how many Types to update.
     */
    limit?: number
  }

  /**
   * Type updateManyAndReturn
   */
  export type TypeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Type
     */
    select?: TypeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Type
     */
    omit?: TypeOmit<ExtArgs> | null
    /**
     * The data used to update Types.
     */
    data: XOR<TypeUpdateManyMutationInput, TypeUncheckedUpdateManyInput>
    /**
     * Filter which Types to update
     */
    where?: TypeWhereInput
    /**
     * Limit how many Types to update.
     */
    limit?: number
  }

  /**
   * Type upsert
   */
  export type TypeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Type
     */
    select?: TypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Type
     */
    omit?: TypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TypeInclude<ExtArgs> | null
    /**
     * The filter to search for the Type to update in case it exists.
     */
    where: TypeWhereUniqueInput
    /**
     * In case the Type found by the `where` argument doesn't exist, create a new Type with this data.
     */
    create: XOR<TypeCreateInput, TypeUncheckedCreateInput>
    /**
     * In case the Type was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TypeUpdateInput, TypeUncheckedUpdateInput>
  }

  /**
   * Type delete
   */
  export type TypeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Type
     */
    select?: TypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Type
     */
    omit?: TypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TypeInclude<ExtArgs> | null
    /**
     * Filter which Type to delete.
     */
    where: TypeWhereUniqueInput
  }

  /**
   * Type deleteMany
   */
  export type TypeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Types to delete
     */
    where?: TypeWhereInput
    /**
     * Limit how many Types to delete.
     */
    limit?: number
  }

  /**
   * Type.creatures
   */
  export type Type$creaturesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Creature
     */
    select?: CreatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Creature
     */
    omit?: CreatureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreatureInclude<ExtArgs> | null
    where?: CreatureWhereInput
    orderBy?: CreatureOrderByWithRelationInput | CreatureOrderByWithRelationInput[]
    cursor?: CreatureWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CreatureScalarFieldEnum | CreatureScalarFieldEnum[]
  }

  /**
   * Type without action
   */
  export type TypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Type
     */
    select?: TypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Type
     */
    omit?: TypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TypeInclude<ExtArgs> | null
  }


  /**
   * Model Alignment
   */

  export type AggregateAlignment = {
    _count: AlignmentCountAggregateOutputType | null
    _avg: AlignmentAvgAggregateOutputType | null
    _sum: AlignmentSumAggregateOutputType | null
    _min: AlignmentMinAggregateOutputType | null
    _max: AlignmentMaxAggregateOutputType | null
  }

  export type AlignmentAvgAggregateOutputType = {
    id: number | null
  }

  export type AlignmentSumAggregateOutputType = {
    id: number | null
  }

  export type AlignmentMinAggregateOutputType = {
    id: number | null
    name: string | null
  }

  export type AlignmentMaxAggregateOutputType = {
    id: number | null
    name: string | null
  }

  export type AlignmentCountAggregateOutputType = {
    id: number
    name: number
    _all: number
  }


  export type AlignmentAvgAggregateInputType = {
    id?: true
  }

  export type AlignmentSumAggregateInputType = {
    id?: true
  }

  export type AlignmentMinAggregateInputType = {
    id?: true
    name?: true
  }

  export type AlignmentMaxAggregateInputType = {
    id?: true
    name?: true
  }

  export type AlignmentCountAggregateInputType = {
    id?: true
    name?: true
    _all?: true
  }

  export type AlignmentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Alignment to aggregate.
     */
    where?: AlignmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Alignments to fetch.
     */
    orderBy?: AlignmentOrderByWithRelationInput | AlignmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AlignmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Alignments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Alignments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Alignments
    **/
    _count?: true | AlignmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AlignmentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AlignmentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AlignmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AlignmentMaxAggregateInputType
  }

  export type GetAlignmentAggregateType<T extends AlignmentAggregateArgs> = {
        [P in keyof T & keyof AggregateAlignment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAlignment[P]>
      : GetScalarType<T[P], AggregateAlignment[P]>
  }




  export type AlignmentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AlignmentWhereInput
    orderBy?: AlignmentOrderByWithAggregationInput | AlignmentOrderByWithAggregationInput[]
    by: AlignmentScalarFieldEnum[] | AlignmentScalarFieldEnum
    having?: AlignmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AlignmentCountAggregateInputType | true
    _avg?: AlignmentAvgAggregateInputType
    _sum?: AlignmentSumAggregateInputType
    _min?: AlignmentMinAggregateInputType
    _max?: AlignmentMaxAggregateInputType
  }

  export type AlignmentGroupByOutputType = {
    id: number
    name: string
    _count: AlignmentCountAggregateOutputType | null
    _avg: AlignmentAvgAggregateOutputType | null
    _sum: AlignmentSumAggregateOutputType | null
    _min: AlignmentMinAggregateOutputType | null
    _max: AlignmentMaxAggregateOutputType | null
  }

  type GetAlignmentGroupByPayload<T extends AlignmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AlignmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AlignmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AlignmentGroupByOutputType[P]>
            : GetScalarType<T[P], AlignmentGroupByOutputType[P]>
        }
      >
    >


  export type AlignmentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    creatures?: boolean | Alignment$creaturesArgs<ExtArgs>
    _count?: boolean | AlignmentCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["alignment"]>

  export type AlignmentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
  }, ExtArgs["result"]["alignment"]>

  export type AlignmentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
  }, ExtArgs["result"]["alignment"]>

  export type AlignmentSelectScalar = {
    id?: boolean
    name?: boolean
  }

  export type AlignmentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name", ExtArgs["result"]["alignment"]>
  export type AlignmentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creatures?: boolean | Alignment$creaturesArgs<ExtArgs>
    _count?: boolean | AlignmentCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type AlignmentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type AlignmentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $AlignmentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Alignment"
    objects: {
      creatures: Prisma.$CreaturePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
    }, ExtArgs["result"]["alignment"]>
    composites: {}
  }

  type AlignmentGetPayload<S extends boolean | null | undefined | AlignmentDefaultArgs> = $Result.GetResult<Prisma.$AlignmentPayload, S>

  type AlignmentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AlignmentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AlignmentCountAggregateInputType | true
    }

  export interface AlignmentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Alignment'], meta: { name: 'Alignment' } }
    /**
     * Find zero or one Alignment that matches the filter.
     * @param {AlignmentFindUniqueArgs} args - Arguments to find a Alignment
     * @example
     * // Get one Alignment
     * const alignment = await prisma.alignment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AlignmentFindUniqueArgs>(args: SelectSubset<T, AlignmentFindUniqueArgs<ExtArgs>>): Prisma__AlignmentClient<$Result.GetResult<Prisma.$AlignmentPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Alignment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AlignmentFindUniqueOrThrowArgs} args - Arguments to find a Alignment
     * @example
     * // Get one Alignment
     * const alignment = await prisma.alignment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AlignmentFindUniqueOrThrowArgs>(args: SelectSubset<T, AlignmentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AlignmentClient<$Result.GetResult<Prisma.$AlignmentPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Alignment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlignmentFindFirstArgs} args - Arguments to find a Alignment
     * @example
     * // Get one Alignment
     * const alignment = await prisma.alignment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AlignmentFindFirstArgs>(args?: SelectSubset<T, AlignmentFindFirstArgs<ExtArgs>>): Prisma__AlignmentClient<$Result.GetResult<Prisma.$AlignmentPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Alignment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlignmentFindFirstOrThrowArgs} args - Arguments to find a Alignment
     * @example
     * // Get one Alignment
     * const alignment = await prisma.alignment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AlignmentFindFirstOrThrowArgs>(args?: SelectSubset<T, AlignmentFindFirstOrThrowArgs<ExtArgs>>): Prisma__AlignmentClient<$Result.GetResult<Prisma.$AlignmentPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Alignments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlignmentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Alignments
     * const alignments = await prisma.alignment.findMany()
     * 
     * // Get first 10 Alignments
     * const alignments = await prisma.alignment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const alignmentWithIdOnly = await prisma.alignment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AlignmentFindManyArgs>(args?: SelectSubset<T, AlignmentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AlignmentPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Alignment.
     * @param {AlignmentCreateArgs} args - Arguments to create a Alignment.
     * @example
     * // Create one Alignment
     * const Alignment = await prisma.alignment.create({
     *   data: {
     *     // ... data to create a Alignment
     *   }
     * })
     * 
     */
    create<T extends AlignmentCreateArgs>(args: SelectSubset<T, AlignmentCreateArgs<ExtArgs>>): Prisma__AlignmentClient<$Result.GetResult<Prisma.$AlignmentPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Alignments.
     * @param {AlignmentCreateManyArgs} args - Arguments to create many Alignments.
     * @example
     * // Create many Alignments
     * const alignment = await prisma.alignment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AlignmentCreateManyArgs>(args?: SelectSubset<T, AlignmentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Alignments and returns the data saved in the database.
     * @param {AlignmentCreateManyAndReturnArgs} args - Arguments to create many Alignments.
     * @example
     * // Create many Alignments
     * const alignment = await prisma.alignment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Alignments and only return the `id`
     * const alignmentWithIdOnly = await prisma.alignment.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AlignmentCreateManyAndReturnArgs>(args?: SelectSubset<T, AlignmentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AlignmentPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Alignment.
     * @param {AlignmentDeleteArgs} args - Arguments to delete one Alignment.
     * @example
     * // Delete one Alignment
     * const Alignment = await prisma.alignment.delete({
     *   where: {
     *     // ... filter to delete one Alignment
     *   }
     * })
     * 
     */
    delete<T extends AlignmentDeleteArgs>(args: SelectSubset<T, AlignmentDeleteArgs<ExtArgs>>): Prisma__AlignmentClient<$Result.GetResult<Prisma.$AlignmentPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Alignment.
     * @param {AlignmentUpdateArgs} args - Arguments to update one Alignment.
     * @example
     * // Update one Alignment
     * const alignment = await prisma.alignment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AlignmentUpdateArgs>(args: SelectSubset<T, AlignmentUpdateArgs<ExtArgs>>): Prisma__AlignmentClient<$Result.GetResult<Prisma.$AlignmentPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Alignments.
     * @param {AlignmentDeleteManyArgs} args - Arguments to filter Alignments to delete.
     * @example
     * // Delete a few Alignments
     * const { count } = await prisma.alignment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AlignmentDeleteManyArgs>(args?: SelectSubset<T, AlignmentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Alignments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlignmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Alignments
     * const alignment = await prisma.alignment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AlignmentUpdateManyArgs>(args: SelectSubset<T, AlignmentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Alignments and returns the data updated in the database.
     * @param {AlignmentUpdateManyAndReturnArgs} args - Arguments to update many Alignments.
     * @example
     * // Update many Alignments
     * const alignment = await prisma.alignment.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Alignments and only return the `id`
     * const alignmentWithIdOnly = await prisma.alignment.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AlignmentUpdateManyAndReturnArgs>(args: SelectSubset<T, AlignmentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AlignmentPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Alignment.
     * @param {AlignmentUpsertArgs} args - Arguments to update or create a Alignment.
     * @example
     * // Update or create a Alignment
     * const alignment = await prisma.alignment.upsert({
     *   create: {
     *     // ... data to create a Alignment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Alignment we want to update
     *   }
     * })
     */
    upsert<T extends AlignmentUpsertArgs>(args: SelectSubset<T, AlignmentUpsertArgs<ExtArgs>>): Prisma__AlignmentClient<$Result.GetResult<Prisma.$AlignmentPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Alignments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlignmentCountArgs} args - Arguments to filter Alignments to count.
     * @example
     * // Count the number of Alignments
     * const count = await prisma.alignment.count({
     *   where: {
     *     // ... the filter for the Alignments we want to count
     *   }
     * })
    **/
    count<T extends AlignmentCountArgs>(
      args?: Subset<T, AlignmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AlignmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Alignment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlignmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AlignmentAggregateArgs>(args: Subset<T, AlignmentAggregateArgs>): Prisma.PrismaPromise<GetAlignmentAggregateType<T>>

    /**
     * Group by Alignment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlignmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AlignmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AlignmentGroupByArgs['orderBy'] }
        : { orderBy?: AlignmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AlignmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAlignmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Alignment model
   */
  readonly fields: AlignmentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Alignment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AlignmentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    creatures<T extends Alignment$creaturesArgs<ExtArgs> = {}>(args?: Subset<T, Alignment$creaturesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CreaturePayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Alignment model
   */ 
  interface AlignmentFieldRefs {
    readonly id: FieldRef<"Alignment", 'Int'>
    readonly name: FieldRef<"Alignment", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Alignment findUnique
   */
  export type AlignmentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alignment
     */
    select?: AlignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Alignment
     */
    omit?: AlignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlignmentInclude<ExtArgs> | null
    /**
     * Filter, which Alignment to fetch.
     */
    where: AlignmentWhereUniqueInput
  }

  /**
   * Alignment findUniqueOrThrow
   */
  export type AlignmentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alignment
     */
    select?: AlignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Alignment
     */
    omit?: AlignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlignmentInclude<ExtArgs> | null
    /**
     * Filter, which Alignment to fetch.
     */
    where: AlignmentWhereUniqueInput
  }

  /**
   * Alignment findFirst
   */
  export type AlignmentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alignment
     */
    select?: AlignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Alignment
     */
    omit?: AlignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlignmentInclude<ExtArgs> | null
    /**
     * Filter, which Alignment to fetch.
     */
    where?: AlignmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Alignments to fetch.
     */
    orderBy?: AlignmentOrderByWithRelationInput | AlignmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Alignments.
     */
    cursor?: AlignmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Alignments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Alignments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Alignments.
     */
    distinct?: AlignmentScalarFieldEnum | AlignmentScalarFieldEnum[]
  }

  /**
   * Alignment findFirstOrThrow
   */
  export type AlignmentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alignment
     */
    select?: AlignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Alignment
     */
    omit?: AlignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlignmentInclude<ExtArgs> | null
    /**
     * Filter, which Alignment to fetch.
     */
    where?: AlignmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Alignments to fetch.
     */
    orderBy?: AlignmentOrderByWithRelationInput | AlignmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Alignments.
     */
    cursor?: AlignmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Alignments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Alignments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Alignments.
     */
    distinct?: AlignmentScalarFieldEnum | AlignmentScalarFieldEnum[]
  }

  /**
   * Alignment findMany
   */
  export type AlignmentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alignment
     */
    select?: AlignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Alignment
     */
    omit?: AlignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlignmentInclude<ExtArgs> | null
    /**
     * Filter, which Alignments to fetch.
     */
    where?: AlignmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Alignments to fetch.
     */
    orderBy?: AlignmentOrderByWithRelationInput | AlignmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Alignments.
     */
    cursor?: AlignmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Alignments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Alignments.
     */
    skip?: number
    distinct?: AlignmentScalarFieldEnum | AlignmentScalarFieldEnum[]
  }

  /**
   * Alignment create
   */
  export type AlignmentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alignment
     */
    select?: AlignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Alignment
     */
    omit?: AlignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlignmentInclude<ExtArgs> | null
    /**
     * The data needed to create a Alignment.
     */
    data: XOR<AlignmentCreateInput, AlignmentUncheckedCreateInput>
  }

  /**
   * Alignment createMany
   */
  export type AlignmentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Alignments.
     */
    data: AlignmentCreateManyInput | AlignmentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Alignment createManyAndReturn
   */
  export type AlignmentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alignment
     */
    select?: AlignmentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Alignment
     */
    omit?: AlignmentOmit<ExtArgs> | null
    /**
     * The data used to create many Alignments.
     */
    data: AlignmentCreateManyInput | AlignmentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Alignment update
   */
  export type AlignmentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alignment
     */
    select?: AlignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Alignment
     */
    omit?: AlignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlignmentInclude<ExtArgs> | null
    /**
     * The data needed to update a Alignment.
     */
    data: XOR<AlignmentUpdateInput, AlignmentUncheckedUpdateInput>
    /**
     * Choose, which Alignment to update.
     */
    where: AlignmentWhereUniqueInput
  }

  /**
   * Alignment updateMany
   */
  export type AlignmentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Alignments.
     */
    data: XOR<AlignmentUpdateManyMutationInput, AlignmentUncheckedUpdateManyInput>
    /**
     * Filter which Alignments to update
     */
    where?: AlignmentWhereInput
    /**
     * Limit how many Alignments to update.
     */
    limit?: number
  }

  /**
   * Alignment updateManyAndReturn
   */
  export type AlignmentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alignment
     */
    select?: AlignmentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Alignment
     */
    omit?: AlignmentOmit<ExtArgs> | null
    /**
     * The data used to update Alignments.
     */
    data: XOR<AlignmentUpdateManyMutationInput, AlignmentUncheckedUpdateManyInput>
    /**
     * Filter which Alignments to update
     */
    where?: AlignmentWhereInput
    /**
     * Limit how many Alignments to update.
     */
    limit?: number
  }

  /**
   * Alignment upsert
   */
  export type AlignmentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alignment
     */
    select?: AlignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Alignment
     */
    omit?: AlignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlignmentInclude<ExtArgs> | null
    /**
     * The filter to search for the Alignment to update in case it exists.
     */
    where: AlignmentWhereUniqueInput
    /**
     * In case the Alignment found by the `where` argument doesn't exist, create a new Alignment with this data.
     */
    create: XOR<AlignmentCreateInput, AlignmentUncheckedCreateInput>
    /**
     * In case the Alignment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AlignmentUpdateInput, AlignmentUncheckedUpdateInput>
  }

  /**
   * Alignment delete
   */
  export type AlignmentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alignment
     */
    select?: AlignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Alignment
     */
    omit?: AlignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlignmentInclude<ExtArgs> | null
    /**
     * Filter which Alignment to delete.
     */
    where: AlignmentWhereUniqueInput
  }

  /**
   * Alignment deleteMany
   */
  export type AlignmentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Alignments to delete
     */
    where?: AlignmentWhereInput
    /**
     * Limit how many Alignments to delete.
     */
    limit?: number
  }

  /**
   * Alignment.creatures
   */
  export type Alignment$creaturesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Creature
     */
    select?: CreatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Creature
     */
    omit?: CreatureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreatureInclude<ExtArgs> | null
    where?: CreatureWhereInput
    orderBy?: CreatureOrderByWithRelationInput | CreatureOrderByWithRelationInput[]
    cursor?: CreatureWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CreatureScalarFieldEnum | CreatureScalarFieldEnum[]
  }

  /**
   * Alignment without action
   */
  export type AlignmentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alignment
     */
    select?: AlignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Alignment
     */
    omit?: AlignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlignmentInclude<ExtArgs> | null
  }


  /**
   * Model CreatureSpeed
   */

  export type AggregateCreatureSpeed = {
    _count: CreatureSpeedCountAggregateOutputType | null
    _avg: CreatureSpeedAvgAggregateOutputType | null
    _sum: CreatureSpeedSumAggregateOutputType | null
    _min: CreatureSpeedMinAggregateOutputType | null
    _max: CreatureSpeedMaxAggregateOutputType | null
  }

  export type CreatureSpeedAvgAggregateOutputType = {
    walk: number | null
    fly: number | null
    swim: number | null
    burrow: number | null
    climb: number | null
  }

  export type CreatureSpeedSumAggregateOutputType = {
    walk: number | null
    fly: number | null
    swim: number | null
    burrow: number | null
    climb: number | null
  }

  export type CreatureSpeedMinAggregateOutputType = {
    id: string | null
    walk: number | null
    fly: number | null
    swim: number | null
    burrow: number | null
    climb: number | null
  }

  export type CreatureSpeedMaxAggregateOutputType = {
    id: string | null
    walk: number | null
    fly: number | null
    swim: number | null
    burrow: number | null
    climb: number | null
  }

  export type CreatureSpeedCountAggregateOutputType = {
    id: number
    walk: number
    fly: number
    swim: number
    burrow: number
    climb: number
    _all: number
  }


  export type CreatureSpeedAvgAggregateInputType = {
    walk?: true
    fly?: true
    swim?: true
    burrow?: true
    climb?: true
  }

  export type CreatureSpeedSumAggregateInputType = {
    walk?: true
    fly?: true
    swim?: true
    burrow?: true
    climb?: true
  }

  export type CreatureSpeedMinAggregateInputType = {
    id?: true
    walk?: true
    fly?: true
    swim?: true
    burrow?: true
    climb?: true
  }

  export type CreatureSpeedMaxAggregateInputType = {
    id?: true
    walk?: true
    fly?: true
    swim?: true
    burrow?: true
    climb?: true
  }

  export type CreatureSpeedCountAggregateInputType = {
    id?: true
    walk?: true
    fly?: true
    swim?: true
    burrow?: true
    climb?: true
    _all?: true
  }

  export type CreatureSpeedAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CreatureSpeed to aggregate.
     */
    where?: CreatureSpeedWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CreatureSpeeds to fetch.
     */
    orderBy?: CreatureSpeedOrderByWithRelationInput | CreatureSpeedOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CreatureSpeedWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CreatureSpeeds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CreatureSpeeds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CreatureSpeeds
    **/
    _count?: true | CreatureSpeedCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CreatureSpeedAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CreatureSpeedSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CreatureSpeedMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CreatureSpeedMaxAggregateInputType
  }

  export type GetCreatureSpeedAggregateType<T extends CreatureSpeedAggregateArgs> = {
        [P in keyof T & keyof AggregateCreatureSpeed]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCreatureSpeed[P]>
      : GetScalarType<T[P], AggregateCreatureSpeed[P]>
  }




  export type CreatureSpeedGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CreatureSpeedWhereInput
    orderBy?: CreatureSpeedOrderByWithAggregationInput | CreatureSpeedOrderByWithAggregationInput[]
    by: CreatureSpeedScalarFieldEnum[] | CreatureSpeedScalarFieldEnum
    having?: CreatureSpeedScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CreatureSpeedCountAggregateInputType | true
    _avg?: CreatureSpeedAvgAggregateInputType
    _sum?: CreatureSpeedSumAggregateInputType
    _min?: CreatureSpeedMinAggregateInputType
    _max?: CreatureSpeedMaxAggregateInputType
  }

  export type CreatureSpeedGroupByOutputType = {
    id: string
    walk: number | null
    fly: number | null
    swim: number | null
    burrow: number | null
    climb: number | null
    _count: CreatureSpeedCountAggregateOutputType | null
    _avg: CreatureSpeedAvgAggregateOutputType | null
    _sum: CreatureSpeedSumAggregateOutputType | null
    _min: CreatureSpeedMinAggregateOutputType | null
    _max: CreatureSpeedMaxAggregateOutputType | null
  }

  type GetCreatureSpeedGroupByPayload<T extends CreatureSpeedGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CreatureSpeedGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CreatureSpeedGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CreatureSpeedGroupByOutputType[P]>
            : GetScalarType<T[P], CreatureSpeedGroupByOutputType[P]>
        }
      >
    >


  export type CreatureSpeedSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    walk?: boolean
    fly?: boolean
    swim?: boolean
    burrow?: boolean
    climb?: boolean
    creature_relation?: boolean | CreatureDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["creatureSpeed"]>

  export type CreatureSpeedSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    walk?: boolean
    fly?: boolean
    swim?: boolean
    burrow?: boolean
    climb?: boolean
    creature_relation?: boolean | CreatureDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["creatureSpeed"]>

  export type CreatureSpeedSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    walk?: boolean
    fly?: boolean
    swim?: boolean
    burrow?: boolean
    climb?: boolean
    creature_relation?: boolean | CreatureDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["creatureSpeed"]>

  export type CreatureSpeedSelectScalar = {
    id?: boolean
    walk?: boolean
    fly?: boolean
    swim?: boolean
    burrow?: boolean
    climb?: boolean
  }

  export type CreatureSpeedOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "walk" | "fly" | "swim" | "burrow" | "climb", ExtArgs["result"]["creatureSpeed"]>
  export type CreatureSpeedInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creature_relation?: boolean | CreatureDefaultArgs<ExtArgs>
  }
  export type CreatureSpeedIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creature_relation?: boolean | CreatureDefaultArgs<ExtArgs>
  }
  export type CreatureSpeedIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creature_relation?: boolean | CreatureDefaultArgs<ExtArgs>
  }

  export type $CreatureSpeedPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CreatureSpeed"
    objects: {
      creature_relation: Prisma.$CreaturePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      walk: number | null
      fly: number | null
      swim: number | null
      burrow: number | null
      climb: number | null
    }, ExtArgs["result"]["creatureSpeed"]>
    composites: {}
  }

  type CreatureSpeedGetPayload<S extends boolean | null | undefined | CreatureSpeedDefaultArgs> = $Result.GetResult<Prisma.$CreatureSpeedPayload, S>

  type CreatureSpeedCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CreatureSpeedFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CreatureSpeedCountAggregateInputType | true
    }

  export interface CreatureSpeedDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CreatureSpeed'], meta: { name: 'CreatureSpeed' } }
    /**
     * Find zero or one CreatureSpeed that matches the filter.
     * @param {CreatureSpeedFindUniqueArgs} args - Arguments to find a CreatureSpeed
     * @example
     * // Get one CreatureSpeed
     * const creatureSpeed = await prisma.creatureSpeed.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CreatureSpeedFindUniqueArgs>(args: SelectSubset<T, CreatureSpeedFindUniqueArgs<ExtArgs>>): Prisma__CreatureSpeedClient<$Result.GetResult<Prisma.$CreatureSpeedPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one CreatureSpeed that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CreatureSpeedFindUniqueOrThrowArgs} args - Arguments to find a CreatureSpeed
     * @example
     * // Get one CreatureSpeed
     * const creatureSpeed = await prisma.creatureSpeed.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CreatureSpeedFindUniqueOrThrowArgs>(args: SelectSubset<T, CreatureSpeedFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CreatureSpeedClient<$Result.GetResult<Prisma.$CreatureSpeedPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first CreatureSpeed that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreatureSpeedFindFirstArgs} args - Arguments to find a CreatureSpeed
     * @example
     * // Get one CreatureSpeed
     * const creatureSpeed = await prisma.creatureSpeed.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CreatureSpeedFindFirstArgs>(args?: SelectSubset<T, CreatureSpeedFindFirstArgs<ExtArgs>>): Prisma__CreatureSpeedClient<$Result.GetResult<Prisma.$CreatureSpeedPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first CreatureSpeed that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreatureSpeedFindFirstOrThrowArgs} args - Arguments to find a CreatureSpeed
     * @example
     * // Get one CreatureSpeed
     * const creatureSpeed = await prisma.creatureSpeed.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CreatureSpeedFindFirstOrThrowArgs>(args?: SelectSubset<T, CreatureSpeedFindFirstOrThrowArgs<ExtArgs>>): Prisma__CreatureSpeedClient<$Result.GetResult<Prisma.$CreatureSpeedPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more CreatureSpeeds that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreatureSpeedFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CreatureSpeeds
     * const creatureSpeeds = await prisma.creatureSpeed.findMany()
     * 
     * // Get first 10 CreatureSpeeds
     * const creatureSpeeds = await prisma.creatureSpeed.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const creatureSpeedWithIdOnly = await prisma.creatureSpeed.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CreatureSpeedFindManyArgs>(args?: SelectSubset<T, CreatureSpeedFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CreatureSpeedPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a CreatureSpeed.
     * @param {CreatureSpeedCreateArgs} args - Arguments to create a CreatureSpeed.
     * @example
     * // Create one CreatureSpeed
     * const CreatureSpeed = await prisma.creatureSpeed.create({
     *   data: {
     *     // ... data to create a CreatureSpeed
     *   }
     * })
     * 
     */
    create<T extends CreatureSpeedCreateArgs>(args: SelectSubset<T, CreatureSpeedCreateArgs<ExtArgs>>): Prisma__CreatureSpeedClient<$Result.GetResult<Prisma.$CreatureSpeedPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many CreatureSpeeds.
     * @param {CreatureSpeedCreateManyArgs} args - Arguments to create many CreatureSpeeds.
     * @example
     * // Create many CreatureSpeeds
     * const creatureSpeed = await prisma.creatureSpeed.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CreatureSpeedCreateManyArgs>(args?: SelectSubset<T, CreatureSpeedCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CreatureSpeeds and returns the data saved in the database.
     * @param {CreatureSpeedCreateManyAndReturnArgs} args - Arguments to create many CreatureSpeeds.
     * @example
     * // Create many CreatureSpeeds
     * const creatureSpeed = await prisma.creatureSpeed.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CreatureSpeeds and only return the `id`
     * const creatureSpeedWithIdOnly = await prisma.creatureSpeed.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CreatureSpeedCreateManyAndReturnArgs>(args?: SelectSubset<T, CreatureSpeedCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CreatureSpeedPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a CreatureSpeed.
     * @param {CreatureSpeedDeleteArgs} args - Arguments to delete one CreatureSpeed.
     * @example
     * // Delete one CreatureSpeed
     * const CreatureSpeed = await prisma.creatureSpeed.delete({
     *   where: {
     *     // ... filter to delete one CreatureSpeed
     *   }
     * })
     * 
     */
    delete<T extends CreatureSpeedDeleteArgs>(args: SelectSubset<T, CreatureSpeedDeleteArgs<ExtArgs>>): Prisma__CreatureSpeedClient<$Result.GetResult<Prisma.$CreatureSpeedPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one CreatureSpeed.
     * @param {CreatureSpeedUpdateArgs} args - Arguments to update one CreatureSpeed.
     * @example
     * // Update one CreatureSpeed
     * const creatureSpeed = await prisma.creatureSpeed.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CreatureSpeedUpdateArgs>(args: SelectSubset<T, CreatureSpeedUpdateArgs<ExtArgs>>): Prisma__CreatureSpeedClient<$Result.GetResult<Prisma.$CreatureSpeedPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more CreatureSpeeds.
     * @param {CreatureSpeedDeleteManyArgs} args - Arguments to filter CreatureSpeeds to delete.
     * @example
     * // Delete a few CreatureSpeeds
     * const { count } = await prisma.creatureSpeed.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CreatureSpeedDeleteManyArgs>(args?: SelectSubset<T, CreatureSpeedDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CreatureSpeeds.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreatureSpeedUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CreatureSpeeds
     * const creatureSpeed = await prisma.creatureSpeed.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CreatureSpeedUpdateManyArgs>(args: SelectSubset<T, CreatureSpeedUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CreatureSpeeds and returns the data updated in the database.
     * @param {CreatureSpeedUpdateManyAndReturnArgs} args - Arguments to update many CreatureSpeeds.
     * @example
     * // Update many CreatureSpeeds
     * const creatureSpeed = await prisma.creatureSpeed.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CreatureSpeeds and only return the `id`
     * const creatureSpeedWithIdOnly = await prisma.creatureSpeed.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CreatureSpeedUpdateManyAndReturnArgs>(args: SelectSubset<T, CreatureSpeedUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CreatureSpeedPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one CreatureSpeed.
     * @param {CreatureSpeedUpsertArgs} args - Arguments to update or create a CreatureSpeed.
     * @example
     * // Update or create a CreatureSpeed
     * const creatureSpeed = await prisma.creatureSpeed.upsert({
     *   create: {
     *     // ... data to create a CreatureSpeed
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CreatureSpeed we want to update
     *   }
     * })
     */
    upsert<T extends CreatureSpeedUpsertArgs>(args: SelectSubset<T, CreatureSpeedUpsertArgs<ExtArgs>>): Prisma__CreatureSpeedClient<$Result.GetResult<Prisma.$CreatureSpeedPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of CreatureSpeeds.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreatureSpeedCountArgs} args - Arguments to filter CreatureSpeeds to count.
     * @example
     * // Count the number of CreatureSpeeds
     * const count = await prisma.creatureSpeed.count({
     *   where: {
     *     // ... the filter for the CreatureSpeeds we want to count
     *   }
     * })
    **/
    count<T extends CreatureSpeedCountArgs>(
      args?: Subset<T, CreatureSpeedCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CreatureSpeedCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CreatureSpeed.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreatureSpeedAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CreatureSpeedAggregateArgs>(args: Subset<T, CreatureSpeedAggregateArgs>): Prisma.PrismaPromise<GetCreatureSpeedAggregateType<T>>

    /**
     * Group by CreatureSpeed.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreatureSpeedGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CreatureSpeedGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CreatureSpeedGroupByArgs['orderBy'] }
        : { orderBy?: CreatureSpeedGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CreatureSpeedGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCreatureSpeedGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CreatureSpeed model
   */
  readonly fields: CreatureSpeedFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CreatureSpeed.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CreatureSpeedClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    creature_relation<T extends CreatureDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CreatureDefaultArgs<ExtArgs>>): Prisma__CreatureClient<$Result.GetResult<Prisma.$CreaturePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CreatureSpeed model
   */ 
  interface CreatureSpeedFieldRefs {
    readonly id: FieldRef<"CreatureSpeed", 'String'>
    readonly walk: FieldRef<"CreatureSpeed", 'Int'>
    readonly fly: FieldRef<"CreatureSpeed", 'Int'>
    readonly swim: FieldRef<"CreatureSpeed", 'Int'>
    readonly burrow: FieldRef<"CreatureSpeed", 'Int'>
    readonly climb: FieldRef<"CreatureSpeed", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * CreatureSpeed findUnique
   */
  export type CreatureSpeedFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreatureSpeed
     */
    select?: CreatureSpeedSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CreatureSpeed
     */
    omit?: CreatureSpeedOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreatureSpeedInclude<ExtArgs> | null
    /**
     * Filter, which CreatureSpeed to fetch.
     */
    where: CreatureSpeedWhereUniqueInput
  }

  /**
   * CreatureSpeed findUniqueOrThrow
   */
  export type CreatureSpeedFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreatureSpeed
     */
    select?: CreatureSpeedSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CreatureSpeed
     */
    omit?: CreatureSpeedOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreatureSpeedInclude<ExtArgs> | null
    /**
     * Filter, which CreatureSpeed to fetch.
     */
    where: CreatureSpeedWhereUniqueInput
  }

  /**
   * CreatureSpeed findFirst
   */
  export type CreatureSpeedFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreatureSpeed
     */
    select?: CreatureSpeedSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CreatureSpeed
     */
    omit?: CreatureSpeedOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreatureSpeedInclude<ExtArgs> | null
    /**
     * Filter, which CreatureSpeed to fetch.
     */
    where?: CreatureSpeedWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CreatureSpeeds to fetch.
     */
    orderBy?: CreatureSpeedOrderByWithRelationInput | CreatureSpeedOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CreatureSpeeds.
     */
    cursor?: CreatureSpeedWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CreatureSpeeds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CreatureSpeeds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CreatureSpeeds.
     */
    distinct?: CreatureSpeedScalarFieldEnum | CreatureSpeedScalarFieldEnum[]
  }

  /**
   * CreatureSpeed findFirstOrThrow
   */
  export type CreatureSpeedFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreatureSpeed
     */
    select?: CreatureSpeedSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CreatureSpeed
     */
    omit?: CreatureSpeedOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreatureSpeedInclude<ExtArgs> | null
    /**
     * Filter, which CreatureSpeed to fetch.
     */
    where?: CreatureSpeedWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CreatureSpeeds to fetch.
     */
    orderBy?: CreatureSpeedOrderByWithRelationInput | CreatureSpeedOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CreatureSpeeds.
     */
    cursor?: CreatureSpeedWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CreatureSpeeds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CreatureSpeeds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CreatureSpeeds.
     */
    distinct?: CreatureSpeedScalarFieldEnum | CreatureSpeedScalarFieldEnum[]
  }

  /**
   * CreatureSpeed findMany
   */
  export type CreatureSpeedFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreatureSpeed
     */
    select?: CreatureSpeedSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CreatureSpeed
     */
    omit?: CreatureSpeedOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreatureSpeedInclude<ExtArgs> | null
    /**
     * Filter, which CreatureSpeeds to fetch.
     */
    where?: CreatureSpeedWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CreatureSpeeds to fetch.
     */
    orderBy?: CreatureSpeedOrderByWithRelationInput | CreatureSpeedOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CreatureSpeeds.
     */
    cursor?: CreatureSpeedWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CreatureSpeeds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CreatureSpeeds.
     */
    skip?: number
    distinct?: CreatureSpeedScalarFieldEnum | CreatureSpeedScalarFieldEnum[]
  }

  /**
   * CreatureSpeed create
   */
  export type CreatureSpeedCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreatureSpeed
     */
    select?: CreatureSpeedSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CreatureSpeed
     */
    omit?: CreatureSpeedOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreatureSpeedInclude<ExtArgs> | null
    /**
     * The data needed to create a CreatureSpeed.
     */
    data: XOR<CreatureSpeedCreateInput, CreatureSpeedUncheckedCreateInput>
  }

  /**
   * CreatureSpeed createMany
   */
  export type CreatureSpeedCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CreatureSpeeds.
     */
    data: CreatureSpeedCreateManyInput | CreatureSpeedCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CreatureSpeed createManyAndReturn
   */
  export type CreatureSpeedCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreatureSpeed
     */
    select?: CreatureSpeedSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CreatureSpeed
     */
    omit?: CreatureSpeedOmit<ExtArgs> | null
    /**
     * The data used to create many CreatureSpeeds.
     */
    data: CreatureSpeedCreateManyInput | CreatureSpeedCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreatureSpeedIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CreatureSpeed update
   */
  export type CreatureSpeedUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreatureSpeed
     */
    select?: CreatureSpeedSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CreatureSpeed
     */
    omit?: CreatureSpeedOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreatureSpeedInclude<ExtArgs> | null
    /**
     * The data needed to update a CreatureSpeed.
     */
    data: XOR<CreatureSpeedUpdateInput, CreatureSpeedUncheckedUpdateInput>
    /**
     * Choose, which CreatureSpeed to update.
     */
    where: CreatureSpeedWhereUniqueInput
  }

  /**
   * CreatureSpeed updateMany
   */
  export type CreatureSpeedUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CreatureSpeeds.
     */
    data: XOR<CreatureSpeedUpdateManyMutationInput, CreatureSpeedUncheckedUpdateManyInput>
    /**
     * Filter which CreatureSpeeds to update
     */
    where?: CreatureSpeedWhereInput
    /**
     * Limit how many CreatureSpeeds to update.
     */
    limit?: number
  }

  /**
   * CreatureSpeed updateManyAndReturn
   */
  export type CreatureSpeedUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreatureSpeed
     */
    select?: CreatureSpeedSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CreatureSpeed
     */
    omit?: CreatureSpeedOmit<ExtArgs> | null
    /**
     * The data used to update CreatureSpeeds.
     */
    data: XOR<CreatureSpeedUpdateManyMutationInput, CreatureSpeedUncheckedUpdateManyInput>
    /**
     * Filter which CreatureSpeeds to update
     */
    where?: CreatureSpeedWhereInput
    /**
     * Limit how many CreatureSpeeds to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreatureSpeedIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CreatureSpeed upsert
   */
  export type CreatureSpeedUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreatureSpeed
     */
    select?: CreatureSpeedSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CreatureSpeed
     */
    omit?: CreatureSpeedOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreatureSpeedInclude<ExtArgs> | null
    /**
     * The filter to search for the CreatureSpeed to update in case it exists.
     */
    where: CreatureSpeedWhereUniqueInput
    /**
     * In case the CreatureSpeed found by the `where` argument doesn't exist, create a new CreatureSpeed with this data.
     */
    create: XOR<CreatureSpeedCreateInput, CreatureSpeedUncheckedCreateInput>
    /**
     * In case the CreatureSpeed was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CreatureSpeedUpdateInput, CreatureSpeedUncheckedUpdateInput>
  }

  /**
   * CreatureSpeed delete
   */
  export type CreatureSpeedDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreatureSpeed
     */
    select?: CreatureSpeedSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CreatureSpeed
     */
    omit?: CreatureSpeedOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreatureSpeedInclude<ExtArgs> | null
    /**
     * Filter which CreatureSpeed to delete.
     */
    where: CreatureSpeedWhereUniqueInput
  }

  /**
   * CreatureSpeed deleteMany
   */
  export type CreatureSpeedDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CreatureSpeeds to delete
     */
    where?: CreatureSpeedWhereInput
    /**
     * Limit how many CreatureSpeeds to delete.
     */
    limit?: number
  }

  /**
   * CreatureSpeed without action
   */
  export type CreatureSpeedDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreatureSpeed
     */
    select?: CreatureSpeedSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CreatureSpeed
     */
    omit?: CreatureSpeedOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreatureSpeedInclude<ExtArgs> | null
  }


  /**
   * Model CreatureStats
   */

  export type AggregateCreatureStats = {
    _count: CreatureStatsCountAggregateOutputType | null
    _min: CreatureStatsMinAggregateOutputType | null
    _max: CreatureStatsMaxAggregateOutputType | null
  }

  export type CreatureStatsMinAggregateOutputType = {
    id: string | null
  }

  export type CreatureStatsMaxAggregateOutputType = {
    id: string | null
  }

  export type CreatureStatsCountAggregateOutputType = {
    id: number
    _all: number
  }


  export type CreatureStatsMinAggregateInputType = {
    id?: true
  }

  export type CreatureStatsMaxAggregateInputType = {
    id?: true
  }

  export type CreatureStatsCountAggregateInputType = {
    id?: true
    _all?: true
  }

  export type CreatureStatsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CreatureStats to aggregate.
     */
    where?: CreatureStatsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CreatureStats to fetch.
     */
    orderBy?: CreatureStatsOrderByWithRelationInput | CreatureStatsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CreatureStatsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CreatureStats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CreatureStats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CreatureStats
    **/
    _count?: true | CreatureStatsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CreatureStatsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CreatureStatsMaxAggregateInputType
  }

  export type GetCreatureStatsAggregateType<T extends CreatureStatsAggregateArgs> = {
        [P in keyof T & keyof AggregateCreatureStats]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCreatureStats[P]>
      : GetScalarType<T[P], AggregateCreatureStats[P]>
  }




  export type CreatureStatsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CreatureStatsWhereInput
    orderBy?: CreatureStatsOrderByWithAggregationInput | CreatureStatsOrderByWithAggregationInput[]
    by: CreatureStatsScalarFieldEnum[] | CreatureStatsScalarFieldEnum
    having?: CreatureStatsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CreatureStatsCountAggregateInputType | true
    _min?: CreatureStatsMinAggregateInputType
    _max?: CreatureStatsMaxAggregateInputType
  }

  export type CreatureStatsGroupByOutputType = {
    id: string
    _count: CreatureStatsCountAggregateOutputType | null
    _min: CreatureStatsMinAggregateOutputType | null
    _max: CreatureStatsMaxAggregateOutputType | null
  }

  type GetCreatureStatsGroupByPayload<T extends CreatureStatsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CreatureStatsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CreatureStatsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CreatureStatsGroupByOutputType[P]>
            : GetScalarType<T[P], CreatureStatsGroupByOutputType[P]>
        }
      >
    >


  export type CreatureStatsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    stats?: boolean | CreatureStats$statsArgs<ExtArgs>
    creature_relation?: boolean | CreatureDefaultArgs<ExtArgs>
    _count?: boolean | CreatureStatsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["creatureStats"]>

  export type CreatureStatsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    creature_relation?: boolean | CreatureDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["creatureStats"]>

  export type CreatureStatsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    creature_relation?: boolean | CreatureDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["creatureStats"]>

  export type CreatureStatsSelectScalar = {
    id?: boolean
  }

  export type CreatureStatsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id", ExtArgs["result"]["creatureStats"]>
  export type CreatureStatsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    stats?: boolean | CreatureStats$statsArgs<ExtArgs>
    creature_relation?: boolean | CreatureDefaultArgs<ExtArgs>
    _count?: boolean | CreatureStatsCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CreatureStatsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creature_relation?: boolean | CreatureDefaultArgs<ExtArgs>
  }
  export type CreatureStatsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creature_relation?: boolean | CreatureDefaultArgs<ExtArgs>
  }

  export type $CreatureStatsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CreatureStats"
    objects: {
      stats: Prisma.$CreatureStatDetailPayload<ExtArgs>[]
      creature_relation: Prisma.$CreaturePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
    }, ExtArgs["result"]["creatureStats"]>
    composites: {}
  }

  type CreatureStatsGetPayload<S extends boolean | null | undefined | CreatureStatsDefaultArgs> = $Result.GetResult<Prisma.$CreatureStatsPayload, S>

  type CreatureStatsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CreatureStatsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CreatureStatsCountAggregateInputType | true
    }

  export interface CreatureStatsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CreatureStats'], meta: { name: 'CreatureStats' } }
    /**
     * Find zero or one CreatureStats that matches the filter.
     * @param {CreatureStatsFindUniqueArgs} args - Arguments to find a CreatureStats
     * @example
     * // Get one CreatureStats
     * const creatureStats = await prisma.creatureStats.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CreatureStatsFindUniqueArgs>(args: SelectSubset<T, CreatureStatsFindUniqueArgs<ExtArgs>>): Prisma__CreatureStatsClient<$Result.GetResult<Prisma.$CreatureStatsPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one CreatureStats that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CreatureStatsFindUniqueOrThrowArgs} args - Arguments to find a CreatureStats
     * @example
     * // Get one CreatureStats
     * const creatureStats = await prisma.creatureStats.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CreatureStatsFindUniqueOrThrowArgs>(args: SelectSubset<T, CreatureStatsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CreatureStatsClient<$Result.GetResult<Prisma.$CreatureStatsPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first CreatureStats that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreatureStatsFindFirstArgs} args - Arguments to find a CreatureStats
     * @example
     * // Get one CreatureStats
     * const creatureStats = await prisma.creatureStats.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CreatureStatsFindFirstArgs>(args?: SelectSubset<T, CreatureStatsFindFirstArgs<ExtArgs>>): Prisma__CreatureStatsClient<$Result.GetResult<Prisma.$CreatureStatsPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first CreatureStats that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreatureStatsFindFirstOrThrowArgs} args - Arguments to find a CreatureStats
     * @example
     * // Get one CreatureStats
     * const creatureStats = await prisma.creatureStats.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CreatureStatsFindFirstOrThrowArgs>(args?: SelectSubset<T, CreatureStatsFindFirstOrThrowArgs<ExtArgs>>): Prisma__CreatureStatsClient<$Result.GetResult<Prisma.$CreatureStatsPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more CreatureStats that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreatureStatsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CreatureStats
     * const creatureStats = await prisma.creatureStats.findMany()
     * 
     * // Get first 10 CreatureStats
     * const creatureStats = await prisma.creatureStats.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const creatureStatsWithIdOnly = await prisma.creatureStats.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CreatureStatsFindManyArgs>(args?: SelectSubset<T, CreatureStatsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CreatureStatsPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a CreatureStats.
     * @param {CreatureStatsCreateArgs} args - Arguments to create a CreatureStats.
     * @example
     * // Create one CreatureStats
     * const CreatureStats = await prisma.creatureStats.create({
     *   data: {
     *     // ... data to create a CreatureStats
     *   }
     * })
     * 
     */
    create<T extends CreatureStatsCreateArgs>(args: SelectSubset<T, CreatureStatsCreateArgs<ExtArgs>>): Prisma__CreatureStatsClient<$Result.GetResult<Prisma.$CreatureStatsPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many CreatureStats.
     * @param {CreatureStatsCreateManyArgs} args - Arguments to create many CreatureStats.
     * @example
     * // Create many CreatureStats
     * const creatureStats = await prisma.creatureStats.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CreatureStatsCreateManyArgs>(args?: SelectSubset<T, CreatureStatsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CreatureStats and returns the data saved in the database.
     * @param {CreatureStatsCreateManyAndReturnArgs} args - Arguments to create many CreatureStats.
     * @example
     * // Create many CreatureStats
     * const creatureStats = await prisma.creatureStats.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CreatureStats and only return the `id`
     * const creatureStatsWithIdOnly = await prisma.creatureStats.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CreatureStatsCreateManyAndReturnArgs>(args?: SelectSubset<T, CreatureStatsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CreatureStatsPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a CreatureStats.
     * @param {CreatureStatsDeleteArgs} args - Arguments to delete one CreatureStats.
     * @example
     * // Delete one CreatureStats
     * const CreatureStats = await prisma.creatureStats.delete({
     *   where: {
     *     // ... filter to delete one CreatureStats
     *   }
     * })
     * 
     */
    delete<T extends CreatureStatsDeleteArgs>(args: SelectSubset<T, CreatureStatsDeleteArgs<ExtArgs>>): Prisma__CreatureStatsClient<$Result.GetResult<Prisma.$CreatureStatsPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one CreatureStats.
     * @param {CreatureStatsUpdateArgs} args - Arguments to update one CreatureStats.
     * @example
     * // Update one CreatureStats
     * const creatureStats = await prisma.creatureStats.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CreatureStatsUpdateArgs>(args: SelectSubset<T, CreatureStatsUpdateArgs<ExtArgs>>): Prisma__CreatureStatsClient<$Result.GetResult<Prisma.$CreatureStatsPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more CreatureStats.
     * @param {CreatureStatsDeleteManyArgs} args - Arguments to filter CreatureStats to delete.
     * @example
     * // Delete a few CreatureStats
     * const { count } = await prisma.creatureStats.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CreatureStatsDeleteManyArgs>(args?: SelectSubset<T, CreatureStatsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CreatureStats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreatureStatsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CreatureStats
     * const creatureStats = await prisma.creatureStats.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CreatureStatsUpdateManyArgs>(args: SelectSubset<T, CreatureStatsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CreatureStats and returns the data updated in the database.
     * @param {CreatureStatsUpdateManyAndReturnArgs} args - Arguments to update many CreatureStats.
     * @example
     * // Update many CreatureStats
     * const creatureStats = await prisma.creatureStats.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CreatureStats and only return the `id`
     * const creatureStatsWithIdOnly = await prisma.creatureStats.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CreatureStatsUpdateManyAndReturnArgs>(args: SelectSubset<T, CreatureStatsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CreatureStatsPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one CreatureStats.
     * @param {CreatureStatsUpsertArgs} args - Arguments to update or create a CreatureStats.
     * @example
     * // Update or create a CreatureStats
     * const creatureStats = await prisma.creatureStats.upsert({
     *   create: {
     *     // ... data to create a CreatureStats
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CreatureStats we want to update
     *   }
     * })
     */
    upsert<T extends CreatureStatsUpsertArgs>(args: SelectSubset<T, CreatureStatsUpsertArgs<ExtArgs>>): Prisma__CreatureStatsClient<$Result.GetResult<Prisma.$CreatureStatsPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of CreatureStats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreatureStatsCountArgs} args - Arguments to filter CreatureStats to count.
     * @example
     * // Count the number of CreatureStats
     * const count = await prisma.creatureStats.count({
     *   where: {
     *     // ... the filter for the CreatureStats we want to count
     *   }
     * })
    **/
    count<T extends CreatureStatsCountArgs>(
      args?: Subset<T, CreatureStatsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CreatureStatsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CreatureStats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreatureStatsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CreatureStatsAggregateArgs>(args: Subset<T, CreatureStatsAggregateArgs>): Prisma.PrismaPromise<GetCreatureStatsAggregateType<T>>

    /**
     * Group by CreatureStats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreatureStatsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CreatureStatsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CreatureStatsGroupByArgs['orderBy'] }
        : { orderBy?: CreatureStatsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CreatureStatsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCreatureStatsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CreatureStats model
   */
  readonly fields: CreatureStatsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CreatureStats.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CreatureStatsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    stats<T extends CreatureStats$statsArgs<ExtArgs> = {}>(args?: Subset<T, CreatureStats$statsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CreatureStatDetailPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    creature_relation<T extends CreatureDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CreatureDefaultArgs<ExtArgs>>): Prisma__CreatureClient<$Result.GetResult<Prisma.$CreaturePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CreatureStats model
   */ 
  interface CreatureStatsFieldRefs {
    readonly id: FieldRef<"CreatureStats", 'String'>
  }
    

  // Custom InputTypes
  /**
   * CreatureStats findUnique
   */
  export type CreatureStatsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreatureStats
     */
    select?: CreatureStatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CreatureStats
     */
    omit?: CreatureStatsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreatureStatsInclude<ExtArgs> | null
    /**
     * Filter, which CreatureStats to fetch.
     */
    where: CreatureStatsWhereUniqueInput
  }

  /**
   * CreatureStats findUniqueOrThrow
   */
  export type CreatureStatsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreatureStats
     */
    select?: CreatureStatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CreatureStats
     */
    omit?: CreatureStatsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreatureStatsInclude<ExtArgs> | null
    /**
     * Filter, which CreatureStats to fetch.
     */
    where: CreatureStatsWhereUniqueInput
  }

  /**
   * CreatureStats findFirst
   */
  export type CreatureStatsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreatureStats
     */
    select?: CreatureStatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CreatureStats
     */
    omit?: CreatureStatsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreatureStatsInclude<ExtArgs> | null
    /**
     * Filter, which CreatureStats to fetch.
     */
    where?: CreatureStatsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CreatureStats to fetch.
     */
    orderBy?: CreatureStatsOrderByWithRelationInput | CreatureStatsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CreatureStats.
     */
    cursor?: CreatureStatsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CreatureStats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CreatureStats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CreatureStats.
     */
    distinct?: CreatureStatsScalarFieldEnum | CreatureStatsScalarFieldEnum[]
  }

  /**
   * CreatureStats findFirstOrThrow
   */
  export type CreatureStatsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreatureStats
     */
    select?: CreatureStatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CreatureStats
     */
    omit?: CreatureStatsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreatureStatsInclude<ExtArgs> | null
    /**
     * Filter, which CreatureStats to fetch.
     */
    where?: CreatureStatsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CreatureStats to fetch.
     */
    orderBy?: CreatureStatsOrderByWithRelationInput | CreatureStatsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CreatureStats.
     */
    cursor?: CreatureStatsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CreatureStats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CreatureStats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CreatureStats.
     */
    distinct?: CreatureStatsScalarFieldEnum | CreatureStatsScalarFieldEnum[]
  }

  /**
   * CreatureStats findMany
   */
  export type CreatureStatsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreatureStats
     */
    select?: CreatureStatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CreatureStats
     */
    omit?: CreatureStatsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreatureStatsInclude<ExtArgs> | null
    /**
     * Filter, which CreatureStats to fetch.
     */
    where?: CreatureStatsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CreatureStats to fetch.
     */
    orderBy?: CreatureStatsOrderByWithRelationInput | CreatureStatsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CreatureStats.
     */
    cursor?: CreatureStatsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CreatureStats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CreatureStats.
     */
    skip?: number
    distinct?: CreatureStatsScalarFieldEnum | CreatureStatsScalarFieldEnum[]
  }

  /**
   * CreatureStats create
   */
  export type CreatureStatsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreatureStats
     */
    select?: CreatureStatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CreatureStats
     */
    omit?: CreatureStatsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreatureStatsInclude<ExtArgs> | null
    /**
     * The data needed to create a CreatureStats.
     */
    data: XOR<CreatureStatsCreateInput, CreatureStatsUncheckedCreateInput>
  }

  /**
   * CreatureStats createMany
   */
  export type CreatureStatsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CreatureStats.
     */
    data: CreatureStatsCreateManyInput | CreatureStatsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CreatureStats createManyAndReturn
   */
  export type CreatureStatsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreatureStats
     */
    select?: CreatureStatsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CreatureStats
     */
    omit?: CreatureStatsOmit<ExtArgs> | null
    /**
     * The data used to create many CreatureStats.
     */
    data: CreatureStatsCreateManyInput | CreatureStatsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreatureStatsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CreatureStats update
   */
  export type CreatureStatsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreatureStats
     */
    select?: CreatureStatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CreatureStats
     */
    omit?: CreatureStatsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreatureStatsInclude<ExtArgs> | null
    /**
     * The data needed to update a CreatureStats.
     */
    data: XOR<CreatureStatsUpdateInput, CreatureStatsUncheckedUpdateInput>
    /**
     * Choose, which CreatureStats to update.
     */
    where: CreatureStatsWhereUniqueInput
  }

  /**
   * CreatureStats updateMany
   */
  export type CreatureStatsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CreatureStats.
     */
    data: XOR<CreatureStatsUpdateManyMutationInput, CreatureStatsUncheckedUpdateManyInput>
    /**
     * Filter which CreatureStats to update
     */
    where?: CreatureStatsWhereInput
    /**
     * Limit how many CreatureStats to update.
     */
    limit?: number
  }

  /**
   * CreatureStats updateManyAndReturn
   */
  export type CreatureStatsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreatureStats
     */
    select?: CreatureStatsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CreatureStats
     */
    omit?: CreatureStatsOmit<ExtArgs> | null
    /**
     * The data used to update CreatureStats.
     */
    data: XOR<CreatureStatsUpdateManyMutationInput, CreatureStatsUncheckedUpdateManyInput>
    /**
     * Filter which CreatureStats to update
     */
    where?: CreatureStatsWhereInput
    /**
     * Limit how many CreatureStats to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreatureStatsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CreatureStats upsert
   */
  export type CreatureStatsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreatureStats
     */
    select?: CreatureStatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CreatureStats
     */
    omit?: CreatureStatsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreatureStatsInclude<ExtArgs> | null
    /**
     * The filter to search for the CreatureStats to update in case it exists.
     */
    where: CreatureStatsWhereUniqueInput
    /**
     * In case the CreatureStats found by the `where` argument doesn't exist, create a new CreatureStats with this data.
     */
    create: XOR<CreatureStatsCreateInput, CreatureStatsUncheckedCreateInput>
    /**
     * In case the CreatureStats was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CreatureStatsUpdateInput, CreatureStatsUncheckedUpdateInput>
  }

  /**
   * CreatureStats delete
   */
  export type CreatureStatsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreatureStats
     */
    select?: CreatureStatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CreatureStats
     */
    omit?: CreatureStatsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreatureStatsInclude<ExtArgs> | null
    /**
     * Filter which CreatureStats to delete.
     */
    where: CreatureStatsWhereUniqueInput
  }

  /**
   * CreatureStats deleteMany
   */
  export type CreatureStatsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CreatureStats to delete
     */
    where?: CreatureStatsWhereInput
    /**
     * Limit how many CreatureStats to delete.
     */
    limit?: number
  }

  /**
   * CreatureStats.stats
   */
  export type CreatureStats$statsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreatureStatDetail
     */
    select?: CreatureStatDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CreatureStatDetail
     */
    omit?: CreatureStatDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreatureStatDetailInclude<ExtArgs> | null
    where?: CreatureStatDetailWhereInput
    orderBy?: CreatureStatDetailOrderByWithRelationInput | CreatureStatDetailOrderByWithRelationInput[]
    cursor?: CreatureStatDetailWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CreatureStatDetailScalarFieldEnum | CreatureStatDetailScalarFieldEnum[]
  }

  /**
   * CreatureStats without action
   */
  export type CreatureStatsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreatureStats
     */
    select?: CreatureStatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CreatureStats
     */
    omit?: CreatureStatsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreatureStatsInclude<ExtArgs> | null
  }


  /**
   * Model CreatureStatDetail
   */

  export type AggregateCreatureStatDetail = {
    _count: CreatureStatDetailCountAggregateOutputType | null
    _avg: CreatureStatDetailAvgAggregateOutputType | null
    _sum: CreatureStatDetailSumAggregateOutputType | null
    _min: CreatureStatDetailMinAggregateOutputType | null
    _max: CreatureStatDetailMaxAggregateOutputType | null
  }

  export type CreatureStatDetailAvgAggregateOutputType = {
    value: number | null
  }

  export type CreatureStatDetailSumAggregateOutputType = {
    value: number | null
  }

  export type CreatureStatDetailMinAggregateOutputType = {
    id: string | null
    ability: $Enums.Ability | null
    value: number | null
    mastery: boolean | null
    creature_stats_id: string | null
  }

  export type CreatureStatDetailMaxAggregateOutputType = {
    id: string | null
    ability: $Enums.Ability | null
    value: number | null
    mastery: boolean | null
    creature_stats_id: string | null
  }

  export type CreatureStatDetailCountAggregateOutputType = {
    id: number
    ability: number
    value: number
    mastery: number
    creature_stats_id: number
    _all: number
  }


  export type CreatureStatDetailAvgAggregateInputType = {
    value?: true
  }

  export type CreatureStatDetailSumAggregateInputType = {
    value?: true
  }

  export type CreatureStatDetailMinAggregateInputType = {
    id?: true
    ability?: true
    value?: true
    mastery?: true
    creature_stats_id?: true
  }

  export type CreatureStatDetailMaxAggregateInputType = {
    id?: true
    ability?: true
    value?: true
    mastery?: true
    creature_stats_id?: true
  }

  export type CreatureStatDetailCountAggregateInputType = {
    id?: true
    ability?: true
    value?: true
    mastery?: true
    creature_stats_id?: true
    _all?: true
  }

  export type CreatureStatDetailAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CreatureStatDetail to aggregate.
     */
    where?: CreatureStatDetailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CreatureStatDetails to fetch.
     */
    orderBy?: CreatureStatDetailOrderByWithRelationInput | CreatureStatDetailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CreatureStatDetailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CreatureStatDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CreatureStatDetails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CreatureStatDetails
    **/
    _count?: true | CreatureStatDetailCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CreatureStatDetailAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CreatureStatDetailSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CreatureStatDetailMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CreatureStatDetailMaxAggregateInputType
  }

  export type GetCreatureStatDetailAggregateType<T extends CreatureStatDetailAggregateArgs> = {
        [P in keyof T & keyof AggregateCreatureStatDetail]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCreatureStatDetail[P]>
      : GetScalarType<T[P], AggregateCreatureStatDetail[P]>
  }




  export type CreatureStatDetailGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CreatureStatDetailWhereInput
    orderBy?: CreatureStatDetailOrderByWithAggregationInput | CreatureStatDetailOrderByWithAggregationInput[]
    by: CreatureStatDetailScalarFieldEnum[] | CreatureStatDetailScalarFieldEnum
    having?: CreatureStatDetailScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CreatureStatDetailCountAggregateInputType | true
    _avg?: CreatureStatDetailAvgAggregateInputType
    _sum?: CreatureStatDetailSumAggregateInputType
    _min?: CreatureStatDetailMinAggregateInputType
    _max?: CreatureStatDetailMaxAggregateInputType
  }

  export type CreatureStatDetailGroupByOutputType = {
    id: string
    ability: $Enums.Ability
    value: number
    mastery: boolean
    creature_stats_id: string
    _count: CreatureStatDetailCountAggregateOutputType | null
    _avg: CreatureStatDetailAvgAggregateOutputType | null
    _sum: CreatureStatDetailSumAggregateOutputType | null
    _min: CreatureStatDetailMinAggregateOutputType | null
    _max: CreatureStatDetailMaxAggregateOutputType | null
  }

  type GetCreatureStatDetailGroupByPayload<T extends CreatureStatDetailGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CreatureStatDetailGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CreatureStatDetailGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CreatureStatDetailGroupByOutputType[P]>
            : GetScalarType<T[P], CreatureStatDetailGroupByOutputType[P]>
        }
      >
    >


  export type CreatureStatDetailSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    ability?: boolean
    value?: boolean
    mastery?: boolean
    creature_stats_id?: boolean
    creature_stats_relation?: boolean | CreatureStatsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["creatureStatDetail"]>

  export type CreatureStatDetailSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    ability?: boolean
    value?: boolean
    mastery?: boolean
    creature_stats_id?: boolean
    creature_stats_relation?: boolean | CreatureStatsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["creatureStatDetail"]>

  export type CreatureStatDetailSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    ability?: boolean
    value?: boolean
    mastery?: boolean
    creature_stats_id?: boolean
    creature_stats_relation?: boolean | CreatureStatsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["creatureStatDetail"]>

  export type CreatureStatDetailSelectScalar = {
    id?: boolean
    ability?: boolean
    value?: boolean
    mastery?: boolean
    creature_stats_id?: boolean
  }

  export type CreatureStatDetailOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "ability" | "value" | "mastery" | "creature_stats_id", ExtArgs["result"]["creatureStatDetail"]>
  export type CreatureStatDetailInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creature_stats_relation?: boolean | CreatureStatsDefaultArgs<ExtArgs>
  }
  export type CreatureStatDetailIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creature_stats_relation?: boolean | CreatureStatsDefaultArgs<ExtArgs>
  }
  export type CreatureStatDetailIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creature_stats_relation?: boolean | CreatureStatsDefaultArgs<ExtArgs>
  }

  export type $CreatureStatDetailPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CreatureStatDetail"
    objects: {
      creature_stats_relation: Prisma.$CreatureStatsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      ability: $Enums.Ability
      value: number
      mastery: boolean
      creature_stats_id: string
    }, ExtArgs["result"]["creatureStatDetail"]>
    composites: {}
  }

  type CreatureStatDetailGetPayload<S extends boolean | null | undefined | CreatureStatDetailDefaultArgs> = $Result.GetResult<Prisma.$CreatureStatDetailPayload, S>

  type CreatureStatDetailCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CreatureStatDetailFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CreatureStatDetailCountAggregateInputType | true
    }

  export interface CreatureStatDetailDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CreatureStatDetail'], meta: { name: 'CreatureStatDetail' } }
    /**
     * Find zero or one CreatureStatDetail that matches the filter.
     * @param {CreatureStatDetailFindUniqueArgs} args - Arguments to find a CreatureStatDetail
     * @example
     * // Get one CreatureStatDetail
     * const creatureStatDetail = await prisma.creatureStatDetail.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CreatureStatDetailFindUniqueArgs>(args: SelectSubset<T, CreatureStatDetailFindUniqueArgs<ExtArgs>>): Prisma__CreatureStatDetailClient<$Result.GetResult<Prisma.$CreatureStatDetailPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one CreatureStatDetail that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CreatureStatDetailFindUniqueOrThrowArgs} args - Arguments to find a CreatureStatDetail
     * @example
     * // Get one CreatureStatDetail
     * const creatureStatDetail = await prisma.creatureStatDetail.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CreatureStatDetailFindUniqueOrThrowArgs>(args: SelectSubset<T, CreatureStatDetailFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CreatureStatDetailClient<$Result.GetResult<Prisma.$CreatureStatDetailPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first CreatureStatDetail that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreatureStatDetailFindFirstArgs} args - Arguments to find a CreatureStatDetail
     * @example
     * // Get one CreatureStatDetail
     * const creatureStatDetail = await prisma.creatureStatDetail.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CreatureStatDetailFindFirstArgs>(args?: SelectSubset<T, CreatureStatDetailFindFirstArgs<ExtArgs>>): Prisma__CreatureStatDetailClient<$Result.GetResult<Prisma.$CreatureStatDetailPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first CreatureStatDetail that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreatureStatDetailFindFirstOrThrowArgs} args - Arguments to find a CreatureStatDetail
     * @example
     * // Get one CreatureStatDetail
     * const creatureStatDetail = await prisma.creatureStatDetail.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CreatureStatDetailFindFirstOrThrowArgs>(args?: SelectSubset<T, CreatureStatDetailFindFirstOrThrowArgs<ExtArgs>>): Prisma__CreatureStatDetailClient<$Result.GetResult<Prisma.$CreatureStatDetailPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more CreatureStatDetails that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreatureStatDetailFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CreatureStatDetails
     * const creatureStatDetails = await prisma.creatureStatDetail.findMany()
     * 
     * // Get first 10 CreatureStatDetails
     * const creatureStatDetails = await prisma.creatureStatDetail.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const creatureStatDetailWithIdOnly = await prisma.creatureStatDetail.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CreatureStatDetailFindManyArgs>(args?: SelectSubset<T, CreatureStatDetailFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CreatureStatDetailPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a CreatureStatDetail.
     * @param {CreatureStatDetailCreateArgs} args - Arguments to create a CreatureStatDetail.
     * @example
     * // Create one CreatureStatDetail
     * const CreatureStatDetail = await prisma.creatureStatDetail.create({
     *   data: {
     *     // ... data to create a CreatureStatDetail
     *   }
     * })
     * 
     */
    create<T extends CreatureStatDetailCreateArgs>(args: SelectSubset<T, CreatureStatDetailCreateArgs<ExtArgs>>): Prisma__CreatureStatDetailClient<$Result.GetResult<Prisma.$CreatureStatDetailPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many CreatureStatDetails.
     * @param {CreatureStatDetailCreateManyArgs} args - Arguments to create many CreatureStatDetails.
     * @example
     * // Create many CreatureStatDetails
     * const creatureStatDetail = await prisma.creatureStatDetail.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CreatureStatDetailCreateManyArgs>(args?: SelectSubset<T, CreatureStatDetailCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CreatureStatDetails and returns the data saved in the database.
     * @param {CreatureStatDetailCreateManyAndReturnArgs} args - Arguments to create many CreatureStatDetails.
     * @example
     * // Create many CreatureStatDetails
     * const creatureStatDetail = await prisma.creatureStatDetail.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CreatureStatDetails and only return the `id`
     * const creatureStatDetailWithIdOnly = await prisma.creatureStatDetail.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CreatureStatDetailCreateManyAndReturnArgs>(args?: SelectSubset<T, CreatureStatDetailCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CreatureStatDetailPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a CreatureStatDetail.
     * @param {CreatureStatDetailDeleteArgs} args - Arguments to delete one CreatureStatDetail.
     * @example
     * // Delete one CreatureStatDetail
     * const CreatureStatDetail = await prisma.creatureStatDetail.delete({
     *   where: {
     *     // ... filter to delete one CreatureStatDetail
     *   }
     * })
     * 
     */
    delete<T extends CreatureStatDetailDeleteArgs>(args: SelectSubset<T, CreatureStatDetailDeleteArgs<ExtArgs>>): Prisma__CreatureStatDetailClient<$Result.GetResult<Prisma.$CreatureStatDetailPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one CreatureStatDetail.
     * @param {CreatureStatDetailUpdateArgs} args - Arguments to update one CreatureStatDetail.
     * @example
     * // Update one CreatureStatDetail
     * const creatureStatDetail = await prisma.creatureStatDetail.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CreatureStatDetailUpdateArgs>(args: SelectSubset<T, CreatureStatDetailUpdateArgs<ExtArgs>>): Prisma__CreatureStatDetailClient<$Result.GetResult<Prisma.$CreatureStatDetailPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more CreatureStatDetails.
     * @param {CreatureStatDetailDeleteManyArgs} args - Arguments to filter CreatureStatDetails to delete.
     * @example
     * // Delete a few CreatureStatDetails
     * const { count } = await prisma.creatureStatDetail.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CreatureStatDetailDeleteManyArgs>(args?: SelectSubset<T, CreatureStatDetailDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CreatureStatDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreatureStatDetailUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CreatureStatDetails
     * const creatureStatDetail = await prisma.creatureStatDetail.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CreatureStatDetailUpdateManyArgs>(args: SelectSubset<T, CreatureStatDetailUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CreatureStatDetails and returns the data updated in the database.
     * @param {CreatureStatDetailUpdateManyAndReturnArgs} args - Arguments to update many CreatureStatDetails.
     * @example
     * // Update many CreatureStatDetails
     * const creatureStatDetail = await prisma.creatureStatDetail.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CreatureStatDetails and only return the `id`
     * const creatureStatDetailWithIdOnly = await prisma.creatureStatDetail.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CreatureStatDetailUpdateManyAndReturnArgs>(args: SelectSubset<T, CreatureStatDetailUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CreatureStatDetailPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one CreatureStatDetail.
     * @param {CreatureStatDetailUpsertArgs} args - Arguments to update or create a CreatureStatDetail.
     * @example
     * // Update or create a CreatureStatDetail
     * const creatureStatDetail = await prisma.creatureStatDetail.upsert({
     *   create: {
     *     // ... data to create a CreatureStatDetail
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CreatureStatDetail we want to update
     *   }
     * })
     */
    upsert<T extends CreatureStatDetailUpsertArgs>(args: SelectSubset<T, CreatureStatDetailUpsertArgs<ExtArgs>>): Prisma__CreatureStatDetailClient<$Result.GetResult<Prisma.$CreatureStatDetailPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of CreatureStatDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreatureStatDetailCountArgs} args - Arguments to filter CreatureStatDetails to count.
     * @example
     * // Count the number of CreatureStatDetails
     * const count = await prisma.creatureStatDetail.count({
     *   where: {
     *     // ... the filter for the CreatureStatDetails we want to count
     *   }
     * })
    **/
    count<T extends CreatureStatDetailCountArgs>(
      args?: Subset<T, CreatureStatDetailCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CreatureStatDetailCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CreatureStatDetail.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreatureStatDetailAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CreatureStatDetailAggregateArgs>(args: Subset<T, CreatureStatDetailAggregateArgs>): Prisma.PrismaPromise<GetCreatureStatDetailAggregateType<T>>

    /**
     * Group by CreatureStatDetail.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreatureStatDetailGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CreatureStatDetailGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CreatureStatDetailGroupByArgs['orderBy'] }
        : { orderBy?: CreatureStatDetailGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CreatureStatDetailGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCreatureStatDetailGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CreatureStatDetail model
   */
  readonly fields: CreatureStatDetailFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CreatureStatDetail.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CreatureStatDetailClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    creature_stats_relation<T extends CreatureStatsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CreatureStatsDefaultArgs<ExtArgs>>): Prisma__CreatureStatsClient<$Result.GetResult<Prisma.$CreatureStatsPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CreatureStatDetail model
   */ 
  interface CreatureStatDetailFieldRefs {
    readonly id: FieldRef<"CreatureStatDetail", 'String'>
    readonly ability: FieldRef<"CreatureStatDetail", 'Ability'>
    readonly value: FieldRef<"CreatureStatDetail", 'Int'>
    readonly mastery: FieldRef<"CreatureStatDetail", 'Boolean'>
    readonly creature_stats_id: FieldRef<"CreatureStatDetail", 'String'>
  }
    

  // Custom InputTypes
  /**
   * CreatureStatDetail findUnique
   */
  export type CreatureStatDetailFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreatureStatDetail
     */
    select?: CreatureStatDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CreatureStatDetail
     */
    omit?: CreatureStatDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreatureStatDetailInclude<ExtArgs> | null
    /**
     * Filter, which CreatureStatDetail to fetch.
     */
    where: CreatureStatDetailWhereUniqueInput
  }

  /**
   * CreatureStatDetail findUniqueOrThrow
   */
  export type CreatureStatDetailFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreatureStatDetail
     */
    select?: CreatureStatDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CreatureStatDetail
     */
    omit?: CreatureStatDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreatureStatDetailInclude<ExtArgs> | null
    /**
     * Filter, which CreatureStatDetail to fetch.
     */
    where: CreatureStatDetailWhereUniqueInput
  }

  /**
   * CreatureStatDetail findFirst
   */
  export type CreatureStatDetailFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreatureStatDetail
     */
    select?: CreatureStatDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CreatureStatDetail
     */
    omit?: CreatureStatDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreatureStatDetailInclude<ExtArgs> | null
    /**
     * Filter, which CreatureStatDetail to fetch.
     */
    where?: CreatureStatDetailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CreatureStatDetails to fetch.
     */
    orderBy?: CreatureStatDetailOrderByWithRelationInput | CreatureStatDetailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CreatureStatDetails.
     */
    cursor?: CreatureStatDetailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CreatureStatDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CreatureStatDetails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CreatureStatDetails.
     */
    distinct?: CreatureStatDetailScalarFieldEnum | CreatureStatDetailScalarFieldEnum[]
  }

  /**
   * CreatureStatDetail findFirstOrThrow
   */
  export type CreatureStatDetailFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreatureStatDetail
     */
    select?: CreatureStatDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CreatureStatDetail
     */
    omit?: CreatureStatDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreatureStatDetailInclude<ExtArgs> | null
    /**
     * Filter, which CreatureStatDetail to fetch.
     */
    where?: CreatureStatDetailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CreatureStatDetails to fetch.
     */
    orderBy?: CreatureStatDetailOrderByWithRelationInput | CreatureStatDetailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CreatureStatDetails.
     */
    cursor?: CreatureStatDetailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CreatureStatDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CreatureStatDetails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CreatureStatDetails.
     */
    distinct?: CreatureStatDetailScalarFieldEnum | CreatureStatDetailScalarFieldEnum[]
  }

  /**
   * CreatureStatDetail findMany
   */
  export type CreatureStatDetailFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreatureStatDetail
     */
    select?: CreatureStatDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CreatureStatDetail
     */
    omit?: CreatureStatDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreatureStatDetailInclude<ExtArgs> | null
    /**
     * Filter, which CreatureStatDetails to fetch.
     */
    where?: CreatureStatDetailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CreatureStatDetails to fetch.
     */
    orderBy?: CreatureStatDetailOrderByWithRelationInput | CreatureStatDetailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CreatureStatDetails.
     */
    cursor?: CreatureStatDetailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CreatureStatDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CreatureStatDetails.
     */
    skip?: number
    distinct?: CreatureStatDetailScalarFieldEnum | CreatureStatDetailScalarFieldEnum[]
  }

  /**
   * CreatureStatDetail create
   */
  export type CreatureStatDetailCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreatureStatDetail
     */
    select?: CreatureStatDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CreatureStatDetail
     */
    omit?: CreatureStatDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreatureStatDetailInclude<ExtArgs> | null
    /**
     * The data needed to create a CreatureStatDetail.
     */
    data: XOR<CreatureStatDetailCreateInput, CreatureStatDetailUncheckedCreateInput>
  }

  /**
   * CreatureStatDetail createMany
   */
  export type CreatureStatDetailCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CreatureStatDetails.
     */
    data: CreatureStatDetailCreateManyInput | CreatureStatDetailCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CreatureStatDetail createManyAndReturn
   */
  export type CreatureStatDetailCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreatureStatDetail
     */
    select?: CreatureStatDetailSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CreatureStatDetail
     */
    omit?: CreatureStatDetailOmit<ExtArgs> | null
    /**
     * The data used to create many CreatureStatDetails.
     */
    data: CreatureStatDetailCreateManyInput | CreatureStatDetailCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreatureStatDetailIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CreatureStatDetail update
   */
  export type CreatureStatDetailUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreatureStatDetail
     */
    select?: CreatureStatDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CreatureStatDetail
     */
    omit?: CreatureStatDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreatureStatDetailInclude<ExtArgs> | null
    /**
     * The data needed to update a CreatureStatDetail.
     */
    data: XOR<CreatureStatDetailUpdateInput, CreatureStatDetailUncheckedUpdateInput>
    /**
     * Choose, which CreatureStatDetail to update.
     */
    where: CreatureStatDetailWhereUniqueInput
  }

  /**
   * CreatureStatDetail updateMany
   */
  export type CreatureStatDetailUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CreatureStatDetails.
     */
    data: XOR<CreatureStatDetailUpdateManyMutationInput, CreatureStatDetailUncheckedUpdateManyInput>
    /**
     * Filter which CreatureStatDetails to update
     */
    where?: CreatureStatDetailWhereInput
    /**
     * Limit how many CreatureStatDetails to update.
     */
    limit?: number
  }

  /**
   * CreatureStatDetail updateManyAndReturn
   */
  export type CreatureStatDetailUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreatureStatDetail
     */
    select?: CreatureStatDetailSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CreatureStatDetail
     */
    omit?: CreatureStatDetailOmit<ExtArgs> | null
    /**
     * The data used to update CreatureStatDetails.
     */
    data: XOR<CreatureStatDetailUpdateManyMutationInput, CreatureStatDetailUncheckedUpdateManyInput>
    /**
     * Filter which CreatureStatDetails to update
     */
    where?: CreatureStatDetailWhereInput
    /**
     * Limit how many CreatureStatDetails to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreatureStatDetailIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CreatureStatDetail upsert
   */
  export type CreatureStatDetailUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreatureStatDetail
     */
    select?: CreatureStatDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CreatureStatDetail
     */
    omit?: CreatureStatDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreatureStatDetailInclude<ExtArgs> | null
    /**
     * The filter to search for the CreatureStatDetail to update in case it exists.
     */
    where: CreatureStatDetailWhereUniqueInput
    /**
     * In case the CreatureStatDetail found by the `where` argument doesn't exist, create a new CreatureStatDetail with this data.
     */
    create: XOR<CreatureStatDetailCreateInput, CreatureStatDetailUncheckedCreateInput>
    /**
     * In case the CreatureStatDetail was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CreatureStatDetailUpdateInput, CreatureStatDetailUncheckedUpdateInput>
  }

  /**
   * CreatureStatDetail delete
   */
  export type CreatureStatDetailDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreatureStatDetail
     */
    select?: CreatureStatDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CreatureStatDetail
     */
    omit?: CreatureStatDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreatureStatDetailInclude<ExtArgs> | null
    /**
     * Filter which CreatureStatDetail to delete.
     */
    where: CreatureStatDetailWhereUniqueInput
  }

  /**
   * CreatureStatDetail deleteMany
   */
  export type CreatureStatDetailDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CreatureStatDetails to delete
     */
    where?: CreatureStatDetailWhereInput
    /**
     * Limit how many CreatureStatDetails to delete.
     */
    limit?: number
  }

  /**
   * CreatureStatDetail without action
   */
  export type CreatureStatDetailDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreatureStatDetail
     */
    select?: CreatureStatDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CreatureStatDetail
     */
    omit?: CreatureStatDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreatureStatDetailInclude<ExtArgs> | null
  }


  /**
   * Model CreatureSkills
   */

  export type AggregateCreatureSkills = {
    _count: CreatureSkillsCountAggregateOutputType | null
    _min: CreatureSkillsMinAggregateOutputType | null
    _max: CreatureSkillsMaxAggregateOutputType | null
  }

  export type CreatureSkillsMinAggregateOutputType = {
    id: string | null
  }

  export type CreatureSkillsMaxAggregateOutputType = {
    id: string | null
  }

  export type CreatureSkillsCountAggregateOutputType = {
    id: number
    _all: number
  }


  export type CreatureSkillsMinAggregateInputType = {
    id?: true
  }

  export type CreatureSkillsMaxAggregateInputType = {
    id?: true
  }

  export type CreatureSkillsCountAggregateInputType = {
    id?: true
    _all?: true
  }

  export type CreatureSkillsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CreatureSkills to aggregate.
     */
    where?: CreatureSkillsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CreatureSkills to fetch.
     */
    orderBy?: CreatureSkillsOrderByWithRelationInput | CreatureSkillsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CreatureSkillsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CreatureSkills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CreatureSkills.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CreatureSkills
    **/
    _count?: true | CreatureSkillsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CreatureSkillsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CreatureSkillsMaxAggregateInputType
  }

  export type GetCreatureSkillsAggregateType<T extends CreatureSkillsAggregateArgs> = {
        [P in keyof T & keyof AggregateCreatureSkills]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCreatureSkills[P]>
      : GetScalarType<T[P], AggregateCreatureSkills[P]>
  }




  export type CreatureSkillsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CreatureSkillsWhereInput
    orderBy?: CreatureSkillsOrderByWithAggregationInput | CreatureSkillsOrderByWithAggregationInput[]
    by: CreatureSkillsScalarFieldEnum[] | CreatureSkillsScalarFieldEnum
    having?: CreatureSkillsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CreatureSkillsCountAggregateInputType | true
    _min?: CreatureSkillsMinAggregateInputType
    _max?: CreatureSkillsMaxAggregateInputType
  }

  export type CreatureSkillsGroupByOutputType = {
    id: string
    _count: CreatureSkillsCountAggregateOutputType | null
    _min: CreatureSkillsMinAggregateOutputType | null
    _max: CreatureSkillsMaxAggregateOutputType | null
  }

  type GetCreatureSkillsGroupByPayload<T extends CreatureSkillsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CreatureSkillsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CreatureSkillsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CreatureSkillsGroupByOutputType[P]>
            : GetScalarType<T[P], CreatureSkillsGroupByOutputType[P]>
        }
      >
    >


  export type CreatureSkillsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    skills?: boolean | CreatureSkills$skillsArgs<ExtArgs>
    creature_relation?: boolean | CreatureDefaultArgs<ExtArgs>
    _count?: boolean | CreatureSkillsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["creatureSkills"]>

  export type CreatureSkillsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    creature_relation?: boolean | CreatureDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["creatureSkills"]>

  export type CreatureSkillsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    creature_relation?: boolean | CreatureDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["creatureSkills"]>

  export type CreatureSkillsSelectScalar = {
    id?: boolean
  }

  export type CreatureSkillsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id", ExtArgs["result"]["creatureSkills"]>
  export type CreatureSkillsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    skills?: boolean | CreatureSkills$skillsArgs<ExtArgs>
    creature_relation?: boolean | CreatureDefaultArgs<ExtArgs>
    _count?: boolean | CreatureSkillsCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CreatureSkillsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creature_relation?: boolean | CreatureDefaultArgs<ExtArgs>
  }
  export type CreatureSkillsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creature_relation?: boolean | CreatureDefaultArgs<ExtArgs>
  }

  export type $CreatureSkillsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CreatureSkills"
    objects: {
      skills: Prisma.$CreatureSkillDetailPayload<ExtArgs>[]
      creature_relation: Prisma.$CreaturePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
    }, ExtArgs["result"]["creatureSkills"]>
    composites: {}
  }

  type CreatureSkillsGetPayload<S extends boolean | null | undefined | CreatureSkillsDefaultArgs> = $Result.GetResult<Prisma.$CreatureSkillsPayload, S>

  type CreatureSkillsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CreatureSkillsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CreatureSkillsCountAggregateInputType | true
    }

  export interface CreatureSkillsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CreatureSkills'], meta: { name: 'CreatureSkills' } }
    /**
     * Find zero or one CreatureSkills that matches the filter.
     * @param {CreatureSkillsFindUniqueArgs} args - Arguments to find a CreatureSkills
     * @example
     * // Get one CreatureSkills
     * const creatureSkills = await prisma.creatureSkills.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CreatureSkillsFindUniqueArgs>(args: SelectSubset<T, CreatureSkillsFindUniqueArgs<ExtArgs>>): Prisma__CreatureSkillsClient<$Result.GetResult<Prisma.$CreatureSkillsPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one CreatureSkills that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CreatureSkillsFindUniqueOrThrowArgs} args - Arguments to find a CreatureSkills
     * @example
     * // Get one CreatureSkills
     * const creatureSkills = await prisma.creatureSkills.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CreatureSkillsFindUniqueOrThrowArgs>(args: SelectSubset<T, CreatureSkillsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CreatureSkillsClient<$Result.GetResult<Prisma.$CreatureSkillsPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first CreatureSkills that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreatureSkillsFindFirstArgs} args - Arguments to find a CreatureSkills
     * @example
     * // Get one CreatureSkills
     * const creatureSkills = await prisma.creatureSkills.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CreatureSkillsFindFirstArgs>(args?: SelectSubset<T, CreatureSkillsFindFirstArgs<ExtArgs>>): Prisma__CreatureSkillsClient<$Result.GetResult<Prisma.$CreatureSkillsPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first CreatureSkills that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreatureSkillsFindFirstOrThrowArgs} args - Arguments to find a CreatureSkills
     * @example
     * // Get one CreatureSkills
     * const creatureSkills = await prisma.creatureSkills.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CreatureSkillsFindFirstOrThrowArgs>(args?: SelectSubset<T, CreatureSkillsFindFirstOrThrowArgs<ExtArgs>>): Prisma__CreatureSkillsClient<$Result.GetResult<Prisma.$CreatureSkillsPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more CreatureSkills that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreatureSkillsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CreatureSkills
     * const creatureSkills = await prisma.creatureSkills.findMany()
     * 
     * // Get first 10 CreatureSkills
     * const creatureSkills = await prisma.creatureSkills.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const creatureSkillsWithIdOnly = await prisma.creatureSkills.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CreatureSkillsFindManyArgs>(args?: SelectSubset<T, CreatureSkillsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CreatureSkillsPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a CreatureSkills.
     * @param {CreatureSkillsCreateArgs} args - Arguments to create a CreatureSkills.
     * @example
     * // Create one CreatureSkills
     * const CreatureSkills = await prisma.creatureSkills.create({
     *   data: {
     *     // ... data to create a CreatureSkills
     *   }
     * })
     * 
     */
    create<T extends CreatureSkillsCreateArgs>(args: SelectSubset<T, CreatureSkillsCreateArgs<ExtArgs>>): Prisma__CreatureSkillsClient<$Result.GetResult<Prisma.$CreatureSkillsPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many CreatureSkills.
     * @param {CreatureSkillsCreateManyArgs} args - Arguments to create many CreatureSkills.
     * @example
     * // Create many CreatureSkills
     * const creatureSkills = await prisma.creatureSkills.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CreatureSkillsCreateManyArgs>(args?: SelectSubset<T, CreatureSkillsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CreatureSkills and returns the data saved in the database.
     * @param {CreatureSkillsCreateManyAndReturnArgs} args - Arguments to create many CreatureSkills.
     * @example
     * // Create many CreatureSkills
     * const creatureSkills = await prisma.creatureSkills.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CreatureSkills and only return the `id`
     * const creatureSkillsWithIdOnly = await prisma.creatureSkills.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CreatureSkillsCreateManyAndReturnArgs>(args?: SelectSubset<T, CreatureSkillsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CreatureSkillsPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a CreatureSkills.
     * @param {CreatureSkillsDeleteArgs} args - Arguments to delete one CreatureSkills.
     * @example
     * // Delete one CreatureSkills
     * const CreatureSkills = await prisma.creatureSkills.delete({
     *   where: {
     *     // ... filter to delete one CreatureSkills
     *   }
     * })
     * 
     */
    delete<T extends CreatureSkillsDeleteArgs>(args: SelectSubset<T, CreatureSkillsDeleteArgs<ExtArgs>>): Prisma__CreatureSkillsClient<$Result.GetResult<Prisma.$CreatureSkillsPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one CreatureSkills.
     * @param {CreatureSkillsUpdateArgs} args - Arguments to update one CreatureSkills.
     * @example
     * // Update one CreatureSkills
     * const creatureSkills = await prisma.creatureSkills.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CreatureSkillsUpdateArgs>(args: SelectSubset<T, CreatureSkillsUpdateArgs<ExtArgs>>): Prisma__CreatureSkillsClient<$Result.GetResult<Prisma.$CreatureSkillsPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more CreatureSkills.
     * @param {CreatureSkillsDeleteManyArgs} args - Arguments to filter CreatureSkills to delete.
     * @example
     * // Delete a few CreatureSkills
     * const { count } = await prisma.creatureSkills.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CreatureSkillsDeleteManyArgs>(args?: SelectSubset<T, CreatureSkillsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CreatureSkills.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreatureSkillsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CreatureSkills
     * const creatureSkills = await prisma.creatureSkills.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CreatureSkillsUpdateManyArgs>(args: SelectSubset<T, CreatureSkillsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CreatureSkills and returns the data updated in the database.
     * @param {CreatureSkillsUpdateManyAndReturnArgs} args - Arguments to update many CreatureSkills.
     * @example
     * // Update many CreatureSkills
     * const creatureSkills = await prisma.creatureSkills.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CreatureSkills and only return the `id`
     * const creatureSkillsWithIdOnly = await prisma.creatureSkills.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CreatureSkillsUpdateManyAndReturnArgs>(args: SelectSubset<T, CreatureSkillsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CreatureSkillsPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one CreatureSkills.
     * @param {CreatureSkillsUpsertArgs} args - Arguments to update or create a CreatureSkills.
     * @example
     * // Update or create a CreatureSkills
     * const creatureSkills = await prisma.creatureSkills.upsert({
     *   create: {
     *     // ... data to create a CreatureSkills
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CreatureSkills we want to update
     *   }
     * })
     */
    upsert<T extends CreatureSkillsUpsertArgs>(args: SelectSubset<T, CreatureSkillsUpsertArgs<ExtArgs>>): Prisma__CreatureSkillsClient<$Result.GetResult<Prisma.$CreatureSkillsPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of CreatureSkills.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreatureSkillsCountArgs} args - Arguments to filter CreatureSkills to count.
     * @example
     * // Count the number of CreatureSkills
     * const count = await prisma.creatureSkills.count({
     *   where: {
     *     // ... the filter for the CreatureSkills we want to count
     *   }
     * })
    **/
    count<T extends CreatureSkillsCountArgs>(
      args?: Subset<T, CreatureSkillsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CreatureSkillsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CreatureSkills.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreatureSkillsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CreatureSkillsAggregateArgs>(args: Subset<T, CreatureSkillsAggregateArgs>): Prisma.PrismaPromise<GetCreatureSkillsAggregateType<T>>

    /**
     * Group by CreatureSkills.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreatureSkillsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CreatureSkillsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CreatureSkillsGroupByArgs['orderBy'] }
        : { orderBy?: CreatureSkillsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CreatureSkillsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCreatureSkillsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CreatureSkills model
   */
  readonly fields: CreatureSkillsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CreatureSkills.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CreatureSkillsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    skills<T extends CreatureSkills$skillsArgs<ExtArgs> = {}>(args?: Subset<T, CreatureSkills$skillsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CreatureSkillDetailPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    creature_relation<T extends CreatureDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CreatureDefaultArgs<ExtArgs>>): Prisma__CreatureClient<$Result.GetResult<Prisma.$CreaturePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CreatureSkills model
   */ 
  interface CreatureSkillsFieldRefs {
    readonly id: FieldRef<"CreatureSkills", 'String'>
  }
    

  // Custom InputTypes
  /**
   * CreatureSkills findUnique
   */
  export type CreatureSkillsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreatureSkills
     */
    select?: CreatureSkillsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CreatureSkills
     */
    omit?: CreatureSkillsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreatureSkillsInclude<ExtArgs> | null
    /**
     * Filter, which CreatureSkills to fetch.
     */
    where: CreatureSkillsWhereUniqueInput
  }

  /**
   * CreatureSkills findUniqueOrThrow
   */
  export type CreatureSkillsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreatureSkills
     */
    select?: CreatureSkillsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CreatureSkills
     */
    omit?: CreatureSkillsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreatureSkillsInclude<ExtArgs> | null
    /**
     * Filter, which CreatureSkills to fetch.
     */
    where: CreatureSkillsWhereUniqueInput
  }

  /**
   * CreatureSkills findFirst
   */
  export type CreatureSkillsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreatureSkills
     */
    select?: CreatureSkillsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CreatureSkills
     */
    omit?: CreatureSkillsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreatureSkillsInclude<ExtArgs> | null
    /**
     * Filter, which CreatureSkills to fetch.
     */
    where?: CreatureSkillsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CreatureSkills to fetch.
     */
    orderBy?: CreatureSkillsOrderByWithRelationInput | CreatureSkillsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CreatureSkills.
     */
    cursor?: CreatureSkillsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CreatureSkills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CreatureSkills.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CreatureSkills.
     */
    distinct?: CreatureSkillsScalarFieldEnum | CreatureSkillsScalarFieldEnum[]
  }

  /**
   * CreatureSkills findFirstOrThrow
   */
  export type CreatureSkillsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreatureSkills
     */
    select?: CreatureSkillsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CreatureSkills
     */
    omit?: CreatureSkillsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreatureSkillsInclude<ExtArgs> | null
    /**
     * Filter, which CreatureSkills to fetch.
     */
    where?: CreatureSkillsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CreatureSkills to fetch.
     */
    orderBy?: CreatureSkillsOrderByWithRelationInput | CreatureSkillsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CreatureSkills.
     */
    cursor?: CreatureSkillsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CreatureSkills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CreatureSkills.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CreatureSkills.
     */
    distinct?: CreatureSkillsScalarFieldEnum | CreatureSkillsScalarFieldEnum[]
  }

  /**
   * CreatureSkills findMany
   */
  export type CreatureSkillsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreatureSkills
     */
    select?: CreatureSkillsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CreatureSkills
     */
    omit?: CreatureSkillsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreatureSkillsInclude<ExtArgs> | null
    /**
     * Filter, which CreatureSkills to fetch.
     */
    where?: CreatureSkillsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CreatureSkills to fetch.
     */
    orderBy?: CreatureSkillsOrderByWithRelationInput | CreatureSkillsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CreatureSkills.
     */
    cursor?: CreatureSkillsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CreatureSkills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CreatureSkills.
     */
    skip?: number
    distinct?: CreatureSkillsScalarFieldEnum | CreatureSkillsScalarFieldEnum[]
  }

  /**
   * CreatureSkills create
   */
  export type CreatureSkillsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreatureSkills
     */
    select?: CreatureSkillsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CreatureSkills
     */
    omit?: CreatureSkillsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreatureSkillsInclude<ExtArgs> | null
    /**
     * The data needed to create a CreatureSkills.
     */
    data: XOR<CreatureSkillsCreateInput, CreatureSkillsUncheckedCreateInput>
  }

  /**
   * CreatureSkills createMany
   */
  export type CreatureSkillsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CreatureSkills.
     */
    data: CreatureSkillsCreateManyInput | CreatureSkillsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CreatureSkills createManyAndReturn
   */
  export type CreatureSkillsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreatureSkills
     */
    select?: CreatureSkillsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CreatureSkills
     */
    omit?: CreatureSkillsOmit<ExtArgs> | null
    /**
     * The data used to create many CreatureSkills.
     */
    data: CreatureSkillsCreateManyInput | CreatureSkillsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreatureSkillsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CreatureSkills update
   */
  export type CreatureSkillsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreatureSkills
     */
    select?: CreatureSkillsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CreatureSkills
     */
    omit?: CreatureSkillsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreatureSkillsInclude<ExtArgs> | null
    /**
     * The data needed to update a CreatureSkills.
     */
    data: XOR<CreatureSkillsUpdateInput, CreatureSkillsUncheckedUpdateInput>
    /**
     * Choose, which CreatureSkills to update.
     */
    where: CreatureSkillsWhereUniqueInput
  }

  /**
   * CreatureSkills updateMany
   */
  export type CreatureSkillsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CreatureSkills.
     */
    data: XOR<CreatureSkillsUpdateManyMutationInput, CreatureSkillsUncheckedUpdateManyInput>
    /**
     * Filter which CreatureSkills to update
     */
    where?: CreatureSkillsWhereInput
    /**
     * Limit how many CreatureSkills to update.
     */
    limit?: number
  }

  /**
   * CreatureSkills updateManyAndReturn
   */
  export type CreatureSkillsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreatureSkills
     */
    select?: CreatureSkillsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CreatureSkills
     */
    omit?: CreatureSkillsOmit<ExtArgs> | null
    /**
     * The data used to update CreatureSkills.
     */
    data: XOR<CreatureSkillsUpdateManyMutationInput, CreatureSkillsUncheckedUpdateManyInput>
    /**
     * Filter which CreatureSkills to update
     */
    where?: CreatureSkillsWhereInput
    /**
     * Limit how many CreatureSkills to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreatureSkillsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CreatureSkills upsert
   */
  export type CreatureSkillsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreatureSkills
     */
    select?: CreatureSkillsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CreatureSkills
     */
    omit?: CreatureSkillsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreatureSkillsInclude<ExtArgs> | null
    /**
     * The filter to search for the CreatureSkills to update in case it exists.
     */
    where: CreatureSkillsWhereUniqueInput
    /**
     * In case the CreatureSkills found by the `where` argument doesn't exist, create a new CreatureSkills with this data.
     */
    create: XOR<CreatureSkillsCreateInput, CreatureSkillsUncheckedCreateInput>
    /**
     * In case the CreatureSkills was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CreatureSkillsUpdateInput, CreatureSkillsUncheckedUpdateInput>
  }

  /**
   * CreatureSkills delete
   */
  export type CreatureSkillsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreatureSkills
     */
    select?: CreatureSkillsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CreatureSkills
     */
    omit?: CreatureSkillsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreatureSkillsInclude<ExtArgs> | null
    /**
     * Filter which CreatureSkills to delete.
     */
    where: CreatureSkillsWhereUniqueInput
  }

  /**
   * CreatureSkills deleteMany
   */
  export type CreatureSkillsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CreatureSkills to delete
     */
    where?: CreatureSkillsWhereInput
    /**
     * Limit how many CreatureSkills to delete.
     */
    limit?: number
  }

  /**
   * CreatureSkills.skills
   */
  export type CreatureSkills$skillsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreatureSkillDetail
     */
    select?: CreatureSkillDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CreatureSkillDetail
     */
    omit?: CreatureSkillDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreatureSkillDetailInclude<ExtArgs> | null
    where?: CreatureSkillDetailWhereInput
    orderBy?: CreatureSkillDetailOrderByWithRelationInput | CreatureSkillDetailOrderByWithRelationInput[]
    cursor?: CreatureSkillDetailWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CreatureSkillDetailScalarFieldEnum | CreatureSkillDetailScalarFieldEnum[]
  }

  /**
   * CreatureSkills without action
   */
  export type CreatureSkillsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreatureSkills
     */
    select?: CreatureSkillsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CreatureSkills
     */
    omit?: CreatureSkillsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreatureSkillsInclude<ExtArgs> | null
  }


  /**
   * Model CreatureSkillDetail
   */

  export type AggregateCreatureSkillDetail = {
    _count: CreatureSkillDetailCountAggregateOutputType | null
    _avg: CreatureSkillDetailAvgAggregateOutputType | null
    _sum: CreatureSkillDetailSumAggregateOutputType | null
    _min: CreatureSkillDetailMinAggregateOutputType | null
    _max: CreatureSkillDetailMaxAggregateOutputType | null
  }

  export type CreatureSkillDetailAvgAggregateOutputType = {
    value: number | null
  }

  export type CreatureSkillDetailSumAggregateOutputType = {
    value: number | null
  }

  export type CreatureSkillDetailMinAggregateOutputType = {
    id: string | null
    skill: $Enums.Skill | null
    value: number | null
    mastery: boolean | null
    creature_skills_id: string | null
  }

  export type CreatureSkillDetailMaxAggregateOutputType = {
    id: string | null
    skill: $Enums.Skill | null
    value: number | null
    mastery: boolean | null
    creature_skills_id: string | null
  }

  export type CreatureSkillDetailCountAggregateOutputType = {
    id: number
    skill: number
    value: number
    mastery: number
    creature_skills_id: number
    _all: number
  }


  export type CreatureSkillDetailAvgAggregateInputType = {
    value?: true
  }

  export type CreatureSkillDetailSumAggregateInputType = {
    value?: true
  }

  export type CreatureSkillDetailMinAggregateInputType = {
    id?: true
    skill?: true
    value?: true
    mastery?: true
    creature_skills_id?: true
  }

  export type CreatureSkillDetailMaxAggregateInputType = {
    id?: true
    skill?: true
    value?: true
    mastery?: true
    creature_skills_id?: true
  }

  export type CreatureSkillDetailCountAggregateInputType = {
    id?: true
    skill?: true
    value?: true
    mastery?: true
    creature_skills_id?: true
    _all?: true
  }

  export type CreatureSkillDetailAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CreatureSkillDetail to aggregate.
     */
    where?: CreatureSkillDetailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CreatureSkillDetails to fetch.
     */
    orderBy?: CreatureSkillDetailOrderByWithRelationInput | CreatureSkillDetailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CreatureSkillDetailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CreatureSkillDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CreatureSkillDetails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CreatureSkillDetails
    **/
    _count?: true | CreatureSkillDetailCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CreatureSkillDetailAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CreatureSkillDetailSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CreatureSkillDetailMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CreatureSkillDetailMaxAggregateInputType
  }

  export type GetCreatureSkillDetailAggregateType<T extends CreatureSkillDetailAggregateArgs> = {
        [P in keyof T & keyof AggregateCreatureSkillDetail]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCreatureSkillDetail[P]>
      : GetScalarType<T[P], AggregateCreatureSkillDetail[P]>
  }




  export type CreatureSkillDetailGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CreatureSkillDetailWhereInput
    orderBy?: CreatureSkillDetailOrderByWithAggregationInput | CreatureSkillDetailOrderByWithAggregationInput[]
    by: CreatureSkillDetailScalarFieldEnum[] | CreatureSkillDetailScalarFieldEnum
    having?: CreatureSkillDetailScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CreatureSkillDetailCountAggregateInputType | true
    _avg?: CreatureSkillDetailAvgAggregateInputType
    _sum?: CreatureSkillDetailSumAggregateInputType
    _min?: CreatureSkillDetailMinAggregateInputType
    _max?: CreatureSkillDetailMaxAggregateInputType
  }

  export type CreatureSkillDetailGroupByOutputType = {
    id: string
    skill: $Enums.Skill
    value: number | null
    mastery: boolean
    creature_skills_id: string
    _count: CreatureSkillDetailCountAggregateOutputType | null
    _avg: CreatureSkillDetailAvgAggregateOutputType | null
    _sum: CreatureSkillDetailSumAggregateOutputType | null
    _min: CreatureSkillDetailMinAggregateOutputType | null
    _max: CreatureSkillDetailMaxAggregateOutputType | null
  }

  type GetCreatureSkillDetailGroupByPayload<T extends CreatureSkillDetailGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CreatureSkillDetailGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CreatureSkillDetailGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CreatureSkillDetailGroupByOutputType[P]>
            : GetScalarType<T[P], CreatureSkillDetailGroupByOutputType[P]>
        }
      >
    >


  export type CreatureSkillDetailSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    skill?: boolean
    value?: boolean
    mastery?: boolean
    creature_skills_id?: boolean
    creature_skills_relation?: boolean | CreatureSkillsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["creatureSkillDetail"]>

  export type CreatureSkillDetailSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    skill?: boolean
    value?: boolean
    mastery?: boolean
    creature_skills_id?: boolean
    creature_skills_relation?: boolean | CreatureSkillsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["creatureSkillDetail"]>

  export type CreatureSkillDetailSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    skill?: boolean
    value?: boolean
    mastery?: boolean
    creature_skills_id?: boolean
    creature_skills_relation?: boolean | CreatureSkillsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["creatureSkillDetail"]>

  export type CreatureSkillDetailSelectScalar = {
    id?: boolean
    skill?: boolean
    value?: boolean
    mastery?: boolean
    creature_skills_id?: boolean
  }

  export type CreatureSkillDetailOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "skill" | "value" | "mastery" | "creature_skills_id", ExtArgs["result"]["creatureSkillDetail"]>
  export type CreatureSkillDetailInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creature_skills_relation?: boolean | CreatureSkillsDefaultArgs<ExtArgs>
  }
  export type CreatureSkillDetailIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creature_skills_relation?: boolean | CreatureSkillsDefaultArgs<ExtArgs>
  }
  export type CreatureSkillDetailIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creature_skills_relation?: boolean | CreatureSkillsDefaultArgs<ExtArgs>
  }

  export type $CreatureSkillDetailPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CreatureSkillDetail"
    objects: {
      creature_skills_relation: Prisma.$CreatureSkillsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      skill: $Enums.Skill
      value: number | null
      mastery: boolean
      creature_skills_id: string
    }, ExtArgs["result"]["creatureSkillDetail"]>
    composites: {}
  }

  type CreatureSkillDetailGetPayload<S extends boolean | null | undefined | CreatureSkillDetailDefaultArgs> = $Result.GetResult<Prisma.$CreatureSkillDetailPayload, S>

  type CreatureSkillDetailCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CreatureSkillDetailFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CreatureSkillDetailCountAggregateInputType | true
    }

  export interface CreatureSkillDetailDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CreatureSkillDetail'], meta: { name: 'CreatureSkillDetail' } }
    /**
     * Find zero or one CreatureSkillDetail that matches the filter.
     * @param {CreatureSkillDetailFindUniqueArgs} args - Arguments to find a CreatureSkillDetail
     * @example
     * // Get one CreatureSkillDetail
     * const creatureSkillDetail = await prisma.creatureSkillDetail.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CreatureSkillDetailFindUniqueArgs>(args: SelectSubset<T, CreatureSkillDetailFindUniqueArgs<ExtArgs>>): Prisma__CreatureSkillDetailClient<$Result.GetResult<Prisma.$CreatureSkillDetailPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one CreatureSkillDetail that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CreatureSkillDetailFindUniqueOrThrowArgs} args - Arguments to find a CreatureSkillDetail
     * @example
     * // Get one CreatureSkillDetail
     * const creatureSkillDetail = await prisma.creatureSkillDetail.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CreatureSkillDetailFindUniqueOrThrowArgs>(args: SelectSubset<T, CreatureSkillDetailFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CreatureSkillDetailClient<$Result.GetResult<Prisma.$CreatureSkillDetailPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first CreatureSkillDetail that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreatureSkillDetailFindFirstArgs} args - Arguments to find a CreatureSkillDetail
     * @example
     * // Get one CreatureSkillDetail
     * const creatureSkillDetail = await prisma.creatureSkillDetail.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CreatureSkillDetailFindFirstArgs>(args?: SelectSubset<T, CreatureSkillDetailFindFirstArgs<ExtArgs>>): Prisma__CreatureSkillDetailClient<$Result.GetResult<Prisma.$CreatureSkillDetailPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first CreatureSkillDetail that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreatureSkillDetailFindFirstOrThrowArgs} args - Arguments to find a CreatureSkillDetail
     * @example
     * // Get one CreatureSkillDetail
     * const creatureSkillDetail = await prisma.creatureSkillDetail.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CreatureSkillDetailFindFirstOrThrowArgs>(args?: SelectSubset<T, CreatureSkillDetailFindFirstOrThrowArgs<ExtArgs>>): Prisma__CreatureSkillDetailClient<$Result.GetResult<Prisma.$CreatureSkillDetailPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more CreatureSkillDetails that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreatureSkillDetailFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CreatureSkillDetails
     * const creatureSkillDetails = await prisma.creatureSkillDetail.findMany()
     * 
     * // Get first 10 CreatureSkillDetails
     * const creatureSkillDetails = await prisma.creatureSkillDetail.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const creatureSkillDetailWithIdOnly = await prisma.creatureSkillDetail.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CreatureSkillDetailFindManyArgs>(args?: SelectSubset<T, CreatureSkillDetailFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CreatureSkillDetailPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a CreatureSkillDetail.
     * @param {CreatureSkillDetailCreateArgs} args - Arguments to create a CreatureSkillDetail.
     * @example
     * // Create one CreatureSkillDetail
     * const CreatureSkillDetail = await prisma.creatureSkillDetail.create({
     *   data: {
     *     // ... data to create a CreatureSkillDetail
     *   }
     * })
     * 
     */
    create<T extends CreatureSkillDetailCreateArgs>(args: SelectSubset<T, CreatureSkillDetailCreateArgs<ExtArgs>>): Prisma__CreatureSkillDetailClient<$Result.GetResult<Prisma.$CreatureSkillDetailPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many CreatureSkillDetails.
     * @param {CreatureSkillDetailCreateManyArgs} args - Arguments to create many CreatureSkillDetails.
     * @example
     * // Create many CreatureSkillDetails
     * const creatureSkillDetail = await prisma.creatureSkillDetail.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CreatureSkillDetailCreateManyArgs>(args?: SelectSubset<T, CreatureSkillDetailCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CreatureSkillDetails and returns the data saved in the database.
     * @param {CreatureSkillDetailCreateManyAndReturnArgs} args - Arguments to create many CreatureSkillDetails.
     * @example
     * // Create many CreatureSkillDetails
     * const creatureSkillDetail = await prisma.creatureSkillDetail.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CreatureSkillDetails and only return the `id`
     * const creatureSkillDetailWithIdOnly = await prisma.creatureSkillDetail.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CreatureSkillDetailCreateManyAndReturnArgs>(args?: SelectSubset<T, CreatureSkillDetailCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CreatureSkillDetailPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a CreatureSkillDetail.
     * @param {CreatureSkillDetailDeleteArgs} args - Arguments to delete one CreatureSkillDetail.
     * @example
     * // Delete one CreatureSkillDetail
     * const CreatureSkillDetail = await prisma.creatureSkillDetail.delete({
     *   where: {
     *     // ... filter to delete one CreatureSkillDetail
     *   }
     * })
     * 
     */
    delete<T extends CreatureSkillDetailDeleteArgs>(args: SelectSubset<T, CreatureSkillDetailDeleteArgs<ExtArgs>>): Prisma__CreatureSkillDetailClient<$Result.GetResult<Prisma.$CreatureSkillDetailPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one CreatureSkillDetail.
     * @param {CreatureSkillDetailUpdateArgs} args - Arguments to update one CreatureSkillDetail.
     * @example
     * // Update one CreatureSkillDetail
     * const creatureSkillDetail = await prisma.creatureSkillDetail.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CreatureSkillDetailUpdateArgs>(args: SelectSubset<T, CreatureSkillDetailUpdateArgs<ExtArgs>>): Prisma__CreatureSkillDetailClient<$Result.GetResult<Prisma.$CreatureSkillDetailPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more CreatureSkillDetails.
     * @param {CreatureSkillDetailDeleteManyArgs} args - Arguments to filter CreatureSkillDetails to delete.
     * @example
     * // Delete a few CreatureSkillDetails
     * const { count } = await prisma.creatureSkillDetail.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CreatureSkillDetailDeleteManyArgs>(args?: SelectSubset<T, CreatureSkillDetailDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CreatureSkillDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreatureSkillDetailUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CreatureSkillDetails
     * const creatureSkillDetail = await prisma.creatureSkillDetail.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CreatureSkillDetailUpdateManyArgs>(args: SelectSubset<T, CreatureSkillDetailUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CreatureSkillDetails and returns the data updated in the database.
     * @param {CreatureSkillDetailUpdateManyAndReturnArgs} args - Arguments to update many CreatureSkillDetails.
     * @example
     * // Update many CreatureSkillDetails
     * const creatureSkillDetail = await prisma.creatureSkillDetail.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CreatureSkillDetails and only return the `id`
     * const creatureSkillDetailWithIdOnly = await prisma.creatureSkillDetail.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CreatureSkillDetailUpdateManyAndReturnArgs>(args: SelectSubset<T, CreatureSkillDetailUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CreatureSkillDetailPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one CreatureSkillDetail.
     * @param {CreatureSkillDetailUpsertArgs} args - Arguments to update or create a CreatureSkillDetail.
     * @example
     * // Update or create a CreatureSkillDetail
     * const creatureSkillDetail = await prisma.creatureSkillDetail.upsert({
     *   create: {
     *     // ... data to create a CreatureSkillDetail
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CreatureSkillDetail we want to update
     *   }
     * })
     */
    upsert<T extends CreatureSkillDetailUpsertArgs>(args: SelectSubset<T, CreatureSkillDetailUpsertArgs<ExtArgs>>): Prisma__CreatureSkillDetailClient<$Result.GetResult<Prisma.$CreatureSkillDetailPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of CreatureSkillDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreatureSkillDetailCountArgs} args - Arguments to filter CreatureSkillDetails to count.
     * @example
     * // Count the number of CreatureSkillDetails
     * const count = await prisma.creatureSkillDetail.count({
     *   where: {
     *     // ... the filter for the CreatureSkillDetails we want to count
     *   }
     * })
    **/
    count<T extends CreatureSkillDetailCountArgs>(
      args?: Subset<T, CreatureSkillDetailCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CreatureSkillDetailCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CreatureSkillDetail.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreatureSkillDetailAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CreatureSkillDetailAggregateArgs>(args: Subset<T, CreatureSkillDetailAggregateArgs>): Prisma.PrismaPromise<GetCreatureSkillDetailAggregateType<T>>

    /**
     * Group by CreatureSkillDetail.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreatureSkillDetailGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CreatureSkillDetailGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CreatureSkillDetailGroupByArgs['orderBy'] }
        : { orderBy?: CreatureSkillDetailGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CreatureSkillDetailGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCreatureSkillDetailGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CreatureSkillDetail model
   */
  readonly fields: CreatureSkillDetailFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CreatureSkillDetail.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CreatureSkillDetailClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    creature_skills_relation<T extends CreatureSkillsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CreatureSkillsDefaultArgs<ExtArgs>>): Prisma__CreatureSkillsClient<$Result.GetResult<Prisma.$CreatureSkillsPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CreatureSkillDetail model
   */ 
  interface CreatureSkillDetailFieldRefs {
    readonly id: FieldRef<"CreatureSkillDetail", 'String'>
    readonly skill: FieldRef<"CreatureSkillDetail", 'Skill'>
    readonly value: FieldRef<"CreatureSkillDetail", 'Int'>
    readonly mastery: FieldRef<"CreatureSkillDetail", 'Boolean'>
    readonly creature_skills_id: FieldRef<"CreatureSkillDetail", 'String'>
  }
    

  // Custom InputTypes
  /**
   * CreatureSkillDetail findUnique
   */
  export type CreatureSkillDetailFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreatureSkillDetail
     */
    select?: CreatureSkillDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CreatureSkillDetail
     */
    omit?: CreatureSkillDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreatureSkillDetailInclude<ExtArgs> | null
    /**
     * Filter, which CreatureSkillDetail to fetch.
     */
    where: CreatureSkillDetailWhereUniqueInput
  }

  /**
   * CreatureSkillDetail findUniqueOrThrow
   */
  export type CreatureSkillDetailFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreatureSkillDetail
     */
    select?: CreatureSkillDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CreatureSkillDetail
     */
    omit?: CreatureSkillDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreatureSkillDetailInclude<ExtArgs> | null
    /**
     * Filter, which CreatureSkillDetail to fetch.
     */
    where: CreatureSkillDetailWhereUniqueInput
  }

  /**
   * CreatureSkillDetail findFirst
   */
  export type CreatureSkillDetailFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreatureSkillDetail
     */
    select?: CreatureSkillDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CreatureSkillDetail
     */
    omit?: CreatureSkillDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreatureSkillDetailInclude<ExtArgs> | null
    /**
     * Filter, which CreatureSkillDetail to fetch.
     */
    where?: CreatureSkillDetailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CreatureSkillDetails to fetch.
     */
    orderBy?: CreatureSkillDetailOrderByWithRelationInput | CreatureSkillDetailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CreatureSkillDetails.
     */
    cursor?: CreatureSkillDetailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CreatureSkillDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CreatureSkillDetails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CreatureSkillDetails.
     */
    distinct?: CreatureSkillDetailScalarFieldEnum | CreatureSkillDetailScalarFieldEnum[]
  }

  /**
   * CreatureSkillDetail findFirstOrThrow
   */
  export type CreatureSkillDetailFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreatureSkillDetail
     */
    select?: CreatureSkillDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CreatureSkillDetail
     */
    omit?: CreatureSkillDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreatureSkillDetailInclude<ExtArgs> | null
    /**
     * Filter, which CreatureSkillDetail to fetch.
     */
    where?: CreatureSkillDetailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CreatureSkillDetails to fetch.
     */
    orderBy?: CreatureSkillDetailOrderByWithRelationInput | CreatureSkillDetailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CreatureSkillDetails.
     */
    cursor?: CreatureSkillDetailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CreatureSkillDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CreatureSkillDetails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CreatureSkillDetails.
     */
    distinct?: CreatureSkillDetailScalarFieldEnum | CreatureSkillDetailScalarFieldEnum[]
  }

  /**
   * CreatureSkillDetail findMany
   */
  export type CreatureSkillDetailFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreatureSkillDetail
     */
    select?: CreatureSkillDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CreatureSkillDetail
     */
    omit?: CreatureSkillDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreatureSkillDetailInclude<ExtArgs> | null
    /**
     * Filter, which CreatureSkillDetails to fetch.
     */
    where?: CreatureSkillDetailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CreatureSkillDetails to fetch.
     */
    orderBy?: CreatureSkillDetailOrderByWithRelationInput | CreatureSkillDetailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CreatureSkillDetails.
     */
    cursor?: CreatureSkillDetailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CreatureSkillDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CreatureSkillDetails.
     */
    skip?: number
    distinct?: CreatureSkillDetailScalarFieldEnum | CreatureSkillDetailScalarFieldEnum[]
  }

  /**
   * CreatureSkillDetail create
   */
  export type CreatureSkillDetailCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreatureSkillDetail
     */
    select?: CreatureSkillDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CreatureSkillDetail
     */
    omit?: CreatureSkillDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreatureSkillDetailInclude<ExtArgs> | null
    /**
     * The data needed to create a CreatureSkillDetail.
     */
    data: XOR<CreatureSkillDetailCreateInput, CreatureSkillDetailUncheckedCreateInput>
  }

  /**
   * CreatureSkillDetail createMany
   */
  export type CreatureSkillDetailCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CreatureSkillDetails.
     */
    data: CreatureSkillDetailCreateManyInput | CreatureSkillDetailCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CreatureSkillDetail createManyAndReturn
   */
  export type CreatureSkillDetailCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreatureSkillDetail
     */
    select?: CreatureSkillDetailSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CreatureSkillDetail
     */
    omit?: CreatureSkillDetailOmit<ExtArgs> | null
    /**
     * The data used to create many CreatureSkillDetails.
     */
    data: CreatureSkillDetailCreateManyInput | CreatureSkillDetailCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreatureSkillDetailIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CreatureSkillDetail update
   */
  export type CreatureSkillDetailUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreatureSkillDetail
     */
    select?: CreatureSkillDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CreatureSkillDetail
     */
    omit?: CreatureSkillDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreatureSkillDetailInclude<ExtArgs> | null
    /**
     * The data needed to update a CreatureSkillDetail.
     */
    data: XOR<CreatureSkillDetailUpdateInput, CreatureSkillDetailUncheckedUpdateInput>
    /**
     * Choose, which CreatureSkillDetail to update.
     */
    where: CreatureSkillDetailWhereUniqueInput
  }

  /**
   * CreatureSkillDetail updateMany
   */
  export type CreatureSkillDetailUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CreatureSkillDetails.
     */
    data: XOR<CreatureSkillDetailUpdateManyMutationInput, CreatureSkillDetailUncheckedUpdateManyInput>
    /**
     * Filter which CreatureSkillDetails to update
     */
    where?: CreatureSkillDetailWhereInput
    /**
     * Limit how many CreatureSkillDetails to update.
     */
    limit?: number
  }

  /**
   * CreatureSkillDetail updateManyAndReturn
   */
  export type CreatureSkillDetailUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreatureSkillDetail
     */
    select?: CreatureSkillDetailSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CreatureSkillDetail
     */
    omit?: CreatureSkillDetailOmit<ExtArgs> | null
    /**
     * The data used to update CreatureSkillDetails.
     */
    data: XOR<CreatureSkillDetailUpdateManyMutationInput, CreatureSkillDetailUncheckedUpdateManyInput>
    /**
     * Filter which CreatureSkillDetails to update
     */
    where?: CreatureSkillDetailWhereInput
    /**
     * Limit how many CreatureSkillDetails to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreatureSkillDetailIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CreatureSkillDetail upsert
   */
  export type CreatureSkillDetailUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreatureSkillDetail
     */
    select?: CreatureSkillDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CreatureSkillDetail
     */
    omit?: CreatureSkillDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreatureSkillDetailInclude<ExtArgs> | null
    /**
     * The filter to search for the CreatureSkillDetail to update in case it exists.
     */
    where: CreatureSkillDetailWhereUniqueInput
    /**
     * In case the CreatureSkillDetail found by the `where` argument doesn't exist, create a new CreatureSkillDetail with this data.
     */
    create: XOR<CreatureSkillDetailCreateInput, CreatureSkillDetailUncheckedCreateInput>
    /**
     * In case the CreatureSkillDetail was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CreatureSkillDetailUpdateInput, CreatureSkillDetailUncheckedUpdateInput>
  }

  /**
   * CreatureSkillDetail delete
   */
  export type CreatureSkillDetailDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreatureSkillDetail
     */
    select?: CreatureSkillDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CreatureSkillDetail
     */
    omit?: CreatureSkillDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreatureSkillDetailInclude<ExtArgs> | null
    /**
     * Filter which CreatureSkillDetail to delete.
     */
    where: CreatureSkillDetailWhereUniqueInput
  }

  /**
   * CreatureSkillDetail deleteMany
   */
  export type CreatureSkillDetailDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CreatureSkillDetails to delete
     */
    where?: CreatureSkillDetailWhereInput
    /**
     * Limit how many CreatureSkillDetails to delete.
     */
    limit?: number
  }

  /**
   * CreatureSkillDetail without action
   */
  export type CreatureSkillDetailDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreatureSkillDetail
     */
    select?: CreatureSkillDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CreatureSkillDetail
     */
    omit?: CreatureSkillDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreatureSkillDetailInclude<ExtArgs> | null
  }


  /**
   * Model SkillMetadata
   */

  export type AggregateSkillMetadata = {
    _count: SkillMetadataCountAggregateOutputType | null
    _min: SkillMetadataMinAggregateOutputType | null
    _max: SkillMetadataMaxAggregateOutputType | null
  }

  export type SkillMetadataMinAggregateOutputType = {
    skill: $Enums.Skill | null
    display_name: string | null
    ability: $Enums.Ability | null
  }

  export type SkillMetadataMaxAggregateOutputType = {
    skill: $Enums.Skill | null
    display_name: string | null
    ability: $Enums.Ability | null
  }

  export type SkillMetadataCountAggregateOutputType = {
    skill: number
    display_name: number
    ability: number
    _all: number
  }


  export type SkillMetadataMinAggregateInputType = {
    skill?: true
    display_name?: true
    ability?: true
  }

  export type SkillMetadataMaxAggregateInputType = {
    skill?: true
    display_name?: true
    ability?: true
  }

  export type SkillMetadataCountAggregateInputType = {
    skill?: true
    display_name?: true
    ability?: true
    _all?: true
  }

  export type SkillMetadataAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SkillMetadata to aggregate.
     */
    where?: SkillMetadataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SkillMetadata to fetch.
     */
    orderBy?: SkillMetadataOrderByWithRelationInput | SkillMetadataOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SkillMetadataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SkillMetadata from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SkillMetadata.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SkillMetadata
    **/
    _count?: true | SkillMetadataCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SkillMetadataMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SkillMetadataMaxAggregateInputType
  }

  export type GetSkillMetadataAggregateType<T extends SkillMetadataAggregateArgs> = {
        [P in keyof T & keyof AggregateSkillMetadata]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSkillMetadata[P]>
      : GetScalarType<T[P], AggregateSkillMetadata[P]>
  }




  export type SkillMetadataGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SkillMetadataWhereInput
    orderBy?: SkillMetadataOrderByWithAggregationInput | SkillMetadataOrderByWithAggregationInput[]
    by: SkillMetadataScalarFieldEnum[] | SkillMetadataScalarFieldEnum
    having?: SkillMetadataScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SkillMetadataCountAggregateInputType | true
    _min?: SkillMetadataMinAggregateInputType
    _max?: SkillMetadataMaxAggregateInputType
  }

  export type SkillMetadataGroupByOutputType = {
    skill: $Enums.Skill
    display_name: string
    ability: $Enums.Ability
    _count: SkillMetadataCountAggregateOutputType | null
    _min: SkillMetadataMinAggregateOutputType | null
    _max: SkillMetadataMaxAggregateOutputType | null
  }

  type GetSkillMetadataGroupByPayload<T extends SkillMetadataGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SkillMetadataGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SkillMetadataGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SkillMetadataGroupByOutputType[P]>
            : GetScalarType<T[P], SkillMetadataGroupByOutputType[P]>
        }
      >
    >


  export type SkillMetadataSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    skill?: boolean
    display_name?: boolean
    ability?: boolean
  }, ExtArgs["result"]["skillMetadata"]>

  export type SkillMetadataSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    skill?: boolean
    display_name?: boolean
    ability?: boolean
  }, ExtArgs["result"]["skillMetadata"]>

  export type SkillMetadataSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    skill?: boolean
    display_name?: boolean
    ability?: boolean
  }, ExtArgs["result"]["skillMetadata"]>

  export type SkillMetadataSelectScalar = {
    skill?: boolean
    display_name?: boolean
    ability?: boolean
  }

  export type SkillMetadataOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"skill" | "display_name" | "ability", ExtArgs["result"]["skillMetadata"]>

  export type $SkillMetadataPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SkillMetadata"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      skill: $Enums.Skill
      display_name: string
      ability: $Enums.Ability
    }, ExtArgs["result"]["skillMetadata"]>
    composites: {}
  }

  type SkillMetadataGetPayload<S extends boolean | null | undefined | SkillMetadataDefaultArgs> = $Result.GetResult<Prisma.$SkillMetadataPayload, S>

  type SkillMetadataCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SkillMetadataFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SkillMetadataCountAggregateInputType | true
    }

  export interface SkillMetadataDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SkillMetadata'], meta: { name: 'SkillMetadata' } }
    /**
     * Find zero or one SkillMetadata that matches the filter.
     * @param {SkillMetadataFindUniqueArgs} args - Arguments to find a SkillMetadata
     * @example
     * // Get one SkillMetadata
     * const skillMetadata = await prisma.skillMetadata.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SkillMetadataFindUniqueArgs>(args: SelectSubset<T, SkillMetadataFindUniqueArgs<ExtArgs>>): Prisma__SkillMetadataClient<$Result.GetResult<Prisma.$SkillMetadataPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one SkillMetadata that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SkillMetadataFindUniqueOrThrowArgs} args - Arguments to find a SkillMetadata
     * @example
     * // Get one SkillMetadata
     * const skillMetadata = await prisma.skillMetadata.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SkillMetadataFindUniqueOrThrowArgs>(args: SelectSubset<T, SkillMetadataFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SkillMetadataClient<$Result.GetResult<Prisma.$SkillMetadataPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first SkillMetadata that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SkillMetadataFindFirstArgs} args - Arguments to find a SkillMetadata
     * @example
     * // Get one SkillMetadata
     * const skillMetadata = await prisma.skillMetadata.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SkillMetadataFindFirstArgs>(args?: SelectSubset<T, SkillMetadataFindFirstArgs<ExtArgs>>): Prisma__SkillMetadataClient<$Result.GetResult<Prisma.$SkillMetadataPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first SkillMetadata that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SkillMetadataFindFirstOrThrowArgs} args - Arguments to find a SkillMetadata
     * @example
     * // Get one SkillMetadata
     * const skillMetadata = await prisma.skillMetadata.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SkillMetadataFindFirstOrThrowArgs>(args?: SelectSubset<T, SkillMetadataFindFirstOrThrowArgs<ExtArgs>>): Prisma__SkillMetadataClient<$Result.GetResult<Prisma.$SkillMetadataPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more SkillMetadata that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SkillMetadataFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SkillMetadata
     * const skillMetadata = await prisma.skillMetadata.findMany()
     * 
     * // Get first 10 SkillMetadata
     * const skillMetadata = await prisma.skillMetadata.findMany({ take: 10 })
     * 
     * // Only select the `display_name`
     * const skillMetadataWithDisplay_nameOnly = await prisma.skillMetadata.findMany({ select: { display_name: true } })
     * 
     */
    findMany<T extends SkillMetadataFindManyArgs>(args?: SelectSubset<T, SkillMetadataFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SkillMetadataPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a SkillMetadata.
     * @param {SkillMetadataCreateArgs} args - Arguments to create a SkillMetadata.
     * @example
     * // Create one SkillMetadata
     * const SkillMetadata = await prisma.skillMetadata.create({
     *   data: {
     *     // ... data to create a SkillMetadata
     *   }
     * })
     * 
     */
    create<T extends SkillMetadataCreateArgs>(args: SelectSubset<T, SkillMetadataCreateArgs<ExtArgs>>): Prisma__SkillMetadataClient<$Result.GetResult<Prisma.$SkillMetadataPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many SkillMetadata.
     * @param {SkillMetadataCreateManyArgs} args - Arguments to create many SkillMetadata.
     * @example
     * // Create many SkillMetadata
     * const skillMetadata = await prisma.skillMetadata.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SkillMetadataCreateManyArgs>(args?: SelectSubset<T, SkillMetadataCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SkillMetadata and returns the data saved in the database.
     * @param {SkillMetadataCreateManyAndReturnArgs} args - Arguments to create many SkillMetadata.
     * @example
     * // Create many SkillMetadata
     * const skillMetadata = await prisma.skillMetadata.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SkillMetadata and only return the `display_name`
     * const skillMetadataWithDisplay_nameOnly = await prisma.skillMetadata.createManyAndReturn({
     *   select: { display_name: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SkillMetadataCreateManyAndReturnArgs>(args?: SelectSubset<T, SkillMetadataCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SkillMetadataPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a SkillMetadata.
     * @param {SkillMetadataDeleteArgs} args - Arguments to delete one SkillMetadata.
     * @example
     * // Delete one SkillMetadata
     * const SkillMetadata = await prisma.skillMetadata.delete({
     *   where: {
     *     // ... filter to delete one SkillMetadata
     *   }
     * })
     * 
     */
    delete<T extends SkillMetadataDeleteArgs>(args: SelectSubset<T, SkillMetadataDeleteArgs<ExtArgs>>): Prisma__SkillMetadataClient<$Result.GetResult<Prisma.$SkillMetadataPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one SkillMetadata.
     * @param {SkillMetadataUpdateArgs} args - Arguments to update one SkillMetadata.
     * @example
     * // Update one SkillMetadata
     * const skillMetadata = await prisma.skillMetadata.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SkillMetadataUpdateArgs>(args: SelectSubset<T, SkillMetadataUpdateArgs<ExtArgs>>): Prisma__SkillMetadataClient<$Result.GetResult<Prisma.$SkillMetadataPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more SkillMetadata.
     * @param {SkillMetadataDeleteManyArgs} args - Arguments to filter SkillMetadata to delete.
     * @example
     * // Delete a few SkillMetadata
     * const { count } = await prisma.skillMetadata.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SkillMetadataDeleteManyArgs>(args?: SelectSubset<T, SkillMetadataDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SkillMetadata.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SkillMetadataUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SkillMetadata
     * const skillMetadata = await prisma.skillMetadata.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SkillMetadataUpdateManyArgs>(args: SelectSubset<T, SkillMetadataUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SkillMetadata and returns the data updated in the database.
     * @param {SkillMetadataUpdateManyAndReturnArgs} args - Arguments to update many SkillMetadata.
     * @example
     * // Update many SkillMetadata
     * const skillMetadata = await prisma.skillMetadata.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SkillMetadata and only return the `display_name`
     * const skillMetadataWithDisplay_nameOnly = await prisma.skillMetadata.updateManyAndReturn({
     *   select: { display_name: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SkillMetadataUpdateManyAndReturnArgs>(args: SelectSubset<T, SkillMetadataUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SkillMetadataPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one SkillMetadata.
     * @param {SkillMetadataUpsertArgs} args - Arguments to update or create a SkillMetadata.
     * @example
     * // Update or create a SkillMetadata
     * const skillMetadata = await prisma.skillMetadata.upsert({
     *   create: {
     *     // ... data to create a SkillMetadata
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SkillMetadata we want to update
     *   }
     * })
     */
    upsert<T extends SkillMetadataUpsertArgs>(args: SelectSubset<T, SkillMetadataUpsertArgs<ExtArgs>>): Prisma__SkillMetadataClient<$Result.GetResult<Prisma.$SkillMetadataPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of SkillMetadata.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SkillMetadataCountArgs} args - Arguments to filter SkillMetadata to count.
     * @example
     * // Count the number of SkillMetadata
     * const count = await prisma.skillMetadata.count({
     *   where: {
     *     // ... the filter for the SkillMetadata we want to count
     *   }
     * })
    **/
    count<T extends SkillMetadataCountArgs>(
      args?: Subset<T, SkillMetadataCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SkillMetadataCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SkillMetadata.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SkillMetadataAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SkillMetadataAggregateArgs>(args: Subset<T, SkillMetadataAggregateArgs>): Prisma.PrismaPromise<GetSkillMetadataAggregateType<T>>

    /**
     * Group by SkillMetadata.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SkillMetadataGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SkillMetadataGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SkillMetadataGroupByArgs['orderBy'] }
        : { orderBy?: SkillMetadataGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SkillMetadataGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSkillMetadataGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SkillMetadata model
   */
  readonly fields: SkillMetadataFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SkillMetadata.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SkillMetadataClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SkillMetadata model
   */ 
  interface SkillMetadataFieldRefs {
    readonly skill: FieldRef<"SkillMetadata", 'Skill'>
    readonly display_name: FieldRef<"SkillMetadata", 'String'>
    readonly ability: FieldRef<"SkillMetadata", 'Ability'>
  }
    

  // Custom InputTypes
  /**
   * SkillMetadata findUnique
   */
  export type SkillMetadataFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SkillMetadata
     */
    select?: SkillMetadataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SkillMetadata
     */
    omit?: SkillMetadataOmit<ExtArgs> | null
    /**
     * Filter, which SkillMetadata to fetch.
     */
    where: SkillMetadataWhereUniqueInput
  }

  /**
   * SkillMetadata findUniqueOrThrow
   */
  export type SkillMetadataFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SkillMetadata
     */
    select?: SkillMetadataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SkillMetadata
     */
    omit?: SkillMetadataOmit<ExtArgs> | null
    /**
     * Filter, which SkillMetadata to fetch.
     */
    where: SkillMetadataWhereUniqueInput
  }

  /**
   * SkillMetadata findFirst
   */
  export type SkillMetadataFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SkillMetadata
     */
    select?: SkillMetadataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SkillMetadata
     */
    omit?: SkillMetadataOmit<ExtArgs> | null
    /**
     * Filter, which SkillMetadata to fetch.
     */
    where?: SkillMetadataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SkillMetadata to fetch.
     */
    orderBy?: SkillMetadataOrderByWithRelationInput | SkillMetadataOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SkillMetadata.
     */
    cursor?: SkillMetadataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SkillMetadata from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SkillMetadata.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SkillMetadata.
     */
    distinct?: SkillMetadataScalarFieldEnum | SkillMetadataScalarFieldEnum[]
  }

  /**
   * SkillMetadata findFirstOrThrow
   */
  export type SkillMetadataFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SkillMetadata
     */
    select?: SkillMetadataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SkillMetadata
     */
    omit?: SkillMetadataOmit<ExtArgs> | null
    /**
     * Filter, which SkillMetadata to fetch.
     */
    where?: SkillMetadataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SkillMetadata to fetch.
     */
    orderBy?: SkillMetadataOrderByWithRelationInput | SkillMetadataOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SkillMetadata.
     */
    cursor?: SkillMetadataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SkillMetadata from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SkillMetadata.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SkillMetadata.
     */
    distinct?: SkillMetadataScalarFieldEnum | SkillMetadataScalarFieldEnum[]
  }

  /**
   * SkillMetadata findMany
   */
  export type SkillMetadataFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SkillMetadata
     */
    select?: SkillMetadataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SkillMetadata
     */
    omit?: SkillMetadataOmit<ExtArgs> | null
    /**
     * Filter, which SkillMetadata to fetch.
     */
    where?: SkillMetadataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SkillMetadata to fetch.
     */
    orderBy?: SkillMetadataOrderByWithRelationInput | SkillMetadataOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SkillMetadata.
     */
    cursor?: SkillMetadataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SkillMetadata from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SkillMetadata.
     */
    skip?: number
    distinct?: SkillMetadataScalarFieldEnum | SkillMetadataScalarFieldEnum[]
  }

  /**
   * SkillMetadata create
   */
  export type SkillMetadataCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SkillMetadata
     */
    select?: SkillMetadataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SkillMetadata
     */
    omit?: SkillMetadataOmit<ExtArgs> | null
    /**
     * The data needed to create a SkillMetadata.
     */
    data: XOR<SkillMetadataCreateInput, SkillMetadataUncheckedCreateInput>
  }

  /**
   * SkillMetadata createMany
   */
  export type SkillMetadataCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SkillMetadata.
     */
    data: SkillMetadataCreateManyInput | SkillMetadataCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SkillMetadata createManyAndReturn
   */
  export type SkillMetadataCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SkillMetadata
     */
    select?: SkillMetadataSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SkillMetadata
     */
    omit?: SkillMetadataOmit<ExtArgs> | null
    /**
     * The data used to create many SkillMetadata.
     */
    data: SkillMetadataCreateManyInput | SkillMetadataCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SkillMetadata update
   */
  export type SkillMetadataUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SkillMetadata
     */
    select?: SkillMetadataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SkillMetadata
     */
    omit?: SkillMetadataOmit<ExtArgs> | null
    /**
     * The data needed to update a SkillMetadata.
     */
    data: XOR<SkillMetadataUpdateInput, SkillMetadataUncheckedUpdateInput>
    /**
     * Choose, which SkillMetadata to update.
     */
    where: SkillMetadataWhereUniqueInput
  }

  /**
   * SkillMetadata updateMany
   */
  export type SkillMetadataUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SkillMetadata.
     */
    data: XOR<SkillMetadataUpdateManyMutationInput, SkillMetadataUncheckedUpdateManyInput>
    /**
     * Filter which SkillMetadata to update
     */
    where?: SkillMetadataWhereInput
    /**
     * Limit how many SkillMetadata to update.
     */
    limit?: number
  }

  /**
   * SkillMetadata updateManyAndReturn
   */
  export type SkillMetadataUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SkillMetadata
     */
    select?: SkillMetadataSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SkillMetadata
     */
    omit?: SkillMetadataOmit<ExtArgs> | null
    /**
     * The data used to update SkillMetadata.
     */
    data: XOR<SkillMetadataUpdateManyMutationInput, SkillMetadataUncheckedUpdateManyInput>
    /**
     * Filter which SkillMetadata to update
     */
    where?: SkillMetadataWhereInput
    /**
     * Limit how many SkillMetadata to update.
     */
    limit?: number
  }

  /**
   * SkillMetadata upsert
   */
  export type SkillMetadataUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SkillMetadata
     */
    select?: SkillMetadataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SkillMetadata
     */
    omit?: SkillMetadataOmit<ExtArgs> | null
    /**
     * The filter to search for the SkillMetadata to update in case it exists.
     */
    where: SkillMetadataWhereUniqueInput
    /**
     * In case the SkillMetadata found by the `where` argument doesn't exist, create a new SkillMetadata with this data.
     */
    create: XOR<SkillMetadataCreateInput, SkillMetadataUncheckedCreateInput>
    /**
     * In case the SkillMetadata was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SkillMetadataUpdateInput, SkillMetadataUncheckedUpdateInput>
  }

  /**
   * SkillMetadata delete
   */
  export type SkillMetadataDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SkillMetadata
     */
    select?: SkillMetadataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SkillMetadata
     */
    omit?: SkillMetadataOmit<ExtArgs> | null
    /**
     * Filter which SkillMetadata to delete.
     */
    where: SkillMetadataWhereUniqueInput
  }

  /**
   * SkillMetadata deleteMany
   */
  export type SkillMetadataDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SkillMetadata to delete
     */
    where?: SkillMetadataWhereInput
    /**
     * Limit how many SkillMetadata to delete.
     */
    limit?: number
  }

  /**
   * SkillMetadata without action
   */
  export type SkillMetadataDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SkillMetadata
     */
    select?: SkillMetadataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SkillMetadata
     */
    omit?: SkillMetadataOmit<ExtArgs> | null
  }


  /**
   * Model Creature
   */

  export type AggregateCreature = {
    _count: CreatureCountAggregateOutputType | null
    _avg: CreatureAvgAggregateOutputType | null
    _sum: CreatureSumAggregateOutputType | null
    _min: CreatureMinAggregateOutputType | null
    _max: CreatureMaxAggregateOutputType | null
  }

  export type CreatureAvgAggregateOutputType = {
    race_id: number | null
    type_id: number | null
    source_id: number | null
    alignment_id: number | null
    armor_class: number | null
    hit_points: number | null
  }

  export type CreatureSumAggregateOutputType = {
    race_id: number | null
    type_id: number | null
    source_id: number | null
    alignment_id: number | null
    armor_class: number | null
    hit_points: number | null
  }

  export type CreatureMinAggregateOutputType = {
    id: string | null
    name: string | null
    creator_id: string | null
    description: string | null
    size: string | null
    race_id: number | null
    type_id: number | null
    source_id: number | null
    alignment_id: number | null
    armor_class: number | null
    hit_points: number | null
    challenge_rating: string | null
  }

  export type CreatureMaxAggregateOutputType = {
    id: string | null
    name: string | null
    creator_id: string | null
    description: string | null
    size: string | null
    race_id: number | null
    type_id: number | null
    source_id: number | null
    alignment_id: number | null
    armor_class: number | null
    hit_points: number | null
    challenge_rating: string | null
  }

  export type CreatureCountAggregateOutputType = {
    id: number
    name: number
    creator_id: number
    description: number
    size: number
    race_id: number
    type_id: number
    source_id: number
    alignment_id: number
    armor_class: number
    hit_points: number
    challenge_rating: number
    _all: number
  }


  export type CreatureAvgAggregateInputType = {
    race_id?: true
    type_id?: true
    source_id?: true
    alignment_id?: true
    armor_class?: true
    hit_points?: true
  }

  export type CreatureSumAggregateInputType = {
    race_id?: true
    type_id?: true
    source_id?: true
    alignment_id?: true
    armor_class?: true
    hit_points?: true
  }

  export type CreatureMinAggregateInputType = {
    id?: true
    name?: true
    creator_id?: true
    description?: true
    size?: true
    race_id?: true
    type_id?: true
    source_id?: true
    alignment_id?: true
    armor_class?: true
    hit_points?: true
    challenge_rating?: true
  }

  export type CreatureMaxAggregateInputType = {
    id?: true
    name?: true
    creator_id?: true
    description?: true
    size?: true
    race_id?: true
    type_id?: true
    source_id?: true
    alignment_id?: true
    armor_class?: true
    hit_points?: true
    challenge_rating?: true
  }

  export type CreatureCountAggregateInputType = {
    id?: true
    name?: true
    creator_id?: true
    description?: true
    size?: true
    race_id?: true
    type_id?: true
    source_id?: true
    alignment_id?: true
    armor_class?: true
    hit_points?: true
    challenge_rating?: true
    _all?: true
  }

  export type CreatureAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Creature to aggregate.
     */
    where?: CreatureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Creatures to fetch.
     */
    orderBy?: CreatureOrderByWithRelationInput | CreatureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CreatureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Creatures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Creatures.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Creatures
    **/
    _count?: true | CreatureCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CreatureAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CreatureSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CreatureMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CreatureMaxAggregateInputType
  }

  export type GetCreatureAggregateType<T extends CreatureAggregateArgs> = {
        [P in keyof T & keyof AggregateCreature]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCreature[P]>
      : GetScalarType<T[P], AggregateCreature[P]>
  }




  export type CreatureGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CreatureWhereInput
    orderBy?: CreatureOrderByWithAggregationInput | CreatureOrderByWithAggregationInput[]
    by: CreatureScalarFieldEnum[] | CreatureScalarFieldEnum
    having?: CreatureScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CreatureCountAggregateInputType | true
    _avg?: CreatureAvgAggregateInputType
    _sum?: CreatureSumAggregateInputType
    _min?: CreatureMinAggregateInputType
    _max?: CreatureMaxAggregateInputType
  }

  export type CreatureGroupByOutputType = {
    id: string
    name: string
    creator_id: string | null
    description: string | null
    size: string | null
    race_id: number | null
    type_id: number | null
    source_id: number | null
    alignment_id: number | null
    armor_class: number | null
    hit_points: number | null
    challenge_rating: string
    _count: CreatureCountAggregateOutputType | null
    _avg: CreatureAvgAggregateOutputType | null
    _sum: CreatureSumAggregateOutputType | null
    _min: CreatureMinAggregateOutputType | null
    _max: CreatureMaxAggregateOutputType | null
  }

  type GetCreatureGroupByPayload<T extends CreatureGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CreatureGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CreatureGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CreatureGroupByOutputType[P]>
            : GetScalarType<T[P], CreatureGroupByOutputType[P]>
        }
      >
    >


  export type CreatureSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    creator_id?: boolean
    description?: boolean
    size?: boolean
    race_id?: boolean
    type_id?: boolean
    source_id?: boolean
    alignment_id?: boolean
    armor_class?: boolean
    hit_points?: boolean
    challenge_rating?: boolean
    speed?: boolean | Creature$speedArgs<ExtArgs>
    stats?: boolean | Creature$statsArgs<ExtArgs>
    skills?: boolean | Creature$skillsArgs<ExtArgs>
    senses?: boolean | Creature$sensesArgs<ExtArgs>
    challenge_rating_meta?: boolean | ChallengeRatingMetadataDefaultArgs<ExtArgs>
    alignment_relation?: boolean | Creature$alignment_relationArgs<ExtArgs>
    race_relation?: boolean | Creature$race_relationArgs<ExtArgs>
    type_relation?: boolean | Creature$type_relationArgs<ExtArgs>
    size_relation?: boolean | Creature$size_relationArgs<ExtArgs>
    source_relation?: boolean | Creature$source_relationArgs<ExtArgs>
    resistances?: boolean | Creature$resistancesArgs<ExtArgs>
    immunities?: boolean | Creature$immunitiesArgs<ExtArgs>
    vulnerabilities?: boolean | Creature$vulnerabilitiesArgs<ExtArgs>
    languages_relation?: boolean | Creature$languages_relationArgs<ExtArgs>
    biomes_relation?: boolean | Creature$biomes_relationArgs<ExtArgs>
    actions_relation?: boolean | Creature$actions_relationArgs<ExtArgs>
    traits_relation?: boolean | Creature$traits_relationArgs<ExtArgs>
    _count?: boolean | CreatureCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["creature"]>

  export type CreatureSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    creator_id?: boolean
    description?: boolean
    size?: boolean
    race_id?: boolean
    type_id?: boolean
    source_id?: boolean
    alignment_id?: boolean
    armor_class?: boolean
    hit_points?: boolean
    challenge_rating?: boolean
    challenge_rating_meta?: boolean | ChallengeRatingMetadataDefaultArgs<ExtArgs>
    alignment_relation?: boolean | Creature$alignment_relationArgs<ExtArgs>
    race_relation?: boolean | Creature$race_relationArgs<ExtArgs>
    type_relation?: boolean | Creature$type_relationArgs<ExtArgs>
    size_relation?: boolean | Creature$size_relationArgs<ExtArgs>
    source_relation?: boolean | Creature$source_relationArgs<ExtArgs>
  }, ExtArgs["result"]["creature"]>

  export type CreatureSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    creator_id?: boolean
    description?: boolean
    size?: boolean
    race_id?: boolean
    type_id?: boolean
    source_id?: boolean
    alignment_id?: boolean
    armor_class?: boolean
    hit_points?: boolean
    challenge_rating?: boolean
    challenge_rating_meta?: boolean | ChallengeRatingMetadataDefaultArgs<ExtArgs>
    alignment_relation?: boolean | Creature$alignment_relationArgs<ExtArgs>
    race_relation?: boolean | Creature$race_relationArgs<ExtArgs>
    type_relation?: boolean | Creature$type_relationArgs<ExtArgs>
    size_relation?: boolean | Creature$size_relationArgs<ExtArgs>
    source_relation?: boolean | Creature$source_relationArgs<ExtArgs>
  }, ExtArgs["result"]["creature"]>

  export type CreatureSelectScalar = {
    id?: boolean
    name?: boolean
    creator_id?: boolean
    description?: boolean
    size?: boolean
    race_id?: boolean
    type_id?: boolean
    source_id?: boolean
    alignment_id?: boolean
    armor_class?: boolean
    hit_points?: boolean
    challenge_rating?: boolean
  }

  export type CreatureOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "creator_id" | "description" | "size" | "race_id" | "type_id" | "source_id" | "alignment_id" | "armor_class" | "hit_points" | "challenge_rating", ExtArgs["result"]["creature"]>
  export type CreatureInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    speed?: boolean | Creature$speedArgs<ExtArgs>
    stats?: boolean | Creature$statsArgs<ExtArgs>
    skills?: boolean | Creature$skillsArgs<ExtArgs>
    senses?: boolean | Creature$sensesArgs<ExtArgs>
    challenge_rating_meta?: boolean | ChallengeRatingMetadataDefaultArgs<ExtArgs>
    alignment_relation?: boolean | Creature$alignment_relationArgs<ExtArgs>
    race_relation?: boolean | Creature$race_relationArgs<ExtArgs>
    type_relation?: boolean | Creature$type_relationArgs<ExtArgs>
    size_relation?: boolean | Creature$size_relationArgs<ExtArgs>
    source_relation?: boolean | Creature$source_relationArgs<ExtArgs>
    resistances?: boolean | Creature$resistancesArgs<ExtArgs>
    immunities?: boolean | Creature$immunitiesArgs<ExtArgs>
    vulnerabilities?: boolean | Creature$vulnerabilitiesArgs<ExtArgs>
    languages_relation?: boolean | Creature$languages_relationArgs<ExtArgs>
    biomes_relation?: boolean | Creature$biomes_relationArgs<ExtArgs>
    actions_relation?: boolean | Creature$actions_relationArgs<ExtArgs>
    traits_relation?: boolean | Creature$traits_relationArgs<ExtArgs>
    _count?: boolean | CreatureCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CreatureIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    challenge_rating_meta?: boolean | ChallengeRatingMetadataDefaultArgs<ExtArgs>
    alignment_relation?: boolean | Creature$alignment_relationArgs<ExtArgs>
    race_relation?: boolean | Creature$race_relationArgs<ExtArgs>
    type_relation?: boolean | Creature$type_relationArgs<ExtArgs>
    size_relation?: boolean | Creature$size_relationArgs<ExtArgs>
    source_relation?: boolean | Creature$source_relationArgs<ExtArgs>
  }
  export type CreatureIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    challenge_rating_meta?: boolean | ChallengeRatingMetadataDefaultArgs<ExtArgs>
    alignment_relation?: boolean | Creature$alignment_relationArgs<ExtArgs>
    race_relation?: boolean | Creature$race_relationArgs<ExtArgs>
    type_relation?: boolean | Creature$type_relationArgs<ExtArgs>
    size_relation?: boolean | Creature$size_relationArgs<ExtArgs>
    source_relation?: boolean | Creature$source_relationArgs<ExtArgs>
  }

  export type $CreaturePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Creature"
    objects: {
      speed: Prisma.$CreatureSpeedPayload<ExtArgs> | null
      stats: Prisma.$CreatureStatsPayload<ExtArgs> | null
      skills: Prisma.$CreatureSkillsPayload<ExtArgs> | null
      senses: Prisma.$CreatureSensesPayload<ExtArgs> | null
      challenge_rating_meta: Prisma.$ChallengeRatingMetadataPayload<ExtArgs>
      alignment_relation: Prisma.$AlignmentPayload<ExtArgs> | null
      race_relation: Prisma.$CreatureRacePayload<ExtArgs> | null
      type_relation: Prisma.$TypePayload<ExtArgs> | null
      size_relation: Prisma.$SizePayload<ExtArgs> | null
      source_relation: Prisma.$SourcePayload<ExtArgs> | null
      resistances: Prisma.$DamageTypePayload<ExtArgs>[]
      immunities: Prisma.$DamageTypePayload<ExtArgs>[]
      vulnerabilities: Prisma.$DamageTypePayload<ExtArgs>[]
      languages_relation: Prisma.$LanguagePayload<ExtArgs>[]
      biomes_relation: Prisma.$BiomePayload<ExtArgs>[]
      actions_relation: Prisma.$ActionPayload<ExtArgs>[]
      traits_relation: Prisma.$TraitPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      creator_id: string | null
      description: string | null
      size: string | null
      race_id: number | null
      type_id: number | null
      source_id: number | null
      alignment_id: number | null
      armor_class: number | null
      hit_points: number | null
      challenge_rating: string
    }, ExtArgs["result"]["creature"]>
    composites: {}
  }

  type CreatureGetPayload<S extends boolean | null | undefined | CreatureDefaultArgs> = $Result.GetResult<Prisma.$CreaturePayload, S>

  type CreatureCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CreatureFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CreatureCountAggregateInputType | true
    }

  export interface CreatureDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Creature'], meta: { name: 'Creature' } }
    /**
     * Find zero or one Creature that matches the filter.
     * @param {CreatureFindUniqueArgs} args - Arguments to find a Creature
     * @example
     * // Get one Creature
     * const creature = await prisma.creature.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CreatureFindUniqueArgs>(args: SelectSubset<T, CreatureFindUniqueArgs<ExtArgs>>): Prisma__CreatureClient<$Result.GetResult<Prisma.$CreaturePayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Creature that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CreatureFindUniqueOrThrowArgs} args - Arguments to find a Creature
     * @example
     * // Get one Creature
     * const creature = await prisma.creature.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CreatureFindUniqueOrThrowArgs>(args: SelectSubset<T, CreatureFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CreatureClient<$Result.GetResult<Prisma.$CreaturePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Creature that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreatureFindFirstArgs} args - Arguments to find a Creature
     * @example
     * // Get one Creature
     * const creature = await prisma.creature.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CreatureFindFirstArgs>(args?: SelectSubset<T, CreatureFindFirstArgs<ExtArgs>>): Prisma__CreatureClient<$Result.GetResult<Prisma.$CreaturePayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Creature that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreatureFindFirstOrThrowArgs} args - Arguments to find a Creature
     * @example
     * // Get one Creature
     * const creature = await prisma.creature.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CreatureFindFirstOrThrowArgs>(args?: SelectSubset<T, CreatureFindFirstOrThrowArgs<ExtArgs>>): Prisma__CreatureClient<$Result.GetResult<Prisma.$CreaturePayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Creatures that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreatureFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Creatures
     * const creatures = await prisma.creature.findMany()
     * 
     * // Get first 10 Creatures
     * const creatures = await prisma.creature.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const creatureWithIdOnly = await prisma.creature.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CreatureFindManyArgs>(args?: SelectSubset<T, CreatureFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CreaturePayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Creature.
     * @param {CreatureCreateArgs} args - Arguments to create a Creature.
     * @example
     * // Create one Creature
     * const Creature = await prisma.creature.create({
     *   data: {
     *     // ... data to create a Creature
     *   }
     * })
     * 
     */
    create<T extends CreatureCreateArgs>(args: SelectSubset<T, CreatureCreateArgs<ExtArgs>>): Prisma__CreatureClient<$Result.GetResult<Prisma.$CreaturePayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Creatures.
     * @param {CreatureCreateManyArgs} args - Arguments to create many Creatures.
     * @example
     * // Create many Creatures
     * const creature = await prisma.creature.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CreatureCreateManyArgs>(args?: SelectSubset<T, CreatureCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Creatures and returns the data saved in the database.
     * @param {CreatureCreateManyAndReturnArgs} args - Arguments to create many Creatures.
     * @example
     * // Create many Creatures
     * const creature = await prisma.creature.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Creatures and only return the `id`
     * const creatureWithIdOnly = await prisma.creature.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CreatureCreateManyAndReturnArgs>(args?: SelectSubset<T, CreatureCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CreaturePayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Creature.
     * @param {CreatureDeleteArgs} args - Arguments to delete one Creature.
     * @example
     * // Delete one Creature
     * const Creature = await prisma.creature.delete({
     *   where: {
     *     // ... filter to delete one Creature
     *   }
     * })
     * 
     */
    delete<T extends CreatureDeleteArgs>(args: SelectSubset<T, CreatureDeleteArgs<ExtArgs>>): Prisma__CreatureClient<$Result.GetResult<Prisma.$CreaturePayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Creature.
     * @param {CreatureUpdateArgs} args - Arguments to update one Creature.
     * @example
     * // Update one Creature
     * const creature = await prisma.creature.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CreatureUpdateArgs>(args: SelectSubset<T, CreatureUpdateArgs<ExtArgs>>): Prisma__CreatureClient<$Result.GetResult<Prisma.$CreaturePayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Creatures.
     * @param {CreatureDeleteManyArgs} args - Arguments to filter Creatures to delete.
     * @example
     * // Delete a few Creatures
     * const { count } = await prisma.creature.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CreatureDeleteManyArgs>(args?: SelectSubset<T, CreatureDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Creatures.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreatureUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Creatures
     * const creature = await prisma.creature.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CreatureUpdateManyArgs>(args: SelectSubset<T, CreatureUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Creatures and returns the data updated in the database.
     * @param {CreatureUpdateManyAndReturnArgs} args - Arguments to update many Creatures.
     * @example
     * // Update many Creatures
     * const creature = await prisma.creature.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Creatures and only return the `id`
     * const creatureWithIdOnly = await prisma.creature.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CreatureUpdateManyAndReturnArgs>(args: SelectSubset<T, CreatureUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CreaturePayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Creature.
     * @param {CreatureUpsertArgs} args - Arguments to update or create a Creature.
     * @example
     * // Update or create a Creature
     * const creature = await prisma.creature.upsert({
     *   create: {
     *     // ... data to create a Creature
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Creature we want to update
     *   }
     * })
     */
    upsert<T extends CreatureUpsertArgs>(args: SelectSubset<T, CreatureUpsertArgs<ExtArgs>>): Prisma__CreatureClient<$Result.GetResult<Prisma.$CreaturePayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Creatures.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreatureCountArgs} args - Arguments to filter Creatures to count.
     * @example
     * // Count the number of Creatures
     * const count = await prisma.creature.count({
     *   where: {
     *     // ... the filter for the Creatures we want to count
     *   }
     * })
    **/
    count<T extends CreatureCountArgs>(
      args?: Subset<T, CreatureCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CreatureCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Creature.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreatureAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CreatureAggregateArgs>(args: Subset<T, CreatureAggregateArgs>): Prisma.PrismaPromise<GetCreatureAggregateType<T>>

    /**
     * Group by Creature.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreatureGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CreatureGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CreatureGroupByArgs['orderBy'] }
        : { orderBy?: CreatureGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CreatureGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCreatureGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Creature model
   */
  readonly fields: CreatureFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Creature.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CreatureClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    speed<T extends Creature$speedArgs<ExtArgs> = {}>(args?: Subset<T, Creature$speedArgs<ExtArgs>>): Prisma__CreatureSpeedClient<$Result.GetResult<Prisma.$CreatureSpeedPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | null, null, ExtArgs, ClientOptions>
    stats<T extends Creature$statsArgs<ExtArgs> = {}>(args?: Subset<T, Creature$statsArgs<ExtArgs>>): Prisma__CreatureStatsClient<$Result.GetResult<Prisma.$CreatureStatsPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | null, null, ExtArgs, ClientOptions>
    skills<T extends Creature$skillsArgs<ExtArgs> = {}>(args?: Subset<T, Creature$skillsArgs<ExtArgs>>): Prisma__CreatureSkillsClient<$Result.GetResult<Prisma.$CreatureSkillsPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | null, null, ExtArgs, ClientOptions>
    senses<T extends Creature$sensesArgs<ExtArgs> = {}>(args?: Subset<T, Creature$sensesArgs<ExtArgs>>): Prisma__CreatureSensesClient<$Result.GetResult<Prisma.$CreatureSensesPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | null, null, ExtArgs, ClientOptions>
    challenge_rating_meta<T extends ChallengeRatingMetadataDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ChallengeRatingMetadataDefaultArgs<ExtArgs>>): Prisma__ChallengeRatingMetadataClient<$Result.GetResult<Prisma.$ChallengeRatingMetadataPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    alignment_relation<T extends Creature$alignment_relationArgs<ExtArgs> = {}>(args?: Subset<T, Creature$alignment_relationArgs<ExtArgs>>): Prisma__AlignmentClient<$Result.GetResult<Prisma.$AlignmentPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | null, null, ExtArgs, ClientOptions>
    race_relation<T extends Creature$race_relationArgs<ExtArgs> = {}>(args?: Subset<T, Creature$race_relationArgs<ExtArgs>>): Prisma__CreatureRaceClient<$Result.GetResult<Prisma.$CreatureRacePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | null, null, ExtArgs, ClientOptions>
    type_relation<T extends Creature$type_relationArgs<ExtArgs> = {}>(args?: Subset<T, Creature$type_relationArgs<ExtArgs>>): Prisma__TypeClient<$Result.GetResult<Prisma.$TypePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | null, null, ExtArgs, ClientOptions>
    size_relation<T extends Creature$size_relationArgs<ExtArgs> = {}>(args?: Subset<T, Creature$size_relationArgs<ExtArgs>>): Prisma__SizeClient<$Result.GetResult<Prisma.$SizePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | null, null, ExtArgs, ClientOptions>
    source_relation<T extends Creature$source_relationArgs<ExtArgs> = {}>(args?: Subset<T, Creature$source_relationArgs<ExtArgs>>): Prisma__SourceClient<$Result.GetResult<Prisma.$SourcePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | null, null, ExtArgs, ClientOptions>
    resistances<T extends Creature$resistancesArgs<ExtArgs> = {}>(args?: Subset<T, Creature$resistancesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DamageTypePayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    immunities<T extends Creature$immunitiesArgs<ExtArgs> = {}>(args?: Subset<T, Creature$immunitiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DamageTypePayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    vulnerabilities<T extends Creature$vulnerabilitiesArgs<ExtArgs> = {}>(args?: Subset<T, Creature$vulnerabilitiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DamageTypePayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    languages_relation<T extends Creature$languages_relationArgs<ExtArgs> = {}>(args?: Subset<T, Creature$languages_relationArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LanguagePayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    biomes_relation<T extends Creature$biomes_relationArgs<ExtArgs> = {}>(args?: Subset<T, Creature$biomes_relationArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BiomePayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    actions_relation<T extends Creature$actions_relationArgs<ExtArgs> = {}>(args?: Subset<T, Creature$actions_relationArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActionPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    traits_relation<T extends Creature$traits_relationArgs<ExtArgs> = {}>(args?: Subset<T, Creature$traits_relationArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TraitPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Creature model
   */ 
  interface CreatureFieldRefs {
    readonly id: FieldRef<"Creature", 'String'>
    readonly name: FieldRef<"Creature", 'String'>
    readonly creator_id: FieldRef<"Creature", 'String'>
    readonly description: FieldRef<"Creature", 'String'>
    readonly size: FieldRef<"Creature", 'String'>
    readonly race_id: FieldRef<"Creature", 'Int'>
    readonly type_id: FieldRef<"Creature", 'Int'>
    readonly source_id: FieldRef<"Creature", 'Int'>
    readonly alignment_id: FieldRef<"Creature", 'Int'>
    readonly armor_class: FieldRef<"Creature", 'Int'>
    readonly hit_points: FieldRef<"Creature", 'Int'>
    readonly challenge_rating: FieldRef<"Creature", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Creature findUnique
   */
  export type CreatureFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Creature
     */
    select?: CreatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Creature
     */
    omit?: CreatureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreatureInclude<ExtArgs> | null
    /**
     * Filter, which Creature to fetch.
     */
    where: CreatureWhereUniqueInput
  }

  /**
   * Creature findUniqueOrThrow
   */
  export type CreatureFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Creature
     */
    select?: CreatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Creature
     */
    omit?: CreatureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreatureInclude<ExtArgs> | null
    /**
     * Filter, which Creature to fetch.
     */
    where: CreatureWhereUniqueInput
  }

  /**
   * Creature findFirst
   */
  export type CreatureFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Creature
     */
    select?: CreatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Creature
     */
    omit?: CreatureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreatureInclude<ExtArgs> | null
    /**
     * Filter, which Creature to fetch.
     */
    where?: CreatureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Creatures to fetch.
     */
    orderBy?: CreatureOrderByWithRelationInput | CreatureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Creatures.
     */
    cursor?: CreatureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Creatures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Creatures.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Creatures.
     */
    distinct?: CreatureScalarFieldEnum | CreatureScalarFieldEnum[]
  }

  /**
   * Creature findFirstOrThrow
   */
  export type CreatureFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Creature
     */
    select?: CreatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Creature
     */
    omit?: CreatureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreatureInclude<ExtArgs> | null
    /**
     * Filter, which Creature to fetch.
     */
    where?: CreatureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Creatures to fetch.
     */
    orderBy?: CreatureOrderByWithRelationInput | CreatureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Creatures.
     */
    cursor?: CreatureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Creatures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Creatures.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Creatures.
     */
    distinct?: CreatureScalarFieldEnum | CreatureScalarFieldEnum[]
  }

  /**
   * Creature findMany
   */
  export type CreatureFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Creature
     */
    select?: CreatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Creature
     */
    omit?: CreatureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreatureInclude<ExtArgs> | null
    /**
     * Filter, which Creatures to fetch.
     */
    where?: CreatureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Creatures to fetch.
     */
    orderBy?: CreatureOrderByWithRelationInput | CreatureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Creatures.
     */
    cursor?: CreatureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Creatures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Creatures.
     */
    skip?: number
    distinct?: CreatureScalarFieldEnum | CreatureScalarFieldEnum[]
  }

  /**
   * Creature create
   */
  export type CreatureCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Creature
     */
    select?: CreatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Creature
     */
    omit?: CreatureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreatureInclude<ExtArgs> | null
    /**
     * The data needed to create a Creature.
     */
    data: XOR<CreatureCreateInput, CreatureUncheckedCreateInput>
  }

  /**
   * Creature createMany
   */
  export type CreatureCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Creatures.
     */
    data: CreatureCreateManyInput | CreatureCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Creature createManyAndReturn
   */
  export type CreatureCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Creature
     */
    select?: CreatureSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Creature
     */
    omit?: CreatureOmit<ExtArgs> | null
    /**
     * The data used to create many Creatures.
     */
    data: CreatureCreateManyInput | CreatureCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreatureIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Creature update
   */
  export type CreatureUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Creature
     */
    select?: CreatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Creature
     */
    omit?: CreatureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreatureInclude<ExtArgs> | null
    /**
     * The data needed to update a Creature.
     */
    data: XOR<CreatureUpdateInput, CreatureUncheckedUpdateInput>
    /**
     * Choose, which Creature to update.
     */
    where: CreatureWhereUniqueInput
  }

  /**
   * Creature updateMany
   */
  export type CreatureUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Creatures.
     */
    data: XOR<CreatureUpdateManyMutationInput, CreatureUncheckedUpdateManyInput>
    /**
     * Filter which Creatures to update
     */
    where?: CreatureWhereInput
    /**
     * Limit how many Creatures to update.
     */
    limit?: number
  }

  /**
   * Creature updateManyAndReturn
   */
  export type CreatureUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Creature
     */
    select?: CreatureSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Creature
     */
    omit?: CreatureOmit<ExtArgs> | null
    /**
     * The data used to update Creatures.
     */
    data: XOR<CreatureUpdateManyMutationInput, CreatureUncheckedUpdateManyInput>
    /**
     * Filter which Creatures to update
     */
    where?: CreatureWhereInput
    /**
     * Limit how many Creatures to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreatureIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Creature upsert
   */
  export type CreatureUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Creature
     */
    select?: CreatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Creature
     */
    omit?: CreatureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreatureInclude<ExtArgs> | null
    /**
     * The filter to search for the Creature to update in case it exists.
     */
    where: CreatureWhereUniqueInput
    /**
     * In case the Creature found by the `where` argument doesn't exist, create a new Creature with this data.
     */
    create: XOR<CreatureCreateInput, CreatureUncheckedCreateInput>
    /**
     * In case the Creature was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CreatureUpdateInput, CreatureUncheckedUpdateInput>
  }

  /**
   * Creature delete
   */
  export type CreatureDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Creature
     */
    select?: CreatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Creature
     */
    omit?: CreatureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreatureInclude<ExtArgs> | null
    /**
     * Filter which Creature to delete.
     */
    where: CreatureWhereUniqueInput
  }

  /**
   * Creature deleteMany
   */
  export type CreatureDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Creatures to delete
     */
    where?: CreatureWhereInput
    /**
     * Limit how many Creatures to delete.
     */
    limit?: number
  }

  /**
   * Creature.speed
   */
  export type Creature$speedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreatureSpeed
     */
    select?: CreatureSpeedSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CreatureSpeed
     */
    omit?: CreatureSpeedOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreatureSpeedInclude<ExtArgs> | null
    where?: CreatureSpeedWhereInput
  }

  /**
   * Creature.stats
   */
  export type Creature$statsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreatureStats
     */
    select?: CreatureStatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CreatureStats
     */
    omit?: CreatureStatsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreatureStatsInclude<ExtArgs> | null
    where?: CreatureStatsWhereInput
  }

  /**
   * Creature.skills
   */
  export type Creature$skillsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreatureSkills
     */
    select?: CreatureSkillsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CreatureSkills
     */
    omit?: CreatureSkillsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreatureSkillsInclude<ExtArgs> | null
    where?: CreatureSkillsWhereInput
  }

  /**
   * Creature.senses
   */
  export type Creature$sensesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreatureSenses
     */
    select?: CreatureSensesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CreatureSenses
     */
    omit?: CreatureSensesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreatureSensesInclude<ExtArgs> | null
    where?: CreatureSensesWhereInput
  }

  /**
   * Creature.alignment_relation
   */
  export type Creature$alignment_relationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alignment
     */
    select?: AlignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Alignment
     */
    omit?: AlignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlignmentInclude<ExtArgs> | null
    where?: AlignmentWhereInput
  }

  /**
   * Creature.race_relation
   */
  export type Creature$race_relationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreatureRace
     */
    select?: CreatureRaceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CreatureRace
     */
    omit?: CreatureRaceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreatureRaceInclude<ExtArgs> | null
    where?: CreatureRaceWhereInput
  }

  /**
   * Creature.type_relation
   */
  export type Creature$type_relationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Type
     */
    select?: TypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Type
     */
    omit?: TypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TypeInclude<ExtArgs> | null
    where?: TypeWhereInput
  }

  /**
   * Creature.size_relation
   */
  export type Creature$size_relationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Size
     */
    select?: SizeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Size
     */
    omit?: SizeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SizeInclude<ExtArgs> | null
    where?: SizeWhereInput
  }

  /**
   * Creature.source_relation
   */
  export type Creature$source_relationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Source
     */
    select?: SourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Source
     */
    omit?: SourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SourceInclude<ExtArgs> | null
    where?: SourceWhereInput
  }

  /**
   * Creature.resistances
   */
  export type Creature$resistancesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DamageType
     */
    select?: DamageTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DamageType
     */
    omit?: DamageTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DamageTypeInclude<ExtArgs> | null
    where?: DamageTypeWhereInput
    orderBy?: DamageTypeOrderByWithRelationInput | DamageTypeOrderByWithRelationInput[]
    cursor?: DamageTypeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DamageTypeScalarFieldEnum | DamageTypeScalarFieldEnum[]
  }

  /**
   * Creature.immunities
   */
  export type Creature$immunitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DamageType
     */
    select?: DamageTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DamageType
     */
    omit?: DamageTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DamageTypeInclude<ExtArgs> | null
    where?: DamageTypeWhereInput
    orderBy?: DamageTypeOrderByWithRelationInput | DamageTypeOrderByWithRelationInput[]
    cursor?: DamageTypeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DamageTypeScalarFieldEnum | DamageTypeScalarFieldEnum[]
  }

  /**
   * Creature.vulnerabilities
   */
  export type Creature$vulnerabilitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DamageType
     */
    select?: DamageTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DamageType
     */
    omit?: DamageTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DamageTypeInclude<ExtArgs> | null
    where?: DamageTypeWhereInput
    orderBy?: DamageTypeOrderByWithRelationInput | DamageTypeOrderByWithRelationInput[]
    cursor?: DamageTypeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DamageTypeScalarFieldEnum | DamageTypeScalarFieldEnum[]
  }

  /**
   * Creature.languages_relation
   */
  export type Creature$languages_relationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Language
     */
    select?: LanguageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Language
     */
    omit?: LanguageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LanguageInclude<ExtArgs> | null
    where?: LanguageWhereInput
    orderBy?: LanguageOrderByWithRelationInput | LanguageOrderByWithRelationInput[]
    cursor?: LanguageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LanguageScalarFieldEnum | LanguageScalarFieldEnum[]
  }

  /**
   * Creature.biomes_relation
   */
  export type Creature$biomes_relationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Biome
     */
    select?: BiomeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Biome
     */
    omit?: BiomeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BiomeInclude<ExtArgs> | null
    where?: BiomeWhereInput
    orderBy?: BiomeOrderByWithRelationInput | BiomeOrderByWithRelationInput[]
    cursor?: BiomeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BiomeScalarFieldEnum | BiomeScalarFieldEnum[]
  }

  /**
   * Creature.actions_relation
   */
  export type Creature$actions_relationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Action
     */
    select?: ActionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Action
     */
    omit?: ActionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActionInclude<ExtArgs> | null
    where?: ActionWhereInput
    orderBy?: ActionOrderByWithRelationInput | ActionOrderByWithRelationInput[]
    cursor?: ActionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ActionScalarFieldEnum | ActionScalarFieldEnum[]
  }

  /**
   * Creature.traits_relation
   */
  export type Creature$traits_relationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Trait
     */
    select?: TraitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Trait
     */
    omit?: TraitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TraitInclude<ExtArgs> | null
    where?: TraitWhereInput
    orderBy?: TraitOrderByWithRelationInput | TraitOrderByWithRelationInput[]
    cursor?: TraitWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TraitScalarFieldEnum | TraitScalarFieldEnum[]
  }

  /**
   * Creature without action
   */
  export type CreatureDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Creature
     */
    select?: CreatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Creature
     */
    omit?: CreatureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreatureInclude<ExtArgs> | null
  }


  /**
   * Model CreatureSenses
   */

  export type AggregateCreatureSenses = {
    _count: CreatureSensesCountAggregateOutputType | null
    _avg: CreatureSensesAvgAggregateOutputType | null
    _sum: CreatureSensesSumAggregateOutputType | null
    _min: CreatureSensesMinAggregateOutputType | null
    _max: CreatureSensesMaxAggregateOutputType | null
  }

  export type CreatureSensesAvgAggregateOutputType = {
    passive_perception: number | null
  }

  export type CreatureSensesSumAggregateOutputType = {
    passive_perception: number | null
  }

  export type CreatureSensesMinAggregateOutputType = {
    id: string | null
    creature_id: string | null
    passive_perception: number | null
  }

  export type CreatureSensesMaxAggregateOutputType = {
    id: string | null
    creature_id: string | null
    passive_perception: number | null
  }

  export type CreatureSensesCountAggregateOutputType = {
    id: number
    creature_id: number
    passive_perception: number
    _all: number
  }


  export type CreatureSensesAvgAggregateInputType = {
    passive_perception?: true
  }

  export type CreatureSensesSumAggregateInputType = {
    passive_perception?: true
  }

  export type CreatureSensesMinAggregateInputType = {
    id?: true
    creature_id?: true
    passive_perception?: true
  }

  export type CreatureSensesMaxAggregateInputType = {
    id?: true
    creature_id?: true
    passive_perception?: true
  }

  export type CreatureSensesCountAggregateInputType = {
    id?: true
    creature_id?: true
    passive_perception?: true
    _all?: true
  }

  export type CreatureSensesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CreatureSenses to aggregate.
     */
    where?: CreatureSensesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CreatureSenses to fetch.
     */
    orderBy?: CreatureSensesOrderByWithRelationInput | CreatureSensesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CreatureSensesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CreatureSenses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CreatureSenses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CreatureSenses
    **/
    _count?: true | CreatureSensesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CreatureSensesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CreatureSensesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CreatureSensesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CreatureSensesMaxAggregateInputType
  }

  export type GetCreatureSensesAggregateType<T extends CreatureSensesAggregateArgs> = {
        [P in keyof T & keyof AggregateCreatureSenses]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCreatureSenses[P]>
      : GetScalarType<T[P], AggregateCreatureSenses[P]>
  }




  export type CreatureSensesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CreatureSensesWhereInput
    orderBy?: CreatureSensesOrderByWithAggregationInput | CreatureSensesOrderByWithAggregationInput[]
    by: CreatureSensesScalarFieldEnum[] | CreatureSensesScalarFieldEnum
    having?: CreatureSensesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CreatureSensesCountAggregateInputType | true
    _avg?: CreatureSensesAvgAggregateInputType
    _sum?: CreatureSensesSumAggregateInputType
    _min?: CreatureSensesMinAggregateInputType
    _max?: CreatureSensesMaxAggregateInputType
  }

  export type CreatureSensesGroupByOutputType = {
    id: string
    creature_id: string
    passive_perception: number | null
    _count: CreatureSensesCountAggregateOutputType | null
    _avg: CreatureSensesAvgAggregateOutputType | null
    _sum: CreatureSensesSumAggregateOutputType | null
    _min: CreatureSensesMinAggregateOutputType | null
    _max: CreatureSensesMaxAggregateOutputType | null
  }

  type GetCreatureSensesGroupByPayload<T extends CreatureSensesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CreatureSensesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CreatureSensesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CreatureSensesGroupByOutputType[P]>
            : GetScalarType<T[P], CreatureSensesGroupByOutputType[P]>
        }
      >
    >


  export type CreatureSensesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    creature_id?: boolean
    passive_perception?: boolean
    creature_relation?: boolean | CreatureDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["creatureSenses"]>

  export type CreatureSensesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    creature_id?: boolean
    passive_perception?: boolean
    creature_relation?: boolean | CreatureDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["creatureSenses"]>

  export type CreatureSensesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    creature_id?: boolean
    passive_perception?: boolean
    creature_relation?: boolean | CreatureDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["creatureSenses"]>

  export type CreatureSensesSelectScalar = {
    id?: boolean
    creature_id?: boolean
    passive_perception?: boolean
  }

  export type CreatureSensesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "creature_id" | "passive_perception", ExtArgs["result"]["creatureSenses"]>
  export type CreatureSensesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creature_relation?: boolean | CreatureDefaultArgs<ExtArgs>
  }
  export type CreatureSensesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creature_relation?: boolean | CreatureDefaultArgs<ExtArgs>
  }
  export type CreatureSensesIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creature_relation?: boolean | CreatureDefaultArgs<ExtArgs>
  }

  export type $CreatureSensesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CreatureSenses"
    objects: {
      creature_relation: Prisma.$CreaturePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      creature_id: string
      passive_perception: number | null
    }, ExtArgs["result"]["creatureSenses"]>
    composites: {}
  }

  type CreatureSensesGetPayload<S extends boolean | null | undefined | CreatureSensesDefaultArgs> = $Result.GetResult<Prisma.$CreatureSensesPayload, S>

  type CreatureSensesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CreatureSensesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CreatureSensesCountAggregateInputType | true
    }

  export interface CreatureSensesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CreatureSenses'], meta: { name: 'CreatureSenses' } }
    /**
     * Find zero or one CreatureSenses that matches the filter.
     * @param {CreatureSensesFindUniqueArgs} args - Arguments to find a CreatureSenses
     * @example
     * // Get one CreatureSenses
     * const creatureSenses = await prisma.creatureSenses.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CreatureSensesFindUniqueArgs>(args: SelectSubset<T, CreatureSensesFindUniqueArgs<ExtArgs>>): Prisma__CreatureSensesClient<$Result.GetResult<Prisma.$CreatureSensesPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one CreatureSenses that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CreatureSensesFindUniqueOrThrowArgs} args - Arguments to find a CreatureSenses
     * @example
     * // Get one CreatureSenses
     * const creatureSenses = await prisma.creatureSenses.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CreatureSensesFindUniqueOrThrowArgs>(args: SelectSubset<T, CreatureSensesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CreatureSensesClient<$Result.GetResult<Prisma.$CreatureSensesPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first CreatureSenses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreatureSensesFindFirstArgs} args - Arguments to find a CreatureSenses
     * @example
     * // Get one CreatureSenses
     * const creatureSenses = await prisma.creatureSenses.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CreatureSensesFindFirstArgs>(args?: SelectSubset<T, CreatureSensesFindFirstArgs<ExtArgs>>): Prisma__CreatureSensesClient<$Result.GetResult<Prisma.$CreatureSensesPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first CreatureSenses that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreatureSensesFindFirstOrThrowArgs} args - Arguments to find a CreatureSenses
     * @example
     * // Get one CreatureSenses
     * const creatureSenses = await prisma.creatureSenses.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CreatureSensesFindFirstOrThrowArgs>(args?: SelectSubset<T, CreatureSensesFindFirstOrThrowArgs<ExtArgs>>): Prisma__CreatureSensesClient<$Result.GetResult<Prisma.$CreatureSensesPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more CreatureSenses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreatureSensesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CreatureSenses
     * const creatureSenses = await prisma.creatureSenses.findMany()
     * 
     * // Get first 10 CreatureSenses
     * const creatureSenses = await prisma.creatureSenses.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const creatureSensesWithIdOnly = await prisma.creatureSenses.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CreatureSensesFindManyArgs>(args?: SelectSubset<T, CreatureSensesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CreatureSensesPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a CreatureSenses.
     * @param {CreatureSensesCreateArgs} args - Arguments to create a CreatureSenses.
     * @example
     * // Create one CreatureSenses
     * const CreatureSenses = await prisma.creatureSenses.create({
     *   data: {
     *     // ... data to create a CreatureSenses
     *   }
     * })
     * 
     */
    create<T extends CreatureSensesCreateArgs>(args: SelectSubset<T, CreatureSensesCreateArgs<ExtArgs>>): Prisma__CreatureSensesClient<$Result.GetResult<Prisma.$CreatureSensesPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many CreatureSenses.
     * @param {CreatureSensesCreateManyArgs} args - Arguments to create many CreatureSenses.
     * @example
     * // Create many CreatureSenses
     * const creatureSenses = await prisma.creatureSenses.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CreatureSensesCreateManyArgs>(args?: SelectSubset<T, CreatureSensesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CreatureSenses and returns the data saved in the database.
     * @param {CreatureSensesCreateManyAndReturnArgs} args - Arguments to create many CreatureSenses.
     * @example
     * // Create many CreatureSenses
     * const creatureSenses = await prisma.creatureSenses.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CreatureSenses and only return the `id`
     * const creatureSensesWithIdOnly = await prisma.creatureSenses.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CreatureSensesCreateManyAndReturnArgs>(args?: SelectSubset<T, CreatureSensesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CreatureSensesPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a CreatureSenses.
     * @param {CreatureSensesDeleteArgs} args - Arguments to delete one CreatureSenses.
     * @example
     * // Delete one CreatureSenses
     * const CreatureSenses = await prisma.creatureSenses.delete({
     *   where: {
     *     // ... filter to delete one CreatureSenses
     *   }
     * })
     * 
     */
    delete<T extends CreatureSensesDeleteArgs>(args: SelectSubset<T, CreatureSensesDeleteArgs<ExtArgs>>): Prisma__CreatureSensesClient<$Result.GetResult<Prisma.$CreatureSensesPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one CreatureSenses.
     * @param {CreatureSensesUpdateArgs} args - Arguments to update one CreatureSenses.
     * @example
     * // Update one CreatureSenses
     * const creatureSenses = await prisma.creatureSenses.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CreatureSensesUpdateArgs>(args: SelectSubset<T, CreatureSensesUpdateArgs<ExtArgs>>): Prisma__CreatureSensesClient<$Result.GetResult<Prisma.$CreatureSensesPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more CreatureSenses.
     * @param {CreatureSensesDeleteManyArgs} args - Arguments to filter CreatureSenses to delete.
     * @example
     * // Delete a few CreatureSenses
     * const { count } = await prisma.creatureSenses.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CreatureSensesDeleteManyArgs>(args?: SelectSubset<T, CreatureSensesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CreatureSenses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreatureSensesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CreatureSenses
     * const creatureSenses = await prisma.creatureSenses.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CreatureSensesUpdateManyArgs>(args: SelectSubset<T, CreatureSensesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CreatureSenses and returns the data updated in the database.
     * @param {CreatureSensesUpdateManyAndReturnArgs} args - Arguments to update many CreatureSenses.
     * @example
     * // Update many CreatureSenses
     * const creatureSenses = await prisma.creatureSenses.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CreatureSenses and only return the `id`
     * const creatureSensesWithIdOnly = await prisma.creatureSenses.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CreatureSensesUpdateManyAndReturnArgs>(args: SelectSubset<T, CreatureSensesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CreatureSensesPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one CreatureSenses.
     * @param {CreatureSensesUpsertArgs} args - Arguments to update or create a CreatureSenses.
     * @example
     * // Update or create a CreatureSenses
     * const creatureSenses = await prisma.creatureSenses.upsert({
     *   create: {
     *     // ... data to create a CreatureSenses
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CreatureSenses we want to update
     *   }
     * })
     */
    upsert<T extends CreatureSensesUpsertArgs>(args: SelectSubset<T, CreatureSensesUpsertArgs<ExtArgs>>): Prisma__CreatureSensesClient<$Result.GetResult<Prisma.$CreatureSensesPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of CreatureSenses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreatureSensesCountArgs} args - Arguments to filter CreatureSenses to count.
     * @example
     * // Count the number of CreatureSenses
     * const count = await prisma.creatureSenses.count({
     *   where: {
     *     // ... the filter for the CreatureSenses we want to count
     *   }
     * })
    **/
    count<T extends CreatureSensesCountArgs>(
      args?: Subset<T, CreatureSensesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CreatureSensesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CreatureSenses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreatureSensesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CreatureSensesAggregateArgs>(args: Subset<T, CreatureSensesAggregateArgs>): Prisma.PrismaPromise<GetCreatureSensesAggregateType<T>>

    /**
     * Group by CreatureSenses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreatureSensesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CreatureSensesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CreatureSensesGroupByArgs['orderBy'] }
        : { orderBy?: CreatureSensesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CreatureSensesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCreatureSensesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CreatureSenses model
   */
  readonly fields: CreatureSensesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CreatureSenses.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CreatureSensesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    creature_relation<T extends CreatureDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CreatureDefaultArgs<ExtArgs>>): Prisma__CreatureClient<$Result.GetResult<Prisma.$CreaturePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CreatureSenses model
   */ 
  interface CreatureSensesFieldRefs {
    readonly id: FieldRef<"CreatureSenses", 'String'>
    readonly creature_id: FieldRef<"CreatureSenses", 'String'>
    readonly passive_perception: FieldRef<"CreatureSenses", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * CreatureSenses findUnique
   */
  export type CreatureSensesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreatureSenses
     */
    select?: CreatureSensesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CreatureSenses
     */
    omit?: CreatureSensesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreatureSensesInclude<ExtArgs> | null
    /**
     * Filter, which CreatureSenses to fetch.
     */
    where: CreatureSensesWhereUniqueInput
  }

  /**
   * CreatureSenses findUniqueOrThrow
   */
  export type CreatureSensesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreatureSenses
     */
    select?: CreatureSensesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CreatureSenses
     */
    omit?: CreatureSensesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreatureSensesInclude<ExtArgs> | null
    /**
     * Filter, which CreatureSenses to fetch.
     */
    where: CreatureSensesWhereUniqueInput
  }

  /**
   * CreatureSenses findFirst
   */
  export type CreatureSensesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreatureSenses
     */
    select?: CreatureSensesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CreatureSenses
     */
    omit?: CreatureSensesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreatureSensesInclude<ExtArgs> | null
    /**
     * Filter, which CreatureSenses to fetch.
     */
    where?: CreatureSensesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CreatureSenses to fetch.
     */
    orderBy?: CreatureSensesOrderByWithRelationInput | CreatureSensesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CreatureSenses.
     */
    cursor?: CreatureSensesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CreatureSenses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CreatureSenses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CreatureSenses.
     */
    distinct?: CreatureSensesScalarFieldEnum | CreatureSensesScalarFieldEnum[]
  }

  /**
   * CreatureSenses findFirstOrThrow
   */
  export type CreatureSensesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreatureSenses
     */
    select?: CreatureSensesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CreatureSenses
     */
    omit?: CreatureSensesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreatureSensesInclude<ExtArgs> | null
    /**
     * Filter, which CreatureSenses to fetch.
     */
    where?: CreatureSensesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CreatureSenses to fetch.
     */
    orderBy?: CreatureSensesOrderByWithRelationInput | CreatureSensesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CreatureSenses.
     */
    cursor?: CreatureSensesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CreatureSenses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CreatureSenses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CreatureSenses.
     */
    distinct?: CreatureSensesScalarFieldEnum | CreatureSensesScalarFieldEnum[]
  }

  /**
   * CreatureSenses findMany
   */
  export type CreatureSensesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreatureSenses
     */
    select?: CreatureSensesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CreatureSenses
     */
    omit?: CreatureSensesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreatureSensesInclude<ExtArgs> | null
    /**
     * Filter, which CreatureSenses to fetch.
     */
    where?: CreatureSensesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CreatureSenses to fetch.
     */
    orderBy?: CreatureSensesOrderByWithRelationInput | CreatureSensesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CreatureSenses.
     */
    cursor?: CreatureSensesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CreatureSenses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CreatureSenses.
     */
    skip?: number
    distinct?: CreatureSensesScalarFieldEnum | CreatureSensesScalarFieldEnum[]
  }

  /**
   * CreatureSenses create
   */
  export type CreatureSensesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreatureSenses
     */
    select?: CreatureSensesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CreatureSenses
     */
    omit?: CreatureSensesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreatureSensesInclude<ExtArgs> | null
    /**
     * The data needed to create a CreatureSenses.
     */
    data: XOR<CreatureSensesCreateInput, CreatureSensesUncheckedCreateInput>
  }

  /**
   * CreatureSenses createMany
   */
  export type CreatureSensesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CreatureSenses.
     */
    data: CreatureSensesCreateManyInput | CreatureSensesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CreatureSenses createManyAndReturn
   */
  export type CreatureSensesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreatureSenses
     */
    select?: CreatureSensesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CreatureSenses
     */
    omit?: CreatureSensesOmit<ExtArgs> | null
    /**
     * The data used to create many CreatureSenses.
     */
    data: CreatureSensesCreateManyInput | CreatureSensesCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreatureSensesIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CreatureSenses update
   */
  export type CreatureSensesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreatureSenses
     */
    select?: CreatureSensesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CreatureSenses
     */
    omit?: CreatureSensesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreatureSensesInclude<ExtArgs> | null
    /**
     * The data needed to update a CreatureSenses.
     */
    data: XOR<CreatureSensesUpdateInput, CreatureSensesUncheckedUpdateInput>
    /**
     * Choose, which CreatureSenses to update.
     */
    where: CreatureSensesWhereUniqueInput
  }

  /**
   * CreatureSenses updateMany
   */
  export type CreatureSensesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CreatureSenses.
     */
    data: XOR<CreatureSensesUpdateManyMutationInput, CreatureSensesUncheckedUpdateManyInput>
    /**
     * Filter which CreatureSenses to update
     */
    where?: CreatureSensesWhereInput
    /**
     * Limit how many CreatureSenses to update.
     */
    limit?: number
  }

  /**
   * CreatureSenses updateManyAndReturn
   */
  export type CreatureSensesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreatureSenses
     */
    select?: CreatureSensesSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CreatureSenses
     */
    omit?: CreatureSensesOmit<ExtArgs> | null
    /**
     * The data used to update CreatureSenses.
     */
    data: XOR<CreatureSensesUpdateManyMutationInput, CreatureSensesUncheckedUpdateManyInput>
    /**
     * Filter which CreatureSenses to update
     */
    where?: CreatureSensesWhereInput
    /**
     * Limit how many CreatureSenses to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreatureSensesIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CreatureSenses upsert
   */
  export type CreatureSensesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreatureSenses
     */
    select?: CreatureSensesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CreatureSenses
     */
    omit?: CreatureSensesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreatureSensesInclude<ExtArgs> | null
    /**
     * The filter to search for the CreatureSenses to update in case it exists.
     */
    where: CreatureSensesWhereUniqueInput
    /**
     * In case the CreatureSenses found by the `where` argument doesn't exist, create a new CreatureSenses with this data.
     */
    create: XOR<CreatureSensesCreateInput, CreatureSensesUncheckedCreateInput>
    /**
     * In case the CreatureSenses was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CreatureSensesUpdateInput, CreatureSensesUncheckedUpdateInput>
  }

  /**
   * CreatureSenses delete
   */
  export type CreatureSensesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreatureSenses
     */
    select?: CreatureSensesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CreatureSenses
     */
    omit?: CreatureSensesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreatureSensesInclude<ExtArgs> | null
    /**
     * Filter which CreatureSenses to delete.
     */
    where: CreatureSensesWhereUniqueInput
  }

  /**
   * CreatureSenses deleteMany
   */
  export type CreatureSensesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CreatureSenses to delete
     */
    where?: CreatureSensesWhereInput
    /**
     * Limit how many CreatureSenses to delete.
     */
    limit?: number
  }

  /**
   * CreatureSenses without action
   */
  export type CreatureSensesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreatureSenses
     */
    select?: CreatureSensesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CreatureSenses
     */
    omit?: CreatureSensesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreatureSensesInclude<ExtArgs> | null
  }


  /**
   * Model Action
   */

  export type AggregateAction = {
    _count: ActionCountAggregateOutputType | null
    _avg: ActionAvgAggregateOutputType | null
    _sum: ActionSumAggregateOutputType | null
    _min: ActionMinAggregateOutputType | null
    _max: ActionMaxAggregateOutputType | null
  }

  export type ActionAvgAggregateOutputType = {
    id: number | null
  }

  export type ActionSumAggregateOutputType = {
    id: number | null
  }

  export type ActionMinAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
    attack: string | null
    is_template: boolean | null
  }

  export type ActionMaxAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
    attack: string | null
    is_template: boolean | null
  }

  export type ActionCountAggregateOutputType = {
    id: number
    name: number
    description: number
    attack: number
    is_template: number
    _all: number
  }


  export type ActionAvgAggregateInputType = {
    id?: true
  }

  export type ActionSumAggregateInputType = {
    id?: true
  }

  export type ActionMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    attack?: true
    is_template?: true
  }

  export type ActionMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    attack?: true
    is_template?: true
  }

  export type ActionCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    attack?: true
    is_template?: true
    _all?: true
  }

  export type ActionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Action to aggregate.
     */
    where?: ActionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Actions to fetch.
     */
    orderBy?: ActionOrderByWithRelationInput | ActionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ActionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Actions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Actions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Actions
    **/
    _count?: true | ActionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ActionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ActionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ActionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ActionMaxAggregateInputType
  }

  export type GetActionAggregateType<T extends ActionAggregateArgs> = {
        [P in keyof T & keyof AggregateAction]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAction[P]>
      : GetScalarType<T[P], AggregateAction[P]>
  }




  export type ActionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ActionWhereInput
    orderBy?: ActionOrderByWithAggregationInput | ActionOrderByWithAggregationInput[]
    by: ActionScalarFieldEnum[] | ActionScalarFieldEnum
    having?: ActionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ActionCountAggregateInputType | true
    _avg?: ActionAvgAggregateInputType
    _sum?: ActionSumAggregateInputType
    _min?: ActionMinAggregateInputType
    _max?: ActionMaxAggregateInputType
  }

  export type ActionGroupByOutputType = {
    id: number
    name: string
    description: string
    attack: string | null
    is_template: boolean | null
    _count: ActionCountAggregateOutputType | null
    _avg: ActionAvgAggregateOutputType | null
    _sum: ActionSumAggregateOutputType | null
    _min: ActionMinAggregateOutputType | null
    _max: ActionMaxAggregateOutputType | null
  }

  type GetActionGroupByPayload<T extends ActionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ActionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ActionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ActionGroupByOutputType[P]>
            : GetScalarType<T[P], ActionGroupByOutputType[P]>
        }
      >
    >


  export type ActionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    attack?: boolean
    is_template?: boolean
    creatures_relation?: boolean | Action$creatures_relationArgs<ExtArgs>
    creature_races_relation?: boolean | Action$creature_races_relationArgs<ExtArgs>
    _count?: boolean | ActionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["action"]>

  export type ActionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    attack?: boolean
    is_template?: boolean
  }, ExtArgs["result"]["action"]>

  export type ActionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    attack?: boolean
    is_template?: boolean
  }, ExtArgs["result"]["action"]>

  export type ActionSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    attack?: boolean
    is_template?: boolean
  }

  export type ActionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "attack" | "is_template", ExtArgs["result"]["action"]>
  export type ActionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creatures_relation?: boolean | Action$creatures_relationArgs<ExtArgs>
    creature_races_relation?: boolean | Action$creature_races_relationArgs<ExtArgs>
    _count?: boolean | ActionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ActionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type ActionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $ActionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Action"
    objects: {
      creatures_relation: Prisma.$CreaturePayload<ExtArgs>[]
      creature_races_relation: Prisma.$CreatureRacePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      description: string
      attack: string | null
      is_template: boolean | null
    }, ExtArgs["result"]["action"]>
    composites: {}
  }

  type ActionGetPayload<S extends boolean | null | undefined | ActionDefaultArgs> = $Result.GetResult<Prisma.$ActionPayload, S>

  type ActionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ActionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ActionCountAggregateInputType | true
    }

  export interface ActionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Action'], meta: { name: 'Action' } }
    /**
     * Find zero or one Action that matches the filter.
     * @param {ActionFindUniqueArgs} args - Arguments to find a Action
     * @example
     * // Get one Action
     * const action = await prisma.action.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ActionFindUniqueArgs>(args: SelectSubset<T, ActionFindUniqueArgs<ExtArgs>>): Prisma__ActionClient<$Result.GetResult<Prisma.$ActionPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Action that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ActionFindUniqueOrThrowArgs} args - Arguments to find a Action
     * @example
     * // Get one Action
     * const action = await prisma.action.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ActionFindUniqueOrThrowArgs>(args: SelectSubset<T, ActionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ActionClient<$Result.GetResult<Prisma.$ActionPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Action that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActionFindFirstArgs} args - Arguments to find a Action
     * @example
     * // Get one Action
     * const action = await prisma.action.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ActionFindFirstArgs>(args?: SelectSubset<T, ActionFindFirstArgs<ExtArgs>>): Prisma__ActionClient<$Result.GetResult<Prisma.$ActionPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Action that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActionFindFirstOrThrowArgs} args - Arguments to find a Action
     * @example
     * // Get one Action
     * const action = await prisma.action.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ActionFindFirstOrThrowArgs>(args?: SelectSubset<T, ActionFindFirstOrThrowArgs<ExtArgs>>): Prisma__ActionClient<$Result.GetResult<Prisma.$ActionPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Actions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Actions
     * const actions = await prisma.action.findMany()
     * 
     * // Get first 10 Actions
     * const actions = await prisma.action.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const actionWithIdOnly = await prisma.action.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ActionFindManyArgs>(args?: SelectSubset<T, ActionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActionPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Action.
     * @param {ActionCreateArgs} args - Arguments to create a Action.
     * @example
     * // Create one Action
     * const Action = await prisma.action.create({
     *   data: {
     *     // ... data to create a Action
     *   }
     * })
     * 
     */
    create<T extends ActionCreateArgs>(args: SelectSubset<T, ActionCreateArgs<ExtArgs>>): Prisma__ActionClient<$Result.GetResult<Prisma.$ActionPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Actions.
     * @param {ActionCreateManyArgs} args - Arguments to create many Actions.
     * @example
     * // Create many Actions
     * const action = await prisma.action.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ActionCreateManyArgs>(args?: SelectSubset<T, ActionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Actions and returns the data saved in the database.
     * @param {ActionCreateManyAndReturnArgs} args - Arguments to create many Actions.
     * @example
     * // Create many Actions
     * const action = await prisma.action.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Actions and only return the `id`
     * const actionWithIdOnly = await prisma.action.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ActionCreateManyAndReturnArgs>(args?: SelectSubset<T, ActionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActionPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Action.
     * @param {ActionDeleteArgs} args - Arguments to delete one Action.
     * @example
     * // Delete one Action
     * const Action = await prisma.action.delete({
     *   where: {
     *     // ... filter to delete one Action
     *   }
     * })
     * 
     */
    delete<T extends ActionDeleteArgs>(args: SelectSubset<T, ActionDeleteArgs<ExtArgs>>): Prisma__ActionClient<$Result.GetResult<Prisma.$ActionPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Action.
     * @param {ActionUpdateArgs} args - Arguments to update one Action.
     * @example
     * // Update one Action
     * const action = await prisma.action.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ActionUpdateArgs>(args: SelectSubset<T, ActionUpdateArgs<ExtArgs>>): Prisma__ActionClient<$Result.GetResult<Prisma.$ActionPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Actions.
     * @param {ActionDeleteManyArgs} args - Arguments to filter Actions to delete.
     * @example
     * // Delete a few Actions
     * const { count } = await prisma.action.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ActionDeleteManyArgs>(args?: SelectSubset<T, ActionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Actions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Actions
     * const action = await prisma.action.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ActionUpdateManyArgs>(args: SelectSubset<T, ActionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Actions and returns the data updated in the database.
     * @param {ActionUpdateManyAndReturnArgs} args - Arguments to update many Actions.
     * @example
     * // Update many Actions
     * const action = await prisma.action.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Actions and only return the `id`
     * const actionWithIdOnly = await prisma.action.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ActionUpdateManyAndReturnArgs>(args: SelectSubset<T, ActionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActionPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Action.
     * @param {ActionUpsertArgs} args - Arguments to update or create a Action.
     * @example
     * // Update or create a Action
     * const action = await prisma.action.upsert({
     *   create: {
     *     // ... data to create a Action
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Action we want to update
     *   }
     * })
     */
    upsert<T extends ActionUpsertArgs>(args: SelectSubset<T, ActionUpsertArgs<ExtArgs>>): Prisma__ActionClient<$Result.GetResult<Prisma.$ActionPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Actions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActionCountArgs} args - Arguments to filter Actions to count.
     * @example
     * // Count the number of Actions
     * const count = await prisma.action.count({
     *   where: {
     *     // ... the filter for the Actions we want to count
     *   }
     * })
    **/
    count<T extends ActionCountArgs>(
      args?: Subset<T, ActionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ActionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Action.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ActionAggregateArgs>(args: Subset<T, ActionAggregateArgs>): Prisma.PrismaPromise<GetActionAggregateType<T>>

    /**
     * Group by Action.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ActionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ActionGroupByArgs['orderBy'] }
        : { orderBy?: ActionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ActionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetActionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Action model
   */
  readonly fields: ActionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Action.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ActionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    creatures_relation<T extends Action$creatures_relationArgs<ExtArgs> = {}>(args?: Subset<T, Action$creatures_relationArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CreaturePayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    creature_races_relation<T extends Action$creature_races_relationArgs<ExtArgs> = {}>(args?: Subset<T, Action$creature_races_relationArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CreatureRacePayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Action model
   */ 
  interface ActionFieldRefs {
    readonly id: FieldRef<"Action", 'Int'>
    readonly name: FieldRef<"Action", 'String'>
    readonly description: FieldRef<"Action", 'String'>
    readonly attack: FieldRef<"Action", 'String'>
    readonly is_template: FieldRef<"Action", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * Action findUnique
   */
  export type ActionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Action
     */
    select?: ActionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Action
     */
    omit?: ActionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActionInclude<ExtArgs> | null
    /**
     * Filter, which Action to fetch.
     */
    where: ActionWhereUniqueInput
  }

  /**
   * Action findUniqueOrThrow
   */
  export type ActionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Action
     */
    select?: ActionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Action
     */
    omit?: ActionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActionInclude<ExtArgs> | null
    /**
     * Filter, which Action to fetch.
     */
    where: ActionWhereUniqueInput
  }

  /**
   * Action findFirst
   */
  export type ActionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Action
     */
    select?: ActionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Action
     */
    omit?: ActionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActionInclude<ExtArgs> | null
    /**
     * Filter, which Action to fetch.
     */
    where?: ActionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Actions to fetch.
     */
    orderBy?: ActionOrderByWithRelationInput | ActionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Actions.
     */
    cursor?: ActionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Actions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Actions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Actions.
     */
    distinct?: ActionScalarFieldEnum | ActionScalarFieldEnum[]
  }

  /**
   * Action findFirstOrThrow
   */
  export type ActionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Action
     */
    select?: ActionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Action
     */
    omit?: ActionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActionInclude<ExtArgs> | null
    /**
     * Filter, which Action to fetch.
     */
    where?: ActionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Actions to fetch.
     */
    orderBy?: ActionOrderByWithRelationInput | ActionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Actions.
     */
    cursor?: ActionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Actions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Actions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Actions.
     */
    distinct?: ActionScalarFieldEnum | ActionScalarFieldEnum[]
  }

  /**
   * Action findMany
   */
  export type ActionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Action
     */
    select?: ActionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Action
     */
    omit?: ActionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActionInclude<ExtArgs> | null
    /**
     * Filter, which Actions to fetch.
     */
    where?: ActionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Actions to fetch.
     */
    orderBy?: ActionOrderByWithRelationInput | ActionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Actions.
     */
    cursor?: ActionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Actions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Actions.
     */
    skip?: number
    distinct?: ActionScalarFieldEnum | ActionScalarFieldEnum[]
  }

  /**
   * Action create
   */
  export type ActionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Action
     */
    select?: ActionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Action
     */
    omit?: ActionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActionInclude<ExtArgs> | null
    /**
     * The data needed to create a Action.
     */
    data: XOR<ActionCreateInput, ActionUncheckedCreateInput>
  }

  /**
   * Action createMany
   */
  export type ActionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Actions.
     */
    data: ActionCreateManyInput | ActionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Action createManyAndReturn
   */
  export type ActionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Action
     */
    select?: ActionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Action
     */
    omit?: ActionOmit<ExtArgs> | null
    /**
     * The data used to create many Actions.
     */
    data: ActionCreateManyInput | ActionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Action update
   */
  export type ActionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Action
     */
    select?: ActionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Action
     */
    omit?: ActionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActionInclude<ExtArgs> | null
    /**
     * The data needed to update a Action.
     */
    data: XOR<ActionUpdateInput, ActionUncheckedUpdateInput>
    /**
     * Choose, which Action to update.
     */
    where: ActionWhereUniqueInput
  }

  /**
   * Action updateMany
   */
  export type ActionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Actions.
     */
    data: XOR<ActionUpdateManyMutationInput, ActionUncheckedUpdateManyInput>
    /**
     * Filter which Actions to update
     */
    where?: ActionWhereInput
    /**
     * Limit how many Actions to update.
     */
    limit?: number
  }

  /**
   * Action updateManyAndReturn
   */
  export type ActionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Action
     */
    select?: ActionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Action
     */
    omit?: ActionOmit<ExtArgs> | null
    /**
     * The data used to update Actions.
     */
    data: XOR<ActionUpdateManyMutationInput, ActionUncheckedUpdateManyInput>
    /**
     * Filter which Actions to update
     */
    where?: ActionWhereInput
    /**
     * Limit how many Actions to update.
     */
    limit?: number
  }

  /**
   * Action upsert
   */
  export type ActionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Action
     */
    select?: ActionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Action
     */
    omit?: ActionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActionInclude<ExtArgs> | null
    /**
     * The filter to search for the Action to update in case it exists.
     */
    where: ActionWhereUniqueInput
    /**
     * In case the Action found by the `where` argument doesn't exist, create a new Action with this data.
     */
    create: XOR<ActionCreateInput, ActionUncheckedCreateInput>
    /**
     * In case the Action was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ActionUpdateInput, ActionUncheckedUpdateInput>
  }

  /**
   * Action delete
   */
  export type ActionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Action
     */
    select?: ActionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Action
     */
    omit?: ActionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActionInclude<ExtArgs> | null
    /**
     * Filter which Action to delete.
     */
    where: ActionWhereUniqueInput
  }

  /**
   * Action deleteMany
   */
  export type ActionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Actions to delete
     */
    where?: ActionWhereInput
    /**
     * Limit how many Actions to delete.
     */
    limit?: number
  }

  /**
   * Action.creatures_relation
   */
  export type Action$creatures_relationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Creature
     */
    select?: CreatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Creature
     */
    omit?: CreatureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreatureInclude<ExtArgs> | null
    where?: CreatureWhereInput
    orderBy?: CreatureOrderByWithRelationInput | CreatureOrderByWithRelationInput[]
    cursor?: CreatureWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CreatureScalarFieldEnum | CreatureScalarFieldEnum[]
  }

  /**
   * Action.creature_races_relation
   */
  export type Action$creature_races_relationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreatureRace
     */
    select?: CreatureRaceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CreatureRace
     */
    omit?: CreatureRaceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreatureRaceInclude<ExtArgs> | null
    where?: CreatureRaceWhereInput
    orderBy?: CreatureRaceOrderByWithRelationInput | CreatureRaceOrderByWithRelationInput[]
    cursor?: CreatureRaceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CreatureRaceScalarFieldEnum | CreatureRaceScalarFieldEnum[]
  }

  /**
   * Action without action
   */
  export type ActionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Action
     */
    select?: ActionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Action
     */
    omit?: ActionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActionInclude<ExtArgs> | null
  }


  /**
   * Model Trait
   */

  export type AggregateTrait = {
    _count: TraitCountAggregateOutputType | null
    _avg: TraitAvgAggregateOutputType | null
    _sum: TraitSumAggregateOutputType | null
    _min: TraitMinAggregateOutputType | null
    _max: TraitMaxAggregateOutputType | null
  }

  export type TraitAvgAggregateOutputType = {
    id: number | null
  }

  export type TraitSumAggregateOutputType = {
    id: number | null
  }

  export type TraitMinAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
    attack: string | null
    is_template: boolean | null
  }

  export type TraitMaxAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
    attack: string | null
    is_template: boolean | null
  }

  export type TraitCountAggregateOutputType = {
    id: number
    name: number
    description: number
    attack: number
    is_template: number
    _all: number
  }


  export type TraitAvgAggregateInputType = {
    id?: true
  }

  export type TraitSumAggregateInputType = {
    id?: true
  }

  export type TraitMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    attack?: true
    is_template?: true
  }

  export type TraitMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    attack?: true
    is_template?: true
  }

  export type TraitCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    attack?: true
    is_template?: true
    _all?: true
  }

  export type TraitAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Trait to aggregate.
     */
    where?: TraitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Traits to fetch.
     */
    orderBy?: TraitOrderByWithRelationInput | TraitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TraitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Traits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Traits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Traits
    **/
    _count?: true | TraitCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TraitAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TraitSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TraitMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TraitMaxAggregateInputType
  }

  export type GetTraitAggregateType<T extends TraitAggregateArgs> = {
        [P in keyof T & keyof AggregateTrait]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTrait[P]>
      : GetScalarType<T[P], AggregateTrait[P]>
  }




  export type TraitGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TraitWhereInput
    orderBy?: TraitOrderByWithAggregationInput | TraitOrderByWithAggregationInput[]
    by: TraitScalarFieldEnum[] | TraitScalarFieldEnum
    having?: TraitScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TraitCountAggregateInputType | true
    _avg?: TraitAvgAggregateInputType
    _sum?: TraitSumAggregateInputType
    _min?: TraitMinAggregateInputType
    _max?: TraitMaxAggregateInputType
  }

  export type TraitGroupByOutputType = {
    id: number
    name: string
    description: string
    attack: string | null
    is_template: boolean | null
    _count: TraitCountAggregateOutputType | null
    _avg: TraitAvgAggregateOutputType | null
    _sum: TraitSumAggregateOutputType | null
    _min: TraitMinAggregateOutputType | null
    _max: TraitMaxAggregateOutputType | null
  }

  type GetTraitGroupByPayload<T extends TraitGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TraitGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TraitGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TraitGroupByOutputType[P]>
            : GetScalarType<T[P], TraitGroupByOutputType[P]>
        }
      >
    >


  export type TraitSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    attack?: boolean
    is_template?: boolean
    creatures_relation?: boolean | Trait$creatures_relationArgs<ExtArgs>
    creature_races_relation?: boolean | Trait$creature_races_relationArgs<ExtArgs>
    _count?: boolean | TraitCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["trait"]>

  export type TraitSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    attack?: boolean
    is_template?: boolean
  }, ExtArgs["result"]["trait"]>

  export type TraitSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    attack?: boolean
    is_template?: boolean
  }, ExtArgs["result"]["trait"]>

  export type TraitSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    attack?: boolean
    is_template?: boolean
  }

  export type TraitOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "attack" | "is_template", ExtArgs["result"]["trait"]>
  export type TraitInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creatures_relation?: boolean | Trait$creatures_relationArgs<ExtArgs>
    creature_races_relation?: boolean | Trait$creature_races_relationArgs<ExtArgs>
    _count?: boolean | TraitCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TraitIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type TraitIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $TraitPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Trait"
    objects: {
      creatures_relation: Prisma.$CreaturePayload<ExtArgs>[]
      creature_races_relation: Prisma.$CreatureRacePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      description: string
      attack: string | null
      is_template: boolean | null
    }, ExtArgs["result"]["trait"]>
    composites: {}
  }

  type TraitGetPayload<S extends boolean | null | undefined | TraitDefaultArgs> = $Result.GetResult<Prisma.$TraitPayload, S>

  type TraitCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TraitFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TraitCountAggregateInputType | true
    }

  export interface TraitDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Trait'], meta: { name: 'Trait' } }
    /**
     * Find zero or one Trait that matches the filter.
     * @param {TraitFindUniqueArgs} args - Arguments to find a Trait
     * @example
     * // Get one Trait
     * const trait = await prisma.trait.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TraitFindUniqueArgs>(args: SelectSubset<T, TraitFindUniqueArgs<ExtArgs>>): Prisma__TraitClient<$Result.GetResult<Prisma.$TraitPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Trait that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TraitFindUniqueOrThrowArgs} args - Arguments to find a Trait
     * @example
     * // Get one Trait
     * const trait = await prisma.trait.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TraitFindUniqueOrThrowArgs>(args: SelectSubset<T, TraitFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TraitClient<$Result.GetResult<Prisma.$TraitPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Trait that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TraitFindFirstArgs} args - Arguments to find a Trait
     * @example
     * // Get one Trait
     * const trait = await prisma.trait.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TraitFindFirstArgs>(args?: SelectSubset<T, TraitFindFirstArgs<ExtArgs>>): Prisma__TraitClient<$Result.GetResult<Prisma.$TraitPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Trait that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TraitFindFirstOrThrowArgs} args - Arguments to find a Trait
     * @example
     * // Get one Trait
     * const trait = await prisma.trait.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TraitFindFirstOrThrowArgs>(args?: SelectSubset<T, TraitFindFirstOrThrowArgs<ExtArgs>>): Prisma__TraitClient<$Result.GetResult<Prisma.$TraitPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Traits that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TraitFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Traits
     * const traits = await prisma.trait.findMany()
     * 
     * // Get first 10 Traits
     * const traits = await prisma.trait.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const traitWithIdOnly = await prisma.trait.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TraitFindManyArgs>(args?: SelectSubset<T, TraitFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TraitPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Trait.
     * @param {TraitCreateArgs} args - Arguments to create a Trait.
     * @example
     * // Create one Trait
     * const Trait = await prisma.trait.create({
     *   data: {
     *     // ... data to create a Trait
     *   }
     * })
     * 
     */
    create<T extends TraitCreateArgs>(args: SelectSubset<T, TraitCreateArgs<ExtArgs>>): Prisma__TraitClient<$Result.GetResult<Prisma.$TraitPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Traits.
     * @param {TraitCreateManyArgs} args - Arguments to create many Traits.
     * @example
     * // Create many Traits
     * const trait = await prisma.trait.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TraitCreateManyArgs>(args?: SelectSubset<T, TraitCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Traits and returns the data saved in the database.
     * @param {TraitCreateManyAndReturnArgs} args - Arguments to create many Traits.
     * @example
     * // Create many Traits
     * const trait = await prisma.trait.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Traits and only return the `id`
     * const traitWithIdOnly = await prisma.trait.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TraitCreateManyAndReturnArgs>(args?: SelectSubset<T, TraitCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TraitPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Trait.
     * @param {TraitDeleteArgs} args - Arguments to delete one Trait.
     * @example
     * // Delete one Trait
     * const Trait = await prisma.trait.delete({
     *   where: {
     *     // ... filter to delete one Trait
     *   }
     * })
     * 
     */
    delete<T extends TraitDeleteArgs>(args: SelectSubset<T, TraitDeleteArgs<ExtArgs>>): Prisma__TraitClient<$Result.GetResult<Prisma.$TraitPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Trait.
     * @param {TraitUpdateArgs} args - Arguments to update one Trait.
     * @example
     * // Update one Trait
     * const trait = await prisma.trait.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TraitUpdateArgs>(args: SelectSubset<T, TraitUpdateArgs<ExtArgs>>): Prisma__TraitClient<$Result.GetResult<Prisma.$TraitPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Traits.
     * @param {TraitDeleteManyArgs} args - Arguments to filter Traits to delete.
     * @example
     * // Delete a few Traits
     * const { count } = await prisma.trait.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TraitDeleteManyArgs>(args?: SelectSubset<T, TraitDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Traits.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TraitUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Traits
     * const trait = await prisma.trait.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TraitUpdateManyArgs>(args: SelectSubset<T, TraitUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Traits and returns the data updated in the database.
     * @param {TraitUpdateManyAndReturnArgs} args - Arguments to update many Traits.
     * @example
     * // Update many Traits
     * const trait = await prisma.trait.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Traits and only return the `id`
     * const traitWithIdOnly = await prisma.trait.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TraitUpdateManyAndReturnArgs>(args: SelectSubset<T, TraitUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TraitPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Trait.
     * @param {TraitUpsertArgs} args - Arguments to update or create a Trait.
     * @example
     * // Update or create a Trait
     * const trait = await prisma.trait.upsert({
     *   create: {
     *     // ... data to create a Trait
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Trait we want to update
     *   }
     * })
     */
    upsert<T extends TraitUpsertArgs>(args: SelectSubset<T, TraitUpsertArgs<ExtArgs>>): Prisma__TraitClient<$Result.GetResult<Prisma.$TraitPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Traits.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TraitCountArgs} args - Arguments to filter Traits to count.
     * @example
     * // Count the number of Traits
     * const count = await prisma.trait.count({
     *   where: {
     *     // ... the filter for the Traits we want to count
     *   }
     * })
    **/
    count<T extends TraitCountArgs>(
      args?: Subset<T, TraitCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TraitCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Trait.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TraitAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TraitAggregateArgs>(args: Subset<T, TraitAggregateArgs>): Prisma.PrismaPromise<GetTraitAggregateType<T>>

    /**
     * Group by Trait.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TraitGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TraitGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TraitGroupByArgs['orderBy'] }
        : { orderBy?: TraitGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TraitGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTraitGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Trait model
   */
  readonly fields: TraitFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Trait.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TraitClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    creatures_relation<T extends Trait$creatures_relationArgs<ExtArgs> = {}>(args?: Subset<T, Trait$creatures_relationArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CreaturePayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    creature_races_relation<T extends Trait$creature_races_relationArgs<ExtArgs> = {}>(args?: Subset<T, Trait$creature_races_relationArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CreatureRacePayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Trait model
   */ 
  interface TraitFieldRefs {
    readonly id: FieldRef<"Trait", 'Int'>
    readonly name: FieldRef<"Trait", 'String'>
    readonly description: FieldRef<"Trait", 'String'>
    readonly attack: FieldRef<"Trait", 'String'>
    readonly is_template: FieldRef<"Trait", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * Trait findUnique
   */
  export type TraitFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Trait
     */
    select?: TraitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Trait
     */
    omit?: TraitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TraitInclude<ExtArgs> | null
    /**
     * Filter, which Trait to fetch.
     */
    where: TraitWhereUniqueInput
  }

  /**
   * Trait findUniqueOrThrow
   */
  export type TraitFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Trait
     */
    select?: TraitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Trait
     */
    omit?: TraitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TraitInclude<ExtArgs> | null
    /**
     * Filter, which Trait to fetch.
     */
    where: TraitWhereUniqueInput
  }

  /**
   * Trait findFirst
   */
  export type TraitFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Trait
     */
    select?: TraitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Trait
     */
    omit?: TraitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TraitInclude<ExtArgs> | null
    /**
     * Filter, which Trait to fetch.
     */
    where?: TraitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Traits to fetch.
     */
    orderBy?: TraitOrderByWithRelationInput | TraitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Traits.
     */
    cursor?: TraitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Traits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Traits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Traits.
     */
    distinct?: TraitScalarFieldEnum | TraitScalarFieldEnum[]
  }

  /**
   * Trait findFirstOrThrow
   */
  export type TraitFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Trait
     */
    select?: TraitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Trait
     */
    omit?: TraitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TraitInclude<ExtArgs> | null
    /**
     * Filter, which Trait to fetch.
     */
    where?: TraitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Traits to fetch.
     */
    orderBy?: TraitOrderByWithRelationInput | TraitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Traits.
     */
    cursor?: TraitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Traits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Traits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Traits.
     */
    distinct?: TraitScalarFieldEnum | TraitScalarFieldEnum[]
  }

  /**
   * Trait findMany
   */
  export type TraitFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Trait
     */
    select?: TraitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Trait
     */
    omit?: TraitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TraitInclude<ExtArgs> | null
    /**
     * Filter, which Traits to fetch.
     */
    where?: TraitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Traits to fetch.
     */
    orderBy?: TraitOrderByWithRelationInput | TraitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Traits.
     */
    cursor?: TraitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Traits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Traits.
     */
    skip?: number
    distinct?: TraitScalarFieldEnum | TraitScalarFieldEnum[]
  }

  /**
   * Trait create
   */
  export type TraitCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Trait
     */
    select?: TraitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Trait
     */
    omit?: TraitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TraitInclude<ExtArgs> | null
    /**
     * The data needed to create a Trait.
     */
    data: XOR<TraitCreateInput, TraitUncheckedCreateInput>
  }

  /**
   * Trait createMany
   */
  export type TraitCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Traits.
     */
    data: TraitCreateManyInput | TraitCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Trait createManyAndReturn
   */
  export type TraitCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Trait
     */
    select?: TraitSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Trait
     */
    omit?: TraitOmit<ExtArgs> | null
    /**
     * The data used to create many Traits.
     */
    data: TraitCreateManyInput | TraitCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Trait update
   */
  export type TraitUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Trait
     */
    select?: TraitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Trait
     */
    omit?: TraitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TraitInclude<ExtArgs> | null
    /**
     * The data needed to update a Trait.
     */
    data: XOR<TraitUpdateInput, TraitUncheckedUpdateInput>
    /**
     * Choose, which Trait to update.
     */
    where: TraitWhereUniqueInput
  }

  /**
   * Trait updateMany
   */
  export type TraitUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Traits.
     */
    data: XOR<TraitUpdateManyMutationInput, TraitUncheckedUpdateManyInput>
    /**
     * Filter which Traits to update
     */
    where?: TraitWhereInput
    /**
     * Limit how many Traits to update.
     */
    limit?: number
  }

  /**
   * Trait updateManyAndReturn
   */
  export type TraitUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Trait
     */
    select?: TraitSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Trait
     */
    omit?: TraitOmit<ExtArgs> | null
    /**
     * The data used to update Traits.
     */
    data: XOR<TraitUpdateManyMutationInput, TraitUncheckedUpdateManyInput>
    /**
     * Filter which Traits to update
     */
    where?: TraitWhereInput
    /**
     * Limit how many Traits to update.
     */
    limit?: number
  }

  /**
   * Trait upsert
   */
  export type TraitUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Trait
     */
    select?: TraitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Trait
     */
    omit?: TraitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TraitInclude<ExtArgs> | null
    /**
     * The filter to search for the Trait to update in case it exists.
     */
    where: TraitWhereUniqueInput
    /**
     * In case the Trait found by the `where` argument doesn't exist, create a new Trait with this data.
     */
    create: XOR<TraitCreateInput, TraitUncheckedCreateInput>
    /**
     * In case the Trait was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TraitUpdateInput, TraitUncheckedUpdateInput>
  }

  /**
   * Trait delete
   */
  export type TraitDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Trait
     */
    select?: TraitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Trait
     */
    omit?: TraitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TraitInclude<ExtArgs> | null
    /**
     * Filter which Trait to delete.
     */
    where: TraitWhereUniqueInput
  }

  /**
   * Trait deleteMany
   */
  export type TraitDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Traits to delete
     */
    where?: TraitWhereInput
    /**
     * Limit how many Traits to delete.
     */
    limit?: number
  }

  /**
   * Trait.creatures_relation
   */
  export type Trait$creatures_relationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Creature
     */
    select?: CreatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Creature
     */
    omit?: CreatureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreatureInclude<ExtArgs> | null
    where?: CreatureWhereInput
    orderBy?: CreatureOrderByWithRelationInput | CreatureOrderByWithRelationInput[]
    cursor?: CreatureWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CreatureScalarFieldEnum | CreatureScalarFieldEnum[]
  }

  /**
   * Trait.creature_races_relation
   */
  export type Trait$creature_races_relationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreatureRace
     */
    select?: CreatureRaceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CreatureRace
     */
    omit?: CreatureRaceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreatureRaceInclude<ExtArgs> | null
    where?: CreatureRaceWhereInput
    orderBy?: CreatureRaceOrderByWithRelationInput | CreatureRaceOrderByWithRelationInput[]
    cursor?: CreatureRaceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CreatureRaceScalarFieldEnum | CreatureRaceScalarFieldEnum[]
  }

  /**
   * Trait without action
   */
  export type TraitDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Trait
     */
    select?: TraitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Trait
     */
    omit?: TraitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TraitInclude<ExtArgs> | null
  }


  /**
   * Model CreatureRace
   */

  export type AggregateCreatureRace = {
    _count: CreatureRaceCountAggregateOutputType | null
    _avg: CreatureRaceAvgAggregateOutputType | null
    _sum: CreatureRaceSumAggregateOutputType | null
    _min: CreatureRaceMinAggregateOutputType | null
    _max: CreatureRaceMaxAggregateOutputType | null
  }

  export type CreatureRaceAvgAggregateOutputType = {
    id: number | null
  }

  export type CreatureRaceSumAggregateOutputType = {
    id: number | null
  }

  export type CreatureRaceMinAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
  }

  export type CreatureRaceMaxAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
  }

  export type CreatureRaceCountAggregateOutputType = {
    id: number
    name: number
    description: number
    _all: number
  }


  export type CreatureRaceAvgAggregateInputType = {
    id?: true
  }

  export type CreatureRaceSumAggregateInputType = {
    id?: true
  }

  export type CreatureRaceMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
  }

  export type CreatureRaceMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
  }

  export type CreatureRaceCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    _all?: true
  }

  export type CreatureRaceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CreatureRace to aggregate.
     */
    where?: CreatureRaceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CreatureRaces to fetch.
     */
    orderBy?: CreatureRaceOrderByWithRelationInput | CreatureRaceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CreatureRaceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CreatureRaces from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CreatureRaces.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CreatureRaces
    **/
    _count?: true | CreatureRaceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CreatureRaceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CreatureRaceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CreatureRaceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CreatureRaceMaxAggregateInputType
  }

  export type GetCreatureRaceAggregateType<T extends CreatureRaceAggregateArgs> = {
        [P in keyof T & keyof AggregateCreatureRace]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCreatureRace[P]>
      : GetScalarType<T[P], AggregateCreatureRace[P]>
  }




  export type CreatureRaceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CreatureRaceWhereInput
    orderBy?: CreatureRaceOrderByWithAggregationInput | CreatureRaceOrderByWithAggregationInput[]
    by: CreatureRaceScalarFieldEnum[] | CreatureRaceScalarFieldEnum
    having?: CreatureRaceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CreatureRaceCountAggregateInputType | true
    _avg?: CreatureRaceAvgAggregateInputType
    _sum?: CreatureRaceSumAggregateInputType
    _min?: CreatureRaceMinAggregateInputType
    _max?: CreatureRaceMaxAggregateInputType
  }

  export type CreatureRaceGroupByOutputType = {
    id: number
    name: string
    description: string
    _count: CreatureRaceCountAggregateOutputType | null
    _avg: CreatureRaceAvgAggregateOutputType | null
    _sum: CreatureRaceSumAggregateOutputType | null
    _min: CreatureRaceMinAggregateOutputType | null
    _max: CreatureRaceMaxAggregateOutputType | null
  }

  type GetCreatureRaceGroupByPayload<T extends CreatureRaceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CreatureRaceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CreatureRaceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CreatureRaceGroupByOutputType[P]>
            : GetScalarType<T[P], CreatureRaceGroupByOutputType[P]>
        }
      >
    >


  export type CreatureRaceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    traits_relation?: boolean | CreatureRace$traits_relationArgs<ExtArgs>
    actions_relation?: boolean | CreatureRace$actions_relationArgs<ExtArgs>
    creatures_relation?: boolean | CreatureRace$creatures_relationArgs<ExtArgs>
    _count?: boolean | CreatureRaceCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["creatureRace"]>

  export type CreatureRaceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
  }, ExtArgs["result"]["creatureRace"]>

  export type CreatureRaceSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
  }, ExtArgs["result"]["creatureRace"]>

  export type CreatureRaceSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
  }

  export type CreatureRaceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description", ExtArgs["result"]["creatureRace"]>
  export type CreatureRaceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    traits_relation?: boolean | CreatureRace$traits_relationArgs<ExtArgs>
    actions_relation?: boolean | CreatureRace$actions_relationArgs<ExtArgs>
    creatures_relation?: boolean | CreatureRace$creatures_relationArgs<ExtArgs>
    _count?: boolean | CreatureRaceCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CreatureRaceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type CreatureRaceIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $CreatureRacePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CreatureRace"
    objects: {
      traits_relation: Prisma.$TraitPayload<ExtArgs>[]
      actions_relation: Prisma.$ActionPayload<ExtArgs>[]
      creatures_relation: Prisma.$CreaturePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      description: string
    }, ExtArgs["result"]["creatureRace"]>
    composites: {}
  }

  type CreatureRaceGetPayload<S extends boolean | null | undefined | CreatureRaceDefaultArgs> = $Result.GetResult<Prisma.$CreatureRacePayload, S>

  type CreatureRaceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CreatureRaceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CreatureRaceCountAggregateInputType | true
    }

  export interface CreatureRaceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CreatureRace'], meta: { name: 'CreatureRace' } }
    /**
     * Find zero or one CreatureRace that matches the filter.
     * @param {CreatureRaceFindUniqueArgs} args - Arguments to find a CreatureRace
     * @example
     * // Get one CreatureRace
     * const creatureRace = await prisma.creatureRace.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CreatureRaceFindUniqueArgs>(args: SelectSubset<T, CreatureRaceFindUniqueArgs<ExtArgs>>): Prisma__CreatureRaceClient<$Result.GetResult<Prisma.$CreatureRacePayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one CreatureRace that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CreatureRaceFindUniqueOrThrowArgs} args - Arguments to find a CreatureRace
     * @example
     * // Get one CreatureRace
     * const creatureRace = await prisma.creatureRace.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CreatureRaceFindUniqueOrThrowArgs>(args: SelectSubset<T, CreatureRaceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CreatureRaceClient<$Result.GetResult<Prisma.$CreatureRacePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first CreatureRace that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreatureRaceFindFirstArgs} args - Arguments to find a CreatureRace
     * @example
     * // Get one CreatureRace
     * const creatureRace = await prisma.creatureRace.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CreatureRaceFindFirstArgs>(args?: SelectSubset<T, CreatureRaceFindFirstArgs<ExtArgs>>): Prisma__CreatureRaceClient<$Result.GetResult<Prisma.$CreatureRacePayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first CreatureRace that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreatureRaceFindFirstOrThrowArgs} args - Arguments to find a CreatureRace
     * @example
     * // Get one CreatureRace
     * const creatureRace = await prisma.creatureRace.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CreatureRaceFindFirstOrThrowArgs>(args?: SelectSubset<T, CreatureRaceFindFirstOrThrowArgs<ExtArgs>>): Prisma__CreatureRaceClient<$Result.GetResult<Prisma.$CreatureRacePayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more CreatureRaces that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreatureRaceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CreatureRaces
     * const creatureRaces = await prisma.creatureRace.findMany()
     * 
     * // Get first 10 CreatureRaces
     * const creatureRaces = await prisma.creatureRace.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const creatureRaceWithIdOnly = await prisma.creatureRace.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CreatureRaceFindManyArgs>(args?: SelectSubset<T, CreatureRaceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CreatureRacePayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a CreatureRace.
     * @param {CreatureRaceCreateArgs} args - Arguments to create a CreatureRace.
     * @example
     * // Create one CreatureRace
     * const CreatureRace = await prisma.creatureRace.create({
     *   data: {
     *     // ... data to create a CreatureRace
     *   }
     * })
     * 
     */
    create<T extends CreatureRaceCreateArgs>(args: SelectSubset<T, CreatureRaceCreateArgs<ExtArgs>>): Prisma__CreatureRaceClient<$Result.GetResult<Prisma.$CreatureRacePayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many CreatureRaces.
     * @param {CreatureRaceCreateManyArgs} args - Arguments to create many CreatureRaces.
     * @example
     * // Create many CreatureRaces
     * const creatureRace = await prisma.creatureRace.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CreatureRaceCreateManyArgs>(args?: SelectSubset<T, CreatureRaceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CreatureRaces and returns the data saved in the database.
     * @param {CreatureRaceCreateManyAndReturnArgs} args - Arguments to create many CreatureRaces.
     * @example
     * // Create many CreatureRaces
     * const creatureRace = await prisma.creatureRace.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CreatureRaces and only return the `id`
     * const creatureRaceWithIdOnly = await prisma.creatureRace.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CreatureRaceCreateManyAndReturnArgs>(args?: SelectSubset<T, CreatureRaceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CreatureRacePayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a CreatureRace.
     * @param {CreatureRaceDeleteArgs} args - Arguments to delete one CreatureRace.
     * @example
     * // Delete one CreatureRace
     * const CreatureRace = await prisma.creatureRace.delete({
     *   where: {
     *     // ... filter to delete one CreatureRace
     *   }
     * })
     * 
     */
    delete<T extends CreatureRaceDeleteArgs>(args: SelectSubset<T, CreatureRaceDeleteArgs<ExtArgs>>): Prisma__CreatureRaceClient<$Result.GetResult<Prisma.$CreatureRacePayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one CreatureRace.
     * @param {CreatureRaceUpdateArgs} args - Arguments to update one CreatureRace.
     * @example
     * // Update one CreatureRace
     * const creatureRace = await prisma.creatureRace.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CreatureRaceUpdateArgs>(args: SelectSubset<T, CreatureRaceUpdateArgs<ExtArgs>>): Prisma__CreatureRaceClient<$Result.GetResult<Prisma.$CreatureRacePayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more CreatureRaces.
     * @param {CreatureRaceDeleteManyArgs} args - Arguments to filter CreatureRaces to delete.
     * @example
     * // Delete a few CreatureRaces
     * const { count } = await prisma.creatureRace.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CreatureRaceDeleteManyArgs>(args?: SelectSubset<T, CreatureRaceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CreatureRaces.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreatureRaceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CreatureRaces
     * const creatureRace = await prisma.creatureRace.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CreatureRaceUpdateManyArgs>(args: SelectSubset<T, CreatureRaceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CreatureRaces and returns the data updated in the database.
     * @param {CreatureRaceUpdateManyAndReturnArgs} args - Arguments to update many CreatureRaces.
     * @example
     * // Update many CreatureRaces
     * const creatureRace = await prisma.creatureRace.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CreatureRaces and only return the `id`
     * const creatureRaceWithIdOnly = await prisma.creatureRace.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CreatureRaceUpdateManyAndReturnArgs>(args: SelectSubset<T, CreatureRaceUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CreatureRacePayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one CreatureRace.
     * @param {CreatureRaceUpsertArgs} args - Arguments to update or create a CreatureRace.
     * @example
     * // Update or create a CreatureRace
     * const creatureRace = await prisma.creatureRace.upsert({
     *   create: {
     *     // ... data to create a CreatureRace
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CreatureRace we want to update
     *   }
     * })
     */
    upsert<T extends CreatureRaceUpsertArgs>(args: SelectSubset<T, CreatureRaceUpsertArgs<ExtArgs>>): Prisma__CreatureRaceClient<$Result.GetResult<Prisma.$CreatureRacePayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of CreatureRaces.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreatureRaceCountArgs} args - Arguments to filter CreatureRaces to count.
     * @example
     * // Count the number of CreatureRaces
     * const count = await prisma.creatureRace.count({
     *   where: {
     *     // ... the filter for the CreatureRaces we want to count
     *   }
     * })
    **/
    count<T extends CreatureRaceCountArgs>(
      args?: Subset<T, CreatureRaceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CreatureRaceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CreatureRace.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreatureRaceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CreatureRaceAggregateArgs>(args: Subset<T, CreatureRaceAggregateArgs>): Prisma.PrismaPromise<GetCreatureRaceAggregateType<T>>

    /**
     * Group by CreatureRace.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreatureRaceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CreatureRaceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CreatureRaceGroupByArgs['orderBy'] }
        : { orderBy?: CreatureRaceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CreatureRaceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCreatureRaceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CreatureRace model
   */
  readonly fields: CreatureRaceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CreatureRace.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CreatureRaceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    traits_relation<T extends CreatureRace$traits_relationArgs<ExtArgs> = {}>(args?: Subset<T, CreatureRace$traits_relationArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TraitPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    actions_relation<T extends CreatureRace$actions_relationArgs<ExtArgs> = {}>(args?: Subset<T, CreatureRace$actions_relationArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActionPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    creatures_relation<T extends CreatureRace$creatures_relationArgs<ExtArgs> = {}>(args?: Subset<T, CreatureRace$creatures_relationArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CreaturePayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CreatureRace model
   */ 
  interface CreatureRaceFieldRefs {
    readonly id: FieldRef<"CreatureRace", 'Int'>
    readonly name: FieldRef<"CreatureRace", 'String'>
    readonly description: FieldRef<"CreatureRace", 'String'>
  }
    

  // Custom InputTypes
  /**
   * CreatureRace findUnique
   */
  export type CreatureRaceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreatureRace
     */
    select?: CreatureRaceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CreatureRace
     */
    omit?: CreatureRaceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreatureRaceInclude<ExtArgs> | null
    /**
     * Filter, which CreatureRace to fetch.
     */
    where: CreatureRaceWhereUniqueInput
  }

  /**
   * CreatureRace findUniqueOrThrow
   */
  export type CreatureRaceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreatureRace
     */
    select?: CreatureRaceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CreatureRace
     */
    omit?: CreatureRaceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreatureRaceInclude<ExtArgs> | null
    /**
     * Filter, which CreatureRace to fetch.
     */
    where: CreatureRaceWhereUniqueInput
  }

  /**
   * CreatureRace findFirst
   */
  export type CreatureRaceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreatureRace
     */
    select?: CreatureRaceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CreatureRace
     */
    omit?: CreatureRaceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreatureRaceInclude<ExtArgs> | null
    /**
     * Filter, which CreatureRace to fetch.
     */
    where?: CreatureRaceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CreatureRaces to fetch.
     */
    orderBy?: CreatureRaceOrderByWithRelationInput | CreatureRaceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CreatureRaces.
     */
    cursor?: CreatureRaceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CreatureRaces from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CreatureRaces.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CreatureRaces.
     */
    distinct?: CreatureRaceScalarFieldEnum | CreatureRaceScalarFieldEnum[]
  }

  /**
   * CreatureRace findFirstOrThrow
   */
  export type CreatureRaceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreatureRace
     */
    select?: CreatureRaceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CreatureRace
     */
    omit?: CreatureRaceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreatureRaceInclude<ExtArgs> | null
    /**
     * Filter, which CreatureRace to fetch.
     */
    where?: CreatureRaceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CreatureRaces to fetch.
     */
    orderBy?: CreatureRaceOrderByWithRelationInput | CreatureRaceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CreatureRaces.
     */
    cursor?: CreatureRaceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CreatureRaces from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CreatureRaces.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CreatureRaces.
     */
    distinct?: CreatureRaceScalarFieldEnum | CreatureRaceScalarFieldEnum[]
  }

  /**
   * CreatureRace findMany
   */
  export type CreatureRaceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreatureRace
     */
    select?: CreatureRaceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CreatureRace
     */
    omit?: CreatureRaceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreatureRaceInclude<ExtArgs> | null
    /**
     * Filter, which CreatureRaces to fetch.
     */
    where?: CreatureRaceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CreatureRaces to fetch.
     */
    orderBy?: CreatureRaceOrderByWithRelationInput | CreatureRaceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CreatureRaces.
     */
    cursor?: CreatureRaceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CreatureRaces from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CreatureRaces.
     */
    skip?: number
    distinct?: CreatureRaceScalarFieldEnum | CreatureRaceScalarFieldEnum[]
  }

  /**
   * CreatureRace create
   */
  export type CreatureRaceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreatureRace
     */
    select?: CreatureRaceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CreatureRace
     */
    omit?: CreatureRaceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreatureRaceInclude<ExtArgs> | null
    /**
     * The data needed to create a CreatureRace.
     */
    data: XOR<CreatureRaceCreateInput, CreatureRaceUncheckedCreateInput>
  }

  /**
   * CreatureRace createMany
   */
  export type CreatureRaceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CreatureRaces.
     */
    data: CreatureRaceCreateManyInput | CreatureRaceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CreatureRace createManyAndReturn
   */
  export type CreatureRaceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreatureRace
     */
    select?: CreatureRaceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CreatureRace
     */
    omit?: CreatureRaceOmit<ExtArgs> | null
    /**
     * The data used to create many CreatureRaces.
     */
    data: CreatureRaceCreateManyInput | CreatureRaceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CreatureRace update
   */
  export type CreatureRaceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreatureRace
     */
    select?: CreatureRaceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CreatureRace
     */
    omit?: CreatureRaceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreatureRaceInclude<ExtArgs> | null
    /**
     * The data needed to update a CreatureRace.
     */
    data: XOR<CreatureRaceUpdateInput, CreatureRaceUncheckedUpdateInput>
    /**
     * Choose, which CreatureRace to update.
     */
    where: CreatureRaceWhereUniqueInput
  }

  /**
   * CreatureRace updateMany
   */
  export type CreatureRaceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CreatureRaces.
     */
    data: XOR<CreatureRaceUpdateManyMutationInput, CreatureRaceUncheckedUpdateManyInput>
    /**
     * Filter which CreatureRaces to update
     */
    where?: CreatureRaceWhereInput
    /**
     * Limit how many CreatureRaces to update.
     */
    limit?: number
  }

  /**
   * CreatureRace updateManyAndReturn
   */
  export type CreatureRaceUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreatureRace
     */
    select?: CreatureRaceSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CreatureRace
     */
    omit?: CreatureRaceOmit<ExtArgs> | null
    /**
     * The data used to update CreatureRaces.
     */
    data: XOR<CreatureRaceUpdateManyMutationInput, CreatureRaceUncheckedUpdateManyInput>
    /**
     * Filter which CreatureRaces to update
     */
    where?: CreatureRaceWhereInput
    /**
     * Limit how many CreatureRaces to update.
     */
    limit?: number
  }

  /**
   * CreatureRace upsert
   */
  export type CreatureRaceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreatureRace
     */
    select?: CreatureRaceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CreatureRace
     */
    omit?: CreatureRaceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreatureRaceInclude<ExtArgs> | null
    /**
     * The filter to search for the CreatureRace to update in case it exists.
     */
    where: CreatureRaceWhereUniqueInput
    /**
     * In case the CreatureRace found by the `where` argument doesn't exist, create a new CreatureRace with this data.
     */
    create: XOR<CreatureRaceCreateInput, CreatureRaceUncheckedCreateInput>
    /**
     * In case the CreatureRace was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CreatureRaceUpdateInput, CreatureRaceUncheckedUpdateInput>
  }

  /**
   * CreatureRace delete
   */
  export type CreatureRaceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreatureRace
     */
    select?: CreatureRaceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CreatureRace
     */
    omit?: CreatureRaceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreatureRaceInclude<ExtArgs> | null
    /**
     * Filter which CreatureRace to delete.
     */
    where: CreatureRaceWhereUniqueInput
  }

  /**
   * CreatureRace deleteMany
   */
  export type CreatureRaceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CreatureRaces to delete
     */
    where?: CreatureRaceWhereInput
    /**
     * Limit how many CreatureRaces to delete.
     */
    limit?: number
  }

  /**
   * CreatureRace.traits_relation
   */
  export type CreatureRace$traits_relationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Trait
     */
    select?: TraitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Trait
     */
    omit?: TraitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TraitInclude<ExtArgs> | null
    where?: TraitWhereInput
    orderBy?: TraitOrderByWithRelationInput | TraitOrderByWithRelationInput[]
    cursor?: TraitWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TraitScalarFieldEnum | TraitScalarFieldEnum[]
  }

  /**
   * CreatureRace.actions_relation
   */
  export type CreatureRace$actions_relationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Action
     */
    select?: ActionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Action
     */
    omit?: ActionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActionInclude<ExtArgs> | null
    where?: ActionWhereInput
    orderBy?: ActionOrderByWithRelationInput | ActionOrderByWithRelationInput[]
    cursor?: ActionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ActionScalarFieldEnum | ActionScalarFieldEnum[]
  }

  /**
   * CreatureRace.creatures_relation
   */
  export type CreatureRace$creatures_relationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Creature
     */
    select?: CreatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Creature
     */
    omit?: CreatureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreatureInclude<ExtArgs> | null
    where?: CreatureWhereInput
    orderBy?: CreatureOrderByWithRelationInput | CreatureOrderByWithRelationInput[]
    cursor?: CreatureWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CreatureScalarFieldEnum | CreatureScalarFieldEnum[]
  }

  /**
   * CreatureRace without action
   */
  export type CreatureRaceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreatureRace
     */
    select?: CreatureRaceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CreatureRace
     */
    omit?: CreatureRaceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreatureRaceInclude<ExtArgs> | null
  }


  /**
   * Model DamageType
   */

  export type AggregateDamageType = {
    _count: DamageTypeCountAggregateOutputType | null
    _min: DamageTypeMinAggregateOutputType | null
    _max: DamageTypeMaxAggregateOutputType | null
  }

  export type DamageTypeMinAggregateOutputType = {
    id: string | null
    name: string | null
  }

  export type DamageTypeMaxAggregateOutputType = {
    id: string | null
    name: string | null
  }

  export type DamageTypeCountAggregateOutputType = {
    id: number
    name: number
    _all: number
  }


  export type DamageTypeMinAggregateInputType = {
    id?: true
    name?: true
  }

  export type DamageTypeMaxAggregateInputType = {
    id?: true
    name?: true
  }

  export type DamageTypeCountAggregateInputType = {
    id?: true
    name?: true
    _all?: true
  }

  export type DamageTypeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DamageType to aggregate.
     */
    where?: DamageTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DamageTypes to fetch.
     */
    orderBy?: DamageTypeOrderByWithRelationInput | DamageTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DamageTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DamageTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DamageTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DamageTypes
    **/
    _count?: true | DamageTypeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DamageTypeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DamageTypeMaxAggregateInputType
  }

  export type GetDamageTypeAggregateType<T extends DamageTypeAggregateArgs> = {
        [P in keyof T & keyof AggregateDamageType]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDamageType[P]>
      : GetScalarType<T[P], AggregateDamageType[P]>
  }




  export type DamageTypeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DamageTypeWhereInput
    orderBy?: DamageTypeOrderByWithAggregationInput | DamageTypeOrderByWithAggregationInput[]
    by: DamageTypeScalarFieldEnum[] | DamageTypeScalarFieldEnum
    having?: DamageTypeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DamageTypeCountAggregateInputType | true
    _min?: DamageTypeMinAggregateInputType
    _max?: DamageTypeMaxAggregateInputType
  }

  export type DamageTypeGroupByOutputType = {
    id: string
    name: string
    _count: DamageTypeCountAggregateOutputType | null
    _min: DamageTypeMinAggregateOutputType | null
    _max: DamageTypeMaxAggregateOutputType | null
  }

  type GetDamageTypeGroupByPayload<T extends DamageTypeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DamageTypeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DamageTypeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DamageTypeGroupByOutputType[P]>
            : GetScalarType<T[P], DamageTypeGroupByOutputType[P]>
        }
      >
    >


  export type DamageTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    resistant_creatures_relation?: boolean | DamageType$resistant_creatures_relationArgs<ExtArgs>
    immune_creatures_relation?: boolean | DamageType$immune_creatures_relationArgs<ExtArgs>
    vulnerable_creatures_relation?: boolean | DamageType$vulnerable_creatures_relationArgs<ExtArgs>
    _count?: boolean | DamageTypeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["damageType"]>

  export type DamageTypeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
  }, ExtArgs["result"]["damageType"]>

  export type DamageTypeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
  }, ExtArgs["result"]["damageType"]>

  export type DamageTypeSelectScalar = {
    id?: boolean
    name?: boolean
  }

  export type DamageTypeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name", ExtArgs["result"]["damageType"]>
  export type DamageTypeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    resistant_creatures_relation?: boolean | DamageType$resistant_creatures_relationArgs<ExtArgs>
    immune_creatures_relation?: boolean | DamageType$immune_creatures_relationArgs<ExtArgs>
    vulnerable_creatures_relation?: boolean | DamageType$vulnerable_creatures_relationArgs<ExtArgs>
    _count?: boolean | DamageTypeCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type DamageTypeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type DamageTypeIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $DamageTypePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DamageType"
    objects: {
      resistant_creatures_relation: Prisma.$CreaturePayload<ExtArgs>[]
      immune_creatures_relation: Prisma.$CreaturePayload<ExtArgs>[]
      vulnerable_creatures_relation: Prisma.$CreaturePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
    }, ExtArgs["result"]["damageType"]>
    composites: {}
  }

  type DamageTypeGetPayload<S extends boolean | null | undefined | DamageTypeDefaultArgs> = $Result.GetResult<Prisma.$DamageTypePayload, S>

  type DamageTypeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DamageTypeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DamageTypeCountAggregateInputType | true
    }

  export interface DamageTypeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DamageType'], meta: { name: 'DamageType' } }
    /**
     * Find zero or one DamageType that matches the filter.
     * @param {DamageTypeFindUniqueArgs} args - Arguments to find a DamageType
     * @example
     * // Get one DamageType
     * const damageType = await prisma.damageType.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DamageTypeFindUniqueArgs>(args: SelectSubset<T, DamageTypeFindUniqueArgs<ExtArgs>>): Prisma__DamageTypeClient<$Result.GetResult<Prisma.$DamageTypePayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one DamageType that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DamageTypeFindUniqueOrThrowArgs} args - Arguments to find a DamageType
     * @example
     * // Get one DamageType
     * const damageType = await prisma.damageType.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DamageTypeFindUniqueOrThrowArgs>(args: SelectSubset<T, DamageTypeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DamageTypeClient<$Result.GetResult<Prisma.$DamageTypePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first DamageType that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DamageTypeFindFirstArgs} args - Arguments to find a DamageType
     * @example
     * // Get one DamageType
     * const damageType = await prisma.damageType.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DamageTypeFindFirstArgs>(args?: SelectSubset<T, DamageTypeFindFirstArgs<ExtArgs>>): Prisma__DamageTypeClient<$Result.GetResult<Prisma.$DamageTypePayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first DamageType that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DamageTypeFindFirstOrThrowArgs} args - Arguments to find a DamageType
     * @example
     * // Get one DamageType
     * const damageType = await prisma.damageType.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DamageTypeFindFirstOrThrowArgs>(args?: SelectSubset<T, DamageTypeFindFirstOrThrowArgs<ExtArgs>>): Prisma__DamageTypeClient<$Result.GetResult<Prisma.$DamageTypePayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more DamageTypes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DamageTypeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DamageTypes
     * const damageTypes = await prisma.damageType.findMany()
     * 
     * // Get first 10 DamageTypes
     * const damageTypes = await prisma.damageType.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const damageTypeWithIdOnly = await prisma.damageType.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DamageTypeFindManyArgs>(args?: SelectSubset<T, DamageTypeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DamageTypePayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a DamageType.
     * @param {DamageTypeCreateArgs} args - Arguments to create a DamageType.
     * @example
     * // Create one DamageType
     * const DamageType = await prisma.damageType.create({
     *   data: {
     *     // ... data to create a DamageType
     *   }
     * })
     * 
     */
    create<T extends DamageTypeCreateArgs>(args: SelectSubset<T, DamageTypeCreateArgs<ExtArgs>>): Prisma__DamageTypeClient<$Result.GetResult<Prisma.$DamageTypePayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many DamageTypes.
     * @param {DamageTypeCreateManyArgs} args - Arguments to create many DamageTypes.
     * @example
     * // Create many DamageTypes
     * const damageType = await prisma.damageType.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DamageTypeCreateManyArgs>(args?: SelectSubset<T, DamageTypeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DamageTypes and returns the data saved in the database.
     * @param {DamageTypeCreateManyAndReturnArgs} args - Arguments to create many DamageTypes.
     * @example
     * // Create many DamageTypes
     * const damageType = await prisma.damageType.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DamageTypes and only return the `id`
     * const damageTypeWithIdOnly = await prisma.damageType.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DamageTypeCreateManyAndReturnArgs>(args?: SelectSubset<T, DamageTypeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DamageTypePayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a DamageType.
     * @param {DamageTypeDeleteArgs} args - Arguments to delete one DamageType.
     * @example
     * // Delete one DamageType
     * const DamageType = await prisma.damageType.delete({
     *   where: {
     *     // ... filter to delete one DamageType
     *   }
     * })
     * 
     */
    delete<T extends DamageTypeDeleteArgs>(args: SelectSubset<T, DamageTypeDeleteArgs<ExtArgs>>): Prisma__DamageTypeClient<$Result.GetResult<Prisma.$DamageTypePayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one DamageType.
     * @param {DamageTypeUpdateArgs} args - Arguments to update one DamageType.
     * @example
     * // Update one DamageType
     * const damageType = await prisma.damageType.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DamageTypeUpdateArgs>(args: SelectSubset<T, DamageTypeUpdateArgs<ExtArgs>>): Prisma__DamageTypeClient<$Result.GetResult<Prisma.$DamageTypePayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more DamageTypes.
     * @param {DamageTypeDeleteManyArgs} args - Arguments to filter DamageTypes to delete.
     * @example
     * // Delete a few DamageTypes
     * const { count } = await prisma.damageType.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DamageTypeDeleteManyArgs>(args?: SelectSubset<T, DamageTypeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DamageTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DamageTypeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DamageTypes
     * const damageType = await prisma.damageType.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DamageTypeUpdateManyArgs>(args: SelectSubset<T, DamageTypeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DamageTypes and returns the data updated in the database.
     * @param {DamageTypeUpdateManyAndReturnArgs} args - Arguments to update many DamageTypes.
     * @example
     * // Update many DamageTypes
     * const damageType = await prisma.damageType.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more DamageTypes and only return the `id`
     * const damageTypeWithIdOnly = await prisma.damageType.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DamageTypeUpdateManyAndReturnArgs>(args: SelectSubset<T, DamageTypeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DamageTypePayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one DamageType.
     * @param {DamageTypeUpsertArgs} args - Arguments to update or create a DamageType.
     * @example
     * // Update or create a DamageType
     * const damageType = await prisma.damageType.upsert({
     *   create: {
     *     // ... data to create a DamageType
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DamageType we want to update
     *   }
     * })
     */
    upsert<T extends DamageTypeUpsertArgs>(args: SelectSubset<T, DamageTypeUpsertArgs<ExtArgs>>): Prisma__DamageTypeClient<$Result.GetResult<Prisma.$DamageTypePayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of DamageTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DamageTypeCountArgs} args - Arguments to filter DamageTypes to count.
     * @example
     * // Count the number of DamageTypes
     * const count = await prisma.damageType.count({
     *   where: {
     *     // ... the filter for the DamageTypes we want to count
     *   }
     * })
    **/
    count<T extends DamageTypeCountArgs>(
      args?: Subset<T, DamageTypeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DamageTypeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DamageType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DamageTypeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DamageTypeAggregateArgs>(args: Subset<T, DamageTypeAggregateArgs>): Prisma.PrismaPromise<GetDamageTypeAggregateType<T>>

    /**
     * Group by DamageType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DamageTypeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DamageTypeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DamageTypeGroupByArgs['orderBy'] }
        : { orderBy?: DamageTypeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DamageTypeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDamageTypeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DamageType model
   */
  readonly fields: DamageTypeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DamageType.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DamageTypeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    resistant_creatures_relation<T extends DamageType$resistant_creatures_relationArgs<ExtArgs> = {}>(args?: Subset<T, DamageType$resistant_creatures_relationArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CreaturePayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    immune_creatures_relation<T extends DamageType$immune_creatures_relationArgs<ExtArgs> = {}>(args?: Subset<T, DamageType$immune_creatures_relationArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CreaturePayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    vulnerable_creatures_relation<T extends DamageType$vulnerable_creatures_relationArgs<ExtArgs> = {}>(args?: Subset<T, DamageType$vulnerable_creatures_relationArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CreaturePayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DamageType model
   */ 
  interface DamageTypeFieldRefs {
    readonly id: FieldRef<"DamageType", 'String'>
    readonly name: FieldRef<"DamageType", 'String'>
  }
    

  // Custom InputTypes
  /**
   * DamageType findUnique
   */
  export type DamageTypeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DamageType
     */
    select?: DamageTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DamageType
     */
    omit?: DamageTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DamageTypeInclude<ExtArgs> | null
    /**
     * Filter, which DamageType to fetch.
     */
    where: DamageTypeWhereUniqueInput
  }

  /**
   * DamageType findUniqueOrThrow
   */
  export type DamageTypeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DamageType
     */
    select?: DamageTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DamageType
     */
    omit?: DamageTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DamageTypeInclude<ExtArgs> | null
    /**
     * Filter, which DamageType to fetch.
     */
    where: DamageTypeWhereUniqueInput
  }

  /**
   * DamageType findFirst
   */
  export type DamageTypeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DamageType
     */
    select?: DamageTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DamageType
     */
    omit?: DamageTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DamageTypeInclude<ExtArgs> | null
    /**
     * Filter, which DamageType to fetch.
     */
    where?: DamageTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DamageTypes to fetch.
     */
    orderBy?: DamageTypeOrderByWithRelationInput | DamageTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DamageTypes.
     */
    cursor?: DamageTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DamageTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DamageTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DamageTypes.
     */
    distinct?: DamageTypeScalarFieldEnum | DamageTypeScalarFieldEnum[]
  }

  /**
   * DamageType findFirstOrThrow
   */
  export type DamageTypeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DamageType
     */
    select?: DamageTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DamageType
     */
    omit?: DamageTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DamageTypeInclude<ExtArgs> | null
    /**
     * Filter, which DamageType to fetch.
     */
    where?: DamageTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DamageTypes to fetch.
     */
    orderBy?: DamageTypeOrderByWithRelationInput | DamageTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DamageTypes.
     */
    cursor?: DamageTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DamageTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DamageTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DamageTypes.
     */
    distinct?: DamageTypeScalarFieldEnum | DamageTypeScalarFieldEnum[]
  }

  /**
   * DamageType findMany
   */
  export type DamageTypeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DamageType
     */
    select?: DamageTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DamageType
     */
    omit?: DamageTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DamageTypeInclude<ExtArgs> | null
    /**
     * Filter, which DamageTypes to fetch.
     */
    where?: DamageTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DamageTypes to fetch.
     */
    orderBy?: DamageTypeOrderByWithRelationInput | DamageTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DamageTypes.
     */
    cursor?: DamageTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DamageTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DamageTypes.
     */
    skip?: number
    distinct?: DamageTypeScalarFieldEnum | DamageTypeScalarFieldEnum[]
  }

  /**
   * DamageType create
   */
  export type DamageTypeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DamageType
     */
    select?: DamageTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DamageType
     */
    omit?: DamageTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DamageTypeInclude<ExtArgs> | null
    /**
     * The data needed to create a DamageType.
     */
    data: XOR<DamageTypeCreateInput, DamageTypeUncheckedCreateInput>
  }

  /**
   * DamageType createMany
   */
  export type DamageTypeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DamageTypes.
     */
    data: DamageTypeCreateManyInput | DamageTypeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DamageType createManyAndReturn
   */
  export type DamageTypeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DamageType
     */
    select?: DamageTypeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DamageType
     */
    omit?: DamageTypeOmit<ExtArgs> | null
    /**
     * The data used to create many DamageTypes.
     */
    data: DamageTypeCreateManyInput | DamageTypeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DamageType update
   */
  export type DamageTypeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DamageType
     */
    select?: DamageTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DamageType
     */
    omit?: DamageTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DamageTypeInclude<ExtArgs> | null
    /**
     * The data needed to update a DamageType.
     */
    data: XOR<DamageTypeUpdateInput, DamageTypeUncheckedUpdateInput>
    /**
     * Choose, which DamageType to update.
     */
    where: DamageTypeWhereUniqueInput
  }

  /**
   * DamageType updateMany
   */
  export type DamageTypeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DamageTypes.
     */
    data: XOR<DamageTypeUpdateManyMutationInput, DamageTypeUncheckedUpdateManyInput>
    /**
     * Filter which DamageTypes to update
     */
    where?: DamageTypeWhereInput
    /**
     * Limit how many DamageTypes to update.
     */
    limit?: number
  }

  /**
   * DamageType updateManyAndReturn
   */
  export type DamageTypeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DamageType
     */
    select?: DamageTypeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DamageType
     */
    omit?: DamageTypeOmit<ExtArgs> | null
    /**
     * The data used to update DamageTypes.
     */
    data: XOR<DamageTypeUpdateManyMutationInput, DamageTypeUncheckedUpdateManyInput>
    /**
     * Filter which DamageTypes to update
     */
    where?: DamageTypeWhereInput
    /**
     * Limit how many DamageTypes to update.
     */
    limit?: number
  }

  /**
   * DamageType upsert
   */
  export type DamageTypeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DamageType
     */
    select?: DamageTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DamageType
     */
    omit?: DamageTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DamageTypeInclude<ExtArgs> | null
    /**
     * The filter to search for the DamageType to update in case it exists.
     */
    where: DamageTypeWhereUniqueInput
    /**
     * In case the DamageType found by the `where` argument doesn't exist, create a new DamageType with this data.
     */
    create: XOR<DamageTypeCreateInput, DamageTypeUncheckedCreateInput>
    /**
     * In case the DamageType was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DamageTypeUpdateInput, DamageTypeUncheckedUpdateInput>
  }

  /**
   * DamageType delete
   */
  export type DamageTypeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DamageType
     */
    select?: DamageTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DamageType
     */
    omit?: DamageTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DamageTypeInclude<ExtArgs> | null
    /**
     * Filter which DamageType to delete.
     */
    where: DamageTypeWhereUniqueInput
  }

  /**
   * DamageType deleteMany
   */
  export type DamageTypeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DamageTypes to delete
     */
    where?: DamageTypeWhereInput
    /**
     * Limit how many DamageTypes to delete.
     */
    limit?: number
  }

  /**
   * DamageType.resistant_creatures_relation
   */
  export type DamageType$resistant_creatures_relationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Creature
     */
    select?: CreatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Creature
     */
    omit?: CreatureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreatureInclude<ExtArgs> | null
    where?: CreatureWhereInput
    orderBy?: CreatureOrderByWithRelationInput | CreatureOrderByWithRelationInput[]
    cursor?: CreatureWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CreatureScalarFieldEnum | CreatureScalarFieldEnum[]
  }

  /**
   * DamageType.immune_creatures_relation
   */
  export type DamageType$immune_creatures_relationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Creature
     */
    select?: CreatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Creature
     */
    omit?: CreatureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreatureInclude<ExtArgs> | null
    where?: CreatureWhereInput
    orderBy?: CreatureOrderByWithRelationInput | CreatureOrderByWithRelationInput[]
    cursor?: CreatureWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CreatureScalarFieldEnum | CreatureScalarFieldEnum[]
  }

  /**
   * DamageType.vulnerable_creatures_relation
   */
  export type DamageType$vulnerable_creatures_relationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Creature
     */
    select?: CreatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Creature
     */
    omit?: CreatureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreatureInclude<ExtArgs> | null
    where?: CreatureWhereInput
    orderBy?: CreatureOrderByWithRelationInput | CreatureOrderByWithRelationInput[]
    cursor?: CreatureWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CreatureScalarFieldEnum | CreatureScalarFieldEnum[]
  }

  /**
   * DamageType without action
   */
  export type DamageTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DamageType
     */
    select?: DamageTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DamageType
     */
    omit?: DamageTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DamageTypeInclude<ExtArgs> | null
  }


  /**
   * Model ChallengeRatingMetadata
   */

  export type AggregateChallengeRatingMetadata = {
    _count: ChallengeRatingMetadataCountAggregateOutputType | null
    _avg: ChallengeRatingMetadataAvgAggregateOutputType | null
    _sum: ChallengeRatingMetadataSumAggregateOutputType | null
    _min: ChallengeRatingMetadataMinAggregateOutputType | null
    _max: ChallengeRatingMetadataMaxAggregateOutputType | null
  }

  export type ChallengeRatingMetadataAvgAggregateOutputType = {
    numeric: number | null
    xp_reward: number | null
  }

  export type ChallengeRatingMetadataSumAggregateOutputType = {
    numeric: number | null
    xp_reward: number | null
  }

  export type ChallengeRatingMetadataMinAggregateOutputType = {
    cr: $Enums.ChallengeRatingEnum | null
    display: string | null
    numeric: number | null
    xp_reward: number | null
  }

  export type ChallengeRatingMetadataMaxAggregateOutputType = {
    cr: $Enums.ChallengeRatingEnum | null
    display: string | null
    numeric: number | null
    xp_reward: number | null
  }

  export type ChallengeRatingMetadataCountAggregateOutputType = {
    cr: number
    display: number
    numeric: number
    xp_reward: number
    _all: number
  }


  export type ChallengeRatingMetadataAvgAggregateInputType = {
    numeric?: true
    xp_reward?: true
  }

  export type ChallengeRatingMetadataSumAggregateInputType = {
    numeric?: true
    xp_reward?: true
  }

  export type ChallengeRatingMetadataMinAggregateInputType = {
    cr?: true
    display?: true
    numeric?: true
    xp_reward?: true
  }

  export type ChallengeRatingMetadataMaxAggregateInputType = {
    cr?: true
    display?: true
    numeric?: true
    xp_reward?: true
  }

  export type ChallengeRatingMetadataCountAggregateInputType = {
    cr?: true
    display?: true
    numeric?: true
    xp_reward?: true
    _all?: true
  }

  export type ChallengeRatingMetadataAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ChallengeRatingMetadata to aggregate.
     */
    where?: ChallengeRatingMetadataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChallengeRatingMetadata to fetch.
     */
    orderBy?: ChallengeRatingMetadataOrderByWithRelationInput | ChallengeRatingMetadataOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ChallengeRatingMetadataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChallengeRatingMetadata from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChallengeRatingMetadata.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ChallengeRatingMetadata
    **/
    _count?: true | ChallengeRatingMetadataCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ChallengeRatingMetadataAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ChallengeRatingMetadataSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ChallengeRatingMetadataMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ChallengeRatingMetadataMaxAggregateInputType
  }

  export type GetChallengeRatingMetadataAggregateType<T extends ChallengeRatingMetadataAggregateArgs> = {
        [P in keyof T & keyof AggregateChallengeRatingMetadata]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateChallengeRatingMetadata[P]>
      : GetScalarType<T[P], AggregateChallengeRatingMetadata[P]>
  }




  export type ChallengeRatingMetadataGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChallengeRatingMetadataWhereInput
    orderBy?: ChallengeRatingMetadataOrderByWithAggregationInput | ChallengeRatingMetadataOrderByWithAggregationInput[]
    by: ChallengeRatingMetadataScalarFieldEnum[] | ChallengeRatingMetadataScalarFieldEnum
    having?: ChallengeRatingMetadataScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ChallengeRatingMetadataCountAggregateInputType | true
    _avg?: ChallengeRatingMetadataAvgAggregateInputType
    _sum?: ChallengeRatingMetadataSumAggregateInputType
    _min?: ChallengeRatingMetadataMinAggregateInputType
    _max?: ChallengeRatingMetadataMaxAggregateInputType
  }

  export type ChallengeRatingMetadataGroupByOutputType = {
    cr: $Enums.ChallengeRatingEnum
    display: string
    numeric: number
    xp_reward: number
    _count: ChallengeRatingMetadataCountAggregateOutputType | null
    _avg: ChallengeRatingMetadataAvgAggregateOutputType | null
    _sum: ChallengeRatingMetadataSumAggregateOutputType | null
    _min: ChallengeRatingMetadataMinAggregateOutputType | null
    _max: ChallengeRatingMetadataMaxAggregateOutputType | null
  }

  type GetChallengeRatingMetadataGroupByPayload<T extends ChallengeRatingMetadataGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ChallengeRatingMetadataGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ChallengeRatingMetadataGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ChallengeRatingMetadataGroupByOutputType[P]>
            : GetScalarType<T[P], ChallengeRatingMetadataGroupByOutputType[P]>
        }
      >
    >


  export type ChallengeRatingMetadataSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    cr?: boolean
    display?: boolean
    numeric?: boolean
    xp_reward?: boolean
    creatures?: boolean | ChallengeRatingMetadata$creaturesArgs<ExtArgs>
    _count?: boolean | ChallengeRatingMetadataCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["challengeRatingMetadata"]>

  export type ChallengeRatingMetadataSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    cr?: boolean
    display?: boolean
    numeric?: boolean
    xp_reward?: boolean
  }, ExtArgs["result"]["challengeRatingMetadata"]>

  export type ChallengeRatingMetadataSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    cr?: boolean
    display?: boolean
    numeric?: boolean
    xp_reward?: boolean
  }, ExtArgs["result"]["challengeRatingMetadata"]>

  export type ChallengeRatingMetadataSelectScalar = {
    cr?: boolean
    display?: boolean
    numeric?: boolean
    xp_reward?: boolean
  }

  export type ChallengeRatingMetadataOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"cr" | "display" | "numeric" | "xp_reward", ExtArgs["result"]["challengeRatingMetadata"]>
  export type ChallengeRatingMetadataInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creatures?: boolean | ChallengeRatingMetadata$creaturesArgs<ExtArgs>
    _count?: boolean | ChallengeRatingMetadataCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ChallengeRatingMetadataIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type ChallengeRatingMetadataIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $ChallengeRatingMetadataPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ChallengeRatingMetadata"
    objects: {
      creatures: Prisma.$CreaturePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      cr: $Enums.ChallengeRatingEnum
      display: string
      numeric: number
      xp_reward: number
    }, ExtArgs["result"]["challengeRatingMetadata"]>
    composites: {}
  }

  type ChallengeRatingMetadataGetPayload<S extends boolean | null | undefined | ChallengeRatingMetadataDefaultArgs> = $Result.GetResult<Prisma.$ChallengeRatingMetadataPayload, S>

  type ChallengeRatingMetadataCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ChallengeRatingMetadataFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ChallengeRatingMetadataCountAggregateInputType | true
    }

  export interface ChallengeRatingMetadataDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ChallengeRatingMetadata'], meta: { name: 'ChallengeRatingMetadata' } }
    /**
     * Find zero or one ChallengeRatingMetadata that matches the filter.
     * @param {ChallengeRatingMetadataFindUniqueArgs} args - Arguments to find a ChallengeRatingMetadata
     * @example
     * // Get one ChallengeRatingMetadata
     * const challengeRatingMetadata = await prisma.challengeRatingMetadata.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ChallengeRatingMetadataFindUniqueArgs>(args: SelectSubset<T, ChallengeRatingMetadataFindUniqueArgs<ExtArgs>>): Prisma__ChallengeRatingMetadataClient<$Result.GetResult<Prisma.$ChallengeRatingMetadataPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one ChallengeRatingMetadata that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ChallengeRatingMetadataFindUniqueOrThrowArgs} args - Arguments to find a ChallengeRatingMetadata
     * @example
     * // Get one ChallengeRatingMetadata
     * const challengeRatingMetadata = await prisma.challengeRatingMetadata.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ChallengeRatingMetadataFindUniqueOrThrowArgs>(args: SelectSubset<T, ChallengeRatingMetadataFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ChallengeRatingMetadataClient<$Result.GetResult<Prisma.$ChallengeRatingMetadataPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first ChallengeRatingMetadata that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChallengeRatingMetadataFindFirstArgs} args - Arguments to find a ChallengeRatingMetadata
     * @example
     * // Get one ChallengeRatingMetadata
     * const challengeRatingMetadata = await prisma.challengeRatingMetadata.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ChallengeRatingMetadataFindFirstArgs>(args?: SelectSubset<T, ChallengeRatingMetadataFindFirstArgs<ExtArgs>>): Prisma__ChallengeRatingMetadataClient<$Result.GetResult<Prisma.$ChallengeRatingMetadataPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first ChallengeRatingMetadata that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChallengeRatingMetadataFindFirstOrThrowArgs} args - Arguments to find a ChallengeRatingMetadata
     * @example
     * // Get one ChallengeRatingMetadata
     * const challengeRatingMetadata = await prisma.challengeRatingMetadata.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ChallengeRatingMetadataFindFirstOrThrowArgs>(args?: SelectSubset<T, ChallengeRatingMetadataFindFirstOrThrowArgs<ExtArgs>>): Prisma__ChallengeRatingMetadataClient<$Result.GetResult<Prisma.$ChallengeRatingMetadataPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more ChallengeRatingMetadata that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChallengeRatingMetadataFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ChallengeRatingMetadata
     * const challengeRatingMetadata = await prisma.challengeRatingMetadata.findMany()
     * 
     * // Get first 10 ChallengeRatingMetadata
     * const challengeRatingMetadata = await prisma.challengeRatingMetadata.findMany({ take: 10 })
     * 
     * // Only select the `display`
     * const challengeRatingMetadataWithDisplayOnly = await prisma.challengeRatingMetadata.findMany({ select: { display: true } })
     * 
     */
    findMany<T extends ChallengeRatingMetadataFindManyArgs>(args?: SelectSubset<T, ChallengeRatingMetadataFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChallengeRatingMetadataPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a ChallengeRatingMetadata.
     * @param {ChallengeRatingMetadataCreateArgs} args - Arguments to create a ChallengeRatingMetadata.
     * @example
     * // Create one ChallengeRatingMetadata
     * const ChallengeRatingMetadata = await prisma.challengeRatingMetadata.create({
     *   data: {
     *     // ... data to create a ChallengeRatingMetadata
     *   }
     * })
     * 
     */
    create<T extends ChallengeRatingMetadataCreateArgs>(args: SelectSubset<T, ChallengeRatingMetadataCreateArgs<ExtArgs>>): Prisma__ChallengeRatingMetadataClient<$Result.GetResult<Prisma.$ChallengeRatingMetadataPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many ChallengeRatingMetadata.
     * @param {ChallengeRatingMetadataCreateManyArgs} args - Arguments to create many ChallengeRatingMetadata.
     * @example
     * // Create many ChallengeRatingMetadata
     * const challengeRatingMetadata = await prisma.challengeRatingMetadata.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ChallengeRatingMetadataCreateManyArgs>(args?: SelectSubset<T, ChallengeRatingMetadataCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ChallengeRatingMetadata and returns the data saved in the database.
     * @param {ChallengeRatingMetadataCreateManyAndReturnArgs} args - Arguments to create many ChallengeRatingMetadata.
     * @example
     * // Create many ChallengeRatingMetadata
     * const challengeRatingMetadata = await prisma.challengeRatingMetadata.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ChallengeRatingMetadata and only return the `display`
     * const challengeRatingMetadataWithDisplayOnly = await prisma.challengeRatingMetadata.createManyAndReturn({
     *   select: { display: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ChallengeRatingMetadataCreateManyAndReturnArgs>(args?: SelectSubset<T, ChallengeRatingMetadataCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChallengeRatingMetadataPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a ChallengeRatingMetadata.
     * @param {ChallengeRatingMetadataDeleteArgs} args - Arguments to delete one ChallengeRatingMetadata.
     * @example
     * // Delete one ChallengeRatingMetadata
     * const ChallengeRatingMetadata = await prisma.challengeRatingMetadata.delete({
     *   where: {
     *     // ... filter to delete one ChallengeRatingMetadata
     *   }
     * })
     * 
     */
    delete<T extends ChallengeRatingMetadataDeleteArgs>(args: SelectSubset<T, ChallengeRatingMetadataDeleteArgs<ExtArgs>>): Prisma__ChallengeRatingMetadataClient<$Result.GetResult<Prisma.$ChallengeRatingMetadataPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one ChallengeRatingMetadata.
     * @param {ChallengeRatingMetadataUpdateArgs} args - Arguments to update one ChallengeRatingMetadata.
     * @example
     * // Update one ChallengeRatingMetadata
     * const challengeRatingMetadata = await prisma.challengeRatingMetadata.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ChallengeRatingMetadataUpdateArgs>(args: SelectSubset<T, ChallengeRatingMetadataUpdateArgs<ExtArgs>>): Prisma__ChallengeRatingMetadataClient<$Result.GetResult<Prisma.$ChallengeRatingMetadataPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more ChallengeRatingMetadata.
     * @param {ChallengeRatingMetadataDeleteManyArgs} args - Arguments to filter ChallengeRatingMetadata to delete.
     * @example
     * // Delete a few ChallengeRatingMetadata
     * const { count } = await prisma.challengeRatingMetadata.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ChallengeRatingMetadataDeleteManyArgs>(args?: SelectSubset<T, ChallengeRatingMetadataDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ChallengeRatingMetadata.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChallengeRatingMetadataUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ChallengeRatingMetadata
     * const challengeRatingMetadata = await prisma.challengeRatingMetadata.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ChallengeRatingMetadataUpdateManyArgs>(args: SelectSubset<T, ChallengeRatingMetadataUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ChallengeRatingMetadata and returns the data updated in the database.
     * @param {ChallengeRatingMetadataUpdateManyAndReturnArgs} args - Arguments to update many ChallengeRatingMetadata.
     * @example
     * // Update many ChallengeRatingMetadata
     * const challengeRatingMetadata = await prisma.challengeRatingMetadata.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ChallengeRatingMetadata and only return the `display`
     * const challengeRatingMetadataWithDisplayOnly = await prisma.challengeRatingMetadata.updateManyAndReturn({
     *   select: { display: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ChallengeRatingMetadataUpdateManyAndReturnArgs>(args: SelectSubset<T, ChallengeRatingMetadataUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChallengeRatingMetadataPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one ChallengeRatingMetadata.
     * @param {ChallengeRatingMetadataUpsertArgs} args - Arguments to update or create a ChallengeRatingMetadata.
     * @example
     * // Update or create a ChallengeRatingMetadata
     * const challengeRatingMetadata = await prisma.challengeRatingMetadata.upsert({
     *   create: {
     *     // ... data to create a ChallengeRatingMetadata
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ChallengeRatingMetadata we want to update
     *   }
     * })
     */
    upsert<T extends ChallengeRatingMetadataUpsertArgs>(args: SelectSubset<T, ChallengeRatingMetadataUpsertArgs<ExtArgs>>): Prisma__ChallengeRatingMetadataClient<$Result.GetResult<Prisma.$ChallengeRatingMetadataPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of ChallengeRatingMetadata.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChallengeRatingMetadataCountArgs} args - Arguments to filter ChallengeRatingMetadata to count.
     * @example
     * // Count the number of ChallengeRatingMetadata
     * const count = await prisma.challengeRatingMetadata.count({
     *   where: {
     *     // ... the filter for the ChallengeRatingMetadata we want to count
     *   }
     * })
    **/
    count<T extends ChallengeRatingMetadataCountArgs>(
      args?: Subset<T, ChallengeRatingMetadataCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ChallengeRatingMetadataCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ChallengeRatingMetadata.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChallengeRatingMetadataAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ChallengeRatingMetadataAggregateArgs>(args: Subset<T, ChallengeRatingMetadataAggregateArgs>): Prisma.PrismaPromise<GetChallengeRatingMetadataAggregateType<T>>

    /**
     * Group by ChallengeRatingMetadata.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChallengeRatingMetadataGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ChallengeRatingMetadataGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ChallengeRatingMetadataGroupByArgs['orderBy'] }
        : { orderBy?: ChallengeRatingMetadataGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ChallengeRatingMetadataGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetChallengeRatingMetadataGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ChallengeRatingMetadata model
   */
  readonly fields: ChallengeRatingMetadataFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ChallengeRatingMetadata.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ChallengeRatingMetadataClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    creatures<T extends ChallengeRatingMetadata$creaturesArgs<ExtArgs> = {}>(args?: Subset<T, ChallengeRatingMetadata$creaturesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CreaturePayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ChallengeRatingMetadata model
   */ 
  interface ChallengeRatingMetadataFieldRefs {
    readonly cr: FieldRef<"ChallengeRatingMetadata", 'ChallengeRatingEnum'>
    readonly display: FieldRef<"ChallengeRatingMetadata", 'String'>
    readonly numeric: FieldRef<"ChallengeRatingMetadata", 'Float'>
    readonly xp_reward: FieldRef<"ChallengeRatingMetadata", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * ChallengeRatingMetadata findUnique
   */
  export type ChallengeRatingMetadataFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeRatingMetadata
     */
    select?: ChallengeRatingMetadataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengeRatingMetadata
     */
    omit?: ChallengeRatingMetadataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeRatingMetadataInclude<ExtArgs> | null
    /**
     * Filter, which ChallengeRatingMetadata to fetch.
     */
    where: ChallengeRatingMetadataWhereUniqueInput
  }

  /**
   * ChallengeRatingMetadata findUniqueOrThrow
   */
  export type ChallengeRatingMetadataFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeRatingMetadata
     */
    select?: ChallengeRatingMetadataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengeRatingMetadata
     */
    omit?: ChallengeRatingMetadataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeRatingMetadataInclude<ExtArgs> | null
    /**
     * Filter, which ChallengeRatingMetadata to fetch.
     */
    where: ChallengeRatingMetadataWhereUniqueInput
  }

  /**
   * ChallengeRatingMetadata findFirst
   */
  export type ChallengeRatingMetadataFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeRatingMetadata
     */
    select?: ChallengeRatingMetadataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengeRatingMetadata
     */
    omit?: ChallengeRatingMetadataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeRatingMetadataInclude<ExtArgs> | null
    /**
     * Filter, which ChallengeRatingMetadata to fetch.
     */
    where?: ChallengeRatingMetadataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChallengeRatingMetadata to fetch.
     */
    orderBy?: ChallengeRatingMetadataOrderByWithRelationInput | ChallengeRatingMetadataOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ChallengeRatingMetadata.
     */
    cursor?: ChallengeRatingMetadataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChallengeRatingMetadata from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChallengeRatingMetadata.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ChallengeRatingMetadata.
     */
    distinct?: ChallengeRatingMetadataScalarFieldEnum | ChallengeRatingMetadataScalarFieldEnum[]
  }

  /**
   * ChallengeRatingMetadata findFirstOrThrow
   */
  export type ChallengeRatingMetadataFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeRatingMetadata
     */
    select?: ChallengeRatingMetadataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengeRatingMetadata
     */
    omit?: ChallengeRatingMetadataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeRatingMetadataInclude<ExtArgs> | null
    /**
     * Filter, which ChallengeRatingMetadata to fetch.
     */
    where?: ChallengeRatingMetadataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChallengeRatingMetadata to fetch.
     */
    orderBy?: ChallengeRatingMetadataOrderByWithRelationInput | ChallengeRatingMetadataOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ChallengeRatingMetadata.
     */
    cursor?: ChallengeRatingMetadataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChallengeRatingMetadata from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChallengeRatingMetadata.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ChallengeRatingMetadata.
     */
    distinct?: ChallengeRatingMetadataScalarFieldEnum | ChallengeRatingMetadataScalarFieldEnum[]
  }

  /**
   * ChallengeRatingMetadata findMany
   */
  export type ChallengeRatingMetadataFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeRatingMetadata
     */
    select?: ChallengeRatingMetadataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengeRatingMetadata
     */
    omit?: ChallengeRatingMetadataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeRatingMetadataInclude<ExtArgs> | null
    /**
     * Filter, which ChallengeRatingMetadata to fetch.
     */
    where?: ChallengeRatingMetadataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChallengeRatingMetadata to fetch.
     */
    orderBy?: ChallengeRatingMetadataOrderByWithRelationInput | ChallengeRatingMetadataOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ChallengeRatingMetadata.
     */
    cursor?: ChallengeRatingMetadataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChallengeRatingMetadata from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChallengeRatingMetadata.
     */
    skip?: number
    distinct?: ChallengeRatingMetadataScalarFieldEnum | ChallengeRatingMetadataScalarFieldEnum[]
  }

  /**
   * ChallengeRatingMetadata create
   */
  export type ChallengeRatingMetadataCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeRatingMetadata
     */
    select?: ChallengeRatingMetadataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengeRatingMetadata
     */
    omit?: ChallengeRatingMetadataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeRatingMetadataInclude<ExtArgs> | null
    /**
     * The data needed to create a ChallengeRatingMetadata.
     */
    data: XOR<ChallengeRatingMetadataCreateInput, ChallengeRatingMetadataUncheckedCreateInput>
  }

  /**
   * ChallengeRatingMetadata createMany
   */
  export type ChallengeRatingMetadataCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ChallengeRatingMetadata.
     */
    data: ChallengeRatingMetadataCreateManyInput | ChallengeRatingMetadataCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ChallengeRatingMetadata createManyAndReturn
   */
  export type ChallengeRatingMetadataCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeRatingMetadata
     */
    select?: ChallengeRatingMetadataSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengeRatingMetadata
     */
    omit?: ChallengeRatingMetadataOmit<ExtArgs> | null
    /**
     * The data used to create many ChallengeRatingMetadata.
     */
    data: ChallengeRatingMetadataCreateManyInput | ChallengeRatingMetadataCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ChallengeRatingMetadata update
   */
  export type ChallengeRatingMetadataUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeRatingMetadata
     */
    select?: ChallengeRatingMetadataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengeRatingMetadata
     */
    omit?: ChallengeRatingMetadataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeRatingMetadataInclude<ExtArgs> | null
    /**
     * The data needed to update a ChallengeRatingMetadata.
     */
    data: XOR<ChallengeRatingMetadataUpdateInput, ChallengeRatingMetadataUncheckedUpdateInput>
    /**
     * Choose, which ChallengeRatingMetadata to update.
     */
    where: ChallengeRatingMetadataWhereUniqueInput
  }

  /**
   * ChallengeRatingMetadata updateMany
   */
  export type ChallengeRatingMetadataUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ChallengeRatingMetadata.
     */
    data: XOR<ChallengeRatingMetadataUpdateManyMutationInput, ChallengeRatingMetadataUncheckedUpdateManyInput>
    /**
     * Filter which ChallengeRatingMetadata to update
     */
    where?: ChallengeRatingMetadataWhereInput
    /**
     * Limit how many ChallengeRatingMetadata to update.
     */
    limit?: number
  }

  /**
   * ChallengeRatingMetadata updateManyAndReturn
   */
  export type ChallengeRatingMetadataUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeRatingMetadata
     */
    select?: ChallengeRatingMetadataSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengeRatingMetadata
     */
    omit?: ChallengeRatingMetadataOmit<ExtArgs> | null
    /**
     * The data used to update ChallengeRatingMetadata.
     */
    data: XOR<ChallengeRatingMetadataUpdateManyMutationInput, ChallengeRatingMetadataUncheckedUpdateManyInput>
    /**
     * Filter which ChallengeRatingMetadata to update
     */
    where?: ChallengeRatingMetadataWhereInput
    /**
     * Limit how many ChallengeRatingMetadata to update.
     */
    limit?: number
  }

  /**
   * ChallengeRatingMetadata upsert
   */
  export type ChallengeRatingMetadataUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeRatingMetadata
     */
    select?: ChallengeRatingMetadataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengeRatingMetadata
     */
    omit?: ChallengeRatingMetadataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeRatingMetadataInclude<ExtArgs> | null
    /**
     * The filter to search for the ChallengeRatingMetadata to update in case it exists.
     */
    where: ChallengeRatingMetadataWhereUniqueInput
    /**
     * In case the ChallengeRatingMetadata found by the `where` argument doesn't exist, create a new ChallengeRatingMetadata with this data.
     */
    create: XOR<ChallengeRatingMetadataCreateInput, ChallengeRatingMetadataUncheckedCreateInput>
    /**
     * In case the ChallengeRatingMetadata was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ChallengeRatingMetadataUpdateInput, ChallengeRatingMetadataUncheckedUpdateInput>
  }

  /**
   * ChallengeRatingMetadata delete
   */
  export type ChallengeRatingMetadataDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeRatingMetadata
     */
    select?: ChallengeRatingMetadataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengeRatingMetadata
     */
    omit?: ChallengeRatingMetadataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeRatingMetadataInclude<ExtArgs> | null
    /**
     * Filter which ChallengeRatingMetadata to delete.
     */
    where: ChallengeRatingMetadataWhereUniqueInput
  }

  /**
   * ChallengeRatingMetadata deleteMany
   */
  export type ChallengeRatingMetadataDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ChallengeRatingMetadata to delete
     */
    where?: ChallengeRatingMetadataWhereInput
    /**
     * Limit how many ChallengeRatingMetadata to delete.
     */
    limit?: number
  }

  /**
   * ChallengeRatingMetadata.creatures
   */
  export type ChallengeRatingMetadata$creaturesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Creature
     */
    select?: CreatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Creature
     */
    omit?: CreatureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreatureInclude<ExtArgs> | null
    where?: CreatureWhereInput
    orderBy?: CreatureOrderByWithRelationInput | CreatureOrderByWithRelationInput[]
    cursor?: CreatureWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CreatureScalarFieldEnum | CreatureScalarFieldEnum[]
  }

  /**
   * ChallengeRatingMetadata without action
   */
  export type ChallengeRatingMetadataDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeRatingMetadata
     */
    select?: ChallengeRatingMetadataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengeRatingMetadata
     */
    omit?: ChallengeRatingMetadataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeRatingMetadataInclude<ExtArgs> | null
  }


  /**
   * Model GenrationRequest
   */

  export type AggregateGenrationRequest = {
    _count: GenrationRequestCountAggregateOutputType | null
    _avg: GenrationRequestAvgAggregateOutputType | null
    _sum: GenrationRequestSumAggregateOutputType | null
    _min: GenrationRequestMinAggregateOutputType | null
    _max: GenrationRequestMaxAggregateOutputType | null
  }

  export type GenrationRequestAvgAggregateOutputType = {
    id: number | null
  }

  export type GenrationRequestSumAggregateOutputType = {
    id: number | null
  }

  export type GenrationRequestMinAggregateOutputType = {
    id: number | null
    request: string | null
    danger: string | null
    name: string | null
  }

  export type GenrationRequestMaxAggregateOutputType = {
    id: number | null
    request: string | null
    danger: string | null
    name: string | null
  }

  export type GenrationRequestCountAggregateOutputType = {
    id: number
    request: number
    danger: number
    name: number
    _all: number
  }


  export type GenrationRequestAvgAggregateInputType = {
    id?: true
  }

  export type GenrationRequestSumAggregateInputType = {
    id?: true
  }

  export type GenrationRequestMinAggregateInputType = {
    id?: true
    request?: true
    danger?: true
    name?: true
  }

  export type GenrationRequestMaxAggregateInputType = {
    id?: true
    request?: true
    danger?: true
    name?: true
  }

  export type GenrationRequestCountAggregateInputType = {
    id?: true
    request?: true
    danger?: true
    name?: true
    _all?: true
  }

  export type GenrationRequestAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GenrationRequest to aggregate.
     */
    where?: GenrationRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GenrationRequests to fetch.
     */
    orderBy?: GenrationRequestOrderByWithRelationInput | GenrationRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: GenrationRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GenrationRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GenrationRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned GenrationRequests
    **/
    _count?: true | GenrationRequestCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: GenrationRequestAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: GenrationRequestSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GenrationRequestMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GenrationRequestMaxAggregateInputType
  }

  export type GetGenrationRequestAggregateType<T extends GenrationRequestAggregateArgs> = {
        [P in keyof T & keyof AggregateGenrationRequest]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGenrationRequest[P]>
      : GetScalarType<T[P], AggregateGenrationRequest[P]>
  }




  export type GenrationRequestGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GenrationRequestWhereInput
    orderBy?: GenrationRequestOrderByWithAggregationInput | GenrationRequestOrderByWithAggregationInput[]
    by: GenrationRequestScalarFieldEnum[] | GenrationRequestScalarFieldEnum
    having?: GenrationRequestScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GenrationRequestCountAggregateInputType | true
    _avg?: GenrationRequestAvgAggregateInputType
    _sum?: GenrationRequestSumAggregateInputType
    _min?: GenrationRequestMinAggregateInputType
    _max?: GenrationRequestMaxAggregateInputType
  }

  export type GenrationRequestGroupByOutputType = {
    id: number
    request: string
    danger: string
    name: string
    _count: GenrationRequestCountAggregateOutputType | null
    _avg: GenrationRequestAvgAggregateOutputType | null
    _sum: GenrationRequestSumAggregateOutputType | null
    _min: GenrationRequestMinAggregateOutputType | null
    _max: GenrationRequestMaxAggregateOutputType | null
  }

  type GetGenrationRequestGroupByPayload<T extends GenrationRequestGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GenrationRequestGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GenrationRequestGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GenrationRequestGroupByOutputType[P]>
            : GetScalarType<T[P], GenrationRequestGroupByOutputType[P]>
        }
      >
    >


  export type GenrationRequestSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    request?: boolean
    danger?: boolean
    name?: boolean
  }, ExtArgs["result"]["genrationRequest"]>

  export type GenrationRequestSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    request?: boolean
    danger?: boolean
    name?: boolean
  }, ExtArgs["result"]["genrationRequest"]>

  export type GenrationRequestSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    request?: boolean
    danger?: boolean
    name?: boolean
  }, ExtArgs["result"]["genrationRequest"]>

  export type GenrationRequestSelectScalar = {
    id?: boolean
    request?: boolean
    danger?: boolean
    name?: boolean
  }

  export type GenrationRequestOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "request" | "danger" | "name", ExtArgs["result"]["genrationRequest"]>

  export type $GenrationRequestPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "GenrationRequest"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      request: string
      danger: string
      name: string
    }, ExtArgs["result"]["genrationRequest"]>
    composites: {}
  }

  type GenrationRequestGetPayload<S extends boolean | null | undefined | GenrationRequestDefaultArgs> = $Result.GetResult<Prisma.$GenrationRequestPayload, S>

  type GenrationRequestCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<GenrationRequestFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: GenrationRequestCountAggregateInputType | true
    }

  export interface GenrationRequestDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['GenrationRequest'], meta: { name: 'GenrationRequest' } }
    /**
     * Find zero or one GenrationRequest that matches the filter.
     * @param {GenrationRequestFindUniqueArgs} args - Arguments to find a GenrationRequest
     * @example
     * // Get one GenrationRequest
     * const genrationRequest = await prisma.genrationRequest.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends GenrationRequestFindUniqueArgs>(args: SelectSubset<T, GenrationRequestFindUniqueArgs<ExtArgs>>): Prisma__GenrationRequestClient<$Result.GetResult<Prisma.$GenrationRequestPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one GenrationRequest that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {GenrationRequestFindUniqueOrThrowArgs} args - Arguments to find a GenrationRequest
     * @example
     * // Get one GenrationRequest
     * const genrationRequest = await prisma.genrationRequest.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends GenrationRequestFindUniqueOrThrowArgs>(args: SelectSubset<T, GenrationRequestFindUniqueOrThrowArgs<ExtArgs>>): Prisma__GenrationRequestClient<$Result.GetResult<Prisma.$GenrationRequestPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first GenrationRequest that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GenrationRequestFindFirstArgs} args - Arguments to find a GenrationRequest
     * @example
     * // Get one GenrationRequest
     * const genrationRequest = await prisma.genrationRequest.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends GenrationRequestFindFirstArgs>(args?: SelectSubset<T, GenrationRequestFindFirstArgs<ExtArgs>>): Prisma__GenrationRequestClient<$Result.GetResult<Prisma.$GenrationRequestPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first GenrationRequest that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GenrationRequestFindFirstOrThrowArgs} args - Arguments to find a GenrationRequest
     * @example
     * // Get one GenrationRequest
     * const genrationRequest = await prisma.genrationRequest.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends GenrationRequestFindFirstOrThrowArgs>(args?: SelectSubset<T, GenrationRequestFindFirstOrThrowArgs<ExtArgs>>): Prisma__GenrationRequestClient<$Result.GetResult<Prisma.$GenrationRequestPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more GenrationRequests that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GenrationRequestFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all GenrationRequests
     * const genrationRequests = await prisma.genrationRequest.findMany()
     * 
     * // Get first 10 GenrationRequests
     * const genrationRequests = await prisma.genrationRequest.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const genrationRequestWithIdOnly = await prisma.genrationRequest.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends GenrationRequestFindManyArgs>(args?: SelectSubset<T, GenrationRequestFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GenrationRequestPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a GenrationRequest.
     * @param {GenrationRequestCreateArgs} args - Arguments to create a GenrationRequest.
     * @example
     * // Create one GenrationRequest
     * const GenrationRequest = await prisma.genrationRequest.create({
     *   data: {
     *     // ... data to create a GenrationRequest
     *   }
     * })
     * 
     */
    create<T extends GenrationRequestCreateArgs>(args: SelectSubset<T, GenrationRequestCreateArgs<ExtArgs>>): Prisma__GenrationRequestClient<$Result.GetResult<Prisma.$GenrationRequestPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many GenrationRequests.
     * @param {GenrationRequestCreateManyArgs} args - Arguments to create many GenrationRequests.
     * @example
     * // Create many GenrationRequests
     * const genrationRequest = await prisma.genrationRequest.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends GenrationRequestCreateManyArgs>(args?: SelectSubset<T, GenrationRequestCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many GenrationRequests and returns the data saved in the database.
     * @param {GenrationRequestCreateManyAndReturnArgs} args - Arguments to create many GenrationRequests.
     * @example
     * // Create many GenrationRequests
     * const genrationRequest = await prisma.genrationRequest.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many GenrationRequests and only return the `id`
     * const genrationRequestWithIdOnly = await prisma.genrationRequest.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends GenrationRequestCreateManyAndReturnArgs>(args?: SelectSubset<T, GenrationRequestCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GenrationRequestPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a GenrationRequest.
     * @param {GenrationRequestDeleteArgs} args - Arguments to delete one GenrationRequest.
     * @example
     * // Delete one GenrationRequest
     * const GenrationRequest = await prisma.genrationRequest.delete({
     *   where: {
     *     // ... filter to delete one GenrationRequest
     *   }
     * })
     * 
     */
    delete<T extends GenrationRequestDeleteArgs>(args: SelectSubset<T, GenrationRequestDeleteArgs<ExtArgs>>): Prisma__GenrationRequestClient<$Result.GetResult<Prisma.$GenrationRequestPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one GenrationRequest.
     * @param {GenrationRequestUpdateArgs} args - Arguments to update one GenrationRequest.
     * @example
     * // Update one GenrationRequest
     * const genrationRequest = await prisma.genrationRequest.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends GenrationRequestUpdateArgs>(args: SelectSubset<T, GenrationRequestUpdateArgs<ExtArgs>>): Prisma__GenrationRequestClient<$Result.GetResult<Prisma.$GenrationRequestPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more GenrationRequests.
     * @param {GenrationRequestDeleteManyArgs} args - Arguments to filter GenrationRequests to delete.
     * @example
     * // Delete a few GenrationRequests
     * const { count } = await prisma.genrationRequest.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends GenrationRequestDeleteManyArgs>(args?: SelectSubset<T, GenrationRequestDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more GenrationRequests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GenrationRequestUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many GenrationRequests
     * const genrationRequest = await prisma.genrationRequest.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends GenrationRequestUpdateManyArgs>(args: SelectSubset<T, GenrationRequestUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more GenrationRequests and returns the data updated in the database.
     * @param {GenrationRequestUpdateManyAndReturnArgs} args - Arguments to update many GenrationRequests.
     * @example
     * // Update many GenrationRequests
     * const genrationRequest = await prisma.genrationRequest.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more GenrationRequests and only return the `id`
     * const genrationRequestWithIdOnly = await prisma.genrationRequest.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends GenrationRequestUpdateManyAndReturnArgs>(args: SelectSubset<T, GenrationRequestUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GenrationRequestPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one GenrationRequest.
     * @param {GenrationRequestUpsertArgs} args - Arguments to update or create a GenrationRequest.
     * @example
     * // Update or create a GenrationRequest
     * const genrationRequest = await prisma.genrationRequest.upsert({
     *   create: {
     *     // ... data to create a GenrationRequest
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the GenrationRequest we want to update
     *   }
     * })
     */
    upsert<T extends GenrationRequestUpsertArgs>(args: SelectSubset<T, GenrationRequestUpsertArgs<ExtArgs>>): Prisma__GenrationRequestClient<$Result.GetResult<Prisma.$GenrationRequestPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of GenrationRequests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GenrationRequestCountArgs} args - Arguments to filter GenrationRequests to count.
     * @example
     * // Count the number of GenrationRequests
     * const count = await prisma.genrationRequest.count({
     *   where: {
     *     // ... the filter for the GenrationRequests we want to count
     *   }
     * })
    **/
    count<T extends GenrationRequestCountArgs>(
      args?: Subset<T, GenrationRequestCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GenrationRequestCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a GenrationRequest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GenrationRequestAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GenrationRequestAggregateArgs>(args: Subset<T, GenrationRequestAggregateArgs>): Prisma.PrismaPromise<GetGenrationRequestAggregateType<T>>

    /**
     * Group by GenrationRequest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GenrationRequestGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GenrationRequestGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GenrationRequestGroupByArgs['orderBy'] }
        : { orderBy?: GenrationRequestGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GenrationRequestGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGenrationRequestGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the GenrationRequest model
   */
  readonly fields: GenrationRequestFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for GenrationRequest.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__GenrationRequestClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the GenrationRequest model
   */ 
  interface GenrationRequestFieldRefs {
    readonly id: FieldRef<"GenrationRequest", 'Int'>
    readonly request: FieldRef<"GenrationRequest", 'String'>
    readonly danger: FieldRef<"GenrationRequest", 'String'>
    readonly name: FieldRef<"GenrationRequest", 'String'>
  }
    

  // Custom InputTypes
  /**
   * GenrationRequest findUnique
   */
  export type GenrationRequestFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GenrationRequest
     */
    select?: GenrationRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GenrationRequest
     */
    omit?: GenrationRequestOmit<ExtArgs> | null
    /**
     * Filter, which GenrationRequest to fetch.
     */
    where: GenrationRequestWhereUniqueInput
  }

  /**
   * GenrationRequest findUniqueOrThrow
   */
  export type GenrationRequestFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GenrationRequest
     */
    select?: GenrationRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GenrationRequest
     */
    omit?: GenrationRequestOmit<ExtArgs> | null
    /**
     * Filter, which GenrationRequest to fetch.
     */
    where: GenrationRequestWhereUniqueInput
  }

  /**
   * GenrationRequest findFirst
   */
  export type GenrationRequestFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GenrationRequest
     */
    select?: GenrationRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GenrationRequest
     */
    omit?: GenrationRequestOmit<ExtArgs> | null
    /**
     * Filter, which GenrationRequest to fetch.
     */
    where?: GenrationRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GenrationRequests to fetch.
     */
    orderBy?: GenrationRequestOrderByWithRelationInput | GenrationRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GenrationRequests.
     */
    cursor?: GenrationRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GenrationRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GenrationRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GenrationRequests.
     */
    distinct?: GenrationRequestScalarFieldEnum | GenrationRequestScalarFieldEnum[]
  }

  /**
   * GenrationRequest findFirstOrThrow
   */
  export type GenrationRequestFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GenrationRequest
     */
    select?: GenrationRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GenrationRequest
     */
    omit?: GenrationRequestOmit<ExtArgs> | null
    /**
     * Filter, which GenrationRequest to fetch.
     */
    where?: GenrationRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GenrationRequests to fetch.
     */
    orderBy?: GenrationRequestOrderByWithRelationInput | GenrationRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GenrationRequests.
     */
    cursor?: GenrationRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GenrationRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GenrationRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GenrationRequests.
     */
    distinct?: GenrationRequestScalarFieldEnum | GenrationRequestScalarFieldEnum[]
  }

  /**
   * GenrationRequest findMany
   */
  export type GenrationRequestFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GenrationRequest
     */
    select?: GenrationRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GenrationRequest
     */
    omit?: GenrationRequestOmit<ExtArgs> | null
    /**
     * Filter, which GenrationRequests to fetch.
     */
    where?: GenrationRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GenrationRequests to fetch.
     */
    orderBy?: GenrationRequestOrderByWithRelationInput | GenrationRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing GenrationRequests.
     */
    cursor?: GenrationRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GenrationRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GenrationRequests.
     */
    skip?: number
    distinct?: GenrationRequestScalarFieldEnum | GenrationRequestScalarFieldEnum[]
  }

  /**
   * GenrationRequest create
   */
  export type GenrationRequestCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GenrationRequest
     */
    select?: GenrationRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GenrationRequest
     */
    omit?: GenrationRequestOmit<ExtArgs> | null
    /**
     * The data needed to create a GenrationRequest.
     */
    data: XOR<GenrationRequestCreateInput, GenrationRequestUncheckedCreateInput>
  }

  /**
   * GenrationRequest createMany
   */
  export type GenrationRequestCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many GenrationRequests.
     */
    data: GenrationRequestCreateManyInput | GenrationRequestCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * GenrationRequest createManyAndReturn
   */
  export type GenrationRequestCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GenrationRequest
     */
    select?: GenrationRequestSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the GenrationRequest
     */
    omit?: GenrationRequestOmit<ExtArgs> | null
    /**
     * The data used to create many GenrationRequests.
     */
    data: GenrationRequestCreateManyInput | GenrationRequestCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * GenrationRequest update
   */
  export type GenrationRequestUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GenrationRequest
     */
    select?: GenrationRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GenrationRequest
     */
    omit?: GenrationRequestOmit<ExtArgs> | null
    /**
     * The data needed to update a GenrationRequest.
     */
    data: XOR<GenrationRequestUpdateInput, GenrationRequestUncheckedUpdateInput>
    /**
     * Choose, which GenrationRequest to update.
     */
    where: GenrationRequestWhereUniqueInput
  }

  /**
   * GenrationRequest updateMany
   */
  export type GenrationRequestUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update GenrationRequests.
     */
    data: XOR<GenrationRequestUpdateManyMutationInput, GenrationRequestUncheckedUpdateManyInput>
    /**
     * Filter which GenrationRequests to update
     */
    where?: GenrationRequestWhereInput
    /**
     * Limit how many GenrationRequests to update.
     */
    limit?: number
  }

  /**
   * GenrationRequest updateManyAndReturn
   */
  export type GenrationRequestUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GenrationRequest
     */
    select?: GenrationRequestSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the GenrationRequest
     */
    omit?: GenrationRequestOmit<ExtArgs> | null
    /**
     * The data used to update GenrationRequests.
     */
    data: XOR<GenrationRequestUpdateManyMutationInput, GenrationRequestUncheckedUpdateManyInput>
    /**
     * Filter which GenrationRequests to update
     */
    where?: GenrationRequestWhereInput
    /**
     * Limit how many GenrationRequests to update.
     */
    limit?: number
  }

  /**
   * GenrationRequest upsert
   */
  export type GenrationRequestUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GenrationRequest
     */
    select?: GenrationRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GenrationRequest
     */
    omit?: GenrationRequestOmit<ExtArgs> | null
    /**
     * The filter to search for the GenrationRequest to update in case it exists.
     */
    where: GenrationRequestWhereUniqueInput
    /**
     * In case the GenrationRequest found by the `where` argument doesn't exist, create a new GenrationRequest with this data.
     */
    create: XOR<GenrationRequestCreateInput, GenrationRequestUncheckedCreateInput>
    /**
     * In case the GenrationRequest was found with the provided `where` argument, update it with this data.
     */
    update: XOR<GenrationRequestUpdateInput, GenrationRequestUncheckedUpdateInput>
  }

  /**
   * GenrationRequest delete
   */
  export type GenrationRequestDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GenrationRequest
     */
    select?: GenrationRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GenrationRequest
     */
    omit?: GenrationRequestOmit<ExtArgs> | null
    /**
     * Filter which GenrationRequest to delete.
     */
    where: GenrationRequestWhereUniqueInput
  }

  /**
   * GenrationRequest deleteMany
   */
  export type GenrationRequestDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GenrationRequests to delete
     */
    where?: GenrationRequestWhereInput
    /**
     * Limit how many GenrationRequests to delete.
     */
    limit?: number
  }

  /**
   * GenrationRequest without action
   */
  export type GenrationRequestDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GenrationRequest
     */
    select?: GenrationRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GenrationRequest
     */
    omit?: GenrationRequestOmit<ExtArgs> | null
  }


  /**
   * Model GPTMessageHistory
   */

  export type AggregateGPTMessageHistory = {
    _count: GPTMessageHistoryCountAggregateOutputType | null
    _min: GPTMessageHistoryMinAggregateOutputType | null
    _max: GPTMessageHistoryMaxAggregateOutputType | null
  }

  export type GPTMessageHistoryMinAggregateOutputType = {
    id: string | null
    type: string | null
  }

  export type GPTMessageHistoryMaxAggregateOutputType = {
    id: string | null
    type: string | null
  }

  export type GPTMessageHistoryCountAggregateOutputType = {
    id: number
    type: number
    _all: number
  }


  export type GPTMessageHistoryMinAggregateInputType = {
    id?: true
    type?: true
  }

  export type GPTMessageHistoryMaxAggregateInputType = {
    id?: true
    type?: true
  }

  export type GPTMessageHistoryCountAggregateInputType = {
    id?: true
    type?: true
    _all?: true
  }

  export type GPTMessageHistoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GPTMessageHistory to aggregate.
     */
    where?: GPTMessageHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GPTMessageHistories to fetch.
     */
    orderBy?: GPTMessageHistoryOrderByWithRelationInput | GPTMessageHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: GPTMessageHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GPTMessageHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GPTMessageHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned GPTMessageHistories
    **/
    _count?: true | GPTMessageHistoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GPTMessageHistoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GPTMessageHistoryMaxAggregateInputType
  }

  export type GetGPTMessageHistoryAggregateType<T extends GPTMessageHistoryAggregateArgs> = {
        [P in keyof T & keyof AggregateGPTMessageHistory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGPTMessageHistory[P]>
      : GetScalarType<T[P], AggregateGPTMessageHistory[P]>
  }




  export type GPTMessageHistoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GPTMessageHistoryWhereInput
    orderBy?: GPTMessageHistoryOrderByWithAggregationInput | GPTMessageHistoryOrderByWithAggregationInput[]
    by: GPTMessageHistoryScalarFieldEnum[] | GPTMessageHistoryScalarFieldEnum
    having?: GPTMessageHistoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GPTMessageHistoryCountAggregateInputType | true
    _min?: GPTMessageHistoryMinAggregateInputType
    _max?: GPTMessageHistoryMaxAggregateInputType
  }

  export type GPTMessageHistoryGroupByOutputType = {
    id: string
    type: string
    _count: GPTMessageHistoryCountAggregateOutputType | null
    _min: GPTMessageHistoryMinAggregateOutputType | null
    _max: GPTMessageHistoryMaxAggregateOutputType | null
  }

  type GetGPTMessageHistoryGroupByPayload<T extends GPTMessageHistoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GPTMessageHistoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GPTMessageHistoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GPTMessageHistoryGroupByOutputType[P]>
            : GetScalarType<T[P], GPTMessageHistoryGroupByOutputType[P]>
        }
      >
    >


  export type GPTMessageHistorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    messages_relation?: boolean | GPTMessageHistory$messages_relationArgs<ExtArgs>
    _count?: boolean | GPTMessageHistoryCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["gPTMessageHistory"]>

  export type GPTMessageHistorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
  }, ExtArgs["result"]["gPTMessageHistory"]>

  export type GPTMessageHistorySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
  }, ExtArgs["result"]["gPTMessageHistory"]>

  export type GPTMessageHistorySelectScalar = {
    id?: boolean
    type?: boolean
  }

  export type GPTMessageHistoryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "type", ExtArgs["result"]["gPTMessageHistory"]>
  export type GPTMessageHistoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    messages_relation?: boolean | GPTMessageHistory$messages_relationArgs<ExtArgs>
    _count?: boolean | GPTMessageHistoryCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type GPTMessageHistoryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type GPTMessageHistoryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $GPTMessageHistoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "GPTMessageHistory"
    objects: {
      messages_relation: Prisma.$GPTMessagePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      type: string
    }, ExtArgs["result"]["gPTMessageHistory"]>
    composites: {}
  }

  type GPTMessageHistoryGetPayload<S extends boolean | null | undefined | GPTMessageHistoryDefaultArgs> = $Result.GetResult<Prisma.$GPTMessageHistoryPayload, S>

  type GPTMessageHistoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<GPTMessageHistoryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: GPTMessageHistoryCountAggregateInputType | true
    }

  export interface GPTMessageHistoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['GPTMessageHistory'], meta: { name: 'GPTMessageHistory' } }
    /**
     * Find zero or one GPTMessageHistory that matches the filter.
     * @param {GPTMessageHistoryFindUniqueArgs} args - Arguments to find a GPTMessageHistory
     * @example
     * // Get one GPTMessageHistory
     * const gPTMessageHistory = await prisma.gPTMessageHistory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends GPTMessageHistoryFindUniqueArgs>(args: SelectSubset<T, GPTMessageHistoryFindUniqueArgs<ExtArgs>>): Prisma__GPTMessageHistoryClient<$Result.GetResult<Prisma.$GPTMessageHistoryPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one GPTMessageHistory that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {GPTMessageHistoryFindUniqueOrThrowArgs} args - Arguments to find a GPTMessageHistory
     * @example
     * // Get one GPTMessageHistory
     * const gPTMessageHistory = await prisma.gPTMessageHistory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends GPTMessageHistoryFindUniqueOrThrowArgs>(args: SelectSubset<T, GPTMessageHistoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__GPTMessageHistoryClient<$Result.GetResult<Prisma.$GPTMessageHistoryPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first GPTMessageHistory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GPTMessageHistoryFindFirstArgs} args - Arguments to find a GPTMessageHistory
     * @example
     * // Get one GPTMessageHistory
     * const gPTMessageHistory = await prisma.gPTMessageHistory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends GPTMessageHistoryFindFirstArgs>(args?: SelectSubset<T, GPTMessageHistoryFindFirstArgs<ExtArgs>>): Prisma__GPTMessageHistoryClient<$Result.GetResult<Prisma.$GPTMessageHistoryPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first GPTMessageHistory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GPTMessageHistoryFindFirstOrThrowArgs} args - Arguments to find a GPTMessageHistory
     * @example
     * // Get one GPTMessageHistory
     * const gPTMessageHistory = await prisma.gPTMessageHistory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends GPTMessageHistoryFindFirstOrThrowArgs>(args?: SelectSubset<T, GPTMessageHistoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__GPTMessageHistoryClient<$Result.GetResult<Prisma.$GPTMessageHistoryPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more GPTMessageHistories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GPTMessageHistoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all GPTMessageHistories
     * const gPTMessageHistories = await prisma.gPTMessageHistory.findMany()
     * 
     * // Get first 10 GPTMessageHistories
     * const gPTMessageHistories = await prisma.gPTMessageHistory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const gPTMessageHistoryWithIdOnly = await prisma.gPTMessageHistory.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends GPTMessageHistoryFindManyArgs>(args?: SelectSubset<T, GPTMessageHistoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GPTMessageHistoryPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a GPTMessageHistory.
     * @param {GPTMessageHistoryCreateArgs} args - Arguments to create a GPTMessageHistory.
     * @example
     * // Create one GPTMessageHistory
     * const GPTMessageHistory = await prisma.gPTMessageHistory.create({
     *   data: {
     *     // ... data to create a GPTMessageHistory
     *   }
     * })
     * 
     */
    create<T extends GPTMessageHistoryCreateArgs>(args: SelectSubset<T, GPTMessageHistoryCreateArgs<ExtArgs>>): Prisma__GPTMessageHistoryClient<$Result.GetResult<Prisma.$GPTMessageHistoryPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many GPTMessageHistories.
     * @param {GPTMessageHistoryCreateManyArgs} args - Arguments to create many GPTMessageHistories.
     * @example
     * // Create many GPTMessageHistories
     * const gPTMessageHistory = await prisma.gPTMessageHistory.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends GPTMessageHistoryCreateManyArgs>(args?: SelectSubset<T, GPTMessageHistoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many GPTMessageHistories and returns the data saved in the database.
     * @param {GPTMessageHistoryCreateManyAndReturnArgs} args - Arguments to create many GPTMessageHistories.
     * @example
     * // Create many GPTMessageHistories
     * const gPTMessageHistory = await prisma.gPTMessageHistory.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many GPTMessageHistories and only return the `id`
     * const gPTMessageHistoryWithIdOnly = await prisma.gPTMessageHistory.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends GPTMessageHistoryCreateManyAndReturnArgs>(args?: SelectSubset<T, GPTMessageHistoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GPTMessageHistoryPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a GPTMessageHistory.
     * @param {GPTMessageHistoryDeleteArgs} args - Arguments to delete one GPTMessageHistory.
     * @example
     * // Delete one GPTMessageHistory
     * const GPTMessageHistory = await prisma.gPTMessageHistory.delete({
     *   where: {
     *     // ... filter to delete one GPTMessageHistory
     *   }
     * })
     * 
     */
    delete<T extends GPTMessageHistoryDeleteArgs>(args: SelectSubset<T, GPTMessageHistoryDeleteArgs<ExtArgs>>): Prisma__GPTMessageHistoryClient<$Result.GetResult<Prisma.$GPTMessageHistoryPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one GPTMessageHistory.
     * @param {GPTMessageHistoryUpdateArgs} args - Arguments to update one GPTMessageHistory.
     * @example
     * // Update one GPTMessageHistory
     * const gPTMessageHistory = await prisma.gPTMessageHistory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends GPTMessageHistoryUpdateArgs>(args: SelectSubset<T, GPTMessageHistoryUpdateArgs<ExtArgs>>): Prisma__GPTMessageHistoryClient<$Result.GetResult<Prisma.$GPTMessageHistoryPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more GPTMessageHistories.
     * @param {GPTMessageHistoryDeleteManyArgs} args - Arguments to filter GPTMessageHistories to delete.
     * @example
     * // Delete a few GPTMessageHistories
     * const { count } = await prisma.gPTMessageHistory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends GPTMessageHistoryDeleteManyArgs>(args?: SelectSubset<T, GPTMessageHistoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more GPTMessageHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GPTMessageHistoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many GPTMessageHistories
     * const gPTMessageHistory = await prisma.gPTMessageHistory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends GPTMessageHistoryUpdateManyArgs>(args: SelectSubset<T, GPTMessageHistoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more GPTMessageHistories and returns the data updated in the database.
     * @param {GPTMessageHistoryUpdateManyAndReturnArgs} args - Arguments to update many GPTMessageHistories.
     * @example
     * // Update many GPTMessageHistories
     * const gPTMessageHistory = await prisma.gPTMessageHistory.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more GPTMessageHistories and only return the `id`
     * const gPTMessageHistoryWithIdOnly = await prisma.gPTMessageHistory.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends GPTMessageHistoryUpdateManyAndReturnArgs>(args: SelectSubset<T, GPTMessageHistoryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GPTMessageHistoryPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one GPTMessageHistory.
     * @param {GPTMessageHistoryUpsertArgs} args - Arguments to update or create a GPTMessageHistory.
     * @example
     * // Update or create a GPTMessageHistory
     * const gPTMessageHistory = await prisma.gPTMessageHistory.upsert({
     *   create: {
     *     // ... data to create a GPTMessageHistory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the GPTMessageHistory we want to update
     *   }
     * })
     */
    upsert<T extends GPTMessageHistoryUpsertArgs>(args: SelectSubset<T, GPTMessageHistoryUpsertArgs<ExtArgs>>): Prisma__GPTMessageHistoryClient<$Result.GetResult<Prisma.$GPTMessageHistoryPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of GPTMessageHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GPTMessageHistoryCountArgs} args - Arguments to filter GPTMessageHistories to count.
     * @example
     * // Count the number of GPTMessageHistories
     * const count = await prisma.gPTMessageHistory.count({
     *   where: {
     *     // ... the filter for the GPTMessageHistories we want to count
     *   }
     * })
    **/
    count<T extends GPTMessageHistoryCountArgs>(
      args?: Subset<T, GPTMessageHistoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GPTMessageHistoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a GPTMessageHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GPTMessageHistoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GPTMessageHistoryAggregateArgs>(args: Subset<T, GPTMessageHistoryAggregateArgs>): Prisma.PrismaPromise<GetGPTMessageHistoryAggregateType<T>>

    /**
     * Group by GPTMessageHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GPTMessageHistoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GPTMessageHistoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GPTMessageHistoryGroupByArgs['orderBy'] }
        : { orderBy?: GPTMessageHistoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GPTMessageHistoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGPTMessageHistoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the GPTMessageHistory model
   */
  readonly fields: GPTMessageHistoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for GPTMessageHistory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__GPTMessageHistoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    messages_relation<T extends GPTMessageHistory$messages_relationArgs<ExtArgs> = {}>(args?: Subset<T, GPTMessageHistory$messages_relationArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GPTMessagePayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the GPTMessageHistory model
   */ 
  interface GPTMessageHistoryFieldRefs {
    readonly id: FieldRef<"GPTMessageHistory", 'String'>
    readonly type: FieldRef<"GPTMessageHistory", 'String'>
  }
    

  // Custom InputTypes
  /**
   * GPTMessageHistory findUnique
   */
  export type GPTMessageHistoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GPTMessageHistory
     */
    select?: GPTMessageHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the GPTMessageHistory
     */
    omit?: GPTMessageHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GPTMessageHistoryInclude<ExtArgs> | null
    /**
     * Filter, which GPTMessageHistory to fetch.
     */
    where: GPTMessageHistoryWhereUniqueInput
  }

  /**
   * GPTMessageHistory findUniqueOrThrow
   */
  export type GPTMessageHistoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GPTMessageHistory
     */
    select?: GPTMessageHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the GPTMessageHistory
     */
    omit?: GPTMessageHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GPTMessageHistoryInclude<ExtArgs> | null
    /**
     * Filter, which GPTMessageHistory to fetch.
     */
    where: GPTMessageHistoryWhereUniqueInput
  }

  /**
   * GPTMessageHistory findFirst
   */
  export type GPTMessageHistoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GPTMessageHistory
     */
    select?: GPTMessageHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the GPTMessageHistory
     */
    omit?: GPTMessageHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GPTMessageHistoryInclude<ExtArgs> | null
    /**
     * Filter, which GPTMessageHistory to fetch.
     */
    where?: GPTMessageHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GPTMessageHistories to fetch.
     */
    orderBy?: GPTMessageHistoryOrderByWithRelationInput | GPTMessageHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GPTMessageHistories.
     */
    cursor?: GPTMessageHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GPTMessageHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GPTMessageHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GPTMessageHistories.
     */
    distinct?: GPTMessageHistoryScalarFieldEnum | GPTMessageHistoryScalarFieldEnum[]
  }

  /**
   * GPTMessageHistory findFirstOrThrow
   */
  export type GPTMessageHistoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GPTMessageHistory
     */
    select?: GPTMessageHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the GPTMessageHistory
     */
    omit?: GPTMessageHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GPTMessageHistoryInclude<ExtArgs> | null
    /**
     * Filter, which GPTMessageHistory to fetch.
     */
    where?: GPTMessageHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GPTMessageHistories to fetch.
     */
    orderBy?: GPTMessageHistoryOrderByWithRelationInput | GPTMessageHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GPTMessageHistories.
     */
    cursor?: GPTMessageHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GPTMessageHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GPTMessageHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GPTMessageHistories.
     */
    distinct?: GPTMessageHistoryScalarFieldEnum | GPTMessageHistoryScalarFieldEnum[]
  }

  /**
   * GPTMessageHistory findMany
   */
  export type GPTMessageHistoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GPTMessageHistory
     */
    select?: GPTMessageHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the GPTMessageHistory
     */
    omit?: GPTMessageHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GPTMessageHistoryInclude<ExtArgs> | null
    /**
     * Filter, which GPTMessageHistories to fetch.
     */
    where?: GPTMessageHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GPTMessageHistories to fetch.
     */
    orderBy?: GPTMessageHistoryOrderByWithRelationInput | GPTMessageHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing GPTMessageHistories.
     */
    cursor?: GPTMessageHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GPTMessageHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GPTMessageHistories.
     */
    skip?: number
    distinct?: GPTMessageHistoryScalarFieldEnum | GPTMessageHistoryScalarFieldEnum[]
  }

  /**
   * GPTMessageHistory create
   */
  export type GPTMessageHistoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GPTMessageHistory
     */
    select?: GPTMessageHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the GPTMessageHistory
     */
    omit?: GPTMessageHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GPTMessageHistoryInclude<ExtArgs> | null
    /**
     * The data needed to create a GPTMessageHistory.
     */
    data: XOR<GPTMessageHistoryCreateInput, GPTMessageHistoryUncheckedCreateInput>
  }

  /**
   * GPTMessageHistory createMany
   */
  export type GPTMessageHistoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many GPTMessageHistories.
     */
    data: GPTMessageHistoryCreateManyInput | GPTMessageHistoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * GPTMessageHistory createManyAndReturn
   */
  export type GPTMessageHistoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GPTMessageHistory
     */
    select?: GPTMessageHistorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the GPTMessageHistory
     */
    omit?: GPTMessageHistoryOmit<ExtArgs> | null
    /**
     * The data used to create many GPTMessageHistories.
     */
    data: GPTMessageHistoryCreateManyInput | GPTMessageHistoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * GPTMessageHistory update
   */
  export type GPTMessageHistoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GPTMessageHistory
     */
    select?: GPTMessageHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the GPTMessageHistory
     */
    omit?: GPTMessageHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GPTMessageHistoryInclude<ExtArgs> | null
    /**
     * The data needed to update a GPTMessageHistory.
     */
    data: XOR<GPTMessageHistoryUpdateInput, GPTMessageHistoryUncheckedUpdateInput>
    /**
     * Choose, which GPTMessageHistory to update.
     */
    where: GPTMessageHistoryWhereUniqueInput
  }

  /**
   * GPTMessageHistory updateMany
   */
  export type GPTMessageHistoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update GPTMessageHistories.
     */
    data: XOR<GPTMessageHistoryUpdateManyMutationInput, GPTMessageHistoryUncheckedUpdateManyInput>
    /**
     * Filter which GPTMessageHistories to update
     */
    where?: GPTMessageHistoryWhereInput
    /**
     * Limit how many GPTMessageHistories to update.
     */
    limit?: number
  }

  /**
   * GPTMessageHistory updateManyAndReturn
   */
  export type GPTMessageHistoryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GPTMessageHistory
     */
    select?: GPTMessageHistorySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the GPTMessageHistory
     */
    omit?: GPTMessageHistoryOmit<ExtArgs> | null
    /**
     * The data used to update GPTMessageHistories.
     */
    data: XOR<GPTMessageHistoryUpdateManyMutationInput, GPTMessageHistoryUncheckedUpdateManyInput>
    /**
     * Filter which GPTMessageHistories to update
     */
    where?: GPTMessageHistoryWhereInput
    /**
     * Limit how many GPTMessageHistories to update.
     */
    limit?: number
  }

  /**
   * GPTMessageHistory upsert
   */
  export type GPTMessageHistoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GPTMessageHistory
     */
    select?: GPTMessageHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the GPTMessageHistory
     */
    omit?: GPTMessageHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GPTMessageHistoryInclude<ExtArgs> | null
    /**
     * The filter to search for the GPTMessageHistory to update in case it exists.
     */
    where: GPTMessageHistoryWhereUniqueInput
    /**
     * In case the GPTMessageHistory found by the `where` argument doesn't exist, create a new GPTMessageHistory with this data.
     */
    create: XOR<GPTMessageHistoryCreateInput, GPTMessageHistoryUncheckedCreateInput>
    /**
     * In case the GPTMessageHistory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<GPTMessageHistoryUpdateInput, GPTMessageHistoryUncheckedUpdateInput>
  }

  /**
   * GPTMessageHistory delete
   */
  export type GPTMessageHistoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GPTMessageHistory
     */
    select?: GPTMessageHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the GPTMessageHistory
     */
    omit?: GPTMessageHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GPTMessageHistoryInclude<ExtArgs> | null
    /**
     * Filter which GPTMessageHistory to delete.
     */
    where: GPTMessageHistoryWhereUniqueInput
  }

  /**
   * GPTMessageHistory deleteMany
   */
  export type GPTMessageHistoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GPTMessageHistories to delete
     */
    where?: GPTMessageHistoryWhereInput
    /**
     * Limit how many GPTMessageHistories to delete.
     */
    limit?: number
  }

  /**
   * GPTMessageHistory.messages_relation
   */
  export type GPTMessageHistory$messages_relationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GPTMessage
     */
    select?: GPTMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GPTMessage
     */
    omit?: GPTMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GPTMessageInclude<ExtArgs> | null
    where?: GPTMessageWhereInput
    orderBy?: GPTMessageOrderByWithRelationInput | GPTMessageOrderByWithRelationInput[]
    cursor?: GPTMessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GPTMessageScalarFieldEnum | GPTMessageScalarFieldEnum[]
  }

  /**
   * GPTMessageHistory without action
   */
  export type GPTMessageHistoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GPTMessageHistory
     */
    select?: GPTMessageHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the GPTMessageHistory
     */
    omit?: GPTMessageHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GPTMessageHistoryInclude<ExtArgs> | null
  }


  /**
   * Model GPTMessage
   */

  export type AggregateGPTMessage = {
    _count: GPTMessageCountAggregateOutputType | null
    _avg: GPTMessageAvgAggregateOutputType | null
    _sum: GPTMessageSumAggregateOutputType | null
    _min: GPTMessageMinAggregateOutputType | null
    _max: GPTMessageMaxAggregateOutputType | null
  }

  export type GPTMessageAvgAggregateOutputType = {
    number: number | null
  }

  export type GPTMessageSumAggregateOutputType = {
    number: number | null
  }

  export type GPTMessageMinAggregateOutputType = {
    message_history_id: string | null
    number: number | null
    text: string | null
    role: string | null
  }

  export type GPTMessageMaxAggregateOutputType = {
    message_history_id: string | null
    number: number | null
    text: string | null
    role: string | null
  }

  export type GPTMessageCountAggregateOutputType = {
    message_history_id: number
    number: number
    text: number
    role: number
    _all: number
  }


  export type GPTMessageAvgAggregateInputType = {
    number?: true
  }

  export type GPTMessageSumAggregateInputType = {
    number?: true
  }

  export type GPTMessageMinAggregateInputType = {
    message_history_id?: true
    number?: true
    text?: true
    role?: true
  }

  export type GPTMessageMaxAggregateInputType = {
    message_history_id?: true
    number?: true
    text?: true
    role?: true
  }

  export type GPTMessageCountAggregateInputType = {
    message_history_id?: true
    number?: true
    text?: true
    role?: true
    _all?: true
  }

  export type GPTMessageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GPTMessage to aggregate.
     */
    where?: GPTMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GPTMessages to fetch.
     */
    orderBy?: GPTMessageOrderByWithRelationInput | GPTMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: GPTMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GPTMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GPTMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned GPTMessages
    **/
    _count?: true | GPTMessageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: GPTMessageAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: GPTMessageSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GPTMessageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GPTMessageMaxAggregateInputType
  }

  export type GetGPTMessageAggregateType<T extends GPTMessageAggregateArgs> = {
        [P in keyof T & keyof AggregateGPTMessage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGPTMessage[P]>
      : GetScalarType<T[P], AggregateGPTMessage[P]>
  }




  export type GPTMessageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GPTMessageWhereInput
    orderBy?: GPTMessageOrderByWithAggregationInput | GPTMessageOrderByWithAggregationInput[]
    by: GPTMessageScalarFieldEnum[] | GPTMessageScalarFieldEnum
    having?: GPTMessageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GPTMessageCountAggregateInputType | true
    _avg?: GPTMessageAvgAggregateInputType
    _sum?: GPTMessageSumAggregateInputType
    _min?: GPTMessageMinAggregateInputType
    _max?: GPTMessageMaxAggregateInputType
  }

  export type GPTMessageGroupByOutputType = {
    message_history_id: string
    number: number
    text: string
    role: string
    _count: GPTMessageCountAggregateOutputType | null
    _avg: GPTMessageAvgAggregateOutputType | null
    _sum: GPTMessageSumAggregateOutputType | null
    _min: GPTMessageMinAggregateOutputType | null
    _max: GPTMessageMaxAggregateOutputType | null
  }

  type GetGPTMessageGroupByPayload<T extends GPTMessageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GPTMessageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GPTMessageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GPTMessageGroupByOutputType[P]>
            : GetScalarType<T[P], GPTMessageGroupByOutputType[P]>
        }
      >
    >


  export type GPTMessageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    message_history_id?: boolean
    number?: boolean
    text?: boolean
    role?: boolean
    message_history_relation?: boolean | GPTMessageHistoryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["gPTMessage"]>

  export type GPTMessageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    message_history_id?: boolean
    number?: boolean
    text?: boolean
    role?: boolean
    message_history_relation?: boolean | GPTMessageHistoryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["gPTMessage"]>

  export type GPTMessageSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    message_history_id?: boolean
    number?: boolean
    text?: boolean
    role?: boolean
    message_history_relation?: boolean | GPTMessageHistoryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["gPTMessage"]>

  export type GPTMessageSelectScalar = {
    message_history_id?: boolean
    number?: boolean
    text?: boolean
    role?: boolean
  }

  export type GPTMessageOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"message_history_id" | "number" | "text" | "role", ExtArgs["result"]["gPTMessage"]>
  export type GPTMessageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    message_history_relation?: boolean | GPTMessageHistoryDefaultArgs<ExtArgs>
  }
  export type GPTMessageIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    message_history_relation?: boolean | GPTMessageHistoryDefaultArgs<ExtArgs>
  }
  export type GPTMessageIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    message_history_relation?: boolean | GPTMessageHistoryDefaultArgs<ExtArgs>
  }

  export type $GPTMessagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "GPTMessage"
    objects: {
      message_history_relation: Prisma.$GPTMessageHistoryPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      message_history_id: string
      number: number
      text: string
      role: string
    }, ExtArgs["result"]["gPTMessage"]>
    composites: {}
  }

  type GPTMessageGetPayload<S extends boolean | null | undefined | GPTMessageDefaultArgs> = $Result.GetResult<Prisma.$GPTMessagePayload, S>

  type GPTMessageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<GPTMessageFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: GPTMessageCountAggregateInputType | true
    }

  export interface GPTMessageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['GPTMessage'], meta: { name: 'GPTMessage' } }
    /**
     * Find zero or one GPTMessage that matches the filter.
     * @param {GPTMessageFindUniqueArgs} args - Arguments to find a GPTMessage
     * @example
     * // Get one GPTMessage
     * const gPTMessage = await prisma.gPTMessage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends GPTMessageFindUniqueArgs>(args: SelectSubset<T, GPTMessageFindUniqueArgs<ExtArgs>>): Prisma__GPTMessageClient<$Result.GetResult<Prisma.$GPTMessagePayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one GPTMessage that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {GPTMessageFindUniqueOrThrowArgs} args - Arguments to find a GPTMessage
     * @example
     * // Get one GPTMessage
     * const gPTMessage = await prisma.gPTMessage.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends GPTMessageFindUniqueOrThrowArgs>(args: SelectSubset<T, GPTMessageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__GPTMessageClient<$Result.GetResult<Prisma.$GPTMessagePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first GPTMessage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GPTMessageFindFirstArgs} args - Arguments to find a GPTMessage
     * @example
     * // Get one GPTMessage
     * const gPTMessage = await prisma.gPTMessage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends GPTMessageFindFirstArgs>(args?: SelectSubset<T, GPTMessageFindFirstArgs<ExtArgs>>): Prisma__GPTMessageClient<$Result.GetResult<Prisma.$GPTMessagePayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first GPTMessage that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GPTMessageFindFirstOrThrowArgs} args - Arguments to find a GPTMessage
     * @example
     * // Get one GPTMessage
     * const gPTMessage = await prisma.gPTMessage.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends GPTMessageFindFirstOrThrowArgs>(args?: SelectSubset<T, GPTMessageFindFirstOrThrowArgs<ExtArgs>>): Prisma__GPTMessageClient<$Result.GetResult<Prisma.$GPTMessagePayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more GPTMessages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GPTMessageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all GPTMessages
     * const gPTMessages = await prisma.gPTMessage.findMany()
     * 
     * // Get first 10 GPTMessages
     * const gPTMessages = await prisma.gPTMessage.findMany({ take: 10 })
     * 
     * // Only select the `message_history_id`
     * const gPTMessageWithMessage_history_idOnly = await prisma.gPTMessage.findMany({ select: { message_history_id: true } })
     * 
     */
    findMany<T extends GPTMessageFindManyArgs>(args?: SelectSubset<T, GPTMessageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GPTMessagePayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a GPTMessage.
     * @param {GPTMessageCreateArgs} args - Arguments to create a GPTMessage.
     * @example
     * // Create one GPTMessage
     * const GPTMessage = await prisma.gPTMessage.create({
     *   data: {
     *     // ... data to create a GPTMessage
     *   }
     * })
     * 
     */
    create<T extends GPTMessageCreateArgs>(args: SelectSubset<T, GPTMessageCreateArgs<ExtArgs>>): Prisma__GPTMessageClient<$Result.GetResult<Prisma.$GPTMessagePayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many GPTMessages.
     * @param {GPTMessageCreateManyArgs} args - Arguments to create many GPTMessages.
     * @example
     * // Create many GPTMessages
     * const gPTMessage = await prisma.gPTMessage.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends GPTMessageCreateManyArgs>(args?: SelectSubset<T, GPTMessageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many GPTMessages and returns the data saved in the database.
     * @param {GPTMessageCreateManyAndReturnArgs} args - Arguments to create many GPTMessages.
     * @example
     * // Create many GPTMessages
     * const gPTMessage = await prisma.gPTMessage.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many GPTMessages and only return the `message_history_id`
     * const gPTMessageWithMessage_history_idOnly = await prisma.gPTMessage.createManyAndReturn({
     *   select: { message_history_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends GPTMessageCreateManyAndReturnArgs>(args?: SelectSubset<T, GPTMessageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GPTMessagePayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a GPTMessage.
     * @param {GPTMessageDeleteArgs} args - Arguments to delete one GPTMessage.
     * @example
     * // Delete one GPTMessage
     * const GPTMessage = await prisma.gPTMessage.delete({
     *   where: {
     *     // ... filter to delete one GPTMessage
     *   }
     * })
     * 
     */
    delete<T extends GPTMessageDeleteArgs>(args: SelectSubset<T, GPTMessageDeleteArgs<ExtArgs>>): Prisma__GPTMessageClient<$Result.GetResult<Prisma.$GPTMessagePayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one GPTMessage.
     * @param {GPTMessageUpdateArgs} args - Arguments to update one GPTMessage.
     * @example
     * // Update one GPTMessage
     * const gPTMessage = await prisma.gPTMessage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends GPTMessageUpdateArgs>(args: SelectSubset<T, GPTMessageUpdateArgs<ExtArgs>>): Prisma__GPTMessageClient<$Result.GetResult<Prisma.$GPTMessagePayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more GPTMessages.
     * @param {GPTMessageDeleteManyArgs} args - Arguments to filter GPTMessages to delete.
     * @example
     * // Delete a few GPTMessages
     * const { count } = await prisma.gPTMessage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends GPTMessageDeleteManyArgs>(args?: SelectSubset<T, GPTMessageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more GPTMessages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GPTMessageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many GPTMessages
     * const gPTMessage = await prisma.gPTMessage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends GPTMessageUpdateManyArgs>(args: SelectSubset<T, GPTMessageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more GPTMessages and returns the data updated in the database.
     * @param {GPTMessageUpdateManyAndReturnArgs} args - Arguments to update many GPTMessages.
     * @example
     * // Update many GPTMessages
     * const gPTMessage = await prisma.gPTMessage.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more GPTMessages and only return the `message_history_id`
     * const gPTMessageWithMessage_history_idOnly = await prisma.gPTMessage.updateManyAndReturn({
     *   select: { message_history_id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends GPTMessageUpdateManyAndReturnArgs>(args: SelectSubset<T, GPTMessageUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GPTMessagePayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one GPTMessage.
     * @param {GPTMessageUpsertArgs} args - Arguments to update or create a GPTMessage.
     * @example
     * // Update or create a GPTMessage
     * const gPTMessage = await prisma.gPTMessage.upsert({
     *   create: {
     *     // ... data to create a GPTMessage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the GPTMessage we want to update
     *   }
     * })
     */
    upsert<T extends GPTMessageUpsertArgs>(args: SelectSubset<T, GPTMessageUpsertArgs<ExtArgs>>): Prisma__GPTMessageClient<$Result.GetResult<Prisma.$GPTMessagePayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of GPTMessages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GPTMessageCountArgs} args - Arguments to filter GPTMessages to count.
     * @example
     * // Count the number of GPTMessages
     * const count = await prisma.gPTMessage.count({
     *   where: {
     *     // ... the filter for the GPTMessages we want to count
     *   }
     * })
    **/
    count<T extends GPTMessageCountArgs>(
      args?: Subset<T, GPTMessageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GPTMessageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a GPTMessage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GPTMessageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GPTMessageAggregateArgs>(args: Subset<T, GPTMessageAggregateArgs>): Prisma.PrismaPromise<GetGPTMessageAggregateType<T>>

    /**
     * Group by GPTMessage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GPTMessageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GPTMessageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GPTMessageGroupByArgs['orderBy'] }
        : { orderBy?: GPTMessageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GPTMessageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGPTMessageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the GPTMessage model
   */
  readonly fields: GPTMessageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for GPTMessage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__GPTMessageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    message_history_relation<T extends GPTMessageHistoryDefaultArgs<ExtArgs> = {}>(args?: Subset<T, GPTMessageHistoryDefaultArgs<ExtArgs>>): Prisma__GPTMessageHistoryClient<$Result.GetResult<Prisma.$GPTMessageHistoryPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the GPTMessage model
   */ 
  interface GPTMessageFieldRefs {
    readonly message_history_id: FieldRef<"GPTMessage", 'String'>
    readonly number: FieldRef<"GPTMessage", 'Int'>
    readonly text: FieldRef<"GPTMessage", 'String'>
    readonly role: FieldRef<"GPTMessage", 'String'>
  }
    

  // Custom InputTypes
  /**
   * GPTMessage findUnique
   */
  export type GPTMessageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GPTMessage
     */
    select?: GPTMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GPTMessage
     */
    omit?: GPTMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GPTMessageInclude<ExtArgs> | null
    /**
     * Filter, which GPTMessage to fetch.
     */
    where: GPTMessageWhereUniqueInput
  }

  /**
   * GPTMessage findUniqueOrThrow
   */
  export type GPTMessageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GPTMessage
     */
    select?: GPTMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GPTMessage
     */
    omit?: GPTMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GPTMessageInclude<ExtArgs> | null
    /**
     * Filter, which GPTMessage to fetch.
     */
    where: GPTMessageWhereUniqueInput
  }

  /**
   * GPTMessage findFirst
   */
  export type GPTMessageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GPTMessage
     */
    select?: GPTMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GPTMessage
     */
    omit?: GPTMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GPTMessageInclude<ExtArgs> | null
    /**
     * Filter, which GPTMessage to fetch.
     */
    where?: GPTMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GPTMessages to fetch.
     */
    orderBy?: GPTMessageOrderByWithRelationInput | GPTMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GPTMessages.
     */
    cursor?: GPTMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GPTMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GPTMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GPTMessages.
     */
    distinct?: GPTMessageScalarFieldEnum | GPTMessageScalarFieldEnum[]
  }

  /**
   * GPTMessage findFirstOrThrow
   */
  export type GPTMessageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GPTMessage
     */
    select?: GPTMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GPTMessage
     */
    omit?: GPTMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GPTMessageInclude<ExtArgs> | null
    /**
     * Filter, which GPTMessage to fetch.
     */
    where?: GPTMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GPTMessages to fetch.
     */
    orderBy?: GPTMessageOrderByWithRelationInput | GPTMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GPTMessages.
     */
    cursor?: GPTMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GPTMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GPTMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GPTMessages.
     */
    distinct?: GPTMessageScalarFieldEnum | GPTMessageScalarFieldEnum[]
  }

  /**
   * GPTMessage findMany
   */
  export type GPTMessageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GPTMessage
     */
    select?: GPTMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GPTMessage
     */
    omit?: GPTMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GPTMessageInclude<ExtArgs> | null
    /**
     * Filter, which GPTMessages to fetch.
     */
    where?: GPTMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GPTMessages to fetch.
     */
    orderBy?: GPTMessageOrderByWithRelationInput | GPTMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing GPTMessages.
     */
    cursor?: GPTMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GPTMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GPTMessages.
     */
    skip?: number
    distinct?: GPTMessageScalarFieldEnum | GPTMessageScalarFieldEnum[]
  }

  /**
   * GPTMessage create
   */
  export type GPTMessageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GPTMessage
     */
    select?: GPTMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GPTMessage
     */
    omit?: GPTMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GPTMessageInclude<ExtArgs> | null
    /**
     * The data needed to create a GPTMessage.
     */
    data: XOR<GPTMessageCreateInput, GPTMessageUncheckedCreateInput>
  }

  /**
   * GPTMessage createMany
   */
  export type GPTMessageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many GPTMessages.
     */
    data: GPTMessageCreateManyInput | GPTMessageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * GPTMessage createManyAndReturn
   */
  export type GPTMessageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GPTMessage
     */
    select?: GPTMessageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the GPTMessage
     */
    omit?: GPTMessageOmit<ExtArgs> | null
    /**
     * The data used to create many GPTMessages.
     */
    data: GPTMessageCreateManyInput | GPTMessageCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GPTMessageIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * GPTMessage update
   */
  export type GPTMessageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GPTMessage
     */
    select?: GPTMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GPTMessage
     */
    omit?: GPTMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GPTMessageInclude<ExtArgs> | null
    /**
     * The data needed to update a GPTMessage.
     */
    data: XOR<GPTMessageUpdateInput, GPTMessageUncheckedUpdateInput>
    /**
     * Choose, which GPTMessage to update.
     */
    where: GPTMessageWhereUniqueInput
  }

  /**
   * GPTMessage updateMany
   */
  export type GPTMessageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update GPTMessages.
     */
    data: XOR<GPTMessageUpdateManyMutationInput, GPTMessageUncheckedUpdateManyInput>
    /**
     * Filter which GPTMessages to update
     */
    where?: GPTMessageWhereInput
    /**
     * Limit how many GPTMessages to update.
     */
    limit?: number
  }

  /**
   * GPTMessage updateManyAndReturn
   */
  export type GPTMessageUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GPTMessage
     */
    select?: GPTMessageSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the GPTMessage
     */
    omit?: GPTMessageOmit<ExtArgs> | null
    /**
     * The data used to update GPTMessages.
     */
    data: XOR<GPTMessageUpdateManyMutationInput, GPTMessageUncheckedUpdateManyInput>
    /**
     * Filter which GPTMessages to update
     */
    where?: GPTMessageWhereInput
    /**
     * Limit how many GPTMessages to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GPTMessageIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * GPTMessage upsert
   */
  export type GPTMessageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GPTMessage
     */
    select?: GPTMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GPTMessage
     */
    omit?: GPTMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GPTMessageInclude<ExtArgs> | null
    /**
     * The filter to search for the GPTMessage to update in case it exists.
     */
    where: GPTMessageWhereUniqueInput
    /**
     * In case the GPTMessage found by the `where` argument doesn't exist, create a new GPTMessage with this data.
     */
    create: XOR<GPTMessageCreateInput, GPTMessageUncheckedCreateInput>
    /**
     * In case the GPTMessage was found with the provided `where` argument, update it with this data.
     */
    update: XOR<GPTMessageUpdateInput, GPTMessageUncheckedUpdateInput>
  }

  /**
   * GPTMessage delete
   */
  export type GPTMessageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GPTMessage
     */
    select?: GPTMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GPTMessage
     */
    omit?: GPTMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GPTMessageInclude<ExtArgs> | null
    /**
     * Filter which GPTMessage to delete.
     */
    where: GPTMessageWhereUniqueInput
  }

  /**
   * GPTMessage deleteMany
   */
  export type GPTMessageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GPTMessages to delete
     */
    where?: GPTMessageWhereInput
    /**
     * Limit how many GPTMessages to delete.
     */
    limit?: number
  }

  /**
   * GPTMessage without action
   */
  export type GPTMessageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GPTMessage
     */
    select?: GPTMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GPTMessage
     */
    omit?: GPTMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GPTMessageInclude<ExtArgs> | null
  }


  /**
   * Model Adventure
   */

  export type AggregateAdventure = {
    _count: AdventureCountAggregateOutputType | null
    _min: AdventureMinAggregateOutputType | null
    _max: AdventureMaxAggregateOutputType | null
  }

  export type AdventureMinAggregateOutputType = {
    id: string | null
    name: string | null
    genre_id: string | null
    creator_id: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type AdventureMaxAggregateOutputType = {
    id: string | null
    name: string | null
    genre_id: string | null
    creator_id: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type AdventureCountAggregateOutputType = {
    id: number
    name: number
    genre_id: number
    creator_id: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type AdventureMinAggregateInputType = {
    id?: true
    name?: true
    genre_id?: true
    creator_id?: true
    created_at?: true
    updated_at?: true
  }

  export type AdventureMaxAggregateInputType = {
    id?: true
    name?: true
    genre_id?: true
    creator_id?: true
    created_at?: true
    updated_at?: true
  }

  export type AdventureCountAggregateInputType = {
    id?: true
    name?: true
    genre_id?: true
    creator_id?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type AdventureAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Adventure to aggregate.
     */
    where?: AdventureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Adventures to fetch.
     */
    orderBy?: AdventureOrderByWithRelationInput | AdventureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AdventureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Adventures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Adventures.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Adventures
    **/
    _count?: true | AdventureCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AdventureMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AdventureMaxAggregateInputType
  }

  export type GetAdventureAggregateType<T extends AdventureAggregateArgs> = {
        [P in keyof T & keyof AggregateAdventure]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAdventure[P]>
      : GetScalarType<T[P], AggregateAdventure[P]>
  }




  export type AdventureGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdventureWhereInput
    orderBy?: AdventureOrderByWithAggregationInput | AdventureOrderByWithAggregationInput[]
    by: AdventureScalarFieldEnum[] | AdventureScalarFieldEnum
    having?: AdventureScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AdventureCountAggregateInputType | true
    _min?: AdventureMinAggregateInputType
    _max?: AdventureMaxAggregateInputType
  }

  export type AdventureGroupByOutputType = {
    id: string
    name: string
    genre_id: string
    creator_id: string
    created_at: Date
    updated_at: Date
    _count: AdventureCountAggregateOutputType | null
    _min: AdventureMinAggregateOutputType | null
    _max: AdventureMaxAggregateOutputType | null
  }

  type GetAdventureGroupByPayload<T extends AdventureGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AdventureGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AdventureGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AdventureGroupByOutputType[P]>
            : GetScalarType<T[P], AdventureGroupByOutputType[P]>
        }
      >
    >


  export type AdventureSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    genre_id?: boolean
    creator_id?: boolean
    created_at?: boolean
    updated_at?: boolean
    genre_relation?: boolean | GenreDefaultArgs<ExtArgs>
    keywords_relation?: boolean | Adventure$keywords_relationArgs<ExtArgs>
    _count?: boolean | AdventureCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["adventure"]>

  export type AdventureSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    genre_id?: boolean
    creator_id?: boolean
    created_at?: boolean
    updated_at?: boolean
    genre_relation?: boolean | GenreDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["adventure"]>

  export type AdventureSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    genre_id?: boolean
    creator_id?: boolean
    created_at?: boolean
    updated_at?: boolean
    genre_relation?: boolean | GenreDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["adventure"]>

  export type AdventureSelectScalar = {
    id?: boolean
    name?: boolean
    genre_id?: boolean
    creator_id?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type AdventureOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "genre_id" | "creator_id" | "created_at" | "updated_at", ExtArgs["result"]["adventure"]>
  export type AdventureInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    genre_relation?: boolean | GenreDefaultArgs<ExtArgs>
    keywords_relation?: boolean | Adventure$keywords_relationArgs<ExtArgs>
    _count?: boolean | AdventureCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type AdventureIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    genre_relation?: boolean | GenreDefaultArgs<ExtArgs>
  }
  export type AdventureIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    genre_relation?: boolean | GenreDefaultArgs<ExtArgs>
  }

  export type $AdventurePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Adventure"
    objects: {
      genre_relation: Prisma.$GenrePayload<ExtArgs>
      keywords_relation: Prisma.$KeywordPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      genre_id: string
      creator_id: string
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["adventure"]>
    composites: {}
  }

  type AdventureGetPayload<S extends boolean | null | undefined | AdventureDefaultArgs> = $Result.GetResult<Prisma.$AdventurePayload, S>

  type AdventureCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AdventureFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AdventureCountAggregateInputType | true
    }

  export interface AdventureDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Adventure'], meta: { name: 'Adventure' } }
    /**
     * Find zero or one Adventure that matches the filter.
     * @param {AdventureFindUniqueArgs} args - Arguments to find a Adventure
     * @example
     * // Get one Adventure
     * const adventure = await prisma.adventure.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AdventureFindUniqueArgs>(args: SelectSubset<T, AdventureFindUniqueArgs<ExtArgs>>): Prisma__AdventureClient<$Result.GetResult<Prisma.$AdventurePayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Adventure that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AdventureFindUniqueOrThrowArgs} args - Arguments to find a Adventure
     * @example
     * // Get one Adventure
     * const adventure = await prisma.adventure.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AdventureFindUniqueOrThrowArgs>(args: SelectSubset<T, AdventureFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AdventureClient<$Result.GetResult<Prisma.$AdventurePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Adventure that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdventureFindFirstArgs} args - Arguments to find a Adventure
     * @example
     * // Get one Adventure
     * const adventure = await prisma.adventure.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AdventureFindFirstArgs>(args?: SelectSubset<T, AdventureFindFirstArgs<ExtArgs>>): Prisma__AdventureClient<$Result.GetResult<Prisma.$AdventurePayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Adventure that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdventureFindFirstOrThrowArgs} args - Arguments to find a Adventure
     * @example
     * // Get one Adventure
     * const adventure = await prisma.adventure.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AdventureFindFirstOrThrowArgs>(args?: SelectSubset<T, AdventureFindFirstOrThrowArgs<ExtArgs>>): Prisma__AdventureClient<$Result.GetResult<Prisma.$AdventurePayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Adventures that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdventureFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Adventures
     * const adventures = await prisma.adventure.findMany()
     * 
     * // Get first 10 Adventures
     * const adventures = await prisma.adventure.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const adventureWithIdOnly = await prisma.adventure.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AdventureFindManyArgs>(args?: SelectSubset<T, AdventureFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdventurePayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Adventure.
     * @param {AdventureCreateArgs} args - Arguments to create a Adventure.
     * @example
     * // Create one Adventure
     * const Adventure = await prisma.adventure.create({
     *   data: {
     *     // ... data to create a Adventure
     *   }
     * })
     * 
     */
    create<T extends AdventureCreateArgs>(args: SelectSubset<T, AdventureCreateArgs<ExtArgs>>): Prisma__AdventureClient<$Result.GetResult<Prisma.$AdventurePayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Adventures.
     * @param {AdventureCreateManyArgs} args - Arguments to create many Adventures.
     * @example
     * // Create many Adventures
     * const adventure = await prisma.adventure.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AdventureCreateManyArgs>(args?: SelectSubset<T, AdventureCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Adventures and returns the data saved in the database.
     * @param {AdventureCreateManyAndReturnArgs} args - Arguments to create many Adventures.
     * @example
     * // Create many Adventures
     * const adventure = await prisma.adventure.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Adventures and only return the `id`
     * const adventureWithIdOnly = await prisma.adventure.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AdventureCreateManyAndReturnArgs>(args?: SelectSubset<T, AdventureCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdventurePayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Adventure.
     * @param {AdventureDeleteArgs} args - Arguments to delete one Adventure.
     * @example
     * // Delete one Adventure
     * const Adventure = await prisma.adventure.delete({
     *   where: {
     *     // ... filter to delete one Adventure
     *   }
     * })
     * 
     */
    delete<T extends AdventureDeleteArgs>(args: SelectSubset<T, AdventureDeleteArgs<ExtArgs>>): Prisma__AdventureClient<$Result.GetResult<Prisma.$AdventurePayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Adventure.
     * @param {AdventureUpdateArgs} args - Arguments to update one Adventure.
     * @example
     * // Update one Adventure
     * const adventure = await prisma.adventure.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AdventureUpdateArgs>(args: SelectSubset<T, AdventureUpdateArgs<ExtArgs>>): Prisma__AdventureClient<$Result.GetResult<Prisma.$AdventurePayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Adventures.
     * @param {AdventureDeleteManyArgs} args - Arguments to filter Adventures to delete.
     * @example
     * // Delete a few Adventures
     * const { count } = await prisma.adventure.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AdventureDeleteManyArgs>(args?: SelectSubset<T, AdventureDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Adventures.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdventureUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Adventures
     * const adventure = await prisma.adventure.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AdventureUpdateManyArgs>(args: SelectSubset<T, AdventureUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Adventures and returns the data updated in the database.
     * @param {AdventureUpdateManyAndReturnArgs} args - Arguments to update many Adventures.
     * @example
     * // Update many Adventures
     * const adventure = await prisma.adventure.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Adventures and only return the `id`
     * const adventureWithIdOnly = await prisma.adventure.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AdventureUpdateManyAndReturnArgs>(args: SelectSubset<T, AdventureUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdventurePayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Adventure.
     * @param {AdventureUpsertArgs} args - Arguments to update or create a Adventure.
     * @example
     * // Update or create a Adventure
     * const adventure = await prisma.adventure.upsert({
     *   create: {
     *     // ... data to create a Adventure
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Adventure we want to update
     *   }
     * })
     */
    upsert<T extends AdventureUpsertArgs>(args: SelectSubset<T, AdventureUpsertArgs<ExtArgs>>): Prisma__AdventureClient<$Result.GetResult<Prisma.$AdventurePayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Adventures.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdventureCountArgs} args - Arguments to filter Adventures to count.
     * @example
     * // Count the number of Adventures
     * const count = await prisma.adventure.count({
     *   where: {
     *     // ... the filter for the Adventures we want to count
     *   }
     * })
    **/
    count<T extends AdventureCountArgs>(
      args?: Subset<T, AdventureCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AdventureCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Adventure.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdventureAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AdventureAggregateArgs>(args: Subset<T, AdventureAggregateArgs>): Prisma.PrismaPromise<GetAdventureAggregateType<T>>

    /**
     * Group by Adventure.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdventureGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AdventureGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AdventureGroupByArgs['orderBy'] }
        : { orderBy?: AdventureGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AdventureGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAdventureGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Adventure model
   */
  readonly fields: AdventureFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Adventure.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AdventureClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    genre_relation<T extends GenreDefaultArgs<ExtArgs> = {}>(args?: Subset<T, GenreDefaultArgs<ExtArgs>>): Prisma__GenreClient<$Result.GetResult<Prisma.$GenrePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    keywords_relation<T extends Adventure$keywords_relationArgs<ExtArgs> = {}>(args?: Subset<T, Adventure$keywords_relationArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$KeywordPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Adventure model
   */ 
  interface AdventureFieldRefs {
    readonly id: FieldRef<"Adventure", 'String'>
    readonly name: FieldRef<"Adventure", 'String'>
    readonly genre_id: FieldRef<"Adventure", 'String'>
    readonly creator_id: FieldRef<"Adventure", 'String'>
    readonly created_at: FieldRef<"Adventure", 'DateTime'>
    readonly updated_at: FieldRef<"Adventure", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Adventure findUnique
   */
  export type AdventureFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Adventure
     */
    select?: AdventureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Adventure
     */
    omit?: AdventureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdventureInclude<ExtArgs> | null
    /**
     * Filter, which Adventure to fetch.
     */
    where: AdventureWhereUniqueInput
  }

  /**
   * Adventure findUniqueOrThrow
   */
  export type AdventureFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Adventure
     */
    select?: AdventureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Adventure
     */
    omit?: AdventureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdventureInclude<ExtArgs> | null
    /**
     * Filter, which Adventure to fetch.
     */
    where: AdventureWhereUniqueInput
  }

  /**
   * Adventure findFirst
   */
  export type AdventureFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Adventure
     */
    select?: AdventureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Adventure
     */
    omit?: AdventureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdventureInclude<ExtArgs> | null
    /**
     * Filter, which Adventure to fetch.
     */
    where?: AdventureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Adventures to fetch.
     */
    orderBy?: AdventureOrderByWithRelationInput | AdventureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Adventures.
     */
    cursor?: AdventureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Adventures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Adventures.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Adventures.
     */
    distinct?: AdventureScalarFieldEnum | AdventureScalarFieldEnum[]
  }

  /**
   * Adventure findFirstOrThrow
   */
  export type AdventureFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Adventure
     */
    select?: AdventureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Adventure
     */
    omit?: AdventureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdventureInclude<ExtArgs> | null
    /**
     * Filter, which Adventure to fetch.
     */
    where?: AdventureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Adventures to fetch.
     */
    orderBy?: AdventureOrderByWithRelationInput | AdventureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Adventures.
     */
    cursor?: AdventureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Adventures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Adventures.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Adventures.
     */
    distinct?: AdventureScalarFieldEnum | AdventureScalarFieldEnum[]
  }

  /**
   * Adventure findMany
   */
  export type AdventureFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Adventure
     */
    select?: AdventureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Adventure
     */
    omit?: AdventureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdventureInclude<ExtArgs> | null
    /**
     * Filter, which Adventures to fetch.
     */
    where?: AdventureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Adventures to fetch.
     */
    orderBy?: AdventureOrderByWithRelationInput | AdventureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Adventures.
     */
    cursor?: AdventureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Adventures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Adventures.
     */
    skip?: number
    distinct?: AdventureScalarFieldEnum | AdventureScalarFieldEnum[]
  }

  /**
   * Adventure create
   */
  export type AdventureCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Adventure
     */
    select?: AdventureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Adventure
     */
    omit?: AdventureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdventureInclude<ExtArgs> | null
    /**
     * The data needed to create a Adventure.
     */
    data: XOR<AdventureCreateInput, AdventureUncheckedCreateInput>
  }

  /**
   * Adventure createMany
   */
  export type AdventureCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Adventures.
     */
    data: AdventureCreateManyInput | AdventureCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Adventure createManyAndReturn
   */
  export type AdventureCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Adventure
     */
    select?: AdventureSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Adventure
     */
    omit?: AdventureOmit<ExtArgs> | null
    /**
     * The data used to create many Adventures.
     */
    data: AdventureCreateManyInput | AdventureCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdventureIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Adventure update
   */
  export type AdventureUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Adventure
     */
    select?: AdventureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Adventure
     */
    omit?: AdventureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdventureInclude<ExtArgs> | null
    /**
     * The data needed to update a Adventure.
     */
    data: XOR<AdventureUpdateInput, AdventureUncheckedUpdateInput>
    /**
     * Choose, which Adventure to update.
     */
    where: AdventureWhereUniqueInput
  }

  /**
   * Adventure updateMany
   */
  export type AdventureUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Adventures.
     */
    data: XOR<AdventureUpdateManyMutationInput, AdventureUncheckedUpdateManyInput>
    /**
     * Filter which Adventures to update
     */
    where?: AdventureWhereInput
    /**
     * Limit how many Adventures to update.
     */
    limit?: number
  }

  /**
   * Adventure updateManyAndReturn
   */
  export type AdventureUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Adventure
     */
    select?: AdventureSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Adventure
     */
    omit?: AdventureOmit<ExtArgs> | null
    /**
     * The data used to update Adventures.
     */
    data: XOR<AdventureUpdateManyMutationInput, AdventureUncheckedUpdateManyInput>
    /**
     * Filter which Adventures to update
     */
    where?: AdventureWhereInput
    /**
     * Limit how many Adventures to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdventureIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Adventure upsert
   */
  export type AdventureUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Adventure
     */
    select?: AdventureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Adventure
     */
    omit?: AdventureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdventureInclude<ExtArgs> | null
    /**
     * The filter to search for the Adventure to update in case it exists.
     */
    where: AdventureWhereUniqueInput
    /**
     * In case the Adventure found by the `where` argument doesn't exist, create a new Adventure with this data.
     */
    create: XOR<AdventureCreateInput, AdventureUncheckedCreateInput>
    /**
     * In case the Adventure was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AdventureUpdateInput, AdventureUncheckedUpdateInput>
  }

  /**
   * Adventure delete
   */
  export type AdventureDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Adventure
     */
    select?: AdventureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Adventure
     */
    omit?: AdventureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdventureInclude<ExtArgs> | null
    /**
     * Filter which Adventure to delete.
     */
    where: AdventureWhereUniqueInput
  }

  /**
   * Adventure deleteMany
   */
  export type AdventureDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Adventures to delete
     */
    where?: AdventureWhereInput
    /**
     * Limit how many Adventures to delete.
     */
    limit?: number
  }

  /**
   * Adventure.keywords_relation
   */
  export type Adventure$keywords_relationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Keyword
     */
    select?: KeywordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Keyword
     */
    omit?: KeywordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KeywordInclude<ExtArgs> | null
    where?: KeywordWhereInput
    orderBy?: KeywordOrderByWithRelationInput | KeywordOrderByWithRelationInput[]
    cursor?: KeywordWhereUniqueInput
    take?: number
    skip?: number
    distinct?: KeywordScalarFieldEnum | KeywordScalarFieldEnum[]
  }

  /**
   * Adventure without action
   */
  export type AdventureDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Adventure
     */
    select?: AdventureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Adventure
     */
    omit?: AdventureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdventureInclude<ExtArgs> | null
  }


  /**
   * Model Keyword
   */

  export type AggregateKeyword = {
    _count: KeywordCountAggregateOutputType | null
    _min: KeywordMinAggregateOutputType | null
    _max: KeywordMaxAggregateOutputType | null
  }

  export type KeywordMinAggregateOutputType = {
    id: string | null
    name: string | null
    genre_id: string | null
  }

  export type KeywordMaxAggregateOutputType = {
    id: string | null
    name: string | null
    genre_id: string | null
  }

  export type KeywordCountAggregateOutputType = {
    id: number
    name: number
    genre_id: number
    _all: number
  }


  export type KeywordMinAggregateInputType = {
    id?: true
    name?: true
    genre_id?: true
  }

  export type KeywordMaxAggregateInputType = {
    id?: true
    name?: true
    genre_id?: true
  }

  export type KeywordCountAggregateInputType = {
    id?: true
    name?: true
    genre_id?: true
    _all?: true
  }

  export type KeywordAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Keyword to aggregate.
     */
    where?: KeywordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Keywords to fetch.
     */
    orderBy?: KeywordOrderByWithRelationInput | KeywordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: KeywordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Keywords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Keywords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Keywords
    **/
    _count?: true | KeywordCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: KeywordMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: KeywordMaxAggregateInputType
  }

  export type GetKeywordAggregateType<T extends KeywordAggregateArgs> = {
        [P in keyof T & keyof AggregateKeyword]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateKeyword[P]>
      : GetScalarType<T[P], AggregateKeyword[P]>
  }




  export type KeywordGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: KeywordWhereInput
    orderBy?: KeywordOrderByWithAggregationInput | KeywordOrderByWithAggregationInput[]
    by: KeywordScalarFieldEnum[] | KeywordScalarFieldEnum
    having?: KeywordScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: KeywordCountAggregateInputType | true
    _min?: KeywordMinAggregateInputType
    _max?: KeywordMaxAggregateInputType
  }

  export type KeywordGroupByOutputType = {
    id: string
    name: string
    genre_id: string
    _count: KeywordCountAggregateOutputType | null
    _min: KeywordMinAggregateOutputType | null
    _max: KeywordMaxAggregateOutputType | null
  }

  type GetKeywordGroupByPayload<T extends KeywordGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<KeywordGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof KeywordGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], KeywordGroupByOutputType[P]>
            : GetScalarType<T[P], KeywordGroupByOutputType[P]>
        }
      >
    >


  export type KeywordSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    genre_id?: boolean
    genre_relation?: boolean | GenreDefaultArgs<ExtArgs>
    adventures_relation?: boolean | Keyword$adventures_relationArgs<ExtArgs>
    _count?: boolean | KeywordCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["keyword"]>

  export type KeywordSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    genre_id?: boolean
    genre_relation?: boolean | GenreDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["keyword"]>

  export type KeywordSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    genre_id?: boolean
    genre_relation?: boolean | GenreDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["keyword"]>

  export type KeywordSelectScalar = {
    id?: boolean
    name?: boolean
    genre_id?: boolean
  }

  export type KeywordOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "genre_id", ExtArgs["result"]["keyword"]>
  export type KeywordInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    genre_relation?: boolean | GenreDefaultArgs<ExtArgs>
    adventures_relation?: boolean | Keyword$adventures_relationArgs<ExtArgs>
    _count?: boolean | KeywordCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type KeywordIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    genre_relation?: boolean | GenreDefaultArgs<ExtArgs>
  }
  export type KeywordIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    genre_relation?: boolean | GenreDefaultArgs<ExtArgs>
  }

  export type $KeywordPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Keyword"
    objects: {
      genre_relation: Prisma.$GenrePayload<ExtArgs>
      adventures_relation: Prisma.$AdventurePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      genre_id: string
    }, ExtArgs["result"]["keyword"]>
    composites: {}
  }

  type KeywordGetPayload<S extends boolean | null | undefined | KeywordDefaultArgs> = $Result.GetResult<Prisma.$KeywordPayload, S>

  type KeywordCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<KeywordFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: KeywordCountAggregateInputType | true
    }

  export interface KeywordDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Keyword'], meta: { name: 'Keyword' } }
    /**
     * Find zero or one Keyword that matches the filter.
     * @param {KeywordFindUniqueArgs} args - Arguments to find a Keyword
     * @example
     * // Get one Keyword
     * const keyword = await prisma.keyword.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends KeywordFindUniqueArgs>(args: SelectSubset<T, KeywordFindUniqueArgs<ExtArgs>>): Prisma__KeywordClient<$Result.GetResult<Prisma.$KeywordPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Keyword that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {KeywordFindUniqueOrThrowArgs} args - Arguments to find a Keyword
     * @example
     * // Get one Keyword
     * const keyword = await prisma.keyword.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends KeywordFindUniqueOrThrowArgs>(args: SelectSubset<T, KeywordFindUniqueOrThrowArgs<ExtArgs>>): Prisma__KeywordClient<$Result.GetResult<Prisma.$KeywordPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Keyword that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KeywordFindFirstArgs} args - Arguments to find a Keyword
     * @example
     * // Get one Keyword
     * const keyword = await prisma.keyword.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends KeywordFindFirstArgs>(args?: SelectSubset<T, KeywordFindFirstArgs<ExtArgs>>): Prisma__KeywordClient<$Result.GetResult<Prisma.$KeywordPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Keyword that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KeywordFindFirstOrThrowArgs} args - Arguments to find a Keyword
     * @example
     * // Get one Keyword
     * const keyword = await prisma.keyword.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends KeywordFindFirstOrThrowArgs>(args?: SelectSubset<T, KeywordFindFirstOrThrowArgs<ExtArgs>>): Prisma__KeywordClient<$Result.GetResult<Prisma.$KeywordPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Keywords that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KeywordFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Keywords
     * const keywords = await prisma.keyword.findMany()
     * 
     * // Get first 10 Keywords
     * const keywords = await prisma.keyword.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const keywordWithIdOnly = await prisma.keyword.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends KeywordFindManyArgs>(args?: SelectSubset<T, KeywordFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$KeywordPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Keyword.
     * @param {KeywordCreateArgs} args - Arguments to create a Keyword.
     * @example
     * // Create one Keyword
     * const Keyword = await prisma.keyword.create({
     *   data: {
     *     // ... data to create a Keyword
     *   }
     * })
     * 
     */
    create<T extends KeywordCreateArgs>(args: SelectSubset<T, KeywordCreateArgs<ExtArgs>>): Prisma__KeywordClient<$Result.GetResult<Prisma.$KeywordPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Keywords.
     * @param {KeywordCreateManyArgs} args - Arguments to create many Keywords.
     * @example
     * // Create many Keywords
     * const keyword = await prisma.keyword.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends KeywordCreateManyArgs>(args?: SelectSubset<T, KeywordCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Keywords and returns the data saved in the database.
     * @param {KeywordCreateManyAndReturnArgs} args - Arguments to create many Keywords.
     * @example
     * // Create many Keywords
     * const keyword = await prisma.keyword.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Keywords and only return the `id`
     * const keywordWithIdOnly = await prisma.keyword.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends KeywordCreateManyAndReturnArgs>(args?: SelectSubset<T, KeywordCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$KeywordPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Keyword.
     * @param {KeywordDeleteArgs} args - Arguments to delete one Keyword.
     * @example
     * // Delete one Keyword
     * const Keyword = await prisma.keyword.delete({
     *   where: {
     *     // ... filter to delete one Keyword
     *   }
     * })
     * 
     */
    delete<T extends KeywordDeleteArgs>(args: SelectSubset<T, KeywordDeleteArgs<ExtArgs>>): Prisma__KeywordClient<$Result.GetResult<Prisma.$KeywordPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Keyword.
     * @param {KeywordUpdateArgs} args - Arguments to update one Keyword.
     * @example
     * // Update one Keyword
     * const keyword = await prisma.keyword.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends KeywordUpdateArgs>(args: SelectSubset<T, KeywordUpdateArgs<ExtArgs>>): Prisma__KeywordClient<$Result.GetResult<Prisma.$KeywordPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Keywords.
     * @param {KeywordDeleteManyArgs} args - Arguments to filter Keywords to delete.
     * @example
     * // Delete a few Keywords
     * const { count } = await prisma.keyword.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends KeywordDeleteManyArgs>(args?: SelectSubset<T, KeywordDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Keywords.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KeywordUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Keywords
     * const keyword = await prisma.keyword.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends KeywordUpdateManyArgs>(args: SelectSubset<T, KeywordUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Keywords and returns the data updated in the database.
     * @param {KeywordUpdateManyAndReturnArgs} args - Arguments to update many Keywords.
     * @example
     * // Update many Keywords
     * const keyword = await prisma.keyword.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Keywords and only return the `id`
     * const keywordWithIdOnly = await prisma.keyword.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends KeywordUpdateManyAndReturnArgs>(args: SelectSubset<T, KeywordUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$KeywordPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Keyword.
     * @param {KeywordUpsertArgs} args - Arguments to update or create a Keyword.
     * @example
     * // Update or create a Keyword
     * const keyword = await prisma.keyword.upsert({
     *   create: {
     *     // ... data to create a Keyword
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Keyword we want to update
     *   }
     * })
     */
    upsert<T extends KeywordUpsertArgs>(args: SelectSubset<T, KeywordUpsertArgs<ExtArgs>>): Prisma__KeywordClient<$Result.GetResult<Prisma.$KeywordPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Keywords.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KeywordCountArgs} args - Arguments to filter Keywords to count.
     * @example
     * // Count the number of Keywords
     * const count = await prisma.keyword.count({
     *   where: {
     *     // ... the filter for the Keywords we want to count
     *   }
     * })
    **/
    count<T extends KeywordCountArgs>(
      args?: Subset<T, KeywordCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], KeywordCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Keyword.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KeywordAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends KeywordAggregateArgs>(args: Subset<T, KeywordAggregateArgs>): Prisma.PrismaPromise<GetKeywordAggregateType<T>>

    /**
     * Group by Keyword.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KeywordGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends KeywordGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: KeywordGroupByArgs['orderBy'] }
        : { orderBy?: KeywordGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, KeywordGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetKeywordGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Keyword model
   */
  readonly fields: KeywordFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Keyword.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__KeywordClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    genre_relation<T extends GenreDefaultArgs<ExtArgs> = {}>(args?: Subset<T, GenreDefaultArgs<ExtArgs>>): Prisma__GenreClient<$Result.GetResult<Prisma.$GenrePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    adventures_relation<T extends Keyword$adventures_relationArgs<ExtArgs> = {}>(args?: Subset<T, Keyword$adventures_relationArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdventurePayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Keyword model
   */ 
  interface KeywordFieldRefs {
    readonly id: FieldRef<"Keyword", 'String'>
    readonly name: FieldRef<"Keyword", 'String'>
    readonly genre_id: FieldRef<"Keyword", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Keyword findUnique
   */
  export type KeywordFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Keyword
     */
    select?: KeywordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Keyword
     */
    omit?: KeywordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KeywordInclude<ExtArgs> | null
    /**
     * Filter, which Keyword to fetch.
     */
    where: KeywordWhereUniqueInput
  }

  /**
   * Keyword findUniqueOrThrow
   */
  export type KeywordFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Keyword
     */
    select?: KeywordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Keyword
     */
    omit?: KeywordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KeywordInclude<ExtArgs> | null
    /**
     * Filter, which Keyword to fetch.
     */
    where: KeywordWhereUniqueInput
  }

  /**
   * Keyword findFirst
   */
  export type KeywordFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Keyword
     */
    select?: KeywordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Keyword
     */
    omit?: KeywordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KeywordInclude<ExtArgs> | null
    /**
     * Filter, which Keyword to fetch.
     */
    where?: KeywordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Keywords to fetch.
     */
    orderBy?: KeywordOrderByWithRelationInput | KeywordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Keywords.
     */
    cursor?: KeywordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Keywords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Keywords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Keywords.
     */
    distinct?: KeywordScalarFieldEnum | KeywordScalarFieldEnum[]
  }

  /**
   * Keyword findFirstOrThrow
   */
  export type KeywordFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Keyword
     */
    select?: KeywordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Keyword
     */
    omit?: KeywordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KeywordInclude<ExtArgs> | null
    /**
     * Filter, which Keyword to fetch.
     */
    where?: KeywordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Keywords to fetch.
     */
    orderBy?: KeywordOrderByWithRelationInput | KeywordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Keywords.
     */
    cursor?: KeywordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Keywords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Keywords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Keywords.
     */
    distinct?: KeywordScalarFieldEnum | KeywordScalarFieldEnum[]
  }

  /**
   * Keyword findMany
   */
  export type KeywordFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Keyword
     */
    select?: KeywordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Keyword
     */
    omit?: KeywordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KeywordInclude<ExtArgs> | null
    /**
     * Filter, which Keywords to fetch.
     */
    where?: KeywordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Keywords to fetch.
     */
    orderBy?: KeywordOrderByWithRelationInput | KeywordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Keywords.
     */
    cursor?: KeywordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Keywords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Keywords.
     */
    skip?: number
    distinct?: KeywordScalarFieldEnum | KeywordScalarFieldEnum[]
  }

  /**
   * Keyword create
   */
  export type KeywordCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Keyword
     */
    select?: KeywordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Keyword
     */
    omit?: KeywordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KeywordInclude<ExtArgs> | null
    /**
     * The data needed to create a Keyword.
     */
    data: XOR<KeywordCreateInput, KeywordUncheckedCreateInput>
  }

  /**
   * Keyword createMany
   */
  export type KeywordCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Keywords.
     */
    data: KeywordCreateManyInput | KeywordCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Keyword createManyAndReturn
   */
  export type KeywordCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Keyword
     */
    select?: KeywordSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Keyword
     */
    omit?: KeywordOmit<ExtArgs> | null
    /**
     * The data used to create many Keywords.
     */
    data: KeywordCreateManyInput | KeywordCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KeywordIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Keyword update
   */
  export type KeywordUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Keyword
     */
    select?: KeywordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Keyword
     */
    omit?: KeywordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KeywordInclude<ExtArgs> | null
    /**
     * The data needed to update a Keyword.
     */
    data: XOR<KeywordUpdateInput, KeywordUncheckedUpdateInput>
    /**
     * Choose, which Keyword to update.
     */
    where: KeywordWhereUniqueInput
  }

  /**
   * Keyword updateMany
   */
  export type KeywordUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Keywords.
     */
    data: XOR<KeywordUpdateManyMutationInput, KeywordUncheckedUpdateManyInput>
    /**
     * Filter which Keywords to update
     */
    where?: KeywordWhereInput
    /**
     * Limit how many Keywords to update.
     */
    limit?: number
  }

  /**
   * Keyword updateManyAndReturn
   */
  export type KeywordUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Keyword
     */
    select?: KeywordSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Keyword
     */
    omit?: KeywordOmit<ExtArgs> | null
    /**
     * The data used to update Keywords.
     */
    data: XOR<KeywordUpdateManyMutationInput, KeywordUncheckedUpdateManyInput>
    /**
     * Filter which Keywords to update
     */
    where?: KeywordWhereInput
    /**
     * Limit how many Keywords to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KeywordIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Keyword upsert
   */
  export type KeywordUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Keyword
     */
    select?: KeywordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Keyword
     */
    omit?: KeywordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KeywordInclude<ExtArgs> | null
    /**
     * The filter to search for the Keyword to update in case it exists.
     */
    where: KeywordWhereUniqueInput
    /**
     * In case the Keyword found by the `where` argument doesn't exist, create a new Keyword with this data.
     */
    create: XOR<KeywordCreateInput, KeywordUncheckedCreateInput>
    /**
     * In case the Keyword was found with the provided `where` argument, update it with this data.
     */
    update: XOR<KeywordUpdateInput, KeywordUncheckedUpdateInput>
  }

  /**
   * Keyword delete
   */
  export type KeywordDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Keyword
     */
    select?: KeywordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Keyword
     */
    omit?: KeywordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KeywordInclude<ExtArgs> | null
    /**
     * Filter which Keyword to delete.
     */
    where: KeywordWhereUniqueInput
  }

  /**
   * Keyword deleteMany
   */
  export type KeywordDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Keywords to delete
     */
    where?: KeywordWhereInput
    /**
     * Limit how many Keywords to delete.
     */
    limit?: number
  }

  /**
   * Keyword.adventures_relation
   */
  export type Keyword$adventures_relationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Adventure
     */
    select?: AdventureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Adventure
     */
    omit?: AdventureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdventureInclude<ExtArgs> | null
    where?: AdventureWhereInput
    orderBy?: AdventureOrderByWithRelationInput | AdventureOrderByWithRelationInput[]
    cursor?: AdventureWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AdventureScalarFieldEnum | AdventureScalarFieldEnum[]
  }

  /**
   * Keyword without action
   */
  export type KeywordDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Keyword
     */
    select?: KeywordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Keyword
     */
    omit?: KeywordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KeywordInclude<ExtArgs> | null
  }


  /**
   * Model Genre
   */

  export type AggregateGenre = {
    _count: GenreCountAggregateOutputType | null
    _min: GenreMinAggregateOutputType | null
    _max: GenreMaxAggregateOutputType | null
  }

  export type GenreMinAggregateOutputType = {
    id: string | null
    name: string | null
  }

  export type GenreMaxAggregateOutputType = {
    id: string | null
    name: string | null
  }

  export type GenreCountAggregateOutputType = {
    id: number
    name: number
    _all: number
  }


  export type GenreMinAggregateInputType = {
    id?: true
    name?: true
  }

  export type GenreMaxAggregateInputType = {
    id?: true
    name?: true
  }

  export type GenreCountAggregateInputType = {
    id?: true
    name?: true
    _all?: true
  }

  export type GenreAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Genre to aggregate.
     */
    where?: GenreWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Genres to fetch.
     */
    orderBy?: GenreOrderByWithRelationInput | GenreOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: GenreWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Genres from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Genres.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Genres
    **/
    _count?: true | GenreCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GenreMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GenreMaxAggregateInputType
  }

  export type GetGenreAggregateType<T extends GenreAggregateArgs> = {
        [P in keyof T & keyof AggregateGenre]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGenre[P]>
      : GetScalarType<T[P], AggregateGenre[P]>
  }




  export type GenreGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GenreWhereInput
    orderBy?: GenreOrderByWithAggregationInput | GenreOrderByWithAggregationInput[]
    by: GenreScalarFieldEnum[] | GenreScalarFieldEnum
    having?: GenreScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GenreCountAggregateInputType | true
    _min?: GenreMinAggregateInputType
    _max?: GenreMaxAggregateInputType
  }

  export type GenreGroupByOutputType = {
    id: string
    name: string
    _count: GenreCountAggregateOutputType | null
    _min: GenreMinAggregateOutputType | null
    _max: GenreMaxAggregateOutputType | null
  }

  type GetGenreGroupByPayload<T extends GenreGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GenreGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GenreGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GenreGroupByOutputType[P]>
            : GetScalarType<T[P], GenreGroupByOutputType[P]>
        }
      >
    >


  export type GenreSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    keywords_relation?: boolean | Genre$keywords_relationArgs<ExtArgs>
    adventures_relation?: boolean | Genre$adventures_relationArgs<ExtArgs>
    _count?: boolean | GenreCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["genre"]>

  export type GenreSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
  }, ExtArgs["result"]["genre"]>

  export type GenreSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
  }, ExtArgs["result"]["genre"]>

  export type GenreSelectScalar = {
    id?: boolean
    name?: boolean
  }

  export type GenreOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name", ExtArgs["result"]["genre"]>
  export type GenreInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    keywords_relation?: boolean | Genre$keywords_relationArgs<ExtArgs>
    adventures_relation?: boolean | Genre$adventures_relationArgs<ExtArgs>
    _count?: boolean | GenreCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type GenreIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type GenreIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $GenrePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Genre"
    objects: {
      keywords_relation: Prisma.$KeywordPayload<ExtArgs>[]
      adventures_relation: Prisma.$AdventurePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
    }, ExtArgs["result"]["genre"]>
    composites: {}
  }

  type GenreGetPayload<S extends boolean | null | undefined | GenreDefaultArgs> = $Result.GetResult<Prisma.$GenrePayload, S>

  type GenreCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<GenreFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: GenreCountAggregateInputType | true
    }

  export interface GenreDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Genre'], meta: { name: 'Genre' } }
    /**
     * Find zero or one Genre that matches the filter.
     * @param {GenreFindUniqueArgs} args - Arguments to find a Genre
     * @example
     * // Get one Genre
     * const genre = await prisma.genre.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends GenreFindUniqueArgs>(args: SelectSubset<T, GenreFindUniqueArgs<ExtArgs>>): Prisma__GenreClient<$Result.GetResult<Prisma.$GenrePayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Genre that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {GenreFindUniqueOrThrowArgs} args - Arguments to find a Genre
     * @example
     * // Get one Genre
     * const genre = await prisma.genre.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends GenreFindUniqueOrThrowArgs>(args: SelectSubset<T, GenreFindUniqueOrThrowArgs<ExtArgs>>): Prisma__GenreClient<$Result.GetResult<Prisma.$GenrePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Genre that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GenreFindFirstArgs} args - Arguments to find a Genre
     * @example
     * // Get one Genre
     * const genre = await prisma.genre.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends GenreFindFirstArgs>(args?: SelectSubset<T, GenreFindFirstArgs<ExtArgs>>): Prisma__GenreClient<$Result.GetResult<Prisma.$GenrePayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Genre that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GenreFindFirstOrThrowArgs} args - Arguments to find a Genre
     * @example
     * // Get one Genre
     * const genre = await prisma.genre.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends GenreFindFirstOrThrowArgs>(args?: SelectSubset<T, GenreFindFirstOrThrowArgs<ExtArgs>>): Prisma__GenreClient<$Result.GetResult<Prisma.$GenrePayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Genres that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GenreFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Genres
     * const genres = await prisma.genre.findMany()
     * 
     * // Get first 10 Genres
     * const genres = await prisma.genre.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const genreWithIdOnly = await prisma.genre.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends GenreFindManyArgs>(args?: SelectSubset<T, GenreFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GenrePayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Genre.
     * @param {GenreCreateArgs} args - Arguments to create a Genre.
     * @example
     * // Create one Genre
     * const Genre = await prisma.genre.create({
     *   data: {
     *     // ... data to create a Genre
     *   }
     * })
     * 
     */
    create<T extends GenreCreateArgs>(args: SelectSubset<T, GenreCreateArgs<ExtArgs>>): Prisma__GenreClient<$Result.GetResult<Prisma.$GenrePayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Genres.
     * @param {GenreCreateManyArgs} args - Arguments to create many Genres.
     * @example
     * // Create many Genres
     * const genre = await prisma.genre.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends GenreCreateManyArgs>(args?: SelectSubset<T, GenreCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Genres and returns the data saved in the database.
     * @param {GenreCreateManyAndReturnArgs} args - Arguments to create many Genres.
     * @example
     * // Create many Genres
     * const genre = await prisma.genre.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Genres and only return the `id`
     * const genreWithIdOnly = await prisma.genre.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends GenreCreateManyAndReturnArgs>(args?: SelectSubset<T, GenreCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GenrePayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Genre.
     * @param {GenreDeleteArgs} args - Arguments to delete one Genre.
     * @example
     * // Delete one Genre
     * const Genre = await prisma.genre.delete({
     *   where: {
     *     // ... filter to delete one Genre
     *   }
     * })
     * 
     */
    delete<T extends GenreDeleteArgs>(args: SelectSubset<T, GenreDeleteArgs<ExtArgs>>): Prisma__GenreClient<$Result.GetResult<Prisma.$GenrePayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Genre.
     * @param {GenreUpdateArgs} args - Arguments to update one Genre.
     * @example
     * // Update one Genre
     * const genre = await prisma.genre.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends GenreUpdateArgs>(args: SelectSubset<T, GenreUpdateArgs<ExtArgs>>): Prisma__GenreClient<$Result.GetResult<Prisma.$GenrePayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Genres.
     * @param {GenreDeleteManyArgs} args - Arguments to filter Genres to delete.
     * @example
     * // Delete a few Genres
     * const { count } = await prisma.genre.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends GenreDeleteManyArgs>(args?: SelectSubset<T, GenreDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Genres.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GenreUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Genres
     * const genre = await prisma.genre.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends GenreUpdateManyArgs>(args: SelectSubset<T, GenreUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Genres and returns the data updated in the database.
     * @param {GenreUpdateManyAndReturnArgs} args - Arguments to update many Genres.
     * @example
     * // Update many Genres
     * const genre = await prisma.genre.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Genres and only return the `id`
     * const genreWithIdOnly = await prisma.genre.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends GenreUpdateManyAndReturnArgs>(args: SelectSubset<T, GenreUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GenrePayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Genre.
     * @param {GenreUpsertArgs} args - Arguments to update or create a Genre.
     * @example
     * // Update or create a Genre
     * const genre = await prisma.genre.upsert({
     *   create: {
     *     // ... data to create a Genre
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Genre we want to update
     *   }
     * })
     */
    upsert<T extends GenreUpsertArgs>(args: SelectSubset<T, GenreUpsertArgs<ExtArgs>>): Prisma__GenreClient<$Result.GetResult<Prisma.$GenrePayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Genres.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GenreCountArgs} args - Arguments to filter Genres to count.
     * @example
     * // Count the number of Genres
     * const count = await prisma.genre.count({
     *   where: {
     *     // ... the filter for the Genres we want to count
     *   }
     * })
    **/
    count<T extends GenreCountArgs>(
      args?: Subset<T, GenreCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GenreCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Genre.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GenreAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GenreAggregateArgs>(args: Subset<T, GenreAggregateArgs>): Prisma.PrismaPromise<GetGenreAggregateType<T>>

    /**
     * Group by Genre.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GenreGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GenreGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GenreGroupByArgs['orderBy'] }
        : { orderBy?: GenreGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GenreGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGenreGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Genre model
   */
  readonly fields: GenreFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Genre.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__GenreClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    keywords_relation<T extends Genre$keywords_relationArgs<ExtArgs> = {}>(args?: Subset<T, Genre$keywords_relationArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$KeywordPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    adventures_relation<T extends Genre$adventures_relationArgs<ExtArgs> = {}>(args?: Subset<T, Genre$adventures_relationArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdventurePayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Genre model
   */ 
  interface GenreFieldRefs {
    readonly id: FieldRef<"Genre", 'String'>
    readonly name: FieldRef<"Genre", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Genre findUnique
   */
  export type GenreFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Genre
     */
    select?: GenreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Genre
     */
    omit?: GenreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GenreInclude<ExtArgs> | null
    /**
     * Filter, which Genre to fetch.
     */
    where: GenreWhereUniqueInput
  }

  /**
   * Genre findUniqueOrThrow
   */
  export type GenreFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Genre
     */
    select?: GenreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Genre
     */
    omit?: GenreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GenreInclude<ExtArgs> | null
    /**
     * Filter, which Genre to fetch.
     */
    where: GenreWhereUniqueInput
  }

  /**
   * Genre findFirst
   */
  export type GenreFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Genre
     */
    select?: GenreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Genre
     */
    omit?: GenreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GenreInclude<ExtArgs> | null
    /**
     * Filter, which Genre to fetch.
     */
    where?: GenreWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Genres to fetch.
     */
    orderBy?: GenreOrderByWithRelationInput | GenreOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Genres.
     */
    cursor?: GenreWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Genres from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Genres.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Genres.
     */
    distinct?: GenreScalarFieldEnum | GenreScalarFieldEnum[]
  }

  /**
   * Genre findFirstOrThrow
   */
  export type GenreFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Genre
     */
    select?: GenreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Genre
     */
    omit?: GenreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GenreInclude<ExtArgs> | null
    /**
     * Filter, which Genre to fetch.
     */
    where?: GenreWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Genres to fetch.
     */
    orderBy?: GenreOrderByWithRelationInput | GenreOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Genres.
     */
    cursor?: GenreWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Genres from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Genres.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Genres.
     */
    distinct?: GenreScalarFieldEnum | GenreScalarFieldEnum[]
  }

  /**
   * Genre findMany
   */
  export type GenreFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Genre
     */
    select?: GenreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Genre
     */
    omit?: GenreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GenreInclude<ExtArgs> | null
    /**
     * Filter, which Genres to fetch.
     */
    where?: GenreWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Genres to fetch.
     */
    orderBy?: GenreOrderByWithRelationInput | GenreOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Genres.
     */
    cursor?: GenreWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Genres from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Genres.
     */
    skip?: number
    distinct?: GenreScalarFieldEnum | GenreScalarFieldEnum[]
  }

  /**
   * Genre create
   */
  export type GenreCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Genre
     */
    select?: GenreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Genre
     */
    omit?: GenreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GenreInclude<ExtArgs> | null
    /**
     * The data needed to create a Genre.
     */
    data: XOR<GenreCreateInput, GenreUncheckedCreateInput>
  }

  /**
   * Genre createMany
   */
  export type GenreCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Genres.
     */
    data: GenreCreateManyInput | GenreCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Genre createManyAndReturn
   */
  export type GenreCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Genre
     */
    select?: GenreSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Genre
     */
    omit?: GenreOmit<ExtArgs> | null
    /**
     * The data used to create many Genres.
     */
    data: GenreCreateManyInput | GenreCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Genre update
   */
  export type GenreUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Genre
     */
    select?: GenreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Genre
     */
    omit?: GenreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GenreInclude<ExtArgs> | null
    /**
     * The data needed to update a Genre.
     */
    data: XOR<GenreUpdateInput, GenreUncheckedUpdateInput>
    /**
     * Choose, which Genre to update.
     */
    where: GenreWhereUniqueInput
  }

  /**
   * Genre updateMany
   */
  export type GenreUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Genres.
     */
    data: XOR<GenreUpdateManyMutationInput, GenreUncheckedUpdateManyInput>
    /**
     * Filter which Genres to update
     */
    where?: GenreWhereInput
    /**
     * Limit how many Genres to update.
     */
    limit?: number
  }

  /**
   * Genre updateManyAndReturn
   */
  export type GenreUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Genre
     */
    select?: GenreSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Genre
     */
    omit?: GenreOmit<ExtArgs> | null
    /**
     * The data used to update Genres.
     */
    data: XOR<GenreUpdateManyMutationInput, GenreUncheckedUpdateManyInput>
    /**
     * Filter which Genres to update
     */
    where?: GenreWhereInput
    /**
     * Limit how many Genres to update.
     */
    limit?: number
  }

  /**
   * Genre upsert
   */
  export type GenreUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Genre
     */
    select?: GenreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Genre
     */
    omit?: GenreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GenreInclude<ExtArgs> | null
    /**
     * The filter to search for the Genre to update in case it exists.
     */
    where: GenreWhereUniqueInput
    /**
     * In case the Genre found by the `where` argument doesn't exist, create a new Genre with this data.
     */
    create: XOR<GenreCreateInput, GenreUncheckedCreateInput>
    /**
     * In case the Genre was found with the provided `where` argument, update it with this data.
     */
    update: XOR<GenreUpdateInput, GenreUncheckedUpdateInput>
  }

  /**
   * Genre delete
   */
  export type GenreDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Genre
     */
    select?: GenreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Genre
     */
    omit?: GenreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GenreInclude<ExtArgs> | null
    /**
     * Filter which Genre to delete.
     */
    where: GenreWhereUniqueInput
  }

  /**
   * Genre deleteMany
   */
  export type GenreDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Genres to delete
     */
    where?: GenreWhereInput
    /**
     * Limit how many Genres to delete.
     */
    limit?: number
  }

  /**
   * Genre.keywords_relation
   */
  export type Genre$keywords_relationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Keyword
     */
    select?: KeywordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Keyword
     */
    omit?: KeywordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KeywordInclude<ExtArgs> | null
    where?: KeywordWhereInput
    orderBy?: KeywordOrderByWithRelationInput | KeywordOrderByWithRelationInput[]
    cursor?: KeywordWhereUniqueInput
    take?: number
    skip?: number
    distinct?: KeywordScalarFieldEnum | KeywordScalarFieldEnum[]
  }

  /**
   * Genre.adventures_relation
   */
  export type Genre$adventures_relationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Adventure
     */
    select?: AdventureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Adventure
     */
    omit?: AdventureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdventureInclude<ExtArgs> | null
    where?: AdventureWhereInput
    orderBy?: AdventureOrderByWithRelationInput | AdventureOrderByWithRelationInput[]
    cursor?: AdventureWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AdventureScalarFieldEnum | AdventureScalarFieldEnum[]
  }

  /**
   * Genre without action
   */
  export type GenreDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Genre
     */
    select?: GenreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Genre
     */
    omit?: GenreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GenreInclude<ExtArgs> | null
  }


  /**
   * Model MagicItem
   */

  export type AggregateMagicItem = {
    _count: MagicItemCountAggregateOutputType | null
    _avg: MagicItemAvgAggregateOutputType | null
    _sum: MagicItemSumAggregateOutputType | null
    _min: MagicItemMinAggregateOutputType | null
    _max: MagicItemMaxAggregateOutputType | null
  }

  export type MagicItemAvgAggregateOutputType = {
    source_id: number | null
  }

  export type MagicItemSumAggregateOutputType = {
    source_id: number | null
  }

  export type MagicItemMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    type_id: string | null
    rarity_id: string | null
    source_id: number | null
    requires_attunement: boolean | null
  }

  export type MagicItemMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    type_id: string | null
    rarity_id: string | null
    source_id: number | null
    requires_attunement: boolean | null
  }

  export type MagicItemCountAggregateOutputType = {
    id: number
    name: number
    description: number
    type_id: number
    rarity_id: number
    source_id: number
    requires_attunement: number
    _all: number
  }


  export type MagicItemAvgAggregateInputType = {
    source_id?: true
  }

  export type MagicItemSumAggregateInputType = {
    source_id?: true
  }

  export type MagicItemMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    type_id?: true
    rarity_id?: true
    source_id?: true
    requires_attunement?: true
  }

  export type MagicItemMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    type_id?: true
    rarity_id?: true
    source_id?: true
    requires_attunement?: true
  }

  export type MagicItemCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    type_id?: true
    rarity_id?: true
    source_id?: true
    requires_attunement?: true
    _all?: true
  }

  export type MagicItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MagicItem to aggregate.
     */
    where?: MagicItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MagicItems to fetch.
     */
    orderBy?: MagicItemOrderByWithRelationInput | MagicItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MagicItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MagicItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MagicItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MagicItems
    **/
    _count?: true | MagicItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MagicItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MagicItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MagicItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MagicItemMaxAggregateInputType
  }

  export type GetMagicItemAggregateType<T extends MagicItemAggregateArgs> = {
        [P in keyof T & keyof AggregateMagicItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMagicItem[P]>
      : GetScalarType<T[P], AggregateMagicItem[P]>
  }




  export type MagicItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MagicItemWhereInput
    orderBy?: MagicItemOrderByWithAggregationInput | MagicItemOrderByWithAggregationInput[]
    by: MagicItemScalarFieldEnum[] | MagicItemScalarFieldEnum
    having?: MagicItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MagicItemCountAggregateInputType | true
    _avg?: MagicItemAvgAggregateInputType
    _sum?: MagicItemSumAggregateInputType
    _min?: MagicItemMinAggregateInputType
    _max?: MagicItemMaxAggregateInputType
  }

  export type MagicItemGroupByOutputType = {
    id: string
    name: string
    description: string
    type_id: string
    rarity_id: string
    source_id: number
    requires_attunement: boolean
    _count: MagicItemCountAggregateOutputType | null
    _avg: MagicItemAvgAggregateOutputType | null
    _sum: MagicItemSumAggregateOutputType | null
    _min: MagicItemMinAggregateOutputType | null
    _max: MagicItemMaxAggregateOutputType | null
  }

  type GetMagicItemGroupByPayload<T extends MagicItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MagicItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MagicItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MagicItemGroupByOutputType[P]>
            : GetScalarType<T[P], MagicItemGroupByOutputType[P]>
        }
      >
    >


  export type MagicItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    type_id?: boolean
    rarity_id?: boolean
    source_id?: boolean
    requires_attunement?: boolean
    type_relation?: boolean | MagicItemTypeDefaultArgs<ExtArgs>
    rarity_relation?: boolean | MagicItemRarityDefaultArgs<ExtArgs>
    source_relation?: boolean | SourceDefaultArgs<ExtArgs>
    attunements_relation?: boolean | MagicItem$attunements_relationArgs<ExtArgs>
    _count?: boolean | MagicItemCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["magicItem"]>

  export type MagicItemSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    type_id?: boolean
    rarity_id?: boolean
    source_id?: boolean
    requires_attunement?: boolean
    type_relation?: boolean | MagicItemTypeDefaultArgs<ExtArgs>
    rarity_relation?: boolean | MagicItemRarityDefaultArgs<ExtArgs>
    source_relation?: boolean | SourceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["magicItem"]>

  export type MagicItemSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    type_id?: boolean
    rarity_id?: boolean
    source_id?: boolean
    requires_attunement?: boolean
    type_relation?: boolean | MagicItemTypeDefaultArgs<ExtArgs>
    rarity_relation?: boolean | MagicItemRarityDefaultArgs<ExtArgs>
    source_relation?: boolean | SourceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["magicItem"]>

  export type MagicItemSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    type_id?: boolean
    rarity_id?: boolean
    source_id?: boolean
    requires_attunement?: boolean
  }

  export type MagicItemOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "type_id" | "rarity_id" | "source_id" | "requires_attunement", ExtArgs["result"]["magicItem"]>
  export type MagicItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    type_relation?: boolean | MagicItemTypeDefaultArgs<ExtArgs>
    rarity_relation?: boolean | MagicItemRarityDefaultArgs<ExtArgs>
    source_relation?: boolean | SourceDefaultArgs<ExtArgs>
    attunements_relation?: boolean | MagicItem$attunements_relationArgs<ExtArgs>
    _count?: boolean | MagicItemCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type MagicItemIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    type_relation?: boolean | MagicItemTypeDefaultArgs<ExtArgs>
    rarity_relation?: boolean | MagicItemRarityDefaultArgs<ExtArgs>
    source_relation?: boolean | SourceDefaultArgs<ExtArgs>
  }
  export type MagicItemIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    type_relation?: boolean | MagicItemTypeDefaultArgs<ExtArgs>
    rarity_relation?: boolean | MagicItemRarityDefaultArgs<ExtArgs>
    source_relation?: boolean | SourceDefaultArgs<ExtArgs>
  }

  export type $MagicItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MagicItem"
    objects: {
      type_relation: Prisma.$MagicItemTypePayload<ExtArgs>
      rarity_relation: Prisma.$MagicItemRarityPayload<ExtArgs>
      source_relation: Prisma.$SourcePayload<ExtArgs>
      attunements_relation: Prisma.$MagicItemAttunementPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string
      type_id: string
      rarity_id: string
      source_id: number
      requires_attunement: boolean
    }, ExtArgs["result"]["magicItem"]>
    composites: {}
  }

  type MagicItemGetPayload<S extends boolean | null | undefined | MagicItemDefaultArgs> = $Result.GetResult<Prisma.$MagicItemPayload, S>

  type MagicItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MagicItemFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MagicItemCountAggregateInputType | true
    }

  export interface MagicItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MagicItem'], meta: { name: 'MagicItem' } }
    /**
     * Find zero or one MagicItem that matches the filter.
     * @param {MagicItemFindUniqueArgs} args - Arguments to find a MagicItem
     * @example
     * // Get one MagicItem
     * const magicItem = await prisma.magicItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MagicItemFindUniqueArgs>(args: SelectSubset<T, MagicItemFindUniqueArgs<ExtArgs>>): Prisma__MagicItemClient<$Result.GetResult<Prisma.$MagicItemPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one MagicItem that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MagicItemFindUniqueOrThrowArgs} args - Arguments to find a MagicItem
     * @example
     * // Get one MagicItem
     * const magicItem = await prisma.magicItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MagicItemFindUniqueOrThrowArgs>(args: SelectSubset<T, MagicItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MagicItemClient<$Result.GetResult<Prisma.$MagicItemPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first MagicItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MagicItemFindFirstArgs} args - Arguments to find a MagicItem
     * @example
     * // Get one MagicItem
     * const magicItem = await prisma.magicItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MagicItemFindFirstArgs>(args?: SelectSubset<T, MagicItemFindFirstArgs<ExtArgs>>): Prisma__MagicItemClient<$Result.GetResult<Prisma.$MagicItemPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first MagicItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MagicItemFindFirstOrThrowArgs} args - Arguments to find a MagicItem
     * @example
     * // Get one MagicItem
     * const magicItem = await prisma.magicItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MagicItemFindFirstOrThrowArgs>(args?: SelectSubset<T, MagicItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__MagicItemClient<$Result.GetResult<Prisma.$MagicItemPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more MagicItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MagicItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MagicItems
     * const magicItems = await prisma.magicItem.findMany()
     * 
     * // Get first 10 MagicItems
     * const magicItems = await prisma.magicItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const magicItemWithIdOnly = await prisma.magicItem.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MagicItemFindManyArgs>(args?: SelectSubset<T, MagicItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MagicItemPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a MagicItem.
     * @param {MagicItemCreateArgs} args - Arguments to create a MagicItem.
     * @example
     * // Create one MagicItem
     * const MagicItem = await prisma.magicItem.create({
     *   data: {
     *     // ... data to create a MagicItem
     *   }
     * })
     * 
     */
    create<T extends MagicItemCreateArgs>(args: SelectSubset<T, MagicItemCreateArgs<ExtArgs>>): Prisma__MagicItemClient<$Result.GetResult<Prisma.$MagicItemPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many MagicItems.
     * @param {MagicItemCreateManyArgs} args - Arguments to create many MagicItems.
     * @example
     * // Create many MagicItems
     * const magicItem = await prisma.magicItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MagicItemCreateManyArgs>(args?: SelectSubset<T, MagicItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MagicItems and returns the data saved in the database.
     * @param {MagicItemCreateManyAndReturnArgs} args - Arguments to create many MagicItems.
     * @example
     * // Create many MagicItems
     * const magicItem = await prisma.magicItem.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MagicItems and only return the `id`
     * const magicItemWithIdOnly = await prisma.magicItem.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MagicItemCreateManyAndReturnArgs>(args?: SelectSubset<T, MagicItemCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MagicItemPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a MagicItem.
     * @param {MagicItemDeleteArgs} args - Arguments to delete one MagicItem.
     * @example
     * // Delete one MagicItem
     * const MagicItem = await prisma.magicItem.delete({
     *   where: {
     *     // ... filter to delete one MagicItem
     *   }
     * })
     * 
     */
    delete<T extends MagicItemDeleteArgs>(args: SelectSubset<T, MagicItemDeleteArgs<ExtArgs>>): Prisma__MagicItemClient<$Result.GetResult<Prisma.$MagicItemPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one MagicItem.
     * @param {MagicItemUpdateArgs} args - Arguments to update one MagicItem.
     * @example
     * // Update one MagicItem
     * const magicItem = await prisma.magicItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MagicItemUpdateArgs>(args: SelectSubset<T, MagicItemUpdateArgs<ExtArgs>>): Prisma__MagicItemClient<$Result.GetResult<Prisma.$MagicItemPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more MagicItems.
     * @param {MagicItemDeleteManyArgs} args - Arguments to filter MagicItems to delete.
     * @example
     * // Delete a few MagicItems
     * const { count } = await prisma.magicItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MagicItemDeleteManyArgs>(args?: SelectSubset<T, MagicItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MagicItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MagicItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MagicItems
     * const magicItem = await prisma.magicItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MagicItemUpdateManyArgs>(args: SelectSubset<T, MagicItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MagicItems and returns the data updated in the database.
     * @param {MagicItemUpdateManyAndReturnArgs} args - Arguments to update many MagicItems.
     * @example
     * // Update many MagicItems
     * const magicItem = await prisma.magicItem.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more MagicItems and only return the `id`
     * const magicItemWithIdOnly = await prisma.magicItem.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MagicItemUpdateManyAndReturnArgs>(args: SelectSubset<T, MagicItemUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MagicItemPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one MagicItem.
     * @param {MagicItemUpsertArgs} args - Arguments to update or create a MagicItem.
     * @example
     * // Update or create a MagicItem
     * const magicItem = await prisma.magicItem.upsert({
     *   create: {
     *     // ... data to create a MagicItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MagicItem we want to update
     *   }
     * })
     */
    upsert<T extends MagicItemUpsertArgs>(args: SelectSubset<T, MagicItemUpsertArgs<ExtArgs>>): Prisma__MagicItemClient<$Result.GetResult<Prisma.$MagicItemPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of MagicItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MagicItemCountArgs} args - Arguments to filter MagicItems to count.
     * @example
     * // Count the number of MagicItems
     * const count = await prisma.magicItem.count({
     *   where: {
     *     // ... the filter for the MagicItems we want to count
     *   }
     * })
    **/
    count<T extends MagicItemCountArgs>(
      args?: Subset<T, MagicItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MagicItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MagicItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MagicItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MagicItemAggregateArgs>(args: Subset<T, MagicItemAggregateArgs>): Prisma.PrismaPromise<GetMagicItemAggregateType<T>>

    /**
     * Group by MagicItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MagicItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MagicItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MagicItemGroupByArgs['orderBy'] }
        : { orderBy?: MagicItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MagicItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMagicItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MagicItem model
   */
  readonly fields: MagicItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MagicItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MagicItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    type_relation<T extends MagicItemTypeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MagicItemTypeDefaultArgs<ExtArgs>>): Prisma__MagicItemTypeClient<$Result.GetResult<Prisma.$MagicItemTypePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    rarity_relation<T extends MagicItemRarityDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MagicItemRarityDefaultArgs<ExtArgs>>): Prisma__MagicItemRarityClient<$Result.GetResult<Prisma.$MagicItemRarityPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    source_relation<T extends SourceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SourceDefaultArgs<ExtArgs>>): Prisma__SourceClient<$Result.GetResult<Prisma.$SourcePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    attunements_relation<T extends MagicItem$attunements_relationArgs<ExtArgs> = {}>(args?: Subset<T, MagicItem$attunements_relationArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MagicItemAttunementPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MagicItem model
   */ 
  interface MagicItemFieldRefs {
    readonly id: FieldRef<"MagicItem", 'String'>
    readonly name: FieldRef<"MagicItem", 'String'>
    readonly description: FieldRef<"MagicItem", 'String'>
    readonly type_id: FieldRef<"MagicItem", 'String'>
    readonly rarity_id: FieldRef<"MagicItem", 'String'>
    readonly source_id: FieldRef<"MagicItem", 'Int'>
    readonly requires_attunement: FieldRef<"MagicItem", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * MagicItem findUnique
   */
  export type MagicItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MagicItem
     */
    select?: MagicItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MagicItem
     */
    omit?: MagicItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MagicItemInclude<ExtArgs> | null
    /**
     * Filter, which MagicItem to fetch.
     */
    where: MagicItemWhereUniqueInput
  }

  /**
   * MagicItem findUniqueOrThrow
   */
  export type MagicItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MagicItem
     */
    select?: MagicItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MagicItem
     */
    omit?: MagicItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MagicItemInclude<ExtArgs> | null
    /**
     * Filter, which MagicItem to fetch.
     */
    where: MagicItemWhereUniqueInput
  }

  /**
   * MagicItem findFirst
   */
  export type MagicItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MagicItem
     */
    select?: MagicItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MagicItem
     */
    omit?: MagicItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MagicItemInclude<ExtArgs> | null
    /**
     * Filter, which MagicItem to fetch.
     */
    where?: MagicItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MagicItems to fetch.
     */
    orderBy?: MagicItemOrderByWithRelationInput | MagicItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MagicItems.
     */
    cursor?: MagicItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MagicItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MagicItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MagicItems.
     */
    distinct?: MagicItemScalarFieldEnum | MagicItemScalarFieldEnum[]
  }

  /**
   * MagicItem findFirstOrThrow
   */
  export type MagicItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MagicItem
     */
    select?: MagicItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MagicItem
     */
    omit?: MagicItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MagicItemInclude<ExtArgs> | null
    /**
     * Filter, which MagicItem to fetch.
     */
    where?: MagicItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MagicItems to fetch.
     */
    orderBy?: MagicItemOrderByWithRelationInput | MagicItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MagicItems.
     */
    cursor?: MagicItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MagicItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MagicItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MagicItems.
     */
    distinct?: MagicItemScalarFieldEnum | MagicItemScalarFieldEnum[]
  }

  /**
   * MagicItem findMany
   */
  export type MagicItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MagicItem
     */
    select?: MagicItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MagicItem
     */
    omit?: MagicItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MagicItemInclude<ExtArgs> | null
    /**
     * Filter, which MagicItems to fetch.
     */
    where?: MagicItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MagicItems to fetch.
     */
    orderBy?: MagicItemOrderByWithRelationInput | MagicItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MagicItems.
     */
    cursor?: MagicItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MagicItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MagicItems.
     */
    skip?: number
    distinct?: MagicItemScalarFieldEnum | MagicItemScalarFieldEnum[]
  }

  /**
   * MagicItem create
   */
  export type MagicItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MagicItem
     */
    select?: MagicItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MagicItem
     */
    omit?: MagicItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MagicItemInclude<ExtArgs> | null
    /**
     * The data needed to create a MagicItem.
     */
    data: XOR<MagicItemCreateInput, MagicItemUncheckedCreateInput>
  }

  /**
   * MagicItem createMany
   */
  export type MagicItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MagicItems.
     */
    data: MagicItemCreateManyInput | MagicItemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MagicItem createManyAndReturn
   */
  export type MagicItemCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MagicItem
     */
    select?: MagicItemSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MagicItem
     */
    omit?: MagicItemOmit<ExtArgs> | null
    /**
     * The data used to create many MagicItems.
     */
    data: MagicItemCreateManyInput | MagicItemCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MagicItemIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * MagicItem update
   */
  export type MagicItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MagicItem
     */
    select?: MagicItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MagicItem
     */
    omit?: MagicItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MagicItemInclude<ExtArgs> | null
    /**
     * The data needed to update a MagicItem.
     */
    data: XOR<MagicItemUpdateInput, MagicItemUncheckedUpdateInput>
    /**
     * Choose, which MagicItem to update.
     */
    where: MagicItemWhereUniqueInput
  }

  /**
   * MagicItem updateMany
   */
  export type MagicItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MagicItems.
     */
    data: XOR<MagicItemUpdateManyMutationInput, MagicItemUncheckedUpdateManyInput>
    /**
     * Filter which MagicItems to update
     */
    where?: MagicItemWhereInput
    /**
     * Limit how many MagicItems to update.
     */
    limit?: number
  }

  /**
   * MagicItem updateManyAndReturn
   */
  export type MagicItemUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MagicItem
     */
    select?: MagicItemSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MagicItem
     */
    omit?: MagicItemOmit<ExtArgs> | null
    /**
     * The data used to update MagicItems.
     */
    data: XOR<MagicItemUpdateManyMutationInput, MagicItemUncheckedUpdateManyInput>
    /**
     * Filter which MagicItems to update
     */
    where?: MagicItemWhereInput
    /**
     * Limit how many MagicItems to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MagicItemIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * MagicItem upsert
   */
  export type MagicItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MagicItem
     */
    select?: MagicItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MagicItem
     */
    omit?: MagicItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MagicItemInclude<ExtArgs> | null
    /**
     * The filter to search for the MagicItem to update in case it exists.
     */
    where: MagicItemWhereUniqueInput
    /**
     * In case the MagicItem found by the `where` argument doesn't exist, create a new MagicItem with this data.
     */
    create: XOR<MagicItemCreateInput, MagicItemUncheckedCreateInput>
    /**
     * In case the MagicItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MagicItemUpdateInput, MagicItemUncheckedUpdateInput>
  }

  /**
   * MagicItem delete
   */
  export type MagicItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MagicItem
     */
    select?: MagicItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MagicItem
     */
    omit?: MagicItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MagicItemInclude<ExtArgs> | null
    /**
     * Filter which MagicItem to delete.
     */
    where: MagicItemWhereUniqueInput
  }

  /**
   * MagicItem deleteMany
   */
  export type MagicItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MagicItems to delete
     */
    where?: MagicItemWhereInput
    /**
     * Limit how many MagicItems to delete.
     */
    limit?: number
  }

  /**
   * MagicItem.attunements_relation
   */
  export type MagicItem$attunements_relationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MagicItemAttunement
     */
    select?: MagicItemAttunementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MagicItemAttunement
     */
    omit?: MagicItemAttunementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MagicItemAttunementInclude<ExtArgs> | null
    where?: MagicItemAttunementWhereInput
    orderBy?: MagicItemAttunementOrderByWithRelationInput | MagicItemAttunementOrderByWithRelationInput[]
    cursor?: MagicItemAttunementWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MagicItemAttunementScalarFieldEnum | MagicItemAttunementScalarFieldEnum[]
  }

  /**
   * MagicItem without action
   */
  export type MagicItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MagicItem
     */
    select?: MagicItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MagicItem
     */
    omit?: MagicItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MagicItemInclude<ExtArgs> | null
  }


  /**
   * Model MagicItemRarity
   */

  export type AggregateMagicItemRarity = {
    _count: MagicItemRarityCountAggregateOutputType | null
    _avg: MagicItemRarityAvgAggregateOutputType | null
    _sum: MagicItemRaritySumAggregateOutputType | null
    _min: MagicItemRarityMinAggregateOutputType | null
    _max: MagicItemRarityMaxAggregateOutputType | null
  }

  export type MagicItemRarityAvgAggregateOutputType = {
    order: number | null
  }

  export type MagicItemRaritySumAggregateOutputType = {
    order: number | null
  }

  export type MagicItemRarityMinAggregateOutputType = {
    id: string | null
    cost: string | null
    name: string | null
    name_he: string | null
    name_she: string | null
    name_it: string | null
    order: number | null
  }

  export type MagicItemRarityMaxAggregateOutputType = {
    id: string | null
    cost: string | null
    name: string | null
    name_he: string | null
    name_she: string | null
    name_it: string | null
    order: number | null
  }

  export type MagicItemRarityCountAggregateOutputType = {
    id: number
    cost: number
    name: number
    name_he: number
    name_she: number
    name_it: number
    order: number
    _all: number
  }


  export type MagicItemRarityAvgAggregateInputType = {
    order?: true
  }

  export type MagicItemRaritySumAggregateInputType = {
    order?: true
  }

  export type MagicItemRarityMinAggregateInputType = {
    id?: true
    cost?: true
    name?: true
    name_he?: true
    name_she?: true
    name_it?: true
    order?: true
  }

  export type MagicItemRarityMaxAggregateInputType = {
    id?: true
    cost?: true
    name?: true
    name_he?: true
    name_she?: true
    name_it?: true
    order?: true
  }

  export type MagicItemRarityCountAggregateInputType = {
    id?: true
    cost?: true
    name?: true
    name_he?: true
    name_she?: true
    name_it?: true
    order?: true
    _all?: true
  }

  export type MagicItemRarityAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MagicItemRarity to aggregate.
     */
    where?: MagicItemRarityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MagicItemRarities to fetch.
     */
    orderBy?: MagicItemRarityOrderByWithRelationInput | MagicItemRarityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MagicItemRarityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MagicItemRarities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MagicItemRarities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MagicItemRarities
    **/
    _count?: true | MagicItemRarityCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MagicItemRarityAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MagicItemRaritySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MagicItemRarityMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MagicItemRarityMaxAggregateInputType
  }

  export type GetMagicItemRarityAggregateType<T extends MagicItemRarityAggregateArgs> = {
        [P in keyof T & keyof AggregateMagicItemRarity]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMagicItemRarity[P]>
      : GetScalarType<T[P], AggregateMagicItemRarity[P]>
  }




  export type MagicItemRarityGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MagicItemRarityWhereInput
    orderBy?: MagicItemRarityOrderByWithAggregationInput | MagicItemRarityOrderByWithAggregationInput[]
    by: MagicItemRarityScalarFieldEnum[] | MagicItemRarityScalarFieldEnum
    having?: MagicItemRarityScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MagicItemRarityCountAggregateInputType | true
    _avg?: MagicItemRarityAvgAggregateInputType
    _sum?: MagicItemRaritySumAggregateInputType
    _min?: MagicItemRarityMinAggregateInputType
    _max?: MagicItemRarityMaxAggregateInputType
  }

  export type MagicItemRarityGroupByOutputType = {
    id: string
    cost: string
    name: string
    name_he: string
    name_she: string
    name_it: string
    order: number
    _count: MagicItemRarityCountAggregateOutputType | null
    _avg: MagicItemRarityAvgAggregateOutputType | null
    _sum: MagicItemRaritySumAggregateOutputType | null
    _min: MagicItemRarityMinAggregateOutputType | null
    _max: MagicItemRarityMaxAggregateOutputType | null
  }

  type GetMagicItemRarityGroupByPayload<T extends MagicItemRarityGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MagicItemRarityGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MagicItemRarityGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MagicItemRarityGroupByOutputType[P]>
            : GetScalarType<T[P], MagicItemRarityGroupByOutputType[P]>
        }
      >
    >


  export type MagicItemRaritySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    cost?: boolean
    name?: boolean
    name_he?: boolean
    name_she?: boolean
    name_it?: boolean
    order?: boolean
    magicItems?: boolean | MagicItemRarity$magicItemsArgs<ExtArgs>
    _count?: boolean | MagicItemRarityCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["magicItemRarity"]>

  export type MagicItemRaritySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    cost?: boolean
    name?: boolean
    name_he?: boolean
    name_she?: boolean
    name_it?: boolean
    order?: boolean
  }, ExtArgs["result"]["magicItemRarity"]>

  export type MagicItemRaritySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    cost?: boolean
    name?: boolean
    name_he?: boolean
    name_she?: boolean
    name_it?: boolean
    order?: boolean
  }, ExtArgs["result"]["magicItemRarity"]>

  export type MagicItemRaritySelectScalar = {
    id?: boolean
    cost?: boolean
    name?: boolean
    name_he?: boolean
    name_she?: boolean
    name_it?: boolean
    order?: boolean
  }

  export type MagicItemRarityOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "cost" | "name" | "name_he" | "name_she" | "name_it" | "order", ExtArgs["result"]["magicItemRarity"]>
  export type MagicItemRarityInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    magicItems?: boolean | MagicItemRarity$magicItemsArgs<ExtArgs>
    _count?: boolean | MagicItemRarityCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type MagicItemRarityIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type MagicItemRarityIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $MagicItemRarityPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MagicItemRarity"
    objects: {
      magicItems: Prisma.$MagicItemPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      cost: string
      name: string
      name_he: string
      name_she: string
      name_it: string
      order: number
    }, ExtArgs["result"]["magicItemRarity"]>
    composites: {}
  }

  type MagicItemRarityGetPayload<S extends boolean | null | undefined | MagicItemRarityDefaultArgs> = $Result.GetResult<Prisma.$MagicItemRarityPayload, S>

  type MagicItemRarityCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MagicItemRarityFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MagicItemRarityCountAggregateInputType | true
    }

  export interface MagicItemRarityDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MagicItemRarity'], meta: { name: 'MagicItemRarity' } }
    /**
     * Find zero or one MagicItemRarity that matches the filter.
     * @param {MagicItemRarityFindUniqueArgs} args - Arguments to find a MagicItemRarity
     * @example
     * // Get one MagicItemRarity
     * const magicItemRarity = await prisma.magicItemRarity.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MagicItemRarityFindUniqueArgs>(args: SelectSubset<T, MagicItemRarityFindUniqueArgs<ExtArgs>>): Prisma__MagicItemRarityClient<$Result.GetResult<Prisma.$MagicItemRarityPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one MagicItemRarity that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MagicItemRarityFindUniqueOrThrowArgs} args - Arguments to find a MagicItemRarity
     * @example
     * // Get one MagicItemRarity
     * const magicItemRarity = await prisma.magicItemRarity.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MagicItemRarityFindUniqueOrThrowArgs>(args: SelectSubset<T, MagicItemRarityFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MagicItemRarityClient<$Result.GetResult<Prisma.$MagicItemRarityPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first MagicItemRarity that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MagicItemRarityFindFirstArgs} args - Arguments to find a MagicItemRarity
     * @example
     * // Get one MagicItemRarity
     * const magicItemRarity = await prisma.magicItemRarity.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MagicItemRarityFindFirstArgs>(args?: SelectSubset<T, MagicItemRarityFindFirstArgs<ExtArgs>>): Prisma__MagicItemRarityClient<$Result.GetResult<Prisma.$MagicItemRarityPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first MagicItemRarity that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MagicItemRarityFindFirstOrThrowArgs} args - Arguments to find a MagicItemRarity
     * @example
     * // Get one MagicItemRarity
     * const magicItemRarity = await prisma.magicItemRarity.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MagicItemRarityFindFirstOrThrowArgs>(args?: SelectSubset<T, MagicItemRarityFindFirstOrThrowArgs<ExtArgs>>): Prisma__MagicItemRarityClient<$Result.GetResult<Prisma.$MagicItemRarityPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more MagicItemRarities that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MagicItemRarityFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MagicItemRarities
     * const magicItemRarities = await prisma.magicItemRarity.findMany()
     * 
     * // Get first 10 MagicItemRarities
     * const magicItemRarities = await prisma.magicItemRarity.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const magicItemRarityWithIdOnly = await prisma.magicItemRarity.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MagicItemRarityFindManyArgs>(args?: SelectSubset<T, MagicItemRarityFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MagicItemRarityPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a MagicItemRarity.
     * @param {MagicItemRarityCreateArgs} args - Arguments to create a MagicItemRarity.
     * @example
     * // Create one MagicItemRarity
     * const MagicItemRarity = await prisma.magicItemRarity.create({
     *   data: {
     *     // ... data to create a MagicItemRarity
     *   }
     * })
     * 
     */
    create<T extends MagicItemRarityCreateArgs>(args: SelectSubset<T, MagicItemRarityCreateArgs<ExtArgs>>): Prisma__MagicItemRarityClient<$Result.GetResult<Prisma.$MagicItemRarityPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many MagicItemRarities.
     * @param {MagicItemRarityCreateManyArgs} args - Arguments to create many MagicItemRarities.
     * @example
     * // Create many MagicItemRarities
     * const magicItemRarity = await prisma.magicItemRarity.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MagicItemRarityCreateManyArgs>(args?: SelectSubset<T, MagicItemRarityCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MagicItemRarities and returns the data saved in the database.
     * @param {MagicItemRarityCreateManyAndReturnArgs} args - Arguments to create many MagicItemRarities.
     * @example
     * // Create many MagicItemRarities
     * const magicItemRarity = await prisma.magicItemRarity.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MagicItemRarities and only return the `id`
     * const magicItemRarityWithIdOnly = await prisma.magicItemRarity.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MagicItemRarityCreateManyAndReturnArgs>(args?: SelectSubset<T, MagicItemRarityCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MagicItemRarityPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a MagicItemRarity.
     * @param {MagicItemRarityDeleteArgs} args - Arguments to delete one MagicItemRarity.
     * @example
     * // Delete one MagicItemRarity
     * const MagicItemRarity = await prisma.magicItemRarity.delete({
     *   where: {
     *     // ... filter to delete one MagicItemRarity
     *   }
     * })
     * 
     */
    delete<T extends MagicItemRarityDeleteArgs>(args: SelectSubset<T, MagicItemRarityDeleteArgs<ExtArgs>>): Prisma__MagicItemRarityClient<$Result.GetResult<Prisma.$MagicItemRarityPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one MagicItemRarity.
     * @param {MagicItemRarityUpdateArgs} args - Arguments to update one MagicItemRarity.
     * @example
     * // Update one MagicItemRarity
     * const magicItemRarity = await prisma.magicItemRarity.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MagicItemRarityUpdateArgs>(args: SelectSubset<T, MagicItemRarityUpdateArgs<ExtArgs>>): Prisma__MagicItemRarityClient<$Result.GetResult<Prisma.$MagicItemRarityPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more MagicItemRarities.
     * @param {MagicItemRarityDeleteManyArgs} args - Arguments to filter MagicItemRarities to delete.
     * @example
     * // Delete a few MagicItemRarities
     * const { count } = await prisma.magicItemRarity.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MagicItemRarityDeleteManyArgs>(args?: SelectSubset<T, MagicItemRarityDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MagicItemRarities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MagicItemRarityUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MagicItemRarities
     * const magicItemRarity = await prisma.magicItemRarity.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MagicItemRarityUpdateManyArgs>(args: SelectSubset<T, MagicItemRarityUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MagicItemRarities and returns the data updated in the database.
     * @param {MagicItemRarityUpdateManyAndReturnArgs} args - Arguments to update many MagicItemRarities.
     * @example
     * // Update many MagicItemRarities
     * const magicItemRarity = await prisma.magicItemRarity.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more MagicItemRarities and only return the `id`
     * const magicItemRarityWithIdOnly = await prisma.magicItemRarity.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MagicItemRarityUpdateManyAndReturnArgs>(args: SelectSubset<T, MagicItemRarityUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MagicItemRarityPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one MagicItemRarity.
     * @param {MagicItemRarityUpsertArgs} args - Arguments to update or create a MagicItemRarity.
     * @example
     * // Update or create a MagicItemRarity
     * const magicItemRarity = await prisma.magicItemRarity.upsert({
     *   create: {
     *     // ... data to create a MagicItemRarity
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MagicItemRarity we want to update
     *   }
     * })
     */
    upsert<T extends MagicItemRarityUpsertArgs>(args: SelectSubset<T, MagicItemRarityUpsertArgs<ExtArgs>>): Prisma__MagicItemRarityClient<$Result.GetResult<Prisma.$MagicItemRarityPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of MagicItemRarities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MagicItemRarityCountArgs} args - Arguments to filter MagicItemRarities to count.
     * @example
     * // Count the number of MagicItemRarities
     * const count = await prisma.magicItemRarity.count({
     *   where: {
     *     // ... the filter for the MagicItemRarities we want to count
     *   }
     * })
    **/
    count<T extends MagicItemRarityCountArgs>(
      args?: Subset<T, MagicItemRarityCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MagicItemRarityCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MagicItemRarity.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MagicItemRarityAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MagicItemRarityAggregateArgs>(args: Subset<T, MagicItemRarityAggregateArgs>): Prisma.PrismaPromise<GetMagicItemRarityAggregateType<T>>

    /**
     * Group by MagicItemRarity.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MagicItemRarityGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MagicItemRarityGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MagicItemRarityGroupByArgs['orderBy'] }
        : { orderBy?: MagicItemRarityGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MagicItemRarityGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMagicItemRarityGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MagicItemRarity model
   */
  readonly fields: MagicItemRarityFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MagicItemRarity.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MagicItemRarityClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    magicItems<T extends MagicItemRarity$magicItemsArgs<ExtArgs> = {}>(args?: Subset<T, MagicItemRarity$magicItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MagicItemPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MagicItemRarity model
   */ 
  interface MagicItemRarityFieldRefs {
    readonly id: FieldRef<"MagicItemRarity", 'String'>
    readonly cost: FieldRef<"MagicItemRarity", 'String'>
    readonly name: FieldRef<"MagicItemRarity", 'String'>
    readonly name_he: FieldRef<"MagicItemRarity", 'String'>
    readonly name_she: FieldRef<"MagicItemRarity", 'String'>
    readonly name_it: FieldRef<"MagicItemRarity", 'String'>
    readonly order: FieldRef<"MagicItemRarity", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * MagicItemRarity findUnique
   */
  export type MagicItemRarityFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MagicItemRarity
     */
    select?: MagicItemRaritySelect<ExtArgs> | null
    /**
     * Omit specific fields from the MagicItemRarity
     */
    omit?: MagicItemRarityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MagicItemRarityInclude<ExtArgs> | null
    /**
     * Filter, which MagicItemRarity to fetch.
     */
    where: MagicItemRarityWhereUniqueInput
  }

  /**
   * MagicItemRarity findUniqueOrThrow
   */
  export type MagicItemRarityFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MagicItemRarity
     */
    select?: MagicItemRaritySelect<ExtArgs> | null
    /**
     * Omit specific fields from the MagicItemRarity
     */
    omit?: MagicItemRarityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MagicItemRarityInclude<ExtArgs> | null
    /**
     * Filter, which MagicItemRarity to fetch.
     */
    where: MagicItemRarityWhereUniqueInput
  }

  /**
   * MagicItemRarity findFirst
   */
  export type MagicItemRarityFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MagicItemRarity
     */
    select?: MagicItemRaritySelect<ExtArgs> | null
    /**
     * Omit specific fields from the MagicItemRarity
     */
    omit?: MagicItemRarityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MagicItemRarityInclude<ExtArgs> | null
    /**
     * Filter, which MagicItemRarity to fetch.
     */
    where?: MagicItemRarityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MagicItemRarities to fetch.
     */
    orderBy?: MagicItemRarityOrderByWithRelationInput | MagicItemRarityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MagicItemRarities.
     */
    cursor?: MagicItemRarityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MagicItemRarities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MagicItemRarities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MagicItemRarities.
     */
    distinct?: MagicItemRarityScalarFieldEnum | MagicItemRarityScalarFieldEnum[]
  }

  /**
   * MagicItemRarity findFirstOrThrow
   */
  export type MagicItemRarityFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MagicItemRarity
     */
    select?: MagicItemRaritySelect<ExtArgs> | null
    /**
     * Omit specific fields from the MagicItemRarity
     */
    omit?: MagicItemRarityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MagicItemRarityInclude<ExtArgs> | null
    /**
     * Filter, which MagicItemRarity to fetch.
     */
    where?: MagicItemRarityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MagicItemRarities to fetch.
     */
    orderBy?: MagicItemRarityOrderByWithRelationInput | MagicItemRarityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MagicItemRarities.
     */
    cursor?: MagicItemRarityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MagicItemRarities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MagicItemRarities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MagicItemRarities.
     */
    distinct?: MagicItemRarityScalarFieldEnum | MagicItemRarityScalarFieldEnum[]
  }

  /**
   * MagicItemRarity findMany
   */
  export type MagicItemRarityFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MagicItemRarity
     */
    select?: MagicItemRaritySelect<ExtArgs> | null
    /**
     * Omit specific fields from the MagicItemRarity
     */
    omit?: MagicItemRarityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MagicItemRarityInclude<ExtArgs> | null
    /**
     * Filter, which MagicItemRarities to fetch.
     */
    where?: MagicItemRarityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MagicItemRarities to fetch.
     */
    orderBy?: MagicItemRarityOrderByWithRelationInput | MagicItemRarityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MagicItemRarities.
     */
    cursor?: MagicItemRarityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MagicItemRarities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MagicItemRarities.
     */
    skip?: number
    distinct?: MagicItemRarityScalarFieldEnum | MagicItemRarityScalarFieldEnum[]
  }

  /**
   * MagicItemRarity create
   */
  export type MagicItemRarityCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MagicItemRarity
     */
    select?: MagicItemRaritySelect<ExtArgs> | null
    /**
     * Omit specific fields from the MagicItemRarity
     */
    omit?: MagicItemRarityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MagicItemRarityInclude<ExtArgs> | null
    /**
     * The data needed to create a MagicItemRarity.
     */
    data: XOR<MagicItemRarityCreateInput, MagicItemRarityUncheckedCreateInput>
  }

  /**
   * MagicItemRarity createMany
   */
  export type MagicItemRarityCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MagicItemRarities.
     */
    data: MagicItemRarityCreateManyInput | MagicItemRarityCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MagicItemRarity createManyAndReturn
   */
  export type MagicItemRarityCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MagicItemRarity
     */
    select?: MagicItemRaritySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MagicItemRarity
     */
    omit?: MagicItemRarityOmit<ExtArgs> | null
    /**
     * The data used to create many MagicItemRarities.
     */
    data: MagicItemRarityCreateManyInput | MagicItemRarityCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MagicItemRarity update
   */
  export type MagicItemRarityUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MagicItemRarity
     */
    select?: MagicItemRaritySelect<ExtArgs> | null
    /**
     * Omit specific fields from the MagicItemRarity
     */
    omit?: MagicItemRarityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MagicItemRarityInclude<ExtArgs> | null
    /**
     * The data needed to update a MagicItemRarity.
     */
    data: XOR<MagicItemRarityUpdateInput, MagicItemRarityUncheckedUpdateInput>
    /**
     * Choose, which MagicItemRarity to update.
     */
    where: MagicItemRarityWhereUniqueInput
  }

  /**
   * MagicItemRarity updateMany
   */
  export type MagicItemRarityUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MagicItemRarities.
     */
    data: XOR<MagicItemRarityUpdateManyMutationInput, MagicItemRarityUncheckedUpdateManyInput>
    /**
     * Filter which MagicItemRarities to update
     */
    where?: MagicItemRarityWhereInput
    /**
     * Limit how many MagicItemRarities to update.
     */
    limit?: number
  }

  /**
   * MagicItemRarity updateManyAndReturn
   */
  export type MagicItemRarityUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MagicItemRarity
     */
    select?: MagicItemRaritySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MagicItemRarity
     */
    omit?: MagicItemRarityOmit<ExtArgs> | null
    /**
     * The data used to update MagicItemRarities.
     */
    data: XOR<MagicItemRarityUpdateManyMutationInput, MagicItemRarityUncheckedUpdateManyInput>
    /**
     * Filter which MagicItemRarities to update
     */
    where?: MagicItemRarityWhereInput
    /**
     * Limit how many MagicItemRarities to update.
     */
    limit?: number
  }

  /**
   * MagicItemRarity upsert
   */
  export type MagicItemRarityUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MagicItemRarity
     */
    select?: MagicItemRaritySelect<ExtArgs> | null
    /**
     * Omit specific fields from the MagicItemRarity
     */
    omit?: MagicItemRarityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MagicItemRarityInclude<ExtArgs> | null
    /**
     * The filter to search for the MagicItemRarity to update in case it exists.
     */
    where: MagicItemRarityWhereUniqueInput
    /**
     * In case the MagicItemRarity found by the `where` argument doesn't exist, create a new MagicItemRarity with this data.
     */
    create: XOR<MagicItemRarityCreateInput, MagicItemRarityUncheckedCreateInput>
    /**
     * In case the MagicItemRarity was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MagicItemRarityUpdateInput, MagicItemRarityUncheckedUpdateInput>
  }

  /**
   * MagicItemRarity delete
   */
  export type MagicItemRarityDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MagicItemRarity
     */
    select?: MagicItemRaritySelect<ExtArgs> | null
    /**
     * Omit specific fields from the MagicItemRarity
     */
    omit?: MagicItemRarityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MagicItemRarityInclude<ExtArgs> | null
    /**
     * Filter which MagicItemRarity to delete.
     */
    where: MagicItemRarityWhereUniqueInput
  }

  /**
   * MagicItemRarity deleteMany
   */
  export type MagicItemRarityDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MagicItemRarities to delete
     */
    where?: MagicItemRarityWhereInput
    /**
     * Limit how many MagicItemRarities to delete.
     */
    limit?: number
  }

  /**
   * MagicItemRarity.magicItems
   */
  export type MagicItemRarity$magicItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MagicItem
     */
    select?: MagicItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MagicItem
     */
    omit?: MagicItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MagicItemInclude<ExtArgs> | null
    where?: MagicItemWhereInput
    orderBy?: MagicItemOrderByWithRelationInput | MagicItemOrderByWithRelationInput[]
    cursor?: MagicItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MagicItemScalarFieldEnum | MagicItemScalarFieldEnum[]
  }

  /**
   * MagicItemRarity without action
   */
  export type MagicItemRarityDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MagicItemRarity
     */
    select?: MagicItemRaritySelect<ExtArgs> | null
    /**
     * Omit specific fields from the MagicItemRarity
     */
    omit?: MagicItemRarityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MagicItemRarityInclude<ExtArgs> | null
  }


  /**
   * Model MagicItemType
   */

  export type AggregateMagicItemType = {
    _count: MagicItemTypeCountAggregateOutputType | null
    _min: MagicItemTypeMinAggregateOutputType | null
    _max: MagicItemTypeMaxAggregateOutputType | null
  }

  export type MagicItemTypeMinAggregateOutputType = {
    id: string | null
    name: string | null
    gender: $Enums.Gender | null
  }

  export type MagicItemTypeMaxAggregateOutputType = {
    id: string | null
    name: string | null
    gender: $Enums.Gender | null
  }

  export type MagicItemTypeCountAggregateOutputType = {
    id: number
    name: number
    gender: number
    _all: number
  }


  export type MagicItemTypeMinAggregateInputType = {
    id?: true
    name?: true
    gender?: true
  }

  export type MagicItemTypeMaxAggregateInputType = {
    id?: true
    name?: true
    gender?: true
  }

  export type MagicItemTypeCountAggregateInputType = {
    id?: true
    name?: true
    gender?: true
    _all?: true
  }

  export type MagicItemTypeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MagicItemType to aggregate.
     */
    where?: MagicItemTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MagicItemTypes to fetch.
     */
    orderBy?: MagicItemTypeOrderByWithRelationInput | MagicItemTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MagicItemTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MagicItemTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MagicItemTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MagicItemTypes
    **/
    _count?: true | MagicItemTypeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MagicItemTypeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MagicItemTypeMaxAggregateInputType
  }

  export type GetMagicItemTypeAggregateType<T extends MagicItemTypeAggregateArgs> = {
        [P in keyof T & keyof AggregateMagicItemType]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMagicItemType[P]>
      : GetScalarType<T[P], AggregateMagicItemType[P]>
  }




  export type MagicItemTypeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MagicItemTypeWhereInput
    orderBy?: MagicItemTypeOrderByWithAggregationInput | MagicItemTypeOrderByWithAggregationInput[]
    by: MagicItemTypeScalarFieldEnum[] | MagicItemTypeScalarFieldEnum
    having?: MagicItemTypeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MagicItemTypeCountAggregateInputType | true
    _min?: MagicItemTypeMinAggregateInputType
    _max?: MagicItemTypeMaxAggregateInputType
  }

  export type MagicItemTypeGroupByOutputType = {
    id: string
    name: string
    gender: $Enums.Gender
    _count: MagicItemTypeCountAggregateOutputType | null
    _min: MagicItemTypeMinAggregateOutputType | null
    _max: MagicItemTypeMaxAggregateOutputType | null
  }

  type GetMagicItemTypeGroupByPayload<T extends MagicItemTypeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MagicItemTypeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MagicItemTypeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MagicItemTypeGroupByOutputType[P]>
            : GetScalarType<T[P], MagicItemTypeGroupByOutputType[P]>
        }
      >
    >


  export type MagicItemTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    gender?: boolean
    magicItems?: boolean | MagicItemType$magicItemsArgs<ExtArgs>
    _count?: boolean | MagicItemTypeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["magicItemType"]>

  export type MagicItemTypeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    gender?: boolean
  }, ExtArgs["result"]["magicItemType"]>

  export type MagicItemTypeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    gender?: boolean
  }, ExtArgs["result"]["magicItemType"]>

  export type MagicItemTypeSelectScalar = {
    id?: boolean
    name?: boolean
    gender?: boolean
  }

  export type MagicItemTypeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "gender", ExtArgs["result"]["magicItemType"]>
  export type MagicItemTypeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    magicItems?: boolean | MagicItemType$magicItemsArgs<ExtArgs>
    _count?: boolean | MagicItemTypeCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type MagicItemTypeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type MagicItemTypeIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $MagicItemTypePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MagicItemType"
    objects: {
      magicItems: Prisma.$MagicItemPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      gender: $Enums.Gender
    }, ExtArgs["result"]["magicItemType"]>
    composites: {}
  }

  type MagicItemTypeGetPayload<S extends boolean | null | undefined | MagicItemTypeDefaultArgs> = $Result.GetResult<Prisma.$MagicItemTypePayload, S>

  type MagicItemTypeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MagicItemTypeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MagicItemTypeCountAggregateInputType | true
    }

  export interface MagicItemTypeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MagicItemType'], meta: { name: 'MagicItemType' } }
    /**
     * Find zero or one MagicItemType that matches the filter.
     * @param {MagicItemTypeFindUniqueArgs} args - Arguments to find a MagicItemType
     * @example
     * // Get one MagicItemType
     * const magicItemType = await prisma.magicItemType.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MagicItemTypeFindUniqueArgs>(args: SelectSubset<T, MagicItemTypeFindUniqueArgs<ExtArgs>>): Prisma__MagicItemTypeClient<$Result.GetResult<Prisma.$MagicItemTypePayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one MagicItemType that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MagicItemTypeFindUniqueOrThrowArgs} args - Arguments to find a MagicItemType
     * @example
     * // Get one MagicItemType
     * const magicItemType = await prisma.magicItemType.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MagicItemTypeFindUniqueOrThrowArgs>(args: SelectSubset<T, MagicItemTypeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MagicItemTypeClient<$Result.GetResult<Prisma.$MagicItemTypePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first MagicItemType that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MagicItemTypeFindFirstArgs} args - Arguments to find a MagicItemType
     * @example
     * // Get one MagicItemType
     * const magicItemType = await prisma.magicItemType.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MagicItemTypeFindFirstArgs>(args?: SelectSubset<T, MagicItemTypeFindFirstArgs<ExtArgs>>): Prisma__MagicItemTypeClient<$Result.GetResult<Prisma.$MagicItemTypePayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first MagicItemType that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MagicItemTypeFindFirstOrThrowArgs} args - Arguments to find a MagicItemType
     * @example
     * // Get one MagicItemType
     * const magicItemType = await prisma.magicItemType.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MagicItemTypeFindFirstOrThrowArgs>(args?: SelectSubset<T, MagicItemTypeFindFirstOrThrowArgs<ExtArgs>>): Prisma__MagicItemTypeClient<$Result.GetResult<Prisma.$MagicItemTypePayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more MagicItemTypes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MagicItemTypeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MagicItemTypes
     * const magicItemTypes = await prisma.magicItemType.findMany()
     * 
     * // Get first 10 MagicItemTypes
     * const magicItemTypes = await prisma.magicItemType.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const magicItemTypeWithIdOnly = await prisma.magicItemType.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MagicItemTypeFindManyArgs>(args?: SelectSubset<T, MagicItemTypeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MagicItemTypePayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a MagicItemType.
     * @param {MagicItemTypeCreateArgs} args - Arguments to create a MagicItemType.
     * @example
     * // Create one MagicItemType
     * const MagicItemType = await prisma.magicItemType.create({
     *   data: {
     *     // ... data to create a MagicItemType
     *   }
     * })
     * 
     */
    create<T extends MagicItemTypeCreateArgs>(args: SelectSubset<T, MagicItemTypeCreateArgs<ExtArgs>>): Prisma__MagicItemTypeClient<$Result.GetResult<Prisma.$MagicItemTypePayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many MagicItemTypes.
     * @param {MagicItemTypeCreateManyArgs} args - Arguments to create many MagicItemTypes.
     * @example
     * // Create many MagicItemTypes
     * const magicItemType = await prisma.magicItemType.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MagicItemTypeCreateManyArgs>(args?: SelectSubset<T, MagicItemTypeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MagicItemTypes and returns the data saved in the database.
     * @param {MagicItemTypeCreateManyAndReturnArgs} args - Arguments to create many MagicItemTypes.
     * @example
     * // Create many MagicItemTypes
     * const magicItemType = await prisma.magicItemType.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MagicItemTypes and only return the `id`
     * const magicItemTypeWithIdOnly = await prisma.magicItemType.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MagicItemTypeCreateManyAndReturnArgs>(args?: SelectSubset<T, MagicItemTypeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MagicItemTypePayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a MagicItemType.
     * @param {MagicItemTypeDeleteArgs} args - Arguments to delete one MagicItemType.
     * @example
     * // Delete one MagicItemType
     * const MagicItemType = await prisma.magicItemType.delete({
     *   where: {
     *     // ... filter to delete one MagicItemType
     *   }
     * })
     * 
     */
    delete<T extends MagicItemTypeDeleteArgs>(args: SelectSubset<T, MagicItemTypeDeleteArgs<ExtArgs>>): Prisma__MagicItemTypeClient<$Result.GetResult<Prisma.$MagicItemTypePayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one MagicItemType.
     * @param {MagicItemTypeUpdateArgs} args - Arguments to update one MagicItemType.
     * @example
     * // Update one MagicItemType
     * const magicItemType = await prisma.magicItemType.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MagicItemTypeUpdateArgs>(args: SelectSubset<T, MagicItemTypeUpdateArgs<ExtArgs>>): Prisma__MagicItemTypeClient<$Result.GetResult<Prisma.$MagicItemTypePayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more MagicItemTypes.
     * @param {MagicItemTypeDeleteManyArgs} args - Arguments to filter MagicItemTypes to delete.
     * @example
     * // Delete a few MagicItemTypes
     * const { count } = await prisma.magicItemType.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MagicItemTypeDeleteManyArgs>(args?: SelectSubset<T, MagicItemTypeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MagicItemTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MagicItemTypeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MagicItemTypes
     * const magicItemType = await prisma.magicItemType.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MagicItemTypeUpdateManyArgs>(args: SelectSubset<T, MagicItemTypeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MagicItemTypes and returns the data updated in the database.
     * @param {MagicItemTypeUpdateManyAndReturnArgs} args - Arguments to update many MagicItemTypes.
     * @example
     * // Update many MagicItemTypes
     * const magicItemType = await prisma.magicItemType.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more MagicItemTypes and only return the `id`
     * const magicItemTypeWithIdOnly = await prisma.magicItemType.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MagicItemTypeUpdateManyAndReturnArgs>(args: SelectSubset<T, MagicItemTypeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MagicItemTypePayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one MagicItemType.
     * @param {MagicItemTypeUpsertArgs} args - Arguments to update or create a MagicItemType.
     * @example
     * // Update or create a MagicItemType
     * const magicItemType = await prisma.magicItemType.upsert({
     *   create: {
     *     // ... data to create a MagicItemType
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MagicItemType we want to update
     *   }
     * })
     */
    upsert<T extends MagicItemTypeUpsertArgs>(args: SelectSubset<T, MagicItemTypeUpsertArgs<ExtArgs>>): Prisma__MagicItemTypeClient<$Result.GetResult<Prisma.$MagicItemTypePayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of MagicItemTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MagicItemTypeCountArgs} args - Arguments to filter MagicItemTypes to count.
     * @example
     * // Count the number of MagicItemTypes
     * const count = await prisma.magicItemType.count({
     *   where: {
     *     // ... the filter for the MagicItemTypes we want to count
     *   }
     * })
    **/
    count<T extends MagicItemTypeCountArgs>(
      args?: Subset<T, MagicItemTypeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MagicItemTypeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MagicItemType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MagicItemTypeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MagicItemTypeAggregateArgs>(args: Subset<T, MagicItemTypeAggregateArgs>): Prisma.PrismaPromise<GetMagicItemTypeAggregateType<T>>

    /**
     * Group by MagicItemType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MagicItemTypeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MagicItemTypeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MagicItemTypeGroupByArgs['orderBy'] }
        : { orderBy?: MagicItemTypeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MagicItemTypeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMagicItemTypeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MagicItemType model
   */
  readonly fields: MagicItemTypeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MagicItemType.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MagicItemTypeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    magicItems<T extends MagicItemType$magicItemsArgs<ExtArgs> = {}>(args?: Subset<T, MagicItemType$magicItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MagicItemPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MagicItemType model
   */ 
  interface MagicItemTypeFieldRefs {
    readonly id: FieldRef<"MagicItemType", 'String'>
    readonly name: FieldRef<"MagicItemType", 'String'>
    readonly gender: FieldRef<"MagicItemType", 'Gender'>
  }
    

  // Custom InputTypes
  /**
   * MagicItemType findUnique
   */
  export type MagicItemTypeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MagicItemType
     */
    select?: MagicItemTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MagicItemType
     */
    omit?: MagicItemTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MagicItemTypeInclude<ExtArgs> | null
    /**
     * Filter, which MagicItemType to fetch.
     */
    where: MagicItemTypeWhereUniqueInput
  }

  /**
   * MagicItemType findUniqueOrThrow
   */
  export type MagicItemTypeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MagicItemType
     */
    select?: MagicItemTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MagicItemType
     */
    omit?: MagicItemTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MagicItemTypeInclude<ExtArgs> | null
    /**
     * Filter, which MagicItemType to fetch.
     */
    where: MagicItemTypeWhereUniqueInput
  }

  /**
   * MagicItemType findFirst
   */
  export type MagicItemTypeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MagicItemType
     */
    select?: MagicItemTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MagicItemType
     */
    omit?: MagicItemTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MagicItemTypeInclude<ExtArgs> | null
    /**
     * Filter, which MagicItemType to fetch.
     */
    where?: MagicItemTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MagicItemTypes to fetch.
     */
    orderBy?: MagicItemTypeOrderByWithRelationInput | MagicItemTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MagicItemTypes.
     */
    cursor?: MagicItemTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MagicItemTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MagicItemTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MagicItemTypes.
     */
    distinct?: MagicItemTypeScalarFieldEnum | MagicItemTypeScalarFieldEnum[]
  }

  /**
   * MagicItemType findFirstOrThrow
   */
  export type MagicItemTypeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MagicItemType
     */
    select?: MagicItemTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MagicItemType
     */
    omit?: MagicItemTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MagicItemTypeInclude<ExtArgs> | null
    /**
     * Filter, which MagicItemType to fetch.
     */
    where?: MagicItemTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MagicItemTypes to fetch.
     */
    orderBy?: MagicItemTypeOrderByWithRelationInput | MagicItemTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MagicItemTypes.
     */
    cursor?: MagicItemTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MagicItemTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MagicItemTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MagicItemTypes.
     */
    distinct?: MagicItemTypeScalarFieldEnum | MagicItemTypeScalarFieldEnum[]
  }

  /**
   * MagicItemType findMany
   */
  export type MagicItemTypeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MagicItemType
     */
    select?: MagicItemTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MagicItemType
     */
    omit?: MagicItemTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MagicItemTypeInclude<ExtArgs> | null
    /**
     * Filter, which MagicItemTypes to fetch.
     */
    where?: MagicItemTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MagicItemTypes to fetch.
     */
    orderBy?: MagicItemTypeOrderByWithRelationInput | MagicItemTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MagicItemTypes.
     */
    cursor?: MagicItemTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MagicItemTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MagicItemTypes.
     */
    skip?: number
    distinct?: MagicItemTypeScalarFieldEnum | MagicItemTypeScalarFieldEnum[]
  }

  /**
   * MagicItemType create
   */
  export type MagicItemTypeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MagicItemType
     */
    select?: MagicItemTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MagicItemType
     */
    omit?: MagicItemTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MagicItemTypeInclude<ExtArgs> | null
    /**
     * The data needed to create a MagicItemType.
     */
    data: XOR<MagicItemTypeCreateInput, MagicItemTypeUncheckedCreateInput>
  }

  /**
   * MagicItemType createMany
   */
  export type MagicItemTypeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MagicItemTypes.
     */
    data: MagicItemTypeCreateManyInput | MagicItemTypeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MagicItemType createManyAndReturn
   */
  export type MagicItemTypeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MagicItemType
     */
    select?: MagicItemTypeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MagicItemType
     */
    omit?: MagicItemTypeOmit<ExtArgs> | null
    /**
     * The data used to create many MagicItemTypes.
     */
    data: MagicItemTypeCreateManyInput | MagicItemTypeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MagicItemType update
   */
  export type MagicItemTypeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MagicItemType
     */
    select?: MagicItemTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MagicItemType
     */
    omit?: MagicItemTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MagicItemTypeInclude<ExtArgs> | null
    /**
     * The data needed to update a MagicItemType.
     */
    data: XOR<MagicItemTypeUpdateInput, MagicItemTypeUncheckedUpdateInput>
    /**
     * Choose, which MagicItemType to update.
     */
    where: MagicItemTypeWhereUniqueInput
  }

  /**
   * MagicItemType updateMany
   */
  export type MagicItemTypeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MagicItemTypes.
     */
    data: XOR<MagicItemTypeUpdateManyMutationInput, MagicItemTypeUncheckedUpdateManyInput>
    /**
     * Filter which MagicItemTypes to update
     */
    where?: MagicItemTypeWhereInput
    /**
     * Limit how many MagicItemTypes to update.
     */
    limit?: number
  }

  /**
   * MagicItemType updateManyAndReturn
   */
  export type MagicItemTypeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MagicItemType
     */
    select?: MagicItemTypeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MagicItemType
     */
    omit?: MagicItemTypeOmit<ExtArgs> | null
    /**
     * The data used to update MagicItemTypes.
     */
    data: XOR<MagicItemTypeUpdateManyMutationInput, MagicItemTypeUncheckedUpdateManyInput>
    /**
     * Filter which MagicItemTypes to update
     */
    where?: MagicItemTypeWhereInput
    /**
     * Limit how many MagicItemTypes to update.
     */
    limit?: number
  }

  /**
   * MagicItemType upsert
   */
  export type MagicItemTypeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MagicItemType
     */
    select?: MagicItemTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MagicItemType
     */
    omit?: MagicItemTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MagicItemTypeInclude<ExtArgs> | null
    /**
     * The filter to search for the MagicItemType to update in case it exists.
     */
    where: MagicItemTypeWhereUniqueInput
    /**
     * In case the MagicItemType found by the `where` argument doesn't exist, create a new MagicItemType with this data.
     */
    create: XOR<MagicItemTypeCreateInput, MagicItemTypeUncheckedCreateInput>
    /**
     * In case the MagicItemType was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MagicItemTypeUpdateInput, MagicItemTypeUncheckedUpdateInput>
  }

  /**
   * MagicItemType delete
   */
  export type MagicItemTypeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MagicItemType
     */
    select?: MagicItemTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MagicItemType
     */
    omit?: MagicItemTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MagicItemTypeInclude<ExtArgs> | null
    /**
     * Filter which MagicItemType to delete.
     */
    where: MagicItemTypeWhereUniqueInput
  }

  /**
   * MagicItemType deleteMany
   */
  export type MagicItemTypeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MagicItemTypes to delete
     */
    where?: MagicItemTypeWhereInput
    /**
     * Limit how many MagicItemTypes to delete.
     */
    limit?: number
  }

  /**
   * MagicItemType.magicItems
   */
  export type MagicItemType$magicItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MagicItem
     */
    select?: MagicItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MagicItem
     */
    omit?: MagicItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MagicItemInclude<ExtArgs> | null
    where?: MagicItemWhereInput
    orderBy?: MagicItemOrderByWithRelationInput | MagicItemOrderByWithRelationInput[]
    cursor?: MagicItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MagicItemScalarFieldEnum | MagicItemScalarFieldEnum[]
  }

  /**
   * MagicItemType without action
   */
  export type MagicItemTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MagicItemType
     */
    select?: MagicItemTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MagicItemType
     */
    omit?: MagicItemTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MagicItemTypeInclude<ExtArgs> | null
  }


  /**
   * Model AttunementCondition
   */

  export type AggregateAttunementCondition = {
    _count: AttunementConditionCountAggregateOutputType | null
    _min: AttunementConditionMinAggregateOutputType | null
    _max: AttunementConditionMaxAggregateOutputType | null
  }

  export type AttunementConditionMinAggregateOutputType = {
    id: string | null
    name: string | null
  }

  export type AttunementConditionMaxAggregateOutputType = {
    id: string | null
    name: string | null
  }

  export type AttunementConditionCountAggregateOutputType = {
    id: number
    name: number
    _all: number
  }


  export type AttunementConditionMinAggregateInputType = {
    id?: true
    name?: true
  }

  export type AttunementConditionMaxAggregateInputType = {
    id?: true
    name?: true
  }

  export type AttunementConditionCountAggregateInputType = {
    id?: true
    name?: true
    _all?: true
  }

  export type AttunementConditionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AttunementCondition to aggregate.
     */
    where?: AttunementConditionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AttunementConditions to fetch.
     */
    orderBy?: AttunementConditionOrderByWithRelationInput | AttunementConditionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AttunementConditionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AttunementConditions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AttunementConditions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AttunementConditions
    **/
    _count?: true | AttunementConditionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AttunementConditionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AttunementConditionMaxAggregateInputType
  }

  export type GetAttunementConditionAggregateType<T extends AttunementConditionAggregateArgs> = {
        [P in keyof T & keyof AggregateAttunementCondition]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAttunementCondition[P]>
      : GetScalarType<T[P], AggregateAttunementCondition[P]>
  }




  export type AttunementConditionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AttunementConditionWhereInput
    orderBy?: AttunementConditionOrderByWithAggregationInput | AttunementConditionOrderByWithAggregationInput[]
    by: AttunementConditionScalarFieldEnum[] | AttunementConditionScalarFieldEnum
    having?: AttunementConditionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AttunementConditionCountAggregateInputType | true
    _min?: AttunementConditionMinAggregateInputType
    _max?: AttunementConditionMaxAggregateInputType
  }

  export type AttunementConditionGroupByOutputType = {
    id: string
    name: string
    _count: AttunementConditionCountAggregateOutputType | null
    _min: AttunementConditionMinAggregateOutputType | null
    _max: AttunementConditionMaxAggregateOutputType | null
  }

  type GetAttunementConditionGroupByPayload<T extends AttunementConditionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AttunementConditionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AttunementConditionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AttunementConditionGroupByOutputType[P]>
            : GetScalarType<T[P], AttunementConditionGroupByOutputType[P]>
        }
      >
    >


  export type AttunementConditionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    magicItems?: boolean | AttunementCondition$magicItemsArgs<ExtArgs>
    _count?: boolean | AttunementConditionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["attunementCondition"]>

  export type AttunementConditionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
  }, ExtArgs["result"]["attunementCondition"]>

  export type AttunementConditionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
  }, ExtArgs["result"]["attunementCondition"]>

  export type AttunementConditionSelectScalar = {
    id?: boolean
    name?: boolean
  }

  export type AttunementConditionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name", ExtArgs["result"]["attunementCondition"]>
  export type AttunementConditionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    magicItems?: boolean | AttunementCondition$magicItemsArgs<ExtArgs>
    _count?: boolean | AttunementConditionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type AttunementConditionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type AttunementConditionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $AttunementConditionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AttunementCondition"
    objects: {
      magicItems: Prisma.$MagicItemAttunementPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
    }, ExtArgs["result"]["attunementCondition"]>
    composites: {}
  }

  type AttunementConditionGetPayload<S extends boolean | null | undefined | AttunementConditionDefaultArgs> = $Result.GetResult<Prisma.$AttunementConditionPayload, S>

  type AttunementConditionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AttunementConditionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AttunementConditionCountAggregateInputType | true
    }

  export interface AttunementConditionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AttunementCondition'], meta: { name: 'AttunementCondition' } }
    /**
     * Find zero or one AttunementCondition that matches the filter.
     * @param {AttunementConditionFindUniqueArgs} args - Arguments to find a AttunementCondition
     * @example
     * // Get one AttunementCondition
     * const attunementCondition = await prisma.attunementCondition.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AttunementConditionFindUniqueArgs>(args: SelectSubset<T, AttunementConditionFindUniqueArgs<ExtArgs>>): Prisma__AttunementConditionClient<$Result.GetResult<Prisma.$AttunementConditionPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one AttunementCondition that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AttunementConditionFindUniqueOrThrowArgs} args - Arguments to find a AttunementCondition
     * @example
     * // Get one AttunementCondition
     * const attunementCondition = await prisma.attunementCondition.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AttunementConditionFindUniqueOrThrowArgs>(args: SelectSubset<T, AttunementConditionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AttunementConditionClient<$Result.GetResult<Prisma.$AttunementConditionPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first AttunementCondition that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttunementConditionFindFirstArgs} args - Arguments to find a AttunementCondition
     * @example
     * // Get one AttunementCondition
     * const attunementCondition = await prisma.attunementCondition.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AttunementConditionFindFirstArgs>(args?: SelectSubset<T, AttunementConditionFindFirstArgs<ExtArgs>>): Prisma__AttunementConditionClient<$Result.GetResult<Prisma.$AttunementConditionPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first AttunementCondition that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttunementConditionFindFirstOrThrowArgs} args - Arguments to find a AttunementCondition
     * @example
     * // Get one AttunementCondition
     * const attunementCondition = await prisma.attunementCondition.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AttunementConditionFindFirstOrThrowArgs>(args?: SelectSubset<T, AttunementConditionFindFirstOrThrowArgs<ExtArgs>>): Prisma__AttunementConditionClient<$Result.GetResult<Prisma.$AttunementConditionPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more AttunementConditions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttunementConditionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AttunementConditions
     * const attunementConditions = await prisma.attunementCondition.findMany()
     * 
     * // Get first 10 AttunementConditions
     * const attunementConditions = await prisma.attunementCondition.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const attunementConditionWithIdOnly = await prisma.attunementCondition.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AttunementConditionFindManyArgs>(args?: SelectSubset<T, AttunementConditionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AttunementConditionPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a AttunementCondition.
     * @param {AttunementConditionCreateArgs} args - Arguments to create a AttunementCondition.
     * @example
     * // Create one AttunementCondition
     * const AttunementCondition = await prisma.attunementCondition.create({
     *   data: {
     *     // ... data to create a AttunementCondition
     *   }
     * })
     * 
     */
    create<T extends AttunementConditionCreateArgs>(args: SelectSubset<T, AttunementConditionCreateArgs<ExtArgs>>): Prisma__AttunementConditionClient<$Result.GetResult<Prisma.$AttunementConditionPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many AttunementConditions.
     * @param {AttunementConditionCreateManyArgs} args - Arguments to create many AttunementConditions.
     * @example
     * // Create many AttunementConditions
     * const attunementCondition = await prisma.attunementCondition.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AttunementConditionCreateManyArgs>(args?: SelectSubset<T, AttunementConditionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AttunementConditions and returns the data saved in the database.
     * @param {AttunementConditionCreateManyAndReturnArgs} args - Arguments to create many AttunementConditions.
     * @example
     * // Create many AttunementConditions
     * const attunementCondition = await prisma.attunementCondition.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AttunementConditions and only return the `id`
     * const attunementConditionWithIdOnly = await prisma.attunementCondition.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AttunementConditionCreateManyAndReturnArgs>(args?: SelectSubset<T, AttunementConditionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AttunementConditionPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a AttunementCondition.
     * @param {AttunementConditionDeleteArgs} args - Arguments to delete one AttunementCondition.
     * @example
     * // Delete one AttunementCondition
     * const AttunementCondition = await prisma.attunementCondition.delete({
     *   where: {
     *     // ... filter to delete one AttunementCondition
     *   }
     * })
     * 
     */
    delete<T extends AttunementConditionDeleteArgs>(args: SelectSubset<T, AttunementConditionDeleteArgs<ExtArgs>>): Prisma__AttunementConditionClient<$Result.GetResult<Prisma.$AttunementConditionPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one AttunementCondition.
     * @param {AttunementConditionUpdateArgs} args - Arguments to update one AttunementCondition.
     * @example
     * // Update one AttunementCondition
     * const attunementCondition = await prisma.attunementCondition.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AttunementConditionUpdateArgs>(args: SelectSubset<T, AttunementConditionUpdateArgs<ExtArgs>>): Prisma__AttunementConditionClient<$Result.GetResult<Prisma.$AttunementConditionPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more AttunementConditions.
     * @param {AttunementConditionDeleteManyArgs} args - Arguments to filter AttunementConditions to delete.
     * @example
     * // Delete a few AttunementConditions
     * const { count } = await prisma.attunementCondition.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AttunementConditionDeleteManyArgs>(args?: SelectSubset<T, AttunementConditionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AttunementConditions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttunementConditionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AttunementConditions
     * const attunementCondition = await prisma.attunementCondition.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AttunementConditionUpdateManyArgs>(args: SelectSubset<T, AttunementConditionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AttunementConditions and returns the data updated in the database.
     * @param {AttunementConditionUpdateManyAndReturnArgs} args - Arguments to update many AttunementConditions.
     * @example
     * // Update many AttunementConditions
     * const attunementCondition = await prisma.attunementCondition.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AttunementConditions and only return the `id`
     * const attunementConditionWithIdOnly = await prisma.attunementCondition.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AttunementConditionUpdateManyAndReturnArgs>(args: SelectSubset<T, AttunementConditionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AttunementConditionPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one AttunementCondition.
     * @param {AttunementConditionUpsertArgs} args - Arguments to update or create a AttunementCondition.
     * @example
     * // Update or create a AttunementCondition
     * const attunementCondition = await prisma.attunementCondition.upsert({
     *   create: {
     *     // ... data to create a AttunementCondition
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AttunementCondition we want to update
     *   }
     * })
     */
    upsert<T extends AttunementConditionUpsertArgs>(args: SelectSubset<T, AttunementConditionUpsertArgs<ExtArgs>>): Prisma__AttunementConditionClient<$Result.GetResult<Prisma.$AttunementConditionPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of AttunementConditions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttunementConditionCountArgs} args - Arguments to filter AttunementConditions to count.
     * @example
     * // Count the number of AttunementConditions
     * const count = await prisma.attunementCondition.count({
     *   where: {
     *     // ... the filter for the AttunementConditions we want to count
     *   }
     * })
    **/
    count<T extends AttunementConditionCountArgs>(
      args?: Subset<T, AttunementConditionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AttunementConditionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AttunementCondition.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttunementConditionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AttunementConditionAggregateArgs>(args: Subset<T, AttunementConditionAggregateArgs>): Prisma.PrismaPromise<GetAttunementConditionAggregateType<T>>

    /**
     * Group by AttunementCondition.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttunementConditionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AttunementConditionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AttunementConditionGroupByArgs['orderBy'] }
        : { orderBy?: AttunementConditionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AttunementConditionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAttunementConditionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AttunementCondition model
   */
  readonly fields: AttunementConditionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AttunementCondition.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AttunementConditionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    magicItems<T extends AttunementCondition$magicItemsArgs<ExtArgs> = {}>(args?: Subset<T, AttunementCondition$magicItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MagicItemAttunementPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AttunementCondition model
   */ 
  interface AttunementConditionFieldRefs {
    readonly id: FieldRef<"AttunementCondition", 'String'>
    readonly name: FieldRef<"AttunementCondition", 'String'>
  }
    

  // Custom InputTypes
  /**
   * AttunementCondition findUnique
   */
  export type AttunementConditionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttunementCondition
     */
    select?: AttunementConditionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AttunementCondition
     */
    omit?: AttunementConditionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttunementConditionInclude<ExtArgs> | null
    /**
     * Filter, which AttunementCondition to fetch.
     */
    where: AttunementConditionWhereUniqueInput
  }

  /**
   * AttunementCondition findUniqueOrThrow
   */
  export type AttunementConditionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttunementCondition
     */
    select?: AttunementConditionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AttunementCondition
     */
    omit?: AttunementConditionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttunementConditionInclude<ExtArgs> | null
    /**
     * Filter, which AttunementCondition to fetch.
     */
    where: AttunementConditionWhereUniqueInput
  }

  /**
   * AttunementCondition findFirst
   */
  export type AttunementConditionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttunementCondition
     */
    select?: AttunementConditionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AttunementCondition
     */
    omit?: AttunementConditionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttunementConditionInclude<ExtArgs> | null
    /**
     * Filter, which AttunementCondition to fetch.
     */
    where?: AttunementConditionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AttunementConditions to fetch.
     */
    orderBy?: AttunementConditionOrderByWithRelationInput | AttunementConditionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AttunementConditions.
     */
    cursor?: AttunementConditionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AttunementConditions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AttunementConditions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AttunementConditions.
     */
    distinct?: AttunementConditionScalarFieldEnum | AttunementConditionScalarFieldEnum[]
  }

  /**
   * AttunementCondition findFirstOrThrow
   */
  export type AttunementConditionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttunementCondition
     */
    select?: AttunementConditionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AttunementCondition
     */
    omit?: AttunementConditionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttunementConditionInclude<ExtArgs> | null
    /**
     * Filter, which AttunementCondition to fetch.
     */
    where?: AttunementConditionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AttunementConditions to fetch.
     */
    orderBy?: AttunementConditionOrderByWithRelationInput | AttunementConditionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AttunementConditions.
     */
    cursor?: AttunementConditionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AttunementConditions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AttunementConditions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AttunementConditions.
     */
    distinct?: AttunementConditionScalarFieldEnum | AttunementConditionScalarFieldEnum[]
  }

  /**
   * AttunementCondition findMany
   */
  export type AttunementConditionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttunementCondition
     */
    select?: AttunementConditionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AttunementCondition
     */
    omit?: AttunementConditionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttunementConditionInclude<ExtArgs> | null
    /**
     * Filter, which AttunementConditions to fetch.
     */
    where?: AttunementConditionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AttunementConditions to fetch.
     */
    orderBy?: AttunementConditionOrderByWithRelationInput | AttunementConditionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AttunementConditions.
     */
    cursor?: AttunementConditionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AttunementConditions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AttunementConditions.
     */
    skip?: number
    distinct?: AttunementConditionScalarFieldEnum | AttunementConditionScalarFieldEnum[]
  }

  /**
   * AttunementCondition create
   */
  export type AttunementConditionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttunementCondition
     */
    select?: AttunementConditionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AttunementCondition
     */
    omit?: AttunementConditionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttunementConditionInclude<ExtArgs> | null
    /**
     * The data needed to create a AttunementCondition.
     */
    data: XOR<AttunementConditionCreateInput, AttunementConditionUncheckedCreateInput>
  }

  /**
   * AttunementCondition createMany
   */
  export type AttunementConditionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AttunementConditions.
     */
    data: AttunementConditionCreateManyInput | AttunementConditionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AttunementCondition createManyAndReturn
   */
  export type AttunementConditionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttunementCondition
     */
    select?: AttunementConditionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AttunementCondition
     */
    omit?: AttunementConditionOmit<ExtArgs> | null
    /**
     * The data used to create many AttunementConditions.
     */
    data: AttunementConditionCreateManyInput | AttunementConditionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AttunementCondition update
   */
  export type AttunementConditionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttunementCondition
     */
    select?: AttunementConditionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AttunementCondition
     */
    omit?: AttunementConditionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttunementConditionInclude<ExtArgs> | null
    /**
     * The data needed to update a AttunementCondition.
     */
    data: XOR<AttunementConditionUpdateInput, AttunementConditionUncheckedUpdateInput>
    /**
     * Choose, which AttunementCondition to update.
     */
    where: AttunementConditionWhereUniqueInput
  }

  /**
   * AttunementCondition updateMany
   */
  export type AttunementConditionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AttunementConditions.
     */
    data: XOR<AttunementConditionUpdateManyMutationInput, AttunementConditionUncheckedUpdateManyInput>
    /**
     * Filter which AttunementConditions to update
     */
    where?: AttunementConditionWhereInput
    /**
     * Limit how many AttunementConditions to update.
     */
    limit?: number
  }

  /**
   * AttunementCondition updateManyAndReturn
   */
  export type AttunementConditionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttunementCondition
     */
    select?: AttunementConditionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AttunementCondition
     */
    omit?: AttunementConditionOmit<ExtArgs> | null
    /**
     * The data used to update AttunementConditions.
     */
    data: XOR<AttunementConditionUpdateManyMutationInput, AttunementConditionUncheckedUpdateManyInput>
    /**
     * Filter which AttunementConditions to update
     */
    where?: AttunementConditionWhereInput
    /**
     * Limit how many AttunementConditions to update.
     */
    limit?: number
  }

  /**
   * AttunementCondition upsert
   */
  export type AttunementConditionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttunementCondition
     */
    select?: AttunementConditionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AttunementCondition
     */
    omit?: AttunementConditionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttunementConditionInclude<ExtArgs> | null
    /**
     * The filter to search for the AttunementCondition to update in case it exists.
     */
    where: AttunementConditionWhereUniqueInput
    /**
     * In case the AttunementCondition found by the `where` argument doesn't exist, create a new AttunementCondition with this data.
     */
    create: XOR<AttunementConditionCreateInput, AttunementConditionUncheckedCreateInput>
    /**
     * In case the AttunementCondition was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AttunementConditionUpdateInput, AttunementConditionUncheckedUpdateInput>
  }

  /**
   * AttunementCondition delete
   */
  export type AttunementConditionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttunementCondition
     */
    select?: AttunementConditionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AttunementCondition
     */
    omit?: AttunementConditionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttunementConditionInclude<ExtArgs> | null
    /**
     * Filter which AttunementCondition to delete.
     */
    where: AttunementConditionWhereUniqueInput
  }

  /**
   * AttunementCondition deleteMany
   */
  export type AttunementConditionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AttunementConditions to delete
     */
    where?: AttunementConditionWhereInput
    /**
     * Limit how many AttunementConditions to delete.
     */
    limit?: number
  }

  /**
   * AttunementCondition.magicItems
   */
  export type AttunementCondition$magicItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MagicItemAttunement
     */
    select?: MagicItemAttunementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MagicItemAttunement
     */
    omit?: MagicItemAttunementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MagicItemAttunementInclude<ExtArgs> | null
    where?: MagicItemAttunementWhereInput
    orderBy?: MagicItemAttunementOrderByWithRelationInput | MagicItemAttunementOrderByWithRelationInput[]
    cursor?: MagicItemAttunementWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MagicItemAttunementScalarFieldEnum | MagicItemAttunementScalarFieldEnum[]
  }

  /**
   * AttunementCondition without action
   */
  export type AttunementConditionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttunementCondition
     */
    select?: AttunementConditionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AttunementCondition
     */
    omit?: AttunementConditionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttunementConditionInclude<ExtArgs> | null
  }


  /**
   * Model MagicItemAttunement
   */

  export type AggregateMagicItemAttunement = {
    _count: MagicItemAttunementCountAggregateOutputType | null
    _min: MagicItemAttunementMinAggregateOutputType | null
    _max: MagicItemAttunementMaxAggregateOutputType | null
  }

  export type MagicItemAttunementMinAggregateOutputType = {
    magicItemId: string | null
    attunementId: string | null
  }

  export type MagicItemAttunementMaxAggregateOutputType = {
    magicItemId: string | null
    attunementId: string | null
  }

  export type MagicItemAttunementCountAggregateOutputType = {
    magicItemId: number
    attunementId: number
    _all: number
  }


  export type MagicItemAttunementMinAggregateInputType = {
    magicItemId?: true
    attunementId?: true
  }

  export type MagicItemAttunementMaxAggregateInputType = {
    magicItemId?: true
    attunementId?: true
  }

  export type MagicItemAttunementCountAggregateInputType = {
    magicItemId?: true
    attunementId?: true
    _all?: true
  }

  export type MagicItemAttunementAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MagicItemAttunement to aggregate.
     */
    where?: MagicItemAttunementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MagicItemAttunements to fetch.
     */
    orderBy?: MagicItemAttunementOrderByWithRelationInput | MagicItemAttunementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MagicItemAttunementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MagicItemAttunements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MagicItemAttunements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MagicItemAttunements
    **/
    _count?: true | MagicItemAttunementCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MagicItemAttunementMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MagicItemAttunementMaxAggregateInputType
  }

  export type GetMagicItemAttunementAggregateType<T extends MagicItemAttunementAggregateArgs> = {
        [P in keyof T & keyof AggregateMagicItemAttunement]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMagicItemAttunement[P]>
      : GetScalarType<T[P], AggregateMagicItemAttunement[P]>
  }




  export type MagicItemAttunementGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MagicItemAttunementWhereInput
    orderBy?: MagicItemAttunementOrderByWithAggregationInput | MagicItemAttunementOrderByWithAggregationInput[]
    by: MagicItemAttunementScalarFieldEnum[] | MagicItemAttunementScalarFieldEnum
    having?: MagicItemAttunementScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MagicItemAttunementCountAggregateInputType | true
    _min?: MagicItemAttunementMinAggregateInputType
    _max?: MagicItemAttunementMaxAggregateInputType
  }

  export type MagicItemAttunementGroupByOutputType = {
    magicItemId: string
    attunementId: string
    _count: MagicItemAttunementCountAggregateOutputType | null
    _min: MagicItemAttunementMinAggregateOutputType | null
    _max: MagicItemAttunementMaxAggregateOutputType | null
  }

  type GetMagicItemAttunementGroupByPayload<T extends MagicItemAttunementGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MagicItemAttunementGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MagicItemAttunementGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MagicItemAttunementGroupByOutputType[P]>
            : GetScalarType<T[P], MagicItemAttunementGroupByOutputType[P]>
        }
      >
    >


  export type MagicItemAttunementSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    magicItemId?: boolean
    attunementId?: boolean
    magicItem?: boolean | MagicItemDefaultArgs<ExtArgs>
    attunement?: boolean | AttunementConditionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["magicItemAttunement"]>

  export type MagicItemAttunementSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    magicItemId?: boolean
    attunementId?: boolean
    magicItem?: boolean | MagicItemDefaultArgs<ExtArgs>
    attunement?: boolean | AttunementConditionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["magicItemAttunement"]>

  export type MagicItemAttunementSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    magicItemId?: boolean
    attunementId?: boolean
    magicItem?: boolean | MagicItemDefaultArgs<ExtArgs>
    attunement?: boolean | AttunementConditionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["magicItemAttunement"]>

  export type MagicItemAttunementSelectScalar = {
    magicItemId?: boolean
    attunementId?: boolean
  }

  export type MagicItemAttunementOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"magicItemId" | "attunementId", ExtArgs["result"]["magicItemAttunement"]>
  export type MagicItemAttunementInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    magicItem?: boolean | MagicItemDefaultArgs<ExtArgs>
    attunement?: boolean | AttunementConditionDefaultArgs<ExtArgs>
  }
  export type MagicItemAttunementIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    magicItem?: boolean | MagicItemDefaultArgs<ExtArgs>
    attunement?: boolean | AttunementConditionDefaultArgs<ExtArgs>
  }
  export type MagicItemAttunementIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    magicItem?: boolean | MagicItemDefaultArgs<ExtArgs>
    attunement?: boolean | AttunementConditionDefaultArgs<ExtArgs>
  }

  export type $MagicItemAttunementPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MagicItemAttunement"
    objects: {
      magicItem: Prisma.$MagicItemPayload<ExtArgs>
      attunement: Prisma.$AttunementConditionPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      magicItemId: string
      attunementId: string
    }, ExtArgs["result"]["magicItemAttunement"]>
    composites: {}
  }

  type MagicItemAttunementGetPayload<S extends boolean | null | undefined | MagicItemAttunementDefaultArgs> = $Result.GetResult<Prisma.$MagicItemAttunementPayload, S>

  type MagicItemAttunementCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MagicItemAttunementFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MagicItemAttunementCountAggregateInputType | true
    }

  export interface MagicItemAttunementDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MagicItemAttunement'], meta: { name: 'MagicItemAttunement' } }
    /**
     * Find zero or one MagicItemAttunement that matches the filter.
     * @param {MagicItemAttunementFindUniqueArgs} args - Arguments to find a MagicItemAttunement
     * @example
     * // Get one MagicItemAttunement
     * const magicItemAttunement = await prisma.magicItemAttunement.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MagicItemAttunementFindUniqueArgs>(args: SelectSubset<T, MagicItemAttunementFindUniqueArgs<ExtArgs>>): Prisma__MagicItemAttunementClient<$Result.GetResult<Prisma.$MagicItemAttunementPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one MagicItemAttunement that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MagicItemAttunementFindUniqueOrThrowArgs} args - Arguments to find a MagicItemAttunement
     * @example
     * // Get one MagicItemAttunement
     * const magicItemAttunement = await prisma.magicItemAttunement.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MagicItemAttunementFindUniqueOrThrowArgs>(args: SelectSubset<T, MagicItemAttunementFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MagicItemAttunementClient<$Result.GetResult<Prisma.$MagicItemAttunementPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first MagicItemAttunement that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MagicItemAttunementFindFirstArgs} args - Arguments to find a MagicItemAttunement
     * @example
     * // Get one MagicItemAttunement
     * const magicItemAttunement = await prisma.magicItemAttunement.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MagicItemAttunementFindFirstArgs>(args?: SelectSubset<T, MagicItemAttunementFindFirstArgs<ExtArgs>>): Prisma__MagicItemAttunementClient<$Result.GetResult<Prisma.$MagicItemAttunementPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first MagicItemAttunement that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MagicItemAttunementFindFirstOrThrowArgs} args - Arguments to find a MagicItemAttunement
     * @example
     * // Get one MagicItemAttunement
     * const magicItemAttunement = await prisma.magicItemAttunement.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MagicItemAttunementFindFirstOrThrowArgs>(args?: SelectSubset<T, MagicItemAttunementFindFirstOrThrowArgs<ExtArgs>>): Prisma__MagicItemAttunementClient<$Result.GetResult<Prisma.$MagicItemAttunementPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more MagicItemAttunements that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MagicItemAttunementFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MagicItemAttunements
     * const magicItemAttunements = await prisma.magicItemAttunement.findMany()
     * 
     * // Get first 10 MagicItemAttunements
     * const magicItemAttunements = await prisma.magicItemAttunement.findMany({ take: 10 })
     * 
     * // Only select the `magicItemId`
     * const magicItemAttunementWithMagicItemIdOnly = await prisma.magicItemAttunement.findMany({ select: { magicItemId: true } })
     * 
     */
    findMany<T extends MagicItemAttunementFindManyArgs>(args?: SelectSubset<T, MagicItemAttunementFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MagicItemAttunementPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a MagicItemAttunement.
     * @param {MagicItemAttunementCreateArgs} args - Arguments to create a MagicItemAttunement.
     * @example
     * // Create one MagicItemAttunement
     * const MagicItemAttunement = await prisma.magicItemAttunement.create({
     *   data: {
     *     // ... data to create a MagicItemAttunement
     *   }
     * })
     * 
     */
    create<T extends MagicItemAttunementCreateArgs>(args: SelectSubset<T, MagicItemAttunementCreateArgs<ExtArgs>>): Prisma__MagicItemAttunementClient<$Result.GetResult<Prisma.$MagicItemAttunementPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many MagicItemAttunements.
     * @param {MagicItemAttunementCreateManyArgs} args - Arguments to create many MagicItemAttunements.
     * @example
     * // Create many MagicItemAttunements
     * const magicItemAttunement = await prisma.magicItemAttunement.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MagicItemAttunementCreateManyArgs>(args?: SelectSubset<T, MagicItemAttunementCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MagicItemAttunements and returns the data saved in the database.
     * @param {MagicItemAttunementCreateManyAndReturnArgs} args - Arguments to create many MagicItemAttunements.
     * @example
     * // Create many MagicItemAttunements
     * const magicItemAttunement = await prisma.magicItemAttunement.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MagicItemAttunements and only return the `magicItemId`
     * const magicItemAttunementWithMagicItemIdOnly = await prisma.magicItemAttunement.createManyAndReturn({
     *   select: { magicItemId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MagicItemAttunementCreateManyAndReturnArgs>(args?: SelectSubset<T, MagicItemAttunementCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MagicItemAttunementPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a MagicItemAttunement.
     * @param {MagicItemAttunementDeleteArgs} args - Arguments to delete one MagicItemAttunement.
     * @example
     * // Delete one MagicItemAttunement
     * const MagicItemAttunement = await prisma.magicItemAttunement.delete({
     *   where: {
     *     // ... filter to delete one MagicItemAttunement
     *   }
     * })
     * 
     */
    delete<T extends MagicItemAttunementDeleteArgs>(args: SelectSubset<T, MagicItemAttunementDeleteArgs<ExtArgs>>): Prisma__MagicItemAttunementClient<$Result.GetResult<Prisma.$MagicItemAttunementPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one MagicItemAttunement.
     * @param {MagicItemAttunementUpdateArgs} args - Arguments to update one MagicItemAttunement.
     * @example
     * // Update one MagicItemAttunement
     * const magicItemAttunement = await prisma.magicItemAttunement.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MagicItemAttunementUpdateArgs>(args: SelectSubset<T, MagicItemAttunementUpdateArgs<ExtArgs>>): Prisma__MagicItemAttunementClient<$Result.GetResult<Prisma.$MagicItemAttunementPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more MagicItemAttunements.
     * @param {MagicItemAttunementDeleteManyArgs} args - Arguments to filter MagicItemAttunements to delete.
     * @example
     * // Delete a few MagicItemAttunements
     * const { count } = await prisma.magicItemAttunement.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MagicItemAttunementDeleteManyArgs>(args?: SelectSubset<T, MagicItemAttunementDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MagicItemAttunements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MagicItemAttunementUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MagicItemAttunements
     * const magicItemAttunement = await prisma.magicItemAttunement.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MagicItemAttunementUpdateManyArgs>(args: SelectSubset<T, MagicItemAttunementUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MagicItemAttunements and returns the data updated in the database.
     * @param {MagicItemAttunementUpdateManyAndReturnArgs} args - Arguments to update many MagicItemAttunements.
     * @example
     * // Update many MagicItemAttunements
     * const magicItemAttunement = await prisma.magicItemAttunement.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more MagicItemAttunements and only return the `magicItemId`
     * const magicItemAttunementWithMagicItemIdOnly = await prisma.magicItemAttunement.updateManyAndReturn({
     *   select: { magicItemId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MagicItemAttunementUpdateManyAndReturnArgs>(args: SelectSubset<T, MagicItemAttunementUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MagicItemAttunementPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one MagicItemAttunement.
     * @param {MagicItemAttunementUpsertArgs} args - Arguments to update or create a MagicItemAttunement.
     * @example
     * // Update or create a MagicItemAttunement
     * const magicItemAttunement = await prisma.magicItemAttunement.upsert({
     *   create: {
     *     // ... data to create a MagicItemAttunement
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MagicItemAttunement we want to update
     *   }
     * })
     */
    upsert<T extends MagicItemAttunementUpsertArgs>(args: SelectSubset<T, MagicItemAttunementUpsertArgs<ExtArgs>>): Prisma__MagicItemAttunementClient<$Result.GetResult<Prisma.$MagicItemAttunementPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of MagicItemAttunements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MagicItemAttunementCountArgs} args - Arguments to filter MagicItemAttunements to count.
     * @example
     * // Count the number of MagicItemAttunements
     * const count = await prisma.magicItemAttunement.count({
     *   where: {
     *     // ... the filter for the MagicItemAttunements we want to count
     *   }
     * })
    **/
    count<T extends MagicItemAttunementCountArgs>(
      args?: Subset<T, MagicItemAttunementCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MagicItemAttunementCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MagicItemAttunement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MagicItemAttunementAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MagicItemAttunementAggregateArgs>(args: Subset<T, MagicItemAttunementAggregateArgs>): Prisma.PrismaPromise<GetMagicItemAttunementAggregateType<T>>

    /**
     * Group by MagicItemAttunement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MagicItemAttunementGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MagicItemAttunementGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MagicItemAttunementGroupByArgs['orderBy'] }
        : { orderBy?: MagicItemAttunementGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MagicItemAttunementGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMagicItemAttunementGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MagicItemAttunement model
   */
  readonly fields: MagicItemAttunementFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MagicItemAttunement.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MagicItemAttunementClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    magicItem<T extends MagicItemDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MagicItemDefaultArgs<ExtArgs>>): Prisma__MagicItemClient<$Result.GetResult<Prisma.$MagicItemPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    attunement<T extends AttunementConditionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AttunementConditionDefaultArgs<ExtArgs>>): Prisma__AttunementConditionClient<$Result.GetResult<Prisma.$AttunementConditionPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MagicItemAttunement model
   */ 
  interface MagicItemAttunementFieldRefs {
    readonly magicItemId: FieldRef<"MagicItemAttunement", 'String'>
    readonly attunementId: FieldRef<"MagicItemAttunement", 'String'>
  }
    

  // Custom InputTypes
  /**
   * MagicItemAttunement findUnique
   */
  export type MagicItemAttunementFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MagicItemAttunement
     */
    select?: MagicItemAttunementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MagicItemAttunement
     */
    omit?: MagicItemAttunementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MagicItemAttunementInclude<ExtArgs> | null
    /**
     * Filter, which MagicItemAttunement to fetch.
     */
    where: MagicItemAttunementWhereUniqueInput
  }

  /**
   * MagicItemAttunement findUniqueOrThrow
   */
  export type MagicItemAttunementFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MagicItemAttunement
     */
    select?: MagicItemAttunementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MagicItemAttunement
     */
    omit?: MagicItemAttunementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MagicItemAttunementInclude<ExtArgs> | null
    /**
     * Filter, which MagicItemAttunement to fetch.
     */
    where: MagicItemAttunementWhereUniqueInput
  }

  /**
   * MagicItemAttunement findFirst
   */
  export type MagicItemAttunementFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MagicItemAttunement
     */
    select?: MagicItemAttunementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MagicItemAttunement
     */
    omit?: MagicItemAttunementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MagicItemAttunementInclude<ExtArgs> | null
    /**
     * Filter, which MagicItemAttunement to fetch.
     */
    where?: MagicItemAttunementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MagicItemAttunements to fetch.
     */
    orderBy?: MagicItemAttunementOrderByWithRelationInput | MagicItemAttunementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MagicItemAttunements.
     */
    cursor?: MagicItemAttunementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MagicItemAttunements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MagicItemAttunements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MagicItemAttunements.
     */
    distinct?: MagicItemAttunementScalarFieldEnum | MagicItemAttunementScalarFieldEnum[]
  }

  /**
   * MagicItemAttunement findFirstOrThrow
   */
  export type MagicItemAttunementFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MagicItemAttunement
     */
    select?: MagicItemAttunementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MagicItemAttunement
     */
    omit?: MagicItemAttunementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MagicItemAttunementInclude<ExtArgs> | null
    /**
     * Filter, which MagicItemAttunement to fetch.
     */
    where?: MagicItemAttunementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MagicItemAttunements to fetch.
     */
    orderBy?: MagicItemAttunementOrderByWithRelationInput | MagicItemAttunementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MagicItemAttunements.
     */
    cursor?: MagicItemAttunementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MagicItemAttunements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MagicItemAttunements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MagicItemAttunements.
     */
    distinct?: MagicItemAttunementScalarFieldEnum | MagicItemAttunementScalarFieldEnum[]
  }

  /**
   * MagicItemAttunement findMany
   */
  export type MagicItemAttunementFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MagicItemAttunement
     */
    select?: MagicItemAttunementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MagicItemAttunement
     */
    omit?: MagicItemAttunementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MagicItemAttunementInclude<ExtArgs> | null
    /**
     * Filter, which MagicItemAttunements to fetch.
     */
    where?: MagicItemAttunementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MagicItemAttunements to fetch.
     */
    orderBy?: MagicItemAttunementOrderByWithRelationInput | MagicItemAttunementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MagicItemAttunements.
     */
    cursor?: MagicItemAttunementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MagicItemAttunements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MagicItemAttunements.
     */
    skip?: number
    distinct?: MagicItemAttunementScalarFieldEnum | MagicItemAttunementScalarFieldEnum[]
  }

  /**
   * MagicItemAttunement create
   */
  export type MagicItemAttunementCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MagicItemAttunement
     */
    select?: MagicItemAttunementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MagicItemAttunement
     */
    omit?: MagicItemAttunementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MagicItemAttunementInclude<ExtArgs> | null
    /**
     * The data needed to create a MagicItemAttunement.
     */
    data: XOR<MagicItemAttunementCreateInput, MagicItemAttunementUncheckedCreateInput>
  }

  /**
   * MagicItemAttunement createMany
   */
  export type MagicItemAttunementCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MagicItemAttunements.
     */
    data: MagicItemAttunementCreateManyInput | MagicItemAttunementCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MagicItemAttunement createManyAndReturn
   */
  export type MagicItemAttunementCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MagicItemAttunement
     */
    select?: MagicItemAttunementSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MagicItemAttunement
     */
    omit?: MagicItemAttunementOmit<ExtArgs> | null
    /**
     * The data used to create many MagicItemAttunements.
     */
    data: MagicItemAttunementCreateManyInput | MagicItemAttunementCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MagicItemAttunementIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * MagicItemAttunement update
   */
  export type MagicItemAttunementUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MagicItemAttunement
     */
    select?: MagicItemAttunementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MagicItemAttunement
     */
    omit?: MagicItemAttunementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MagicItemAttunementInclude<ExtArgs> | null
    /**
     * The data needed to update a MagicItemAttunement.
     */
    data: XOR<MagicItemAttunementUpdateInput, MagicItemAttunementUncheckedUpdateInput>
    /**
     * Choose, which MagicItemAttunement to update.
     */
    where: MagicItemAttunementWhereUniqueInput
  }

  /**
   * MagicItemAttunement updateMany
   */
  export type MagicItemAttunementUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MagicItemAttunements.
     */
    data: XOR<MagicItemAttunementUpdateManyMutationInput, MagicItemAttunementUncheckedUpdateManyInput>
    /**
     * Filter which MagicItemAttunements to update
     */
    where?: MagicItemAttunementWhereInput
    /**
     * Limit how many MagicItemAttunements to update.
     */
    limit?: number
  }

  /**
   * MagicItemAttunement updateManyAndReturn
   */
  export type MagicItemAttunementUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MagicItemAttunement
     */
    select?: MagicItemAttunementSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MagicItemAttunement
     */
    omit?: MagicItemAttunementOmit<ExtArgs> | null
    /**
     * The data used to update MagicItemAttunements.
     */
    data: XOR<MagicItemAttunementUpdateManyMutationInput, MagicItemAttunementUncheckedUpdateManyInput>
    /**
     * Filter which MagicItemAttunements to update
     */
    where?: MagicItemAttunementWhereInput
    /**
     * Limit how many MagicItemAttunements to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MagicItemAttunementIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * MagicItemAttunement upsert
   */
  export type MagicItemAttunementUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MagicItemAttunement
     */
    select?: MagicItemAttunementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MagicItemAttunement
     */
    omit?: MagicItemAttunementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MagicItemAttunementInclude<ExtArgs> | null
    /**
     * The filter to search for the MagicItemAttunement to update in case it exists.
     */
    where: MagicItemAttunementWhereUniqueInput
    /**
     * In case the MagicItemAttunement found by the `where` argument doesn't exist, create a new MagicItemAttunement with this data.
     */
    create: XOR<MagicItemAttunementCreateInput, MagicItemAttunementUncheckedCreateInput>
    /**
     * In case the MagicItemAttunement was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MagicItemAttunementUpdateInput, MagicItemAttunementUncheckedUpdateInput>
  }

  /**
   * MagicItemAttunement delete
   */
  export type MagicItemAttunementDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MagicItemAttunement
     */
    select?: MagicItemAttunementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MagicItemAttunement
     */
    omit?: MagicItemAttunementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MagicItemAttunementInclude<ExtArgs> | null
    /**
     * Filter which MagicItemAttunement to delete.
     */
    where: MagicItemAttunementWhereUniqueInput
  }

  /**
   * MagicItemAttunement deleteMany
   */
  export type MagicItemAttunementDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MagicItemAttunements to delete
     */
    where?: MagicItemAttunementWhereInput
    /**
     * Limit how many MagicItemAttunements to delete.
     */
    limit?: number
  }

  /**
   * MagicItemAttunement without action
   */
  export type MagicItemAttunementDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MagicItemAttunement
     */
    select?: MagicItemAttunementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MagicItemAttunement
     */
    omit?: MagicItemAttunementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MagicItemAttunementInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const SizeScalarFieldEnum: {
    id: 'id',
    name: 'name'
  };

  export type SizeScalarFieldEnum = (typeof SizeScalarFieldEnum)[keyof typeof SizeScalarFieldEnum]


  export const SourceScalarFieldEnum: {
    id: 'id',
    short_name: 'short_name',
    name: 'name'
  };

  export type SourceScalarFieldEnum = (typeof SourceScalarFieldEnum)[keyof typeof SourceScalarFieldEnum]


  export const LanguageScalarFieldEnum: {
    id: 'id',
    name: 'name'
  };

  export type LanguageScalarFieldEnum = (typeof LanguageScalarFieldEnum)[keyof typeof LanguageScalarFieldEnum]


  export const BiomeScalarFieldEnum: {
    id: 'id',
    short_name: 'short_name',
    name: 'name'
  };

  export type BiomeScalarFieldEnum = (typeof BiomeScalarFieldEnum)[keyof typeof BiomeScalarFieldEnum]


  export const TypeScalarFieldEnum: {
    id: 'id',
    name: 'name'
  };

  export type TypeScalarFieldEnum = (typeof TypeScalarFieldEnum)[keyof typeof TypeScalarFieldEnum]


  export const AlignmentScalarFieldEnum: {
    id: 'id',
    name: 'name'
  };

  export type AlignmentScalarFieldEnum = (typeof AlignmentScalarFieldEnum)[keyof typeof AlignmentScalarFieldEnum]


  export const CreatureSpeedScalarFieldEnum: {
    id: 'id',
    walk: 'walk',
    fly: 'fly',
    swim: 'swim',
    burrow: 'burrow',
    climb: 'climb'
  };

  export type CreatureSpeedScalarFieldEnum = (typeof CreatureSpeedScalarFieldEnum)[keyof typeof CreatureSpeedScalarFieldEnum]


  export const CreatureStatsScalarFieldEnum: {
    id: 'id'
  };

  export type CreatureStatsScalarFieldEnum = (typeof CreatureStatsScalarFieldEnum)[keyof typeof CreatureStatsScalarFieldEnum]


  export const CreatureStatDetailScalarFieldEnum: {
    id: 'id',
    ability: 'ability',
    value: 'value',
    mastery: 'mastery',
    creature_stats_id: 'creature_stats_id'
  };

  export type CreatureStatDetailScalarFieldEnum = (typeof CreatureStatDetailScalarFieldEnum)[keyof typeof CreatureStatDetailScalarFieldEnum]


  export const CreatureSkillsScalarFieldEnum: {
    id: 'id'
  };

  export type CreatureSkillsScalarFieldEnum = (typeof CreatureSkillsScalarFieldEnum)[keyof typeof CreatureSkillsScalarFieldEnum]


  export const CreatureSkillDetailScalarFieldEnum: {
    id: 'id',
    skill: 'skill',
    value: 'value',
    mastery: 'mastery',
    creature_skills_id: 'creature_skills_id'
  };

  export type CreatureSkillDetailScalarFieldEnum = (typeof CreatureSkillDetailScalarFieldEnum)[keyof typeof CreatureSkillDetailScalarFieldEnum]


  export const SkillMetadataScalarFieldEnum: {
    skill: 'skill',
    display_name: 'display_name',
    ability: 'ability'
  };

  export type SkillMetadataScalarFieldEnum = (typeof SkillMetadataScalarFieldEnum)[keyof typeof SkillMetadataScalarFieldEnum]


  export const CreatureScalarFieldEnum: {
    id: 'id',
    name: 'name',
    creator_id: 'creator_id',
    description: 'description',
    size: 'size',
    race_id: 'race_id',
    type_id: 'type_id',
    source_id: 'source_id',
    alignment_id: 'alignment_id',
    armor_class: 'armor_class',
    hit_points: 'hit_points',
    challenge_rating: 'challenge_rating'
  };

  export type CreatureScalarFieldEnum = (typeof CreatureScalarFieldEnum)[keyof typeof CreatureScalarFieldEnum]


  export const CreatureSensesScalarFieldEnum: {
    id: 'id',
    creature_id: 'creature_id',
    passive_perception: 'passive_perception'
  };

  export type CreatureSensesScalarFieldEnum = (typeof CreatureSensesScalarFieldEnum)[keyof typeof CreatureSensesScalarFieldEnum]


  export const ActionScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    attack: 'attack',
    is_template: 'is_template'
  };

  export type ActionScalarFieldEnum = (typeof ActionScalarFieldEnum)[keyof typeof ActionScalarFieldEnum]


  export const TraitScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    attack: 'attack',
    is_template: 'is_template'
  };

  export type TraitScalarFieldEnum = (typeof TraitScalarFieldEnum)[keyof typeof TraitScalarFieldEnum]


  export const CreatureRaceScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description'
  };

  export type CreatureRaceScalarFieldEnum = (typeof CreatureRaceScalarFieldEnum)[keyof typeof CreatureRaceScalarFieldEnum]


  export const DamageTypeScalarFieldEnum: {
    id: 'id',
    name: 'name'
  };

  export type DamageTypeScalarFieldEnum = (typeof DamageTypeScalarFieldEnum)[keyof typeof DamageTypeScalarFieldEnum]


  export const ChallengeRatingMetadataScalarFieldEnum: {
    cr: 'cr',
    display: 'display',
    numeric: 'numeric',
    xp_reward: 'xp_reward'
  };

  export type ChallengeRatingMetadataScalarFieldEnum = (typeof ChallengeRatingMetadataScalarFieldEnum)[keyof typeof ChallengeRatingMetadataScalarFieldEnum]


  export const GenrationRequestScalarFieldEnum: {
    id: 'id',
    request: 'request',
    danger: 'danger',
    name: 'name'
  };

  export type GenrationRequestScalarFieldEnum = (typeof GenrationRequestScalarFieldEnum)[keyof typeof GenrationRequestScalarFieldEnum]


  export const GPTMessageHistoryScalarFieldEnum: {
    id: 'id',
    type: 'type'
  };

  export type GPTMessageHistoryScalarFieldEnum = (typeof GPTMessageHistoryScalarFieldEnum)[keyof typeof GPTMessageHistoryScalarFieldEnum]


  export const GPTMessageScalarFieldEnum: {
    message_history_id: 'message_history_id',
    number: 'number',
    text: 'text',
    role: 'role'
  };

  export type GPTMessageScalarFieldEnum = (typeof GPTMessageScalarFieldEnum)[keyof typeof GPTMessageScalarFieldEnum]


  export const AdventureScalarFieldEnum: {
    id: 'id',
    name: 'name',
    genre_id: 'genre_id',
    creator_id: 'creator_id',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type AdventureScalarFieldEnum = (typeof AdventureScalarFieldEnum)[keyof typeof AdventureScalarFieldEnum]


  export const KeywordScalarFieldEnum: {
    id: 'id',
    name: 'name',
    genre_id: 'genre_id'
  };

  export type KeywordScalarFieldEnum = (typeof KeywordScalarFieldEnum)[keyof typeof KeywordScalarFieldEnum]


  export const GenreScalarFieldEnum: {
    id: 'id',
    name: 'name'
  };

  export type GenreScalarFieldEnum = (typeof GenreScalarFieldEnum)[keyof typeof GenreScalarFieldEnum]


  export const MagicItemScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    type_id: 'type_id',
    rarity_id: 'rarity_id',
    source_id: 'source_id',
    requires_attunement: 'requires_attunement'
  };

  export type MagicItemScalarFieldEnum = (typeof MagicItemScalarFieldEnum)[keyof typeof MagicItemScalarFieldEnum]


  export const MagicItemRarityScalarFieldEnum: {
    id: 'id',
    cost: 'cost',
    name: 'name',
    name_he: 'name_he',
    name_she: 'name_she',
    name_it: 'name_it',
    order: 'order'
  };

  export type MagicItemRarityScalarFieldEnum = (typeof MagicItemRarityScalarFieldEnum)[keyof typeof MagicItemRarityScalarFieldEnum]


  export const MagicItemTypeScalarFieldEnum: {
    id: 'id',
    name: 'name',
    gender: 'gender'
  };

  export type MagicItemTypeScalarFieldEnum = (typeof MagicItemTypeScalarFieldEnum)[keyof typeof MagicItemTypeScalarFieldEnum]


  export const AttunementConditionScalarFieldEnum: {
    id: 'id',
    name: 'name'
  };

  export type AttunementConditionScalarFieldEnum = (typeof AttunementConditionScalarFieldEnum)[keyof typeof AttunementConditionScalarFieldEnum]


  export const MagicItemAttunementScalarFieldEnum: {
    magicItemId: 'magicItemId',
    attunementId: 'attunementId'
  };

  export type MagicItemAttunementScalarFieldEnum = (typeof MagicItemAttunementScalarFieldEnum)[keyof typeof MagicItemAttunementScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'Ability'
   */
  export type EnumAbilityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Ability'>
    


  /**
   * Reference to a field of type 'Ability[]'
   */
  export type ListEnumAbilityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Ability[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Skill'
   */
  export type EnumSkillFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Skill'>
    


  /**
   * Reference to a field of type 'Skill[]'
   */
  export type ListEnumSkillFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Skill[]'>
    


  /**
   * Reference to a field of type 'ChallengeRatingEnum'
   */
  export type EnumChallengeRatingEnumFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ChallengeRatingEnum'>
    


  /**
   * Reference to a field of type 'ChallengeRatingEnum[]'
   */
  export type ListEnumChallengeRatingEnumFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ChallengeRatingEnum[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Gender'
   */
  export type EnumGenderFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Gender'>
    


  /**
   * Reference to a field of type 'Gender[]'
   */
  export type ListEnumGenderFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Gender[]'>
    
  /**
   * Deep Input Types
   */


  export type SizeWhereInput = {
    AND?: SizeWhereInput | SizeWhereInput[]
    OR?: SizeWhereInput[]
    NOT?: SizeWhereInput | SizeWhereInput[]
    id?: StringFilter<"Size"> | string
    name?: StringFilter<"Size"> | string
    creature?: CreatureListRelationFilter
  }

  export type SizeOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    creature?: CreatureOrderByRelationAggregateInput
  }

  export type SizeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    AND?: SizeWhereInput | SizeWhereInput[]
    OR?: SizeWhereInput[]
    NOT?: SizeWhereInput | SizeWhereInput[]
    creature?: CreatureListRelationFilter
  }, "id" | "name">

  export type SizeOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    _count?: SizeCountOrderByAggregateInput
    _max?: SizeMaxOrderByAggregateInput
    _min?: SizeMinOrderByAggregateInput
  }

  export type SizeScalarWhereWithAggregatesInput = {
    AND?: SizeScalarWhereWithAggregatesInput | SizeScalarWhereWithAggregatesInput[]
    OR?: SizeScalarWhereWithAggregatesInput[]
    NOT?: SizeScalarWhereWithAggregatesInput | SizeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Size"> | string
    name?: StringWithAggregatesFilter<"Size"> | string
  }

  export type SourceWhereInput = {
    AND?: SourceWhereInput | SourceWhereInput[]
    OR?: SourceWhereInput[]
    NOT?: SourceWhereInput | SourceWhereInput[]
    id?: IntFilter<"Source"> | number
    short_name?: StringFilter<"Source"> | string
    name?: StringFilter<"Source"> | string
    creatures?: CreatureListRelationFilter
    magicItems?: MagicItemListRelationFilter
  }

  export type SourceOrderByWithRelationInput = {
    id?: SortOrder
    short_name?: SortOrder
    name?: SortOrder
    creatures?: CreatureOrderByRelationAggregateInput
    magicItems?: MagicItemOrderByRelationAggregateInput
  }

  export type SourceWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    short_name?: string
    AND?: SourceWhereInput | SourceWhereInput[]
    OR?: SourceWhereInput[]
    NOT?: SourceWhereInput | SourceWhereInput[]
    name?: StringFilter<"Source"> | string
    creatures?: CreatureListRelationFilter
    magicItems?: MagicItemListRelationFilter
  }, "id" | "short_name">

  export type SourceOrderByWithAggregationInput = {
    id?: SortOrder
    short_name?: SortOrder
    name?: SortOrder
    _count?: SourceCountOrderByAggregateInput
    _avg?: SourceAvgOrderByAggregateInput
    _max?: SourceMaxOrderByAggregateInput
    _min?: SourceMinOrderByAggregateInput
    _sum?: SourceSumOrderByAggregateInput
  }

  export type SourceScalarWhereWithAggregatesInput = {
    AND?: SourceScalarWhereWithAggregatesInput | SourceScalarWhereWithAggregatesInput[]
    OR?: SourceScalarWhereWithAggregatesInput[]
    NOT?: SourceScalarWhereWithAggregatesInput | SourceScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Source"> | number
    short_name?: StringWithAggregatesFilter<"Source"> | string
    name?: StringWithAggregatesFilter<"Source"> | string
  }

  export type LanguageWhereInput = {
    AND?: LanguageWhereInput | LanguageWhereInput[]
    OR?: LanguageWhereInput[]
    NOT?: LanguageWhereInput | LanguageWhereInput[]
    id?: IntFilter<"Language"> | number
    name?: StringFilter<"Language"> | string
    creatures_relation?: CreatureListRelationFilter
  }

  export type LanguageOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    creatures_relation?: CreatureOrderByRelationAggregateInput
  }

  export type LanguageWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    name?: string
    AND?: LanguageWhereInput | LanguageWhereInput[]
    OR?: LanguageWhereInput[]
    NOT?: LanguageWhereInput | LanguageWhereInput[]
    creatures_relation?: CreatureListRelationFilter
  }, "id" | "name">

  export type LanguageOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    _count?: LanguageCountOrderByAggregateInput
    _avg?: LanguageAvgOrderByAggregateInput
    _max?: LanguageMaxOrderByAggregateInput
    _min?: LanguageMinOrderByAggregateInput
    _sum?: LanguageSumOrderByAggregateInput
  }

  export type LanguageScalarWhereWithAggregatesInput = {
    AND?: LanguageScalarWhereWithAggregatesInput | LanguageScalarWhereWithAggregatesInput[]
    OR?: LanguageScalarWhereWithAggregatesInput[]
    NOT?: LanguageScalarWhereWithAggregatesInput | LanguageScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Language"> | number
    name?: StringWithAggregatesFilter<"Language"> | string
  }

  export type BiomeWhereInput = {
    AND?: BiomeWhereInput | BiomeWhereInput[]
    OR?: BiomeWhereInput[]
    NOT?: BiomeWhereInput | BiomeWhereInput[]
    id?: IntFilter<"Biome"> | number
    short_name?: StringFilter<"Biome"> | string
    name?: StringFilter<"Biome"> | string
    creatures_relation?: CreatureListRelationFilter
  }

  export type BiomeOrderByWithRelationInput = {
    id?: SortOrder
    short_name?: SortOrder
    name?: SortOrder
    creatures_relation?: CreatureOrderByRelationAggregateInput
  }

  export type BiomeWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    short_name?: string
    name?: string
    AND?: BiomeWhereInput | BiomeWhereInput[]
    OR?: BiomeWhereInput[]
    NOT?: BiomeWhereInput | BiomeWhereInput[]
    creatures_relation?: CreatureListRelationFilter
  }, "id" | "short_name" | "name">

  export type BiomeOrderByWithAggregationInput = {
    id?: SortOrder
    short_name?: SortOrder
    name?: SortOrder
    _count?: BiomeCountOrderByAggregateInput
    _avg?: BiomeAvgOrderByAggregateInput
    _max?: BiomeMaxOrderByAggregateInput
    _min?: BiomeMinOrderByAggregateInput
    _sum?: BiomeSumOrderByAggregateInput
  }

  export type BiomeScalarWhereWithAggregatesInput = {
    AND?: BiomeScalarWhereWithAggregatesInput | BiomeScalarWhereWithAggregatesInput[]
    OR?: BiomeScalarWhereWithAggregatesInput[]
    NOT?: BiomeScalarWhereWithAggregatesInput | BiomeScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Biome"> | number
    short_name?: StringWithAggregatesFilter<"Biome"> | string
    name?: StringWithAggregatesFilter<"Biome"> | string
  }

  export type TypeWhereInput = {
    AND?: TypeWhereInput | TypeWhereInput[]
    OR?: TypeWhereInput[]
    NOT?: TypeWhereInput | TypeWhereInput[]
    id?: IntFilter<"Type"> | number
    name?: StringFilter<"Type"> | string
    creatures?: CreatureListRelationFilter
  }

  export type TypeOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    creatures?: CreatureOrderByRelationAggregateInput
  }

  export type TypeWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    name?: string
    AND?: TypeWhereInput | TypeWhereInput[]
    OR?: TypeWhereInput[]
    NOT?: TypeWhereInput | TypeWhereInput[]
    creatures?: CreatureListRelationFilter
  }, "id" | "name">

  export type TypeOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    _count?: TypeCountOrderByAggregateInput
    _avg?: TypeAvgOrderByAggregateInput
    _max?: TypeMaxOrderByAggregateInput
    _min?: TypeMinOrderByAggregateInput
    _sum?: TypeSumOrderByAggregateInput
  }

  export type TypeScalarWhereWithAggregatesInput = {
    AND?: TypeScalarWhereWithAggregatesInput | TypeScalarWhereWithAggregatesInput[]
    OR?: TypeScalarWhereWithAggregatesInput[]
    NOT?: TypeScalarWhereWithAggregatesInput | TypeScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Type"> | number
    name?: StringWithAggregatesFilter<"Type"> | string
  }

  export type AlignmentWhereInput = {
    AND?: AlignmentWhereInput | AlignmentWhereInput[]
    OR?: AlignmentWhereInput[]
    NOT?: AlignmentWhereInput | AlignmentWhereInput[]
    id?: IntFilter<"Alignment"> | number
    name?: StringFilter<"Alignment"> | string
    creatures?: CreatureListRelationFilter
  }

  export type AlignmentOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    creatures?: CreatureOrderByRelationAggregateInput
  }

  export type AlignmentWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    name?: string
    AND?: AlignmentWhereInput | AlignmentWhereInput[]
    OR?: AlignmentWhereInput[]
    NOT?: AlignmentWhereInput | AlignmentWhereInput[]
    creatures?: CreatureListRelationFilter
  }, "id" | "name">

  export type AlignmentOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    _count?: AlignmentCountOrderByAggregateInput
    _avg?: AlignmentAvgOrderByAggregateInput
    _max?: AlignmentMaxOrderByAggregateInput
    _min?: AlignmentMinOrderByAggregateInput
    _sum?: AlignmentSumOrderByAggregateInput
  }

  export type AlignmentScalarWhereWithAggregatesInput = {
    AND?: AlignmentScalarWhereWithAggregatesInput | AlignmentScalarWhereWithAggregatesInput[]
    OR?: AlignmentScalarWhereWithAggregatesInput[]
    NOT?: AlignmentScalarWhereWithAggregatesInput | AlignmentScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Alignment"> | number
    name?: StringWithAggregatesFilter<"Alignment"> | string
  }

  export type CreatureSpeedWhereInput = {
    AND?: CreatureSpeedWhereInput | CreatureSpeedWhereInput[]
    OR?: CreatureSpeedWhereInput[]
    NOT?: CreatureSpeedWhereInput | CreatureSpeedWhereInput[]
    id?: StringFilter<"CreatureSpeed"> | string
    walk?: IntNullableFilter<"CreatureSpeed"> | number | null
    fly?: IntNullableFilter<"CreatureSpeed"> | number | null
    swim?: IntNullableFilter<"CreatureSpeed"> | number | null
    burrow?: IntNullableFilter<"CreatureSpeed"> | number | null
    climb?: IntNullableFilter<"CreatureSpeed"> | number | null
    creature_relation?: XOR<CreatureScalarRelationFilter, CreatureWhereInput>
  }

  export type CreatureSpeedOrderByWithRelationInput = {
    id?: SortOrder
    walk?: SortOrderInput | SortOrder
    fly?: SortOrderInput | SortOrder
    swim?: SortOrderInput | SortOrder
    burrow?: SortOrderInput | SortOrder
    climb?: SortOrderInput | SortOrder
    creature_relation?: CreatureOrderByWithRelationInput
  }

  export type CreatureSpeedWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CreatureSpeedWhereInput | CreatureSpeedWhereInput[]
    OR?: CreatureSpeedWhereInput[]
    NOT?: CreatureSpeedWhereInput | CreatureSpeedWhereInput[]
    walk?: IntNullableFilter<"CreatureSpeed"> | number | null
    fly?: IntNullableFilter<"CreatureSpeed"> | number | null
    swim?: IntNullableFilter<"CreatureSpeed"> | number | null
    burrow?: IntNullableFilter<"CreatureSpeed"> | number | null
    climb?: IntNullableFilter<"CreatureSpeed"> | number | null
    creature_relation?: XOR<CreatureScalarRelationFilter, CreatureWhereInput>
  }, "id">

  export type CreatureSpeedOrderByWithAggregationInput = {
    id?: SortOrder
    walk?: SortOrderInput | SortOrder
    fly?: SortOrderInput | SortOrder
    swim?: SortOrderInput | SortOrder
    burrow?: SortOrderInput | SortOrder
    climb?: SortOrderInput | SortOrder
    _count?: CreatureSpeedCountOrderByAggregateInput
    _avg?: CreatureSpeedAvgOrderByAggregateInput
    _max?: CreatureSpeedMaxOrderByAggregateInput
    _min?: CreatureSpeedMinOrderByAggregateInput
    _sum?: CreatureSpeedSumOrderByAggregateInput
  }

  export type CreatureSpeedScalarWhereWithAggregatesInput = {
    AND?: CreatureSpeedScalarWhereWithAggregatesInput | CreatureSpeedScalarWhereWithAggregatesInput[]
    OR?: CreatureSpeedScalarWhereWithAggregatesInput[]
    NOT?: CreatureSpeedScalarWhereWithAggregatesInput | CreatureSpeedScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CreatureSpeed"> | string
    walk?: IntNullableWithAggregatesFilter<"CreatureSpeed"> | number | null
    fly?: IntNullableWithAggregatesFilter<"CreatureSpeed"> | number | null
    swim?: IntNullableWithAggregatesFilter<"CreatureSpeed"> | number | null
    burrow?: IntNullableWithAggregatesFilter<"CreatureSpeed"> | number | null
    climb?: IntNullableWithAggregatesFilter<"CreatureSpeed"> | number | null
  }

  export type CreatureStatsWhereInput = {
    AND?: CreatureStatsWhereInput | CreatureStatsWhereInput[]
    OR?: CreatureStatsWhereInput[]
    NOT?: CreatureStatsWhereInput | CreatureStatsWhereInput[]
    id?: StringFilter<"CreatureStats"> | string
    stats?: CreatureStatDetailListRelationFilter
    creature_relation?: XOR<CreatureScalarRelationFilter, CreatureWhereInput>
  }

  export type CreatureStatsOrderByWithRelationInput = {
    id?: SortOrder
    stats?: CreatureStatDetailOrderByRelationAggregateInput
    creature_relation?: CreatureOrderByWithRelationInput
  }

  export type CreatureStatsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CreatureStatsWhereInput | CreatureStatsWhereInput[]
    OR?: CreatureStatsWhereInput[]
    NOT?: CreatureStatsWhereInput | CreatureStatsWhereInput[]
    stats?: CreatureStatDetailListRelationFilter
    creature_relation?: XOR<CreatureScalarRelationFilter, CreatureWhereInput>
  }, "id">

  export type CreatureStatsOrderByWithAggregationInput = {
    id?: SortOrder
    _count?: CreatureStatsCountOrderByAggregateInput
    _max?: CreatureStatsMaxOrderByAggregateInput
    _min?: CreatureStatsMinOrderByAggregateInput
  }

  export type CreatureStatsScalarWhereWithAggregatesInput = {
    AND?: CreatureStatsScalarWhereWithAggregatesInput | CreatureStatsScalarWhereWithAggregatesInput[]
    OR?: CreatureStatsScalarWhereWithAggregatesInput[]
    NOT?: CreatureStatsScalarWhereWithAggregatesInput | CreatureStatsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CreatureStats"> | string
  }

  export type CreatureStatDetailWhereInput = {
    AND?: CreatureStatDetailWhereInput | CreatureStatDetailWhereInput[]
    OR?: CreatureStatDetailWhereInput[]
    NOT?: CreatureStatDetailWhereInput | CreatureStatDetailWhereInput[]
    id?: StringFilter<"CreatureStatDetail"> | string
    ability?: EnumAbilityFilter<"CreatureStatDetail"> | $Enums.Ability
    value?: IntFilter<"CreatureStatDetail"> | number
    mastery?: BoolFilter<"CreatureStatDetail"> | boolean
    creature_stats_id?: StringFilter<"CreatureStatDetail"> | string
    creature_stats_relation?: XOR<CreatureStatsScalarRelationFilter, CreatureStatsWhereInput>
  }

  export type CreatureStatDetailOrderByWithRelationInput = {
    id?: SortOrder
    ability?: SortOrder
    value?: SortOrder
    mastery?: SortOrder
    creature_stats_id?: SortOrder
    creature_stats_relation?: CreatureStatsOrderByWithRelationInput
  }

  export type CreatureStatDetailWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    creature_stats_id_ability?: CreatureStatDetailCreature_stats_idAbilityCompoundUniqueInput
    AND?: CreatureStatDetailWhereInput | CreatureStatDetailWhereInput[]
    OR?: CreatureStatDetailWhereInput[]
    NOT?: CreatureStatDetailWhereInput | CreatureStatDetailWhereInput[]
    ability?: EnumAbilityFilter<"CreatureStatDetail"> | $Enums.Ability
    value?: IntFilter<"CreatureStatDetail"> | number
    mastery?: BoolFilter<"CreatureStatDetail"> | boolean
    creature_stats_id?: StringFilter<"CreatureStatDetail"> | string
    creature_stats_relation?: XOR<CreatureStatsScalarRelationFilter, CreatureStatsWhereInput>
  }, "id" | "creature_stats_id_ability">

  export type CreatureStatDetailOrderByWithAggregationInput = {
    id?: SortOrder
    ability?: SortOrder
    value?: SortOrder
    mastery?: SortOrder
    creature_stats_id?: SortOrder
    _count?: CreatureStatDetailCountOrderByAggregateInput
    _avg?: CreatureStatDetailAvgOrderByAggregateInput
    _max?: CreatureStatDetailMaxOrderByAggregateInput
    _min?: CreatureStatDetailMinOrderByAggregateInput
    _sum?: CreatureStatDetailSumOrderByAggregateInput
  }

  export type CreatureStatDetailScalarWhereWithAggregatesInput = {
    AND?: CreatureStatDetailScalarWhereWithAggregatesInput | CreatureStatDetailScalarWhereWithAggregatesInput[]
    OR?: CreatureStatDetailScalarWhereWithAggregatesInput[]
    NOT?: CreatureStatDetailScalarWhereWithAggregatesInput | CreatureStatDetailScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CreatureStatDetail"> | string
    ability?: EnumAbilityWithAggregatesFilter<"CreatureStatDetail"> | $Enums.Ability
    value?: IntWithAggregatesFilter<"CreatureStatDetail"> | number
    mastery?: BoolWithAggregatesFilter<"CreatureStatDetail"> | boolean
    creature_stats_id?: StringWithAggregatesFilter<"CreatureStatDetail"> | string
  }

  export type CreatureSkillsWhereInput = {
    AND?: CreatureSkillsWhereInput | CreatureSkillsWhereInput[]
    OR?: CreatureSkillsWhereInput[]
    NOT?: CreatureSkillsWhereInput | CreatureSkillsWhereInput[]
    id?: StringFilter<"CreatureSkills"> | string
    skills?: CreatureSkillDetailListRelationFilter
    creature_relation?: XOR<CreatureScalarRelationFilter, CreatureWhereInput>
  }

  export type CreatureSkillsOrderByWithRelationInput = {
    id?: SortOrder
    skills?: CreatureSkillDetailOrderByRelationAggregateInput
    creature_relation?: CreatureOrderByWithRelationInput
  }

  export type CreatureSkillsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CreatureSkillsWhereInput | CreatureSkillsWhereInput[]
    OR?: CreatureSkillsWhereInput[]
    NOT?: CreatureSkillsWhereInput | CreatureSkillsWhereInput[]
    skills?: CreatureSkillDetailListRelationFilter
    creature_relation?: XOR<CreatureScalarRelationFilter, CreatureWhereInput>
  }, "id">

  export type CreatureSkillsOrderByWithAggregationInput = {
    id?: SortOrder
    _count?: CreatureSkillsCountOrderByAggregateInput
    _max?: CreatureSkillsMaxOrderByAggregateInput
    _min?: CreatureSkillsMinOrderByAggregateInput
  }

  export type CreatureSkillsScalarWhereWithAggregatesInput = {
    AND?: CreatureSkillsScalarWhereWithAggregatesInput | CreatureSkillsScalarWhereWithAggregatesInput[]
    OR?: CreatureSkillsScalarWhereWithAggregatesInput[]
    NOT?: CreatureSkillsScalarWhereWithAggregatesInput | CreatureSkillsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CreatureSkills"> | string
  }

  export type CreatureSkillDetailWhereInput = {
    AND?: CreatureSkillDetailWhereInput | CreatureSkillDetailWhereInput[]
    OR?: CreatureSkillDetailWhereInput[]
    NOT?: CreatureSkillDetailWhereInput | CreatureSkillDetailWhereInput[]
    id?: StringFilter<"CreatureSkillDetail"> | string
    skill?: EnumSkillFilter<"CreatureSkillDetail"> | $Enums.Skill
    value?: IntNullableFilter<"CreatureSkillDetail"> | number | null
    mastery?: BoolFilter<"CreatureSkillDetail"> | boolean
    creature_skills_id?: StringFilter<"CreatureSkillDetail"> | string
    creature_skills_relation?: XOR<CreatureSkillsScalarRelationFilter, CreatureSkillsWhereInput>
  }

  export type CreatureSkillDetailOrderByWithRelationInput = {
    id?: SortOrder
    skill?: SortOrder
    value?: SortOrderInput | SortOrder
    mastery?: SortOrder
    creature_skills_id?: SortOrder
    creature_skills_relation?: CreatureSkillsOrderByWithRelationInput
  }

  export type CreatureSkillDetailWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    creature_skills_id_skill?: CreatureSkillDetailCreature_skills_idSkillCompoundUniqueInput
    AND?: CreatureSkillDetailWhereInput | CreatureSkillDetailWhereInput[]
    OR?: CreatureSkillDetailWhereInput[]
    NOT?: CreatureSkillDetailWhereInput | CreatureSkillDetailWhereInput[]
    skill?: EnumSkillFilter<"CreatureSkillDetail"> | $Enums.Skill
    value?: IntNullableFilter<"CreatureSkillDetail"> | number | null
    mastery?: BoolFilter<"CreatureSkillDetail"> | boolean
    creature_skills_id?: StringFilter<"CreatureSkillDetail"> | string
    creature_skills_relation?: XOR<CreatureSkillsScalarRelationFilter, CreatureSkillsWhereInput>
  }, "id" | "creature_skills_id_skill">

  export type CreatureSkillDetailOrderByWithAggregationInput = {
    id?: SortOrder
    skill?: SortOrder
    value?: SortOrderInput | SortOrder
    mastery?: SortOrder
    creature_skills_id?: SortOrder
    _count?: CreatureSkillDetailCountOrderByAggregateInput
    _avg?: CreatureSkillDetailAvgOrderByAggregateInput
    _max?: CreatureSkillDetailMaxOrderByAggregateInput
    _min?: CreatureSkillDetailMinOrderByAggregateInput
    _sum?: CreatureSkillDetailSumOrderByAggregateInput
  }

  export type CreatureSkillDetailScalarWhereWithAggregatesInput = {
    AND?: CreatureSkillDetailScalarWhereWithAggregatesInput | CreatureSkillDetailScalarWhereWithAggregatesInput[]
    OR?: CreatureSkillDetailScalarWhereWithAggregatesInput[]
    NOT?: CreatureSkillDetailScalarWhereWithAggregatesInput | CreatureSkillDetailScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CreatureSkillDetail"> | string
    skill?: EnumSkillWithAggregatesFilter<"CreatureSkillDetail"> | $Enums.Skill
    value?: IntNullableWithAggregatesFilter<"CreatureSkillDetail"> | number | null
    mastery?: BoolWithAggregatesFilter<"CreatureSkillDetail"> | boolean
    creature_skills_id?: StringWithAggregatesFilter<"CreatureSkillDetail"> | string
  }

  export type SkillMetadataWhereInput = {
    AND?: SkillMetadataWhereInput | SkillMetadataWhereInput[]
    OR?: SkillMetadataWhereInput[]
    NOT?: SkillMetadataWhereInput | SkillMetadataWhereInput[]
    skill?: EnumSkillFilter<"SkillMetadata"> | $Enums.Skill
    display_name?: StringFilter<"SkillMetadata"> | string
    ability?: EnumAbilityFilter<"SkillMetadata"> | $Enums.Ability
  }

  export type SkillMetadataOrderByWithRelationInput = {
    skill?: SortOrder
    display_name?: SortOrder
    ability?: SortOrder
  }

  export type SkillMetadataWhereUniqueInput = Prisma.AtLeast<{
    skill?: $Enums.Skill
    AND?: SkillMetadataWhereInput | SkillMetadataWhereInput[]
    OR?: SkillMetadataWhereInput[]
    NOT?: SkillMetadataWhereInput | SkillMetadataWhereInput[]
    display_name?: StringFilter<"SkillMetadata"> | string
    ability?: EnumAbilityFilter<"SkillMetadata"> | $Enums.Ability
  }, "skill">

  export type SkillMetadataOrderByWithAggregationInput = {
    skill?: SortOrder
    display_name?: SortOrder
    ability?: SortOrder
    _count?: SkillMetadataCountOrderByAggregateInput
    _max?: SkillMetadataMaxOrderByAggregateInput
    _min?: SkillMetadataMinOrderByAggregateInput
  }

  export type SkillMetadataScalarWhereWithAggregatesInput = {
    AND?: SkillMetadataScalarWhereWithAggregatesInput | SkillMetadataScalarWhereWithAggregatesInput[]
    OR?: SkillMetadataScalarWhereWithAggregatesInput[]
    NOT?: SkillMetadataScalarWhereWithAggregatesInput | SkillMetadataScalarWhereWithAggregatesInput[]
    skill?: EnumSkillWithAggregatesFilter<"SkillMetadata"> | $Enums.Skill
    display_name?: StringWithAggregatesFilter<"SkillMetadata"> | string
    ability?: EnumAbilityWithAggregatesFilter<"SkillMetadata"> | $Enums.Ability
  }

  export type CreatureWhereInput = {
    AND?: CreatureWhereInput | CreatureWhereInput[]
    OR?: CreatureWhereInput[]
    NOT?: CreatureWhereInput | CreatureWhereInput[]
    id?: StringFilter<"Creature"> | string
    name?: StringFilter<"Creature"> | string
    creator_id?: StringNullableFilter<"Creature"> | string | null
    description?: StringNullableFilter<"Creature"> | string | null
    size?: StringNullableFilter<"Creature"> | string | null
    race_id?: IntNullableFilter<"Creature"> | number | null
    type_id?: IntNullableFilter<"Creature"> | number | null
    source_id?: IntNullableFilter<"Creature"> | number | null
    alignment_id?: IntNullableFilter<"Creature"> | number | null
    armor_class?: IntNullableFilter<"Creature"> | number | null
    hit_points?: IntNullableFilter<"Creature"> | number | null
    challenge_rating?: StringFilter<"Creature"> | string
    speed?: XOR<CreatureSpeedNullableScalarRelationFilter, CreatureSpeedWhereInput> | null
    stats?: XOR<CreatureStatsNullableScalarRelationFilter, CreatureStatsWhereInput> | null
    skills?: XOR<CreatureSkillsNullableScalarRelationFilter, CreatureSkillsWhereInput> | null
    senses?: XOR<CreatureSensesNullableScalarRelationFilter, CreatureSensesWhereInput> | null
    challenge_rating_meta?: XOR<ChallengeRatingMetadataScalarRelationFilter, ChallengeRatingMetadataWhereInput>
    alignment_relation?: XOR<AlignmentNullableScalarRelationFilter, AlignmentWhereInput> | null
    race_relation?: XOR<CreatureRaceNullableScalarRelationFilter, CreatureRaceWhereInput> | null
    type_relation?: XOR<TypeNullableScalarRelationFilter, TypeWhereInput> | null
    size_relation?: XOR<SizeNullableScalarRelationFilter, SizeWhereInput> | null
    source_relation?: XOR<SourceNullableScalarRelationFilter, SourceWhereInput> | null
    resistances?: DamageTypeListRelationFilter
    immunities?: DamageTypeListRelationFilter
    vulnerabilities?: DamageTypeListRelationFilter
    languages_relation?: LanguageListRelationFilter
    biomes_relation?: BiomeListRelationFilter
    actions_relation?: ActionListRelationFilter
    traits_relation?: TraitListRelationFilter
  }

  export type CreatureOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    creator_id?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    size?: SortOrderInput | SortOrder
    race_id?: SortOrderInput | SortOrder
    type_id?: SortOrderInput | SortOrder
    source_id?: SortOrderInput | SortOrder
    alignment_id?: SortOrderInput | SortOrder
    armor_class?: SortOrderInput | SortOrder
    hit_points?: SortOrderInput | SortOrder
    challenge_rating?: SortOrder
    speed?: CreatureSpeedOrderByWithRelationInput
    stats?: CreatureStatsOrderByWithRelationInput
    skills?: CreatureSkillsOrderByWithRelationInput
    senses?: CreatureSensesOrderByWithRelationInput
    challenge_rating_meta?: ChallengeRatingMetadataOrderByWithRelationInput
    alignment_relation?: AlignmentOrderByWithRelationInput
    race_relation?: CreatureRaceOrderByWithRelationInput
    type_relation?: TypeOrderByWithRelationInput
    size_relation?: SizeOrderByWithRelationInput
    source_relation?: SourceOrderByWithRelationInput
    resistances?: DamageTypeOrderByRelationAggregateInput
    immunities?: DamageTypeOrderByRelationAggregateInput
    vulnerabilities?: DamageTypeOrderByRelationAggregateInput
    languages_relation?: LanguageOrderByRelationAggregateInput
    biomes_relation?: BiomeOrderByRelationAggregateInput
    actions_relation?: ActionOrderByRelationAggregateInput
    traits_relation?: TraitOrderByRelationAggregateInput
  }

  export type CreatureWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CreatureWhereInput | CreatureWhereInput[]
    OR?: CreatureWhereInput[]
    NOT?: CreatureWhereInput | CreatureWhereInput[]
    name?: StringFilter<"Creature"> | string
    creator_id?: StringNullableFilter<"Creature"> | string | null
    description?: StringNullableFilter<"Creature"> | string | null
    size?: StringNullableFilter<"Creature"> | string | null
    race_id?: IntNullableFilter<"Creature"> | number | null
    type_id?: IntNullableFilter<"Creature"> | number | null
    source_id?: IntNullableFilter<"Creature"> | number | null
    alignment_id?: IntNullableFilter<"Creature"> | number | null
    armor_class?: IntNullableFilter<"Creature"> | number | null
    hit_points?: IntNullableFilter<"Creature"> | number | null
    challenge_rating?: StringFilter<"Creature"> | string
    speed?: XOR<CreatureSpeedNullableScalarRelationFilter, CreatureSpeedWhereInput> | null
    stats?: XOR<CreatureStatsNullableScalarRelationFilter, CreatureStatsWhereInput> | null
    skills?: XOR<CreatureSkillsNullableScalarRelationFilter, CreatureSkillsWhereInput> | null
    senses?: XOR<CreatureSensesNullableScalarRelationFilter, CreatureSensesWhereInput> | null
    challenge_rating_meta?: XOR<ChallengeRatingMetadataScalarRelationFilter, ChallengeRatingMetadataWhereInput>
    alignment_relation?: XOR<AlignmentNullableScalarRelationFilter, AlignmentWhereInput> | null
    race_relation?: XOR<CreatureRaceNullableScalarRelationFilter, CreatureRaceWhereInput> | null
    type_relation?: XOR<TypeNullableScalarRelationFilter, TypeWhereInput> | null
    size_relation?: XOR<SizeNullableScalarRelationFilter, SizeWhereInput> | null
    source_relation?: XOR<SourceNullableScalarRelationFilter, SourceWhereInput> | null
    resistances?: DamageTypeListRelationFilter
    immunities?: DamageTypeListRelationFilter
    vulnerabilities?: DamageTypeListRelationFilter
    languages_relation?: LanguageListRelationFilter
    biomes_relation?: BiomeListRelationFilter
    actions_relation?: ActionListRelationFilter
    traits_relation?: TraitListRelationFilter
  }, "id">

  export type CreatureOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    creator_id?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    size?: SortOrderInput | SortOrder
    race_id?: SortOrderInput | SortOrder
    type_id?: SortOrderInput | SortOrder
    source_id?: SortOrderInput | SortOrder
    alignment_id?: SortOrderInput | SortOrder
    armor_class?: SortOrderInput | SortOrder
    hit_points?: SortOrderInput | SortOrder
    challenge_rating?: SortOrder
    _count?: CreatureCountOrderByAggregateInput
    _avg?: CreatureAvgOrderByAggregateInput
    _max?: CreatureMaxOrderByAggregateInput
    _min?: CreatureMinOrderByAggregateInput
    _sum?: CreatureSumOrderByAggregateInput
  }

  export type CreatureScalarWhereWithAggregatesInput = {
    AND?: CreatureScalarWhereWithAggregatesInput | CreatureScalarWhereWithAggregatesInput[]
    OR?: CreatureScalarWhereWithAggregatesInput[]
    NOT?: CreatureScalarWhereWithAggregatesInput | CreatureScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Creature"> | string
    name?: StringWithAggregatesFilter<"Creature"> | string
    creator_id?: StringNullableWithAggregatesFilter<"Creature"> | string | null
    description?: StringNullableWithAggregatesFilter<"Creature"> | string | null
    size?: StringNullableWithAggregatesFilter<"Creature"> | string | null
    race_id?: IntNullableWithAggregatesFilter<"Creature"> | number | null
    type_id?: IntNullableWithAggregatesFilter<"Creature"> | number | null
    source_id?: IntNullableWithAggregatesFilter<"Creature"> | number | null
    alignment_id?: IntNullableWithAggregatesFilter<"Creature"> | number | null
    armor_class?: IntNullableWithAggregatesFilter<"Creature"> | number | null
    hit_points?: IntNullableWithAggregatesFilter<"Creature"> | number | null
    challenge_rating?: StringWithAggregatesFilter<"Creature"> | string
  }

  export type CreatureSensesWhereInput = {
    AND?: CreatureSensesWhereInput | CreatureSensesWhereInput[]
    OR?: CreatureSensesWhereInput[]
    NOT?: CreatureSensesWhereInput | CreatureSensesWhereInput[]
    id?: StringFilter<"CreatureSenses"> | string
    creature_id?: StringFilter<"CreatureSenses"> | string
    passive_perception?: IntNullableFilter<"CreatureSenses"> | number | null
    creature_relation?: XOR<CreatureScalarRelationFilter, CreatureWhereInput>
  }

  export type CreatureSensesOrderByWithRelationInput = {
    id?: SortOrder
    creature_id?: SortOrder
    passive_perception?: SortOrderInput | SortOrder
    creature_relation?: CreatureOrderByWithRelationInput
  }

  export type CreatureSensesWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    creature_id?: string
    AND?: CreatureSensesWhereInput | CreatureSensesWhereInput[]
    OR?: CreatureSensesWhereInput[]
    NOT?: CreatureSensesWhereInput | CreatureSensesWhereInput[]
    passive_perception?: IntNullableFilter<"CreatureSenses"> | number | null
    creature_relation?: XOR<CreatureScalarRelationFilter, CreatureWhereInput>
  }, "id" | "creature_id">

  export type CreatureSensesOrderByWithAggregationInput = {
    id?: SortOrder
    creature_id?: SortOrder
    passive_perception?: SortOrderInput | SortOrder
    _count?: CreatureSensesCountOrderByAggregateInput
    _avg?: CreatureSensesAvgOrderByAggregateInput
    _max?: CreatureSensesMaxOrderByAggregateInput
    _min?: CreatureSensesMinOrderByAggregateInput
    _sum?: CreatureSensesSumOrderByAggregateInput
  }

  export type CreatureSensesScalarWhereWithAggregatesInput = {
    AND?: CreatureSensesScalarWhereWithAggregatesInput | CreatureSensesScalarWhereWithAggregatesInput[]
    OR?: CreatureSensesScalarWhereWithAggregatesInput[]
    NOT?: CreatureSensesScalarWhereWithAggregatesInput | CreatureSensesScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CreatureSenses"> | string
    creature_id?: StringWithAggregatesFilter<"CreatureSenses"> | string
    passive_perception?: IntNullableWithAggregatesFilter<"CreatureSenses"> | number | null
  }

  export type ActionWhereInput = {
    AND?: ActionWhereInput | ActionWhereInput[]
    OR?: ActionWhereInput[]
    NOT?: ActionWhereInput | ActionWhereInput[]
    id?: IntFilter<"Action"> | number
    name?: StringFilter<"Action"> | string
    description?: StringFilter<"Action"> | string
    attack?: StringNullableFilter<"Action"> | string | null
    is_template?: BoolNullableFilter<"Action"> | boolean | null
    creatures_relation?: CreatureListRelationFilter
    creature_races_relation?: CreatureRaceListRelationFilter
  }

  export type ActionOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    attack?: SortOrderInput | SortOrder
    is_template?: SortOrderInput | SortOrder
    creatures_relation?: CreatureOrderByRelationAggregateInput
    creature_races_relation?: CreatureRaceOrderByRelationAggregateInput
  }

  export type ActionWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    description?: string
    AND?: ActionWhereInput | ActionWhereInput[]
    OR?: ActionWhereInput[]
    NOT?: ActionWhereInput | ActionWhereInput[]
    name?: StringFilter<"Action"> | string
    attack?: StringNullableFilter<"Action"> | string | null
    is_template?: BoolNullableFilter<"Action"> | boolean | null
    creatures_relation?: CreatureListRelationFilter
    creature_races_relation?: CreatureRaceListRelationFilter
  }, "id" | "description">

  export type ActionOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    attack?: SortOrderInput | SortOrder
    is_template?: SortOrderInput | SortOrder
    _count?: ActionCountOrderByAggregateInput
    _avg?: ActionAvgOrderByAggregateInput
    _max?: ActionMaxOrderByAggregateInput
    _min?: ActionMinOrderByAggregateInput
    _sum?: ActionSumOrderByAggregateInput
  }

  export type ActionScalarWhereWithAggregatesInput = {
    AND?: ActionScalarWhereWithAggregatesInput | ActionScalarWhereWithAggregatesInput[]
    OR?: ActionScalarWhereWithAggregatesInput[]
    NOT?: ActionScalarWhereWithAggregatesInput | ActionScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Action"> | number
    name?: StringWithAggregatesFilter<"Action"> | string
    description?: StringWithAggregatesFilter<"Action"> | string
    attack?: StringNullableWithAggregatesFilter<"Action"> | string | null
    is_template?: BoolNullableWithAggregatesFilter<"Action"> | boolean | null
  }

  export type TraitWhereInput = {
    AND?: TraitWhereInput | TraitWhereInput[]
    OR?: TraitWhereInput[]
    NOT?: TraitWhereInput | TraitWhereInput[]
    id?: IntFilter<"Trait"> | number
    name?: StringFilter<"Trait"> | string
    description?: StringFilter<"Trait"> | string
    attack?: StringNullableFilter<"Trait"> | string | null
    is_template?: BoolNullableFilter<"Trait"> | boolean | null
    creatures_relation?: CreatureListRelationFilter
    creature_races_relation?: CreatureRaceListRelationFilter
  }

  export type TraitOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    attack?: SortOrderInput | SortOrder
    is_template?: SortOrderInput | SortOrder
    creatures_relation?: CreatureOrderByRelationAggregateInput
    creature_races_relation?: CreatureRaceOrderByRelationAggregateInput
  }

  export type TraitWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    description?: string
    AND?: TraitWhereInput | TraitWhereInput[]
    OR?: TraitWhereInput[]
    NOT?: TraitWhereInput | TraitWhereInput[]
    name?: StringFilter<"Trait"> | string
    attack?: StringNullableFilter<"Trait"> | string | null
    is_template?: BoolNullableFilter<"Trait"> | boolean | null
    creatures_relation?: CreatureListRelationFilter
    creature_races_relation?: CreatureRaceListRelationFilter
  }, "id" | "description">

  export type TraitOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    attack?: SortOrderInput | SortOrder
    is_template?: SortOrderInput | SortOrder
    _count?: TraitCountOrderByAggregateInput
    _avg?: TraitAvgOrderByAggregateInput
    _max?: TraitMaxOrderByAggregateInput
    _min?: TraitMinOrderByAggregateInput
    _sum?: TraitSumOrderByAggregateInput
  }

  export type TraitScalarWhereWithAggregatesInput = {
    AND?: TraitScalarWhereWithAggregatesInput | TraitScalarWhereWithAggregatesInput[]
    OR?: TraitScalarWhereWithAggregatesInput[]
    NOT?: TraitScalarWhereWithAggregatesInput | TraitScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Trait"> | number
    name?: StringWithAggregatesFilter<"Trait"> | string
    description?: StringWithAggregatesFilter<"Trait"> | string
    attack?: StringNullableWithAggregatesFilter<"Trait"> | string | null
    is_template?: BoolNullableWithAggregatesFilter<"Trait"> | boolean | null
  }

  export type CreatureRaceWhereInput = {
    AND?: CreatureRaceWhereInput | CreatureRaceWhereInput[]
    OR?: CreatureRaceWhereInput[]
    NOT?: CreatureRaceWhereInput | CreatureRaceWhereInput[]
    id?: IntFilter<"CreatureRace"> | number
    name?: StringFilter<"CreatureRace"> | string
    description?: StringFilter<"CreatureRace"> | string
    traits_relation?: TraitListRelationFilter
    actions_relation?: ActionListRelationFilter
    creatures_relation?: CreatureListRelationFilter
  }

  export type CreatureRaceOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    traits_relation?: TraitOrderByRelationAggregateInput
    actions_relation?: ActionOrderByRelationAggregateInput
    creatures_relation?: CreatureOrderByRelationAggregateInput
  }

  export type CreatureRaceWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: CreatureRaceWhereInput | CreatureRaceWhereInput[]
    OR?: CreatureRaceWhereInput[]
    NOT?: CreatureRaceWhereInput | CreatureRaceWhereInput[]
    name?: StringFilter<"CreatureRace"> | string
    description?: StringFilter<"CreatureRace"> | string
    traits_relation?: TraitListRelationFilter
    actions_relation?: ActionListRelationFilter
    creatures_relation?: CreatureListRelationFilter
  }, "id">

  export type CreatureRaceOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    _count?: CreatureRaceCountOrderByAggregateInput
    _avg?: CreatureRaceAvgOrderByAggregateInput
    _max?: CreatureRaceMaxOrderByAggregateInput
    _min?: CreatureRaceMinOrderByAggregateInput
    _sum?: CreatureRaceSumOrderByAggregateInput
  }

  export type CreatureRaceScalarWhereWithAggregatesInput = {
    AND?: CreatureRaceScalarWhereWithAggregatesInput | CreatureRaceScalarWhereWithAggregatesInput[]
    OR?: CreatureRaceScalarWhereWithAggregatesInput[]
    NOT?: CreatureRaceScalarWhereWithAggregatesInput | CreatureRaceScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"CreatureRace"> | number
    name?: StringWithAggregatesFilter<"CreatureRace"> | string
    description?: StringWithAggregatesFilter<"CreatureRace"> | string
  }

  export type DamageTypeWhereInput = {
    AND?: DamageTypeWhereInput | DamageTypeWhereInput[]
    OR?: DamageTypeWhereInput[]
    NOT?: DamageTypeWhereInput | DamageTypeWhereInput[]
    id?: StringFilter<"DamageType"> | string
    name?: StringFilter<"DamageType"> | string
    resistant_creatures_relation?: CreatureListRelationFilter
    immune_creatures_relation?: CreatureListRelationFilter
    vulnerable_creatures_relation?: CreatureListRelationFilter
  }

  export type DamageTypeOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    resistant_creatures_relation?: CreatureOrderByRelationAggregateInput
    immune_creatures_relation?: CreatureOrderByRelationAggregateInput
    vulnerable_creatures_relation?: CreatureOrderByRelationAggregateInput
  }

  export type DamageTypeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    AND?: DamageTypeWhereInput | DamageTypeWhereInput[]
    OR?: DamageTypeWhereInput[]
    NOT?: DamageTypeWhereInput | DamageTypeWhereInput[]
    resistant_creatures_relation?: CreatureListRelationFilter
    immune_creatures_relation?: CreatureListRelationFilter
    vulnerable_creatures_relation?: CreatureListRelationFilter
  }, "id" | "name">

  export type DamageTypeOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    _count?: DamageTypeCountOrderByAggregateInput
    _max?: DamageTypeMaxOrderByAggregateInput
    _min?: DamageTypeMinOrderByAggregateInput
  }

  export type DamageTypeScalarWhereWithAggregatesInput = {
    AND?: DamageTypeScalarWhereWithAggregatesInput | DamageTypeScalarWhereWithAggregatesInput[]
    OR?: DamageTypeScalarWhereWithAggregatesInput[]
    NOT?: DamageTypeScalarWhereWithAggregatesInput | DamageTypeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"DamageType"> | string
    name?: StringWithAggregatesFilter<"DamageType"> | string
  }

  export type ChallengeRatingMetadataWhereInput = {
    AND?: ChallengeRatingMetadataWhereInput | ChallengeRatingMetadataWhereInput[]
    OR?: ChallengeRatingMetadataWhereInput[]
    NOT?: ChallengeRatingMetadataWhereInput | ChallengeRatingMetadataWhereInput[]
    cr?: EnumChallengeRatingEnumFilter<"ChallengeRatingMetadata"> | $Enums.ChallengeRatingEnum
    display?: StringFilter<"ChallengeRatingMetadata"> | string
    numeric?: FloatFilter<"ChallengeRatingMetadata"> | number
    xp_reward?: IntFilter<"ChallengeRatingMetadata"> | number
    creatures?: CreatureListRelationFilter
  }

  export type ChallengeRatingMetadataOrderByWithRelationInput = {
    cr?: SortOrder
    display?: SortOrder
    numeric?: SortOrder
    xp_reward?: SortOrder
    creatures?: CreatureOrderByRelationAggregateInput
  }

  export type ChallengeRatingMetadataWhereUniqueInput = Prisma.AtLeast<{
    cr?: $Enums.ChallengeRatingEnum
    display?: string
    AND?: ChallengeRatingMetadataWhereInput | ChallengeRatingMetadataWhereInput[]
    OR?: ChallengeRatingMetadataWhereInput[]
    NOT?: ChallengeRatingMetadataWhereInput | ChallengeRatingMetadataWhereInput[]
    numeric?: FloatFilter<"ChallengeRatingMetadata"> | number
    xp_reward?: IntFilter<"ChallengeRatingMetadata"> | number
    creatures?: CreatureListRelationFilter
  }, "cr" | "display">

  export type ChallengeRatingMetadataOrderByWithAggregationInput = {
    cr?: SortOrder
    display?: SortOrder
    numeric?: SortOrder
    xp_reward?: SortOrder
    _count?: ChallengeRatingMetadataCountOrderByAggregateInput
    _avg?: ChallengeRatingMetadataAvgOrderByAggregateInput
    _max?: ChallengeRatingMetadataMaxOrderByAggregateInput
    _min?: ChallengeRatingMetadataMinOrderByAggregateInput
    _sum?: ChallengeRatingMetadataSumOrderByAggregateInput
  }

  export type ChallengeRatingMetadataScalarWhereWithAggregatesInput = {
    AND?: ChallengeRatingMetadataScalarWhereWithAggregatesInput | ChallengeRatingMetadataScalarWhereWithAggregatesInput[]
    OR?: ChallengeRatingMetadataScalarWhereWithAggregatesInput[]
    NOT?: ChallengeRatingMetadataScalarWhereWithAggregatesInput | ChallengeRatingMetadataScalarWhereWithAggregatesInput[]
    cr?: EnumChallengeRatingEnumWithAggregatesFilter<"ChallengeRatingMetadata"> | $Enums.ChallengeRatingEnum
    display?: StringWithAggregatesFilter<"ChallengeRatingMetadata"> | string
    numeric?: FloatWithAggregatesFilter<"ChallengeRatingMetadata"> | number
    xp_reward?: IntWithAggregatesFilter<"ChallengeRatingMetadata"> | number
  }

  export type GenrationRequestWhereInput = {
    AND?: GenrationRequestWhereInput | GenrationRequestWhereInput[]
    OR?: GenrationRequestWhereInput[]
    NOT?: GenrationRequestWhereInput | GenrationRequestWhereInput[]
    id?: IntFilter<"GenrationRequest"> | number
    request?: StringFilter<"GenrationRequest"> | string
    danger?: StringFilter<"GenrationRequest"> | string
    name?: StringFilter<"GenrationRequest"> | string
  }

  export type GenrationRequestOrderByWithRelationInput = {
    id?: SortOrder
    request?: SortOrder
    danger?: SortOrder
    name?: SortOrder
  }

  export type GenrationRequestWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: GenrationRequestWhereInput | GenrationRequestWhereInput[]
    OR?: GenrationRequestWhereInput[]
    NOT?: GenrationRequestWhereInput | GenrationRequestWhereInput[]
    request?: StringFilter<"GenrationRequest"> | string
    danger?: StringFilter<"GenrationRequest"> | string
    name?: StringFilter<"GenrationRequest"> | string
  }, "id">

  export type GenrationRequestOrderByWithAggregationInput = {
    id?: SortOrder
    request?: SortOrder
    danger?: SortOrder
    name?: SortOrder
    _count?: GenrationRequestCountOrderByAggregateInput
    _avg?: GenrationRequestAvgOrderByAggregateInput
    _max?: GenrationRequestMaxOrderByAggregateInput
    _min?: GenrationRequestMinOrderByAggregateInput
    _sum?: GenrationRequestSumOrderByAggregateInput
  }

  export type GenrationRequestScalarWhereWithAggregatesInput = {
    AND?: GenrationRequestScalarWhereWithAggregatesInput | GenrationRequestScalarWhereWithAggregatesInput[]
    OR?: GenrationRequestScalarWhereWithAggregatesInput[]
    NOT?: GenrationRequestScalarWhereWithAggregatesInput | GenrationRequestScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"GenrationRequest"> | number
    request?: StringWithAggregatesFilter<"GenrationRequest"> | string
    danger?: StringWithAggregatesFilter<"GenrationRequest"> | string
    name?: StringWithAggregatesFilter<"GenrationRequest"> | string
  }

  export type GPTMessageHistoryWhereInput = {
    AND?: GPTMessageHistoryWhereInput | GPTMessageHistoryWhereInput[]
    OR?: GPTMessageHistoryWhereInput[]
    NOT?: GPTMessageHistoryWhereInput | GPTMessageHistoryWhereInput[]
    id?: StringFilter<"GPTMessageHistory"> | string
    type?: StringFilter<"GPTMessageHistory"> | string
    messages_relation?: GPTMessageListRelationFilter
  }

  export type GPTMessageHistoryOrderByWithRelationInput = {
    id?: SortOrder
    type?: SortOrder
    messages_relation?: GPTMessageOrderByRelationAggregateInput
  }

  export type GPTMessageHistoryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: GPTMessageHistoryWhereInput | GPTMessageHistoryWhereInput[]
    OR?: GPTMessageHistoryWhereInput[]
    NOT?: GPTMessageHistoryWhereInput | GPTMessageHistoryWhereInput[]
    type?: StringFilter<"GPTMessageHistory"> | string
    messages_relation?: GPTMessageListRelationFilter
  }, "id">

  export type GPTMessageHistoryOrderByWithAggregationInput = {
    id?: SortOrder
    type?: SortOrder
    _count?: GPTMessageHistoryCountOrderByAggregateInput
    _max?: GPTMessageHistoryMaxOrderByAggregateInput
    _min?: GPTMessageHistoryMinOrderByAggregateInput
  }

  export type GPTMessageHistoryScalarWhereWithAggregatesInput = {
    AND?: GPTMessageHistoryScalarWhereWithAggregatesInput | GPTMessageHistoryScalarWhereWithAggregatesInput[]
    OR?: GPTMessageHistoryScalarWhereWithAggregatesInput[]
    NOT?: GPTMessageHistoryScalarWhereWithAggregatesInput | GPTMessageHistoryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"GPTMessageHistory"> | string
    type?: StringWithAggregatesFilter<"GPTMessageHistory"> | string
  }

  export type GPTMessageWhereInput = {
    AND?: GPTMessageWhereInput | GPTMessageWhereInput[]
    OR?: GPTMessageWhereInput[]
    NOT?: GPTMessageWhereInput | GPTMessageWhereInput[]
    message_history_id?: StringFilter<"GPTMessage"> | string
    number?: IntFilter<"GPTMessage"> | number
    text?: StringFilter<"GPTMessage"> | string
    role?: StringFilter<"GPTMessage"> | string
    message_history_relation?: XOR<GPTMessageHistoryScalarRelationFilter, GPTMessageHistoryWhereInput>
  }

  export type GPTMessageOrderByWithRelationInput = {
    message_history_id?: SortOrder
    number?: SortOrder
    text?: SortOrder
    role?: SortOrder
    message_history_relation?: GPTMessageHistoryOrderByWithRelationInput
  }

  export type GPTMessageWhereUniqueInput = Prisma.AtLeast<{
    message_history_id_number?: GPTMessageMessage_history_idNumberCompoundUniqueInput
    AND?: GPTMessageWhereInput | GPTMessageWhereInput[]
    OR?: GPTMessageWhereInput[]
    NOT?: GPTMessageWhereInput | GPTMessageWhereInput[]
    message_history_id?: StringFilter<"GPTMessage"> | string
    number?: IntFilter<"GPTMessage"> | number
    text?: StringFilter<"GPTMessage"> | string
    role?: StringFilter<"GPTMessage"> | string
    message_history_relation?: XOR<GPTMessageHistoryScalarRelationFilter, GPTMessageHistoryWhereInput>
  }, "message_history_id_number">

  export type GPTMessageOrderByWithAggregationInput = {
    message_history_id?: SortOrder
    number?: SortOrder
    text?: SortOrder
    role?: SortOrder
    _count?: GPTMessageCountOrderByAggregateInput
    _avg?: GPTMessageAvgOrderByAggregateInput
    _max?: GPTMessageMaxOrderByAggregateInput
    _min?: GPTMessageMinOrderByAggregateInput
    _sum?: GPTMessageSumOrderByAggregateInput
  }

  export type GPTMessageScalarWhereWithAggregatesInput = {
    AND?: GPTMessageScalarWhereWithAggregatesInput | GPTMessageScalarWhereWithAggregatesInput[]
    OR?: GPTMessageScalarWhereWithAggregatesInput[]
    NOT?: GPTMessageScalarWhereWithAggregatesInput | GPTMessageScalarWhereWithAggregatesInput[]
    message_history_id?: StringWithAggregatesFilter<"GPTMessage"> | string
    number?: IntWithAggregatesFilter<"GPTMessage"> | number
    text?: StringWithAggregatesFilter<"GPTMessage"> | string
    role?: StringWithAggregatesFilter<"GPTMessage"> | string
  }

  export type AdventureWhereInput = {
    AND?: AdventureWhereInput | AdventureWhereInput[]
    OR?: AdventureWhereInput[]
    NOT?: AdventureWhereInput | AdventureWhereInput[]
    id?: StringFilter<"Adventure"> | string
    name?: StringFilter<"Adventure"> | string
    genre_id?: StringFilter<"Adventure"> | string
    creator_id?: StringFilter<"Adventure"> | string
    created_at?: DateTimeFilter<"Adventure"> | Date | string
    updated_at?: DateTimeFilter<"Adventure"> | Date | string
    genre_relation?: XOR<GenreScalarRelationFilter, GenreWhereInput>
    keywords_relation?: KeywordListRelationFilter
  }

  export type AdventureOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    genre_id?: SortOrder
    creator_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    genre_relation?: GenreOrderByWithRelationInput
    keywords_relation?: KeywordOrderByRelationAggregateInput
  }

  export type AdventureWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AdventureWhereInput | AdventureWhereInput[]
    OR?: AdventureWhereInput[]
    NOT?: AdventureWhereInput | AdventureWhereInput[]
    name?: StringFilter<"Adventure"> | string
    genre_id?: StringFilter<"Adventure"> | string
    creator_id?: StringFilter<"Adventure"> | string
    created_at?: DateTimeFilter<"Adventure"> | Date | string
    updated_at?: DateTimeFilter<"Adventure"> | Date | string
    genre_relation?: XOR<GenreScalarRelationFilter, GenreWhereInput>
    keywords_relation?: KeywordListRelationFilter
  }, "id">

  export type AdventureOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    genre_id?: SortOrder
    creator_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: AdventureCountOrderByAggregateInput
    _max?: AdventureMaxOrderByAggregateInput
    _min?: AdventureMinOrderByAggregateInput
  }

  export type AdventureScalarWhereWithAggregatesInput = {
    AND?: AdventureScalarWhereWithAggregatesInput | AdventureScalarWhereWithAggregatesInput[]
    OR?: AdventureScalarWhereWithAggregatesInput[]
    NOT?: AdventureScalarWhereWithAggregatesInput | AdventureScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Adventure"> | string
    name?: StringWithAggregatesFilter<"Adventure"> | string
    genre_id?: StringWithAggregatesFilter<"Adventure"> | string
    creator_id?: StringWithAggregatesFilter<"Adventure"> | string
    created_at?: DateTimeWithAggregatesFilter<"Adventure"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"Adventure"> | Date | string
  }

  export type KeywordWhereInput = {
    AND?: KeywordWhereInput | KeywordWhereInput[]
    OR?: KeywordWhereInput[]
    NOT?: KeywordWhereInput | KeywordWhereInput[]
    id?: StringFilter<"Keyword"> | string
    name?: StringFilter<"Keyword"> | string
    genre_id?: StringFilter<"Keyword"> | string
    genre_relation?: XOR<GenreScalarRelationFilter, GenreWhereInput>
    adventures_relation?: AdventureListRelationFilter
  }

  export type KeywordOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    genre_id?: SortOrder
    genre_relation?: GenreOrderByWithRelationInput
    adventures_relation?: AdventureOrderByRelationAggregateInput
  }

  export type KeywordWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: KeywordWhereInput | KeywordWhereInput[]
    OR?: KeywordWhereInput[]
    NOT?: KeywordWhereInput | KeywordWhereInput[]
    name?: StringFilter<"Keyword"> | string
    genre_id?: StringFilter<"Keyword"> | string
    genre_relation?: XOR<GenreScalarRelationFilter, GenreWhereInput>
    adventures_relation?: AdventureListRelationFilter
  }, "id">

  export type KeywordOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    genre_id?: SortOrder
    _count?: KeywordCountOrderByAggregateInput
    _max?: KeywordMaxOrderByAggregateInput
    _min?: KeywordMinOrderByAggregateInput
  }

  export type KeywordScalarWhereWithAggregatesInput = {
    AND?: KeywordScalarWhereWithAggregatesInput | KeywordScalarWhereWithAggregatesInput[]
    OR?: KeywordScalarWhereWithAggregatesInput[]
    NOT?: KeywordScalarWhereWithAggregatesInput | KeywordScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Keyword"> | string
    name?: StringWithAggregatesFilter<"Keyword"> | string
    genre_id?: StringWithAggregatesFilter<"Keyword"> | string
  }

  export type GenreWhereInput = {
    AND?: GenreWhereInput | GenreWhereInput[]
    OR?: GenreWhereInput[]
    NOT?: GenreWhereInput | GenreWhereInput[]
    id?: StringFilter<"Genre"> | string
    name?: StringFilter<"Genre"> | string
    keywords_relation?: KeywordListRelationFilter
    adventures_relation?: AdventureListRelationFilter
  }

  export type GenreOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    keywords_relation?: KeywordOrderByRelationAggregateInput
    adventures_relation?: AdventureOrderByRelationAggregateInput
  }

  export type GenreWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: GenreWhereInput | GenreWhereInput[]
    OR?: GenreWhereInput[]
    NOT?: GenreWhereInput | GenreWhereInput[]
    name?: StringFilter<"Genre"> | string
    keywords_relation?: KeywordListRelationFilter
    adventures_relation?: AdventureListRelationFilter
  }, "id">

  export type GenreOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    _count?: GenreCountOrderByAggregateInput
    _max?: GenreMaxOrderByAggregateInput
    _min?: GenreMinOrderByAggregateInput
  }

  export type GenreScalarWhereWithAggregatesInput = {
    AND?: GenreScalarWhereWithAggregatesInput | GenreScalarWhereWithAggregatesInput[]
    OR?: GenreScalarWhereWithAggregatesInput[]
    NOT?: GenreScalarWhereWithAggregatesInput | GenreScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Genre"> | string
    name?: StringWithAggregatesFilter<"Genre"> | string
  }

  export type MagicItemWhereInput = {
    AND?: MagicItemWhereInput | MagicItemWhereInput[]
    OR?: MagicItemWhereInput[]
    NOT?: MagicItemWhereInput | MagicItemWhereInput[]
    id?: StringFilter<"MagicItem"> | string
    name?: StringFilter<"MagicItem"> | string
    description?: StringFilter<"MagicItem"> | string
    type_id?: StringFilter<"MagicItem"> | string
    rarity_id?: StringFilter<"MagicItem"> | string
    source_id?: IntFilter<"MagicItem"> | number
    requires_attunement?: BoolFilter<"MagicItem"> | boolean
    type_relation?: XOR<MagicItemTypeScalarRelationFilter, MagicItemTypeWhereInput>
    rarity_relation?: XOR<MagicItemRarityScalarRelationFilter, MagicItemRarityWhereInput>
    source_relation?: XOR<SourceScalarRelationFilter, SourceWhereInput>
    attunements_relation?: MagicItemAttunementListRelationFilter
  }

  export type MagicItemOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    type_id?: SortOrder
    rarity_id?: SortOrder
    source_id?: SortOrder
    requires_attunement?: SortOrder
    type_relation?: MagicItemTypeOrderByWithRelationInput
    rarity_relation?: MagicItemRarityOrderByWithRelationInput
    source_relation?: SourceOrderByWithRelationInput
    attunements_relation?: MagicItemAttunementOrderByRelationAggregateInput
  }

  export type MagicItemWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: MagicItemWhereInput | MagicItemWhereInput[]
    OR?: MagicItemWhereInput[]
    NOT?: MagicItemWhereInput | MagicItemWhereInput[]
    name?: StringFilter<"MagicItem"> | string
    description?: StringFilter<"MagicItem"> | string
    type_id?: StringFilter<"MagicItem"> | string
    rarity_id?: StringFilter<"MagicItem"> | string
    source_id?: IntFilter<"MagicItem"> | number
    requires_attunement?: BoolFilter<"MagicItem"> | boolean
    type_relation?: XOR<MagicItemTypeScalarRelationFilter, MagicItemTypeWhereInput>
    rarity_relation?: XOR<MagicItemRarityScalarRelationFilter, MagicItemRarityWhereInput>
    source_relation?: XOR<SourceScalarRelationFilter, SourceWhereInput>
    attunements_relation?: MagicItemAttunementListRelationFilter
  }, "id">

  export type MagicItemOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    type_id?: SortOrder
    rarity_id?: SortOrder
    source_id?: SortOrder
    requires_attunement?: SortOrder
    _count?: MagicItemCountOrderByAggregateInput
    _avg?: MagicItemAvgOrderByAggregateInput
    _max?: MagicItemMaxOrderByAggregateInput
    _min?: MagicItemMinOrderByAggregateInput
    _sum?: MagicItemSumOrderByAggregateInput
  }

  export type MagicItemScalarWhereWithAggregatesInput = {
    AND?: MagicItemScalarWhereWithAggregatesInput | MagicItemScalarWhereWithAggregatesInput[]
    OR?: MagicItemScalarWhereWithAggregatesInput[]
    NOT?: MagicItemScalarWhereWithAggregatesInput | MagicItemScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"MagicItem"> | string
    name?: StringWithAggregatesFilter<"MagicItem"> | string
    description?: StringWithAggregatesFilter<"MagicItem"> | string
    type_id?: StringWithAggregatesFilter<"MagicItem"> | string
    rarity_id?: StringWithAggregatesFilter<"MagicItem"> | string
    source_id?: IntWithAggregatesFilter<"MagicItem"> | number
    requires_attunement?: BoolWithAggregatesFilter<"MagicItem"> | boolean
  }

  export type MagicItemRarityWhereInput = {
    AND?: MagicItemRarityWhereInput | MagicItemRarityWhereInput[]
    OR?: MagicItemRarityWhereInput[]
    NOT?: MagicItemRarityWhereInput | MagicItemRarityWhereInput[]
    id?: StringFilter<"MagicItemRarity"> | string
    cost?: StringFilter<"MagicItemRarity"> | string
    name?: StringFilter<"MagicItemRarity"> | string
    name_he?: StringFilter<"MagicItemRarity"> | string
    name_she?: StringFilter<"MagicItemRarity"> | string
    name_it?: StringFilter<"MagicItemRarity"> | string
    order?: IntFilter<"MagicItemRarity"> | number
    magicItems?: MagicItemListRelationFilter
  }

  export type MagicItemRarityOrderByWithRelationInput = {
    id?: SortOrder
    cost?: SortOrder
    name?: SortOrder
    name_he?: SortOrder
    name_she?: SortOrder
    name_it?: SortOrder
    order?: SortOrder
    magicItems?: MagicItemOrderByRelationAggregateInput
  }

  export type MagicItemRarityWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: MagicItemRarityWhereInput | MagicItemRarityWhereInput[]
    OR?: MagicItemRarityWhereInput[]
    NOT?: MagicItemRarityWhereInput | MagicItemRarityWhereInput[]
    cost?: StringFilter<"MagicItemRarity"> | string
    name?: StringFilter<"MagicItemRarity"> | string
    name_he?: StringFilter<"MagicItemRarity"> | string
    name_she?: StringFilter<"MagicItemRarity"> | string
    name_it?: StringFilter<"MagicItemRarity"> | string
    order?: IntFilter<"MagicItemRarity"> | number
    magicItems?: MagicItemListRelationFilter
  }, "id">

  export type MagicItemRarityOrderByWithAggregationInput = {
    id?: SortOrder
    cost?: SortOrder
    name?: SortOrder
    name_he?: SortOrder
    name_she?: SortOrder
    name_it?: SortOrder
    order?: SortOrder
    _count?: MagicItemRarityCountOrderByAggregateInput
    _avg?: MagicItemRarityAvgOrderByAggregateInput
    _max?: MagicItemRarityMaxOrderByAggregateInput
    _min?: MagicItemRarityMinOrderByAggregateInput
    _sum?: MagicItemRaritySumOrderByAggregateInput
  }

  export type MagicItemRarityScalarWhereWithAggregatesInput = {
    AND?: MagicItemRarityScalarWhereWithAggregatesInput | MagicItemRarityScalarWhereWithAggregatesInput[]
    OR?: MagicItemRarityScalarWhereWithAggregatesInput[]
    NOT?: MagicItemRarityScalarWhereWithAggregatesInput | MagicItemRarityScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"MagicItemRarity"> | string
    cost?: StringWithAggregatesFilter<"MagicItemRarity"> | string
    name?: StringWithAggregatesFilter<"MagicItemRarity"> | string
    name_he?: StringWithAggregatesFilter<"MagicItemRarity"> | string
    name_she?: StringWithAggregatesFilter<"MagicItemRarity"> | string
    name_it?: StringWithAggregatesFilter<"MagicItemRarity"> | string
    order?: IntWithAggregatesFilter<"MagicItemRarity"> | number
  }

  export type MagicItemTypeWhereInput = {
    AND?: MagicItemTypeWhereInput | MagicItemTypeWhereInput[]
    OR?: MagicItemTypeWhereInput[]
    NOT?: MagicItemTypeWhereInput | MagicItemTypeWhereInput[]
    id?: StringFilter<"MagicItemType"> | string
    name?: StringFilter<"MagicItemType"> | string
    gender?: EnumGenderFilter<"MagicItemType"> | $Enums.Gender
    magicItems?: MagicItemListRelationFilter
  }

  export type MagicItemTypeOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    gender?: SortOrder
    magicItems?: MagicItemOrderByRelationAggregateInput
  }

  export type MagicItemTypeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: MagicItemTypeWhereInput | MagicItemTypeWhereInput[]
    OR?: MagicItemTypeWhereInput[]
    NOT?: MagicItemTypeWhereInput | MagicItemTypeWhereInput[]
    name?: StringFilter<"MagicItemType"> | string
    gender?: EnumGenderFilter<"MagicItemType"> | $Enums.Gender
    magicItems?: MagicItemListRelationFilter
  }, "id">

  export type MagicItemTypeOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    gender?: SortOrder
    _count?: MagicItemTypeCountOrderByAggregateInput
    _max?: MagicItemTypeMaxOrderByAggregateInput
    _min?: MagicItemTypeMinOrderByAggregateInput
  }

  export type MagicItemTypeScalarWhereWithAggregatesInput = {
    AND?: MagicItemTypeScalarWhereWithAggregatesInput | MagicItemTypeScalarWhereWithAggregatesInput[]
    OR?: MagicItemTypeScalarWhereWithAggregatesInput[]
    NOT?: MagicItemTypeScalarWhereWithAggregatesInput | MagicItemTypeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"MagicItemType"> | string
    name?: StringWithAggregatesFilter<"MagicItemType"> | string
    gender?: EnumGenderWithAggregatesFilter<"MagicItemType"> | $Enums.Gender
  }

  export type AttunementConditionWhereInput = {
    AND?: AttunementConditionWhereInput | AttunementConditionWhereInput[]
    OR?: AttunementConditionWhereInput[]
    NOT?: AttunementConditionWhereInput | AttunementConditionWhereInput[]
    id?: StringFilter<"AttunementCondition"> | string
    name?: StringFilter<"AttunementCondition"> | string
    magicItems?: MagicItemAttunementListRelationFilter
  }

  export type AttunementConditionOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    magicItems?: MagicItemAttunementOrderByRelationAggregateInput
  }

  export type AttunementConditionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    AND?: AttunementConditionWhereInput | AttunementConditionWhereInput[]
    OR?: AttunementConditionWhereInput[]
    NOT?: AttunementConditionWhereInput | AttunementConditionWhereInput[]
    magicItems?: MagicItemAttunementListRelationFilter
  }, "id" | "name">

  export type AttunementConditionOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    _count?: AttunementConditionCountOrderByAggregateInput
    _max?: AttunementConditionMaxOrderByAggregateInput
    _min?: AttunementConditionMinOrderByAggregateInput
  }

  export type AttunementConditionScalarWhereWithAggregatesInput = {
    AND?: AttunementConditionScalarWhereWithAggregatesInput | AttunementConditionScalarWhereWithAggregatesInput[]
    OR?: AttunementConditionScalarWhereWithAggregatesInput[]
    NOT?: AttunementConditionScalarWhereWithAggregatesInput | AttunementConditionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AttunementCondition"> | string
    name?: StringWithAggregatesFilter<"AttunementCondition"> | string
  }

  export type MagicItemAttunementWhereInput = {
    AND?: MagicItemAttunementWhereInput | MagicItemAttunementWhereInput[]
    OR?: MagicItemAttunementWhereInput[]
    NOT?: MagicItemAttunementWhereInput | MagicItemAttunementWhereInput[]
    magicItemId?: StringFilter<"MagicItemAttunement"> | string
    attunementId?: StringFilter<"MagicItemAttunement"> | string
    magicItem?: XOR<MagicItemScalarRelationFilter, MagicItemWhereInput>
    attunement?: XOR<AttunementConditionScalarRelationFilter, AttunementConditionWhereInput>
  }

  export type MagicItemAttunementOrderByWithRelationInput = {
    magicItemId?: SortOrder
    attunementId?: SortOrder
    magicItem?: MagicItemOrderByWithRelationInput
    attunement?: AttunementConditionOrderByWithRelationInput
  }

  export type MagicItemAttunementWhereUniqueInput = Prisma.AtLeast<{
    magicItemId_attunementId?: MagicItemAttunementMagicItemIdAttunementIdCompoundUniqueInput
    AND?: MagicItemAttunementWhereInput | MagicItemAttunementWhereInput[]
    OR?: MagicItemAttunementWhereInput[]
    NOT?: MagicItemAttunementWhereInput | MagicItemAttunementWhereInput[]
    magicItemId?: StringFilter<"MagicItemAttunement"> | string
    attunementId?: StringFilter<"MagicItemAttunement"> | string
    magicItem?: XOR<MagicItemScalarRelationFilter, MagicItemWhereInput>
    attunement?: XOR<AttunementConditionScalarRelationFilter, AttunementConditionWhereInput>
  }, "magicItemId_attunementId">

  export type MagicItemAttunementOrderByWithAggregationInput = {
    magicItemId?: SortOrder
    attunementId?: SortOrder
    _count?: MagicItemAttunementCountOrderByAggregateInput
    _max?: MagicItemAttunementMaxOrderByAggregateInput
    _min?: MagicItemAttunementMinOrderByAggregateInput
  }

  export type MagicItemAttunementScalarWhereWithAggregatesInput = {
    AND?: MagicItemAttunementScalarWhereWithAggregatesInput | MagicItemAttunementScalarWhereWithAggregatesInput[]
    OR?: MagicItemAttunementScalarWhereWithAggregatesInput[]
    NOT?: MagicItemAttunementScalarWhereWithAggregatesInput | MagicItemAttunementScalarWhereWithAggregatesInput[]
    magicItemId?: StringWithAggregatesFilter<"MagicItemAttunement"> | string
    attunementId?: StringWithAggregatesFilter<"MagicItemAttunement"> | string
  }

  export type SizeCreateInput = {
    id: string
    name: string
    creature?: CreatureCreateNestedManyWithoutSize_relationInput
  }

  export type SizeUncheckedCreateInput = {
    id: string
    name: string
    creature?: CreatureUncheckedCreateNestedManyWithoutSize_relationInput
  }

  export type SizeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    creature?: CreatureUpdateManyWithoutSize_relationNestedInput
  }

  export type SizeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    creature?: CreatureUncheckedUpdateManyWithoutSize_relationNestedInput
  }

  export type SizeCreateManyInput = {
    id: string
    name: string
  }

  export type SizeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type SizeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type SourceCreateInput = {
    short_name: string
    name: string
    creatures?: CreatureCreateNestedManyWithoutSource_relationInput
    magicItems?: MagicItemCreateNestedManyWithoutSource_relationInput
  }

  export type SourceUncheckedCreateInput = {
    id?: number
    short_name: string
    name: string
    creatures?: CreatureUncheckedCreateNestedManyWithoutSource_relationInput
    magicItems?: MagicItemUncheckedCreateNestedManyWithoutSource_relationInput
  }

  export type SourceUpdateInput = {
    short_name?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    creatures?: CreatureUpdateManyWithoutSource_relationNestedInput
    magicItems?: MagicItemUpdateManyWithoutSource_relationNestedInput
  }

  export type SourceUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    short_name?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    creatures?: CreatureUncheckedUpdateManyWithoutSource_relationNestedInput
    magicItems?: MagicItemUncheckedUpdateManyWithoutSource_relationNestedInput
  }

  export type SourceCreateManyInput = {
    id?: number
    short_name: string
    name: string
  }

  export type SourceUpdateManyMutationInput = {
    short_name?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type SourceUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    short_name?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type LanguageCreateInput = {
    name: string
    creatures_relation?: CreatureCreateNestedManyWithoutLanguages_relationInput
  }

  export type LanguageUncheckedCreateInput = {
    id?: number
    name: string
    creatures_relation?: CreatureUncheckedCreateNestedManyWithoutLanguages_relationInput
  }

  export type LanguageUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    creatures_relation?: CreatureUpdateManyWithoutLanguages_relationNestedInput
  }

  export type LanguageUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    creatures_relation?: CreatureUncheckedUpdateManyWithoutLanguages_relationNestedInput
  }

  export type LanguageCreateManyInput = {
    id?: number
    name: string
  }

  export type LanguageUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
  }

  export type LanguageUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type BiomeCreateInput = {
    short_name: string
    name: string
    creatures_relation?: CreatureCreateNestedManyWithoutBiomes_relationInput
  }

  export type BiomeUncheckedCreateInput = {
    id?: number
    short_name: string
    name: string
    creatures_relation?: CreatureUncheckedCreateNestedManyWithoutBiomes_relationInput
  }

  export type BiomeUpdateInput = {
    short_name?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    creatures_relation?: CreatureUpdateManyWithoutBiomes_relationNestedInput
  }

  export type BiomeUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    short_name?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    creatures_relation?: CreatureUncheckedUpdateManyWithoutBiomes_relationNestedInput
  }

  export type BiomeCreateManyInput = {
    id?: number
    short_name: string
    name: string
  }

  export type BiomeUpdateManyMutationInput = {
    short_name?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type BiomeUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    short_name?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type TypeCreateInput = {
    name: string
    creatures?: CreatureCreateNestedManyWithoutType_relationInput
  }

  export type TypeUncheckedCreateInput = {
    id?: number
    name: string
    creatures?: CreatureUncheckedCreateNestedManyWithoutType_relationInput
  }

  export type TypeUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    creatures?: CreatureUpdateManyWithoutType_relationNestedInput
  }

  export type TypeUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    creatures?: CreatureUncheckedUpdateManyWithoutType_relationNestedInput
  }

  export type TypeCreateManyInput = {
    id?: number
    name: string
  }

  export type TypeUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
  }

  export type TypeUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type AlignmentCreateInput = {
    name: string
    creatures?: CreatureCreateNestedManyWithoutAlignment_relationInput
  }

  export type AlignmentUncheckedCreateInput = {
    id?: number
    name: string
    creatures?: CreatureUncheckedCreateNestedManyWithoutAlignment_relationInput
  }

  export type AlignmentUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    creatures?: CreatureUpdateManyWithoutAlignment_relationNestedInput
  }

  export type AlignmentUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    creatures?: CreatureUncheckedUpdateManyWithoutAlignment_relationNestedInput
  }

  export type AlignmentCreateManyInput = {
    id?: number
    name: string
  }

  export type AlignmentUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
  }

  export type AlignmentUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type CreatureSpeedCreateInput = {
    walk?: number | null
    fly?: number | null
    swim?: number | null
    burrow?: number | null
    climb?: number | null
    creature_relation: CreatureCreateNestedOneWithoutSpeedInput
  }

  export type CreatureSpeedUncheckedCreateInput = {
    id: string
    walk?: number | null
    fly?: number | null
    swim?: number | null
    burrow?: number | null
    climb?: number | null
  }

  export type CreatureSpeedUpdateInput = {
    walk?: NullableIntFieldUpdateOperationsInput | number | null
    fly?: NullableIntFieldUpdateOperationsInput | number | null
    swim?: NullableIntFieldUpdateOperationsInput | number | null
    burrow?: NullableIntFieldUpdateOperationsInput | number | null
    climb?: NullableIntFieldUpdateOperationsInput | number | null
    creature_relation?: CreatureUpdateOneRequiredWithoutSpeedNestedInput
  }

  export type CreatureSpeedUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    walk?: NullableIntFieldUpdateOperationsInput | number | null
    fly?: NullableIntFieldUpdateOperationsInput | number | null
    swim?: NullableIntFieldUpdateOperationsInput | number | null
    burrow?: NullableIntFieldUpdateOperationsInput | number | null
    climb?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type CreatureSpeedCreateManyInput = {
    id: string
    walk?: number | null
    fly?: number | null
    swim?: number | null
    burrow?: number | null
    climb?: number | null
  }

  export type CreatureSpeedUpdateManyMutationInput = {
    walk?: NullableIntFieldUpdateOperationsInput | number | null
    fly?: NullableIntFieldUpdateOperationsInput | number | null
    swim?: NullableIntFieldUpdateOperationsInput | number | null
    burrow?: NullableIntFieldUpdateOperationsInput | number | null
    climb?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type CreatureSpeedUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    walk?: NullableIntFieldUpdateOperationsInput | number | null
    fly?: NullableIntFieldUpdateOperationsInput | number | null
    swim?: NullableIntFieldUpdateOperationsInput | number | null
    burrow?: NullableIntFieldUpdateOperationsInput | number | null
    climb?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type CreatureStatsCreateInput = {
    stats?: CreatureStatDetailCreateNestedManyWithoutCreature_stats_relationInput
    creature_relation: CreatureCreateNestedOneWithoutStatsInput
  }

  export type CreatureStatsUncheckedCreateInput = {
    id: string
    stats?: CreatureStatDetailUncheckedCreateNestedManyWithoutCreature_stats_relationInput
  }

  export type CreatureStatsUpdateInput = {
    stats?: CreatureStatDetailUpdateManyWithoutCreature_stats_relationNestedInput
    creature_relation?: CreatureUpdateOneRequiredWithoutStatsNestedInput
  }

  export type CreatureStatsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    stats?: CreatureStatDetailUncheckedUpdateManyWithoutCreature_stats_relationNestedInput
  }

  export type CreatureStatsCreateManyInput = {
    id: string
  }

  export type CreatureStatsUpdateManyMutationInput = {

  }

  export type CreatureStatsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
  }

  export type CreatureStatDetailCreateInput = {
    id?: string
    ability: $Enums.Ability
    value: number
    mastery: boolean
    creature_stats_relation: CreatureStatsCreateNestedOneWithoutStatsInput
  }

  export type CreatureStatDetailUncheckedCreateInput = {
    id?: string
    ability: $Enums.Ability
    value: number
    mastery: boolean
    creature_stats_id: string
  }

  export type CreatureStatDetailUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    ability?: EnumAbilityFieldUpdateOperationsInput | $Enums.Ability
    value?: IntFieldUpdateOperationsInput | number
    mastery?: BoolFieldUpdateOperationsInput | boolean
    creature_stats_relation?: CreatureStatsUpdateOneRequiredWithoutStatsNestedInput
  }

  export type CreatureStatDetailUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    ability?: EnumAbilityFieldUpdateOperationsInput | $Enums.Ability
    value?: IntFieldUpdateOperationsInput | number
    mastery?: BoolFieldUpdateOperationsInput | boolean
    creature_stats_id?: StringFieldUpdateOperationsInput | string
  }

  export type CreatureStatDetailCreateManyInput = {
    id?: string
    ability: $Enums.Ability
    value: number
    mastery: boolean
    creature_stats_id: string
  }

  export type CreatureStatDetailUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    ability?: EnumAbilityFieldUpdateOperationsInput | $Enums.Ability
    value?: IntFieldUpdateOperationsInput | number
    mastery?: BoolFieldUpdateOperationsInput | boolean
  }

  export type CreatureStatDetailUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    ability?: EnumAbilityFieldUpdateOperationsInput | $Enums.Ability
    value?: IntFieldUpdateOperationsInput | number
    mastery?: BoolFieldUpdateOperationsInput | boolean
    creature_stats_id?: StringFieldUpdateOperationsInput | string
  }

  export type CreatureSkillsCreateInput = {
    skills?: CreatureSkillDetailCreateNestedManyWithoutCreature_skills_relationInput
    creature_relation: CreatureCreateNestedOneWithoutSkillsInput
  }

  export type CreatureSkillsUncheckedCreateInput = {
    id: string
    skills?: CreatureSkillDetailUncheckedCreateNestedManyWithoutCreature_skills_relationInput
  }

  export type CreatureSkillsUpdateInput = {
    skills?: CreatureSkillDetailUpdateManyWithoutCreature_skills_relationNestedInput
    creature_relation?: CreatureUpdateOneRequiredWithoutSkillsNestedInput
  }

  export type CreatureSkillsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    skills?: CreatureSkillDetailUncheckedUpdateManyWithoutCreature_skills_relationNestedInput
  }

  export type CreatureSkillsCreateManyInput = {
    id: string
  }

  export type CreatureSkillsUpdateManyMutationInput = {

  }

  export type CreatureSkillsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
  }

  export type CreatureSkillDetailCreateInput = {
    id?: string
    skill: $Enums.Skill
    value?: number | null
    mastery: boolean
    creature_skills_relation: CreatureSkillsCreateNestedOneWithoutSkillsInput
  }

  export type CreatureSkillDetailUncheckedCreateInput = {
    id?: string
    skill: $Enums.Skill
    value?: number | null
    mastery: boolean
    creature_skills_id: string
  }

  export type CreatureSkillDetailUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    skill?: EnumSkillFieldUpdateOperationsInput | $Enums.Skill
    value?: NullableIntFieldUpdateOperationsInput | number | null
    mastery?: BoolFieldUpdateOperationsInput | boolean
    creature_skills_relation?: CreatureSkillsUpdateOneRequiredWithoutSkillsNestedInput
  }

  export type CreatureSkillDetailUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    skill?: EnumSkillFieldUpdateOperationsInput | $Enums.Skill
    value?: NullableIntFieldUpdateOperationsInput | number | null
    mastery?: BoolFieldUpdateOperationsInput | boolean
    creature_skills_id?: StringFieldUpdateOperationsInput | string
  }

  export type CreatureSkillDetailCreateManyInput = {
    id?: string
    skill: $Enums.Skill
    value?: number | null
    mastery: boolean
    creature_skills_id: string
  }

  export type CreatureSkillDetailUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    skill?: EnumSkillFieldUpdateOperationsInput | $Enums.Skill
    value?: NullableIntFieldUpdateOperationsInput | number | null
    mastery?: BoolFieldUpdateOperationsInput | boolean
  }

  export type CreatureSkillDetailUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    skill?: EnumSkillFieldUpdateOperationsInput | $Enums.Skill
    value?: NullableIntFieldUpdateOperationsInput | number | null
    mastery?: BoolFieldUpdateOperationsInput | boolean
    creature_skills_id?: StringFieldUpdateOperationsInput | string
  }

  export type SkillMetadataCreateInput = {
    skill: $Enums.Skill
    display_name: string
    ability: $Enums.Ability
  }

  export type SkillMetadataUncheckedCreateInput = {
    skill: $Enums.Skill
    display_name: string
    ability: $Enums.Ability
  }

  export type SkillMetadataUpdateInput = {
    skill?: EnumSkillFieldUpdateOperationsInput | $Enums.Skill
    display_name?: StringFieldUpdateOperationsInput | string
    ability?: EnumAbilityFieldUpdateOperationsInput | $Enums.Ability
  }

  export type SkillMetadataUncheckedUpdateInput = {
    skill?: EnumSkillFieldUpdateOperationsInput | $Enums.Skill
    display_name?: StringFieldUpdateOperationsInput | string
    ability?: EnumAbilityFieldUpdateOperationsInput | $Enums.Ability
  }

  export type SkillMetadataCreateManyInput = {
    skill: $Enums.Skill
    display_name: string
    ability: $Enums.Ability
  }

  export type SkillMetadataUpdateManyMutationInput = {
    skill?: EnumSkillFieldUpdateOperationsInput | $Enums.Skill
    display_name?: StringFieldUpdateOperationsInput | string
    ability?: EnumAbilityFieldUpdateOperationsInput | $Enums.Ability
  }

  export type SkillMetadataUncheckedUpdateManyInput = {
    skill?: EnumSkillFieldUpdateOperationsInput | $Enums.Skill
    display_name?: StringFieldUpdateOperationsInput | string
    ability?: EnumAbilityFieldUpdateOperationsInput | $Enums.Ability
  }

  export type CreatureCreateInput = {
    id?: string
    name: string
    creator_id?: string | null
    description?: string | null
    armor_class?: number | null
    hit_points?: number | null
    speed?: CreatureSpeedCreateNestedOneWithoutCreature_relationInput
    stats?: CreatureStatsCreateNestedOneWithoutCreature_relationInput
    skills?: CreatureSkillsCreateNestedOneWithoutCreature_relationInput
    senses?: CreatureSensesCreateNestedOneWithoutCreature_relationInput
    challenge_rating_meta: ChallengeRatingMetadataCreateNestedOneWithoutCreaturesInput
    alignment_relation?: AlignmentCreateNestedOneWithoutCreaturesInput
    race_relation?: CreatureRaceCreateNestedOneWithoutCreatures_relationInput
    type_relation?: TypeCreateNestedOneWithoutCreaturesInput
    size_relation?: SizeCreateNestedOneWithoutCreatureInput
    source_relation?: SourceCreateNestedOneWithoutCreaturesInput
    resistances?: DamageTypeCreateNestedManyWithoutResistant_creatures_relationInput
    immunities?: DamageTypeCreateNestedManyWithoutImmune_creatures_relationInput
    vulnerabilities?: DamageTypeCreateNestedManyWithoutVulnerable_creatures_relationInput
    languages_relation?: LanguageCreateNestedManyWithoutCreatures_relationInput
    biomes_relation?: BiomeCreateNestedManyWithoutCreatures_relationInput
    actions_relation?: ActionCreateNestedManyWithoutCreatures_relationInput
    traits_relation?: TraitCreateNestedManyWithoutCreatures_relationInput
  }

  export type CreatureUncheckedCreateInput = {
    id?: string
    name: string
    creator_id?: string | null
    description?: string | null
    size?: string | null
    race_id?: number | null
    type_id?: number | null
    source_id?: number | null
    alignment_id?: number | null
    armor_class?: number | null
    hit_points?: number | null
    challenge_rating: string
    speed?: CreatureSpeedUncheckedCreateNestedOneWithoutCreature_relationInput
    stats?: CreatureStatsUncheckedCreateNestedOneWithoutCreature_relationInput
    skills?: CreatureSkillsUncheckedCreateNestedOneWithoutCreature_relationInput
    senses?: CreatureSensesUncheckedCreateNestedOneWithoutCreature_relationInput
    resistances?: DamageTypeUncheckedCreateNestedManyWithoutResistant_creatures_relationInput
    immunities?: DamageTypeUncheckedCreateNestedManyWithoutImmune_creatures_relationInput
    vulnerabilities?: DamageTypeUncheckedCreateNestedManyWithoutVulnerable_creatures_relationInput
    languages_relation?: LanguageUncheckedCreateNestedManyWithoutCreatures_relationInput
    biomes_relation?: BiomeUncheckedCreateNestedManyWithoutCreatures_relationInput
    actions_relation?: ActionUncheckedCreateNestedManyWithoutCreatures_relationInput
    traits_relation?: TraitUncheckedCreateNestedManyWithoutCreatures_relationInput
  }

  export type CreatureUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    creator_id?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    armor_class?: NullableIntFieldUpdateOperationsInput | number | null
    hit_points?: NullableIntFieldUpdateOperationsInput | number | null
    speed?: CreatureSpeedUpdateOneWithoutCreature_relationNestedInput
    stats?: CreatureStatsUpdateOneWithoutCreature_relationNestedInput
    skills?: CreatureSkillsUpdateOneWithoutCreature_relationNestedInput
    senses?: CreatureSensesUpdateOneWithoutCreature_relationNestedInput
    challenge_rating_meta?: ChallengeRatingMetadataUpdateOneRequiredWithoutCreaturesNestedInput
    alignment_relation?: AlignmentUpdateOneWithoutCreaturesNestedInput
    race_relation?: CreatureRaceUpdateOneWithoutCreatures_relationNestedInput
    type_relation?: TypeUpdateOneWithoutCreaturesNestedInput
    size_relation?: SizeUpdateOneWithoutCreatureNestedInput
    source_relation?: SourceUpdateOneWithoutCreaturesNestedInput
    resistances?: DamageTypeUpdateManyWithoutResistant_creatures_relationNestedInput
    immunities?: DamageTypeUpdateManyWithoutImmune_creatures_relationNestedInput
    vulnerabilities?: DamageTypeUpdateManyWithoutVulnerable_creatures_relationNestedInput
    languages_relation?: LanguageUpdateManyWithoutCreatures_relationNestedInput
    biomes_relation?: BiomeUpdateManyWithoutCreatures_relationNestedInput
    actions_relation?: ActionUpdateManyWithoutCreatures_relationNestedInput
    traits_relation?: TraitUpdateManyWithoutCreatures_relationNestedInput
  }

  export type CreatureUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    creator_id?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableStringFieldUpdateOperationsInput | string | null
    race_id?: NullableIntFieldUpdateOperationsInput | number | null
    type_id?: NullableIntFieldUpdateOperationsInput | number | null
    source_id?: NullableIntFieldUpdateOperationsInput | number | null
    alignment_id?: NullableIntFieldUpdateOperationsInput | number | null
    armor_class?: NullableIntFieldUpdateOperationsInput | number | null
    hit_points?: NullableIntFieldUpdateOperationsInput | number | null
    challenge_rating?: StringFieldUpdateOperationsInput | string
    speed?: CreatureSpeedUncheckedUpdateOneWithoutCreature_relationNestedInput
    stats?: CreatureStatsUncheckedUpdateOneWithoutCreature_relationNestedInput
    skills?: CreatureSkillsUncheckedUpdateOneWithoutCreature_relationNestedInput
    senses?: CreatureSensesUncheckedUpdateOneWithoutCreature_relationNestedInput
    resistances?: DamageTypeUncheckedUpdateManyWithoutResistant_creatures_relationNestedInput
    immunities?: DamageTypeUncheckedUpdateManyWithoutImmune_creatures_relationNestedInput
    vulnerabilities?: DamageTypeUncheckedUpdateManyWithoutVulnerable_creatures_relationNestedInput
    languages_relation?: LanguageUncheckedUpdateManyWithoutCreatures_relationNestedInput
    biomes_relation?: BiomeUncheckedUpdateManyWithoutCreatures_relationNestedInput
    actions_relation?: ActionUncheckedUpdateManyWithoutCreatures_relationNestedInput
    traits_relation?: TraitUncheckedUpdateManyWithoutCreatures_relationNestedInput
  }

  export type CreatureCreateManyInput = {
    id?: string
    name: string
    creator_id?: string | null
    description?: string | null
    size?: string | null
    race_id?: number | null
    type_id?: number | null
    source_id?: number | null
    alignment_id?: number | null
    armor_class?: number | null
    hit_points?: number | null
    challenge_rating: string
  }

  export type CreatureUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    creator_id?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    armor_class?: NullableIntFieldUpdateOperationsInput | number | null
    hit_points?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type CreatureUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    creator_id?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableStringFieldUpdateOperationsInput | string | null
    race_id?: NullableIntFieldUpdateOperationsInput | number | null
    type_id?: NullableIntFieldUpdateOperationsInput | number | null
    source_id?: NullableIntFieldUpdateOperationsInput | number | null
    alignment_id?: NullableIntFieldUpdateOperationsInput | number | null
    armor_class?: NullableIntFieldUpdateOperationsInput | number | null
    hit_points?: NullableIntFieldUpdateOperationsInput | number | null
    challenge_rating?: StringFieldUpdateOperationsInput | string
  }

  export type CreatureSensesCreateInput = {
    id?: string
    passive_perception?: number | null
    creature_relation: CreatureCreateNestedOneWithoutSensesInput
  }

  export type CreatureSensesUncheckedCreateInput = {
    id?: string
    creature_id: string
    passive_perception?: number | null
  }

  export type CreatureSensesUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    passive_perception?: NullableIntFieldUpdateOperationsInput | number | null
    creature_relation?: CreatureUpdateOneRequiredWithoutSensesNestedInput
  }

  export type CreatureSensesUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    creature_id?: StringFieldUpdateOperationsInput | string
    passive_perception?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type CreatureSensesCreateManyInput = {
    id?: string
    creature_id: string
    passive_perception?: number | null
  }

  export type CreatureSensesUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    passive_perception?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type CreatureSensesUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    creature_id?: StringFieldUpdateOperationsInput | string
    passive_perception?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ActionCreateInput = {
    name: string
    description: string
    attack?: string | null
    is_template?: boolean | null
    creatures_relation?: CreatureCreateNestedManyWithoutActions_relationInput
    creature_races_relation?: CreatureRaceCreateNestedManyWithoutActions_relationInput
  }

  export type ActionUncheckedCreateInput = {
    id?: number
    name: string
    description: string
    attack?: string | null
    is_template?: boolean | null
    creatures_relation?: CreatureUncheckedCreateNestedManyWithoutActions_relationInput
    creature_races_relation?: CreatureRaceUncheckedCreateNestedManyWithoutActions_relationInput
  }

  export type ActionUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    attack?: NullableStringFieldUpdateOperationsInput | string | null
    is_template?: NullableBoolFieldUpdateOperationsInput | boolean | null
    creatures_relation?: CreatureUpdateManyWithoutActions_relationNestedInput
    creature_races_relation?: CreatureRaceUpdateManyWithoutActions_relationNestedInput
  }

  export type ActionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    attack?: NullableStringFieldUpdateOperationsInput | string | null
    is_template?: NullableBoolFieldUpdateOperationsInput | boolean | null
    creatures_relation?: CreatureUncheckedUpdateManyWithoutActions_relationNestedInput
    creature_races_relation?: CreatureRaceUncheckedUpdateManyWithoutActions_relationNestedInput
  }

  export type ActionCreateManyInput = {
    id?: number
    name: string
    description: string
    attack?: string | null
    is_template?: boolean | null
  }

  export type ActionUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    attack?: NullableStringFieldUpdateOperationsInput | string | null
    is_template?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type ActionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    attack?: NullableStringFieldUpdateOperationsInput | string | null
    is_template?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type TraitCreateInput = {
    name: string
    description: string
    attack?: string | null
    is_template?: boolean | null
    creatures_relation?: CreatureCreateNestedManyWithoutTraits_relationInput
    creature_races_relation?: CreatureRaceCreateNestedManyWithoutTraits_relationInput
  }

  export type TraitUncheckedCreateInput = {
    id?: number
    name: string
    description: string
    attack?: string | null
    is_template?: boolean | null
    creatures_relation?: CreatureUncheckedCreateNestedManyWithoutTraits_relationInput
    creature_races_relation?: CreatureRaceUncheckedCreateNestedManyWithoutTraits_relationInput
  }

  export type TraitUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    attack?: NullableStringFieldUpdateOperationsInput | string | null
    is_template?: NullableBoolFieldUpdateOperationsInput | boolean | null
    creatures_relation?: CreatureUpdateManyWithoutTraits_relationNestedInput
    creature_races_relation?: CreatureRaceUpdateManyWithoutTraits_relationNestedInput
  }

  export type TraitUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    attack?: NullableStringFieldUpdateOperationsInput | string | null
    is_template?: NullableBoolFieldUpdateOperationsInput | boolean | null
    creatures_relation?: CreatureUncheckedUpdateManyWithoutTraits_relationNestedInput
    creature_races_relation?: CreatureRaceUncheckedUpdateManyWithoutTraits_relationNestedInput
  }

  export type TraitCreateManyInput = {
    id?: number
    name: string
    description: string
    attack?: string | null
    is_template?: boolean | null
  }

  export type TraitUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    attack?: NullableStringFieldUpdateOperationsInput | string | null
    is_template?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type TraitUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    attack?: NullableStringFieldUpdateOperationsInput | string | null
    is_template?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type CreatureRaceCreateInput = {
    name: string
    description: string
    traits_relation?: TraitCreateNestedManyWithoutCreature_races_relationInput
    actions_relation?: ActionCreateNestedManyWithoutCreature_races_relationInput
    creatures_relation?: CreatureCreateNestedManyWithoutRace_relationInput
  }

  export type CreatureRaceUncheckedCreateInput = {
    id?: number
    name: string
    description: string
    traits_relation?: TraitUncheckedCreateNestedManyWithoutCreature_races_relationInput
    actions_relation?: ActionUncheckedCreateNestedManyWithoutCreature_races_relationInput
    creatures_relation?: CreatureUncheckedCreateNestedManyWithoutRace_relationInput
  }

  export type CreatureRaceUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    traits_relation?: TraitUpdateManyWithoutCreature_races_relationNestedInput
    actions_relation?: ActionUpdateManyWithoutCreature_races_relationNestedInput
    creatures_relation?: CreatureUpdateManyWithoutRace_relationNestedInput
  }

  export type CreatureRaceUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    traits_relation?: TraitUncheckedUpdateManyWithoutCreature_races_relationNestedInput
    actions_relation?: ActionUncheckedUpdateManyWithoutCreature_races_relationNestedInput
    creatures_relation?: CreatureUncheckedUpdateManyWithoutRace_relationNestedInput
  }

  export type CreatureRaceCreateManyInput = {
    id?: number
    name: string
    description: string
  }

  export type CreatureRaceUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
  }

  export type CreatureRaceUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
  }

  export type DamageTypeCreateInput = {
    id: string
    name: string
    resistant_creatures_relation?: CreatureCreateNestedManyWithoutResistancesInput
    immune_creatures_relation?: CreatureCreateNestedManyWithoutImmunitiesInput
    vulnerable_creatures_relation?: CreatureCreateNestedManyWithoutVulnerabilitiesInput
  }

  export type DamageTypeUncheckedCreateInput = {
    id: string
    name: string
    resistant_creatures_relation?: CreatureUncheckedCreateNestedManyWithoutResistancesInput
    immune_creatures_relation?: CreatureUncheckedCreateNestedManyWithoutImmunitiesInput
    vulnerable_creatures_relation?: CreatureUncheckedCreateNestedManyWithoutVulnerabilitiesInput
  }

  export type DamageTypeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    resistant_creatures_relation?: CreatureUpdateManyWithoutResistancesNestedInput
    immune_creatures_relation?: CreatureUpdateManyWithoutImmunitiesNestedInput
    vulnerable_creatures_relation?: CreatureUpdateManyWithoutVulnerabilitiesNestedInput
  }

  export type DamageTypeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    resistant_creatures_relation?: CreatureUncheckedUpdateManyWithoutResistancesNestedInput
    immune_creatures_relation?: CreatureUncheckedUpdateManyWithoutImmunitiesNestedInput
    vulnerable_creatures_relation?: CreatureUncheckedUpdateManyWithoutVulnerabilitiesNestedInput
  }

  export type DamageTypeCreateManyInput = {
    id: string
    name: string
  }

  export type DamageTypeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type DamageTypeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type ChallengeRatingMetadataCreateInput = {
    cr: $Enums.ChallengeRatingEnum
    display: string
    numeric: number
    xp_reward: number
    creatures?: CreatureCreateNestedManyWithoutChallenge_rating_metaInput
  }

  export type ChallengeRatingMetadataUncheckedCreateInput = {
    cr: $Enums.ChallengeRatingEnum
    display: string
    numeric: number
    xp_reward: number
    creatures?: CreatureUncheckedCreateNestedManyWithoutChallenge_rating_metaInput
  }

  export type ChallengeRatingMetadataUpdateInput = {
    cr?: EnumChallengeRatingEnumFieldUpdateOperationsInput | $Enums.ChallengeRatingEnum
    display?: StringFieldUpdateOperationsInput | string
    numeric?: FloatFieldUpdateOperationsInput | number
    xp_reward?: IntFieldUpdateOperationsInput | number
    creatures?: CreatureUpdateManyWithoutChallenge_rating_metaNestedInput
  }

  export type ChallengeRatingMetadataUncheckedUpdateInput = {
    cr?: EnumChallengeRatingEnumFieldUpdateOperationsInput | $Enums.ChallengeRatingEnum
    display?: StringFieldUpdateOperationsInput | string
    numeric?: FloatFieldUpdateOperationsInput | number
    xp_reward?: IntFieldUpdateOperationsInput | number
    creatures?: CreatureUncheckedUpdateManyWithoutChallenge_rating_metaNestedInput
  }

  export type ChallengeRatingMetadataCreateManyInput = {
    cr: $Enums.ChallengeRatingEnum
    display: string
    numeric: number
    xp_reward: number
  }

  export type ChallengeRatingMetadataUpdateManyMutationInput = {
    cr?: EnumChallengeRatingEnumFieldUpdateOperationsInput | $Enums.ChallengeRatingEnum
    display?: StringFieldUpdateOperationsInput | string
    numeric?: FloatFieldUpdateOperationsInput | number
    xp_reward?: IntFieldUpdateOperationsInput | number
  }

  export type ChallengeRatingMetadataUncheckedUpdateManyInput = {
    cr?: EnumChallengeRatingEnumFieldUpdateOperationsInput | $Enums.ChallengeRatingEnum
    display?: StringFieldUpdateOperationsInput | string
    numeric?: FloatFieldUpdateOperationsInput | number
    xp_reward?: IntFieldUpdateOperationsInput | number
  }

  export type GenrationRequestCreateInput = {
    request: string
    danger: string
    name: string
  }

  export type GenrationRequestUncheckedCreateInput = {
    id?: number
    request: string
    danger: string
    name: string
  }

  export type GenrationRequestUpdateInput = {
    request?: StringFieldUpdateOperationsInput | string
    danger?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type GenrationRequestUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    request?: StringFieldUpdateOperationsInput | string
    danger?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type GenrationRequestCreateManyInput = {
    id?: number
    request: string
    danger: string
    name: string
  }

  export type GenrationRequestUpdateManyMutationInput = {
    request?: StringFieldUpdateOperationsInput | string
    danger?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type GenrationRequestUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    request?: StringFieldUpdateOperationsInput | string
    danger?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type GPTMessageHistoryCreateInput = {
    id?: string
    type: string
    messages_relation?: GPTMessageCreateNestedManyWithoutMessage_history_relationInput
  }

  export type GPTMessageHistoryUncheckedCreateInput = {
    id?: string
    type: string
    messages_relation?: GPTMessageUncheckedCreateNestedManyWithoutMessage_history_relationInput
  }

  export type GPTMessageHistoryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    messages_relation?: GPTMessageUpdateManyWithoutMessage_history_relationNestedInput
  }

  export type GPTMessageHistoryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    messages_relation?: GPTMessageUncheckedUpdateManyWithoutMessage_history_relationNestedInput
  }

  export type GPTMessageHistoryCreateManyInput = {
    id?: string
    type: string
  }

  export type GPTMessageHistoryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
  }

  export type GPTMessageHistoryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
  }

  export type GPTMessageCreateInput = {
    number: number
    text: string
    role: string
    message_history_relation: GPTMessageHistoryCreateNestedOneWithoutMessages_relationInput
  }

  export type GPTMessageUncheckedCreateInput = {
    message_history_id: string
    number: number
    text: string
    role: string
  }

  export type GPTMessageUpdateInput = {
    number?: IntFieldUpdateOperationsInput | number
    text?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    message_history_relation?: GPTMessageHistoryUpdateOneRequiredWithoutMessages_relationNestedInput
  }

  export type GPTMessageUncheckedUpdateInput = {
    message_history_id?: StringFieldUpdateOperationsInput | string
    number?: IntFieldUpdateOperationsInput | number
    text?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
  }

  export type GPTMessageCreateManyInput = {
    message_history_id: string
    number: number
    text: string
    role: string
  }

  export type GPTMessageUpdateManyMutationInput = {
    number?: IntFieldUpdateOperationsInput | number
    text?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
  }

  export type GPTMessageUncheckedUpdateManyInput = {
    message_history_id?: StringFieldUpdateOperationsInput | string
    number?: IntFieldUpdateOperationsInput | number
    text?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
  }

  export type AdventureCreateInput = {
    id?: string
    name: string
    creator_id: string
    created_at?: Date | string
    updated_at?: Date | string
    genre_relation: GenreCreateNestedOneWithoutAdventures_relationInput
    keywords_relation?: KeywordCreateNestedManyWithoutAdventures_relationInput
  }

  export type AdventureUncheckedCreateInput = {
    id?: string
    name: string
    genre_id: string
    creator_id: string
    created_at?: Date | string
    updated_at?: Date | string
    keywords_relation?: KeywordUncheckedCreateNestedManyWithoutAdventures_relationInput
  }

  export type AdventureUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    creator_id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    genre_relation?: GenreUpdateOneRequiredWithoutAdventures_relationNestedInput
    keywords_relation?: KeywordUpdateManyWithoutAdventures_relationNestedInput
  }

  export type AdventureUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    genre_id?: StringFieldUpdateOperationsInput | string
    creator_id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    keywords_relation?: KeywordUncheckedUpdateManyWithoutAdventures_relationNestedInput
  }

  export type AdventureCreateManyInput = {
    id?: string
    name: string
    genre_id: string
    creator_id: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type AdventureUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    creator_id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdventureUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    genre_id?: StringFieldUpdateOperationsInput | string
    creator_id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type KeywordCreateInput = {
    id?: string
    name: string
    genre_relation: GenreCreateNestedOneWithoutKeywords_relationInput
    adventures_relation?: AdventureCreateNestedManyWithoutKeywords_relationInput
  }

  export type KeywordUncheckedCreateInput = {
    id?: string
    name: string
    genre_id: string
    adventures_relation?: AdventureUncheckedCreateNestedManyWithoutKeywords_relationInput
  }

  export type KeywordUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    genre_relation?: GenreUpdateOneRequiredWithoutKeywords_relationNestedInput
    adventures_relation?: AdventureUpdateManyWithoutKeywords_relationNestedInput
  }

  export type KeywordUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    genre_id?: StringFieldUpdateOperationsInput | string
    adventures_relation?: AdventureUncheckedUpdateManyWithoutKeywords_relationNestedInput
  }

  export type KeywordCreateManyInput = {
    id?: string
    name: string
    genre_id: string
  }

  export type KeywordUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type KeywordUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    genre_id?: StringFieldUpdateOperationsInput | string
  }

  export type GenreCreateInput = {
    id?: string
    name: string
    keywords_relation?: KeywordCreateNestedManyWithoutGenre_relationInput
    adventures_relation?: AdventureCreateNestedManyWithoutGenre_relationInput
  }

  export type GenreUncheckedCreateInput = {
    id?: string
    name: string
    keywords_relation?: KeywordUncheckedCreateNestedManyWithoutGenre_relationInput
    adventures_relation?: AdventureUncheckedCreateNestedManyWithoutGenre_relationInput
  }

  export type GenreUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    keywords_relation?: KeywordUpdateManyWithoutGenre_relationNestedInput
    adventures_relation?: AdventureUpdateManyWithoutGenre_relationNestedInput
  }

  export type GenreUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    keywords_relation?: KeywordUncheckedUpdateManyWithoutGenre_relationNestedInput
    adventures_relation?: AdventureUncheckedUpdateManyWithoutGenre_relationNestedInput
  }

  export type GenreCreateManyInput = {
    id?: string
    name: string
  }

  export type GenreUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type GenreUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type MagicItemCreateInput = {
    id?: string
    name: string
    description: string
    requires_attunement?: boolean
    type_relation: MagicItemTypeCreateNestedOneWithoutMagicItemsInput
    rarity_relation: MagicItemRarityCreateNestedOneWithoutMagicItemsInput
    source_relation: SourceCreateNestedOneWithoutMagicItemsInput
    attunements_relation?: MagicItemAttunementCreateNestedManyWithoutMagicItemInput
  }

  export type MagicItemUncheckedCreateInput = {
    id?: string
    name: string
    description: string
    type_id: string
    rarity_id: string
    source_id: number
    requires_attunement?: boolean
    attunements_relation?: MagicItemAttunementUncheckedCreateNestedManyWithoutMagicItemInput
  }

  export type MagicItemUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    requires_attunement?: BoolFieldUpdateOperationsInput | boolean
    type_relation?: MagicItemTypeUpdateOneRequiredWithoutMagicItemsNestedInput
    rarity_relation?: MagicItemRarityUpdateOneRequiredWithoutMagicItemsNestedInput
    source_relation?: SourceUpdateOneRequiredWithoutMagicItemsNestedInput
    attunements_relation?: MagicItemAttunementUpdateManyWithoutMagicItemNestedInput
  }

  export type MagicItemUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type_id?: StringFieldUpdateOperationsInput | string
    rarity_id?: StringFieldUpdateOperationsInput | string
    source_id?: IntFieldUpdateOperationsInput | number
    requires_attunement?: BoolFieldUpdateOperationsInput | boolean
    attunements_relation?: MagicItemAttunementUncheckedUpdateManyWithoutMagicItemNestedInput
  }

  export type MagicItemCreateManyInput = {
    id?: string
    name: string
    description: string
    type_id: string
    rarity_id: string
    source_id: number
    requires_attunement?: boolean
  }

  export type MagicItemUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    requires_attunement?: BoolFieldUpdateOperationsInput | boolean
  }

  export type MagicItemUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type_id?: StringFieldUpdateOperationsInput | string
    rarity_id?: StringFieldUpdateOperationsInput | string
    source_id?: IntFieldUpdateOperationsInput | number
    requires_attunement?: BoolFieldUpdateOperationsInput | boolean
  }

  export type MagicItemRarityCreateInput = {
    id: string
    cost: string
    name: string
    name_he: string
    name_she: string
    name_it: string
    order: number
    magicItems?: MagicItemCreateNestedManyWithoutRarity_relationInput
  }

  export type MagicItemRarityUncheckedCreateInput = {
    id: string
    cost: string
    name: string
    name_he: string
    name_she: string
    name_it: string
    order: number
    magicItems?: MagicItemUncheckedCreateNestedManyWithoutRarity_relationInput
  }

  export type MagicItemRarityUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    cost?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    name_he?: StringFieldUpdateOperationsInput | string
    name_she?: StringFieldUpdateOperationsInput | string
    name_it?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    magicItems?: MagicItemUpdateManyWithoutRarity_relationNestedInput
  }

  export type MagicItemRarityUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    cost?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    name_he?: StringFieldUpdateOperationsInput | string
    name_she?: StringFieldUpdateOperationsInput | string
    name_it?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    magicItems?: MagicItemUncheckedUpdateManyWithoutRarity_relationNestedInput
  }

  export type MagicItemRarityCreateManyInput = {
    id: string
    cost: string
    name: string
    name_he: string
    name_she: string
    name_it: string
    order: number
  }

  export type MagicItemRarityUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    cost?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    name_he?: StringFieldUpdateOperationsInput | string
    name_she?: StringFieldUpdateOperationsInput | string
    name_it?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
  }

  export type MagicItemRarityUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    cost?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    name_he?: StringFieldUpdateOperationsInput | string
    name_she?: StringFieldUpdateOperationsInput | string
    name_it?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
  }

  export type MagicItemTypeCreateInput = {
    id: string
    name: string
    gender: $Enums.Gender
    magicItems?: MagicItemCreateNestedManyWithoutType_relationInput
  }

  export type MagicItemTypeUncheckedCreateInput = {
    id: string
    name: string
    gender: $Enums.Gender
    magicItems?: MagicItemUncheckedCreateNestedManyWithoutType_relationInput
  }

  export type MagicItemTypeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    magicItems?: MagicItemUpdateManyWithoutType_relationNestedInput
  }

  export type MagicItemTypeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    magicItems?: MagicItemUncheckedUpdateManyWithoutType_relationNestedInput
  }

  export type MagicItemTypeCreateManyInput = {
    id: string
    name: string
    gender: $Enums.Gender
  }

  export type MagicItemTypeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
  }

  export type MagicItemTypeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
  }

  export type AttunementConditionCreateInput = {
    id?: string
    name: string
    magicItems?: MagicItemAttunementCreateNestedManyWithoutAttunementInput
  }

  export type AttunementConditionUncheckedCreateInput = {
    id?: string
    name: string
    magicItems?: MagicItemAttunementUncheckedCreateNestedManyWithoutAttunementInput
  }

  export type AttunementConditionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    magicItems?: MagicItemAttunementUpdateManyWithoutAttunementNestedInput
  }

  export type AttunementConditionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    magicItems?: MagicItemAttunementUncheckedUpdateManyWithoutAttunementNestedInput
  }

  export type AttunementConditionCreateManyInput = {
    id?: string
    name: string
  }

  export type AttunementConditionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type AttunementConditionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type MagicItemAttunementCreateInput = {
    magicItem: MagicItemCreateNestedOneWithoutAttunements_relationInput
    attunement: AttunementConditionCreateNestedOneWithoutMagicItemsInput
  }

  export type MagicItemAttunementUncheckedCreateInput = {
    magicItemId: string
    attunementId: string
  }

  export type MagicItemAttunementUpdateInput = {
    magicItem?: MagicItemUpdateOneRequiredWithoutAttunements_relationNestedInput
    attunement?: AttunementConditionUpdateOneRequiredWithoutMagicItemsNestedInput
  }

  export type MagicItemAttunementUncheckedUpdateInput = {
    magicItemId?: StringFieldUpdateOperationsInput | string
    attunementId?: StringFieldUpdateOperationsInput | string
  }

  export type MagicItemAttunementCreateManyInput = {
    magicItemId: string
    attunementId: string
  }

  export type MagicItemAttunementUpdateManyMutationInput = {

  }

  export type MagicItemAttunementUncheckedUpdateManyInput = {
    magicItemId?: StringFieldUpdateOperationsInput | string
    attunementId?: StringFieldUpdateOperationsInput | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type CreatureListRelationFilter = {
    every?: CreatureWhereInput
    some?: CreatureWhereInput
    none?: CreatureWhereInput
  }

  export type CreatureOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SizeCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type SizeMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type SizeMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type MagicItemListRelationFilter = {
    every?: MagicItemWhereInput
    some?: MagicItemWhereInput
    none?: MagicItemWhereInput
  }

  export type MagicItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SourceCountOrderByAggregateInput = {
    id?: SortOrder
    short_name?: SortOrder
    name?: SortOrder
  }

  export type SourceAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type SourceMaxOrderByAggregateInput = {
    id?: SortOrder
    short_name?: SortOrder
    name?: SortOrder
  }

  export type SourceMinOrderByAggregateInput = {
    id?: SortOrder
    short_name?: SortOrder
    name?: SortOrder
  }

  export type SourceSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type LanguageCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type LanguageAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type LanguageMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type LanguageMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type LanguageSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type BiomeCountOrderByAggregateInput = {
    id?: SortOrder
    short_name?: SortOrder
    name?: SortOrder
  }

  export type BiomeAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type BiomeMaxOrderByAggregateInput = {
    id?: SortOrder
    short_name?: SortOrder
    name?: SortOrder
  }

  export type BiomeMinOrderByAggregateInput = {
    id?: SortOrder
    short_name?: SortOrder
    name?: SortOrder
  }

  export type BiomeSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type TypeCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type TypeAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type TypeMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type TypeMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type TypeSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type AlignmentCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type AlignmentAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type AlignmentMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type AlignmentMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type AlignmentSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type CreatureScalarRelationFilter = {
    is?: CreatureWhereInput
    isNot?: CreatureWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type CreatureSpeedCountOrderByAggregateInput = {
    id?: SortOrder
    walk?: SortOrder
    fly?: SortOrder
    swim?: SortOrder
    burrow?: SortOrder
    climb?: SortOrder
  }

  export type CreatureSpeedAvgOrderByAggregateInput = {
    walk?: SortOrder
    fly?: SortOrder
    swim?: SortOrder
    burrow?: SortOrder
    climb?: SortOrder
  }

  export type CreatureSpeedMaxOrderByAggregateInput = {
    id?: SortOrder
    walk?: SortOrder
    fly?: SortOrder
    swim?: SortOrder
    burrow?: SortOrder
    climb?: SortOrder
  }

  export type CreatureSpeedMinOrderByAggregateInput = {
    id?: SortOrder
    walk?: SortOrder
    fly?: SortOrder
    swim?: SortOrder
    burrow?: SortOrder
    climb?: SortOrder
  }

  export type CreatureSpeedSumOrderByAggregateInput = {
    walk?: SortOrder
    fly?: SortOrder
    swim?: SortOrder
    burrow?: SortOrder
    climb?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type CreatureStatDetailListRelationFilter = {
    every?: CreatureStatDetailWhereInput
    some?: CreatureStatDetailWhereInput
    none?: CreatureStatDetailWhereInput
  }

  export type CreatureStatDetailOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CreatureStatsCountOrderByAggregateInput = {
    id?: SortOrder
  }

  export type CreatureStatsMaxOrderByAggregateInput = {
    id?: SortOrder
  }

  export type CreatureStatsMinOrderByAggregateInput = {
    id?: SortOrder
  }

  export type EnumAbilityFilter<$PrismaModel = never> = {
    equals?: $Enums.Ability | EnumAbilityFieldRefInput<$PrismaModel>
    in?: $Enums.Ability[] | ListEnumAbilityFieldRefInput<$PrismaModel>
    notIn?: $Enums.Ability[] | ListEnumAbilityFieldRefInput<$PrismaModel>
    not?: NestedEnumAbilityFilter<$PrismaModel> | $Enums.Ability
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type CreatureStatsScalarRelationFilter = {
    is?: CreatureStatsWhereInput
    isNot?: CreatureStatsWhereInput
  }

  export type CreatureStatDetailCreature_stats_idAbilityCompoundUniqueInput = {
    creature_stats_id: string
    ability: $Enums.Ability
  }

  export type CreatureStatDetailCountOrderByAggregateInput = {
    id?: SortOrder
    ability?: SortOrder
    value?: SortOrder
    mastery?: SortOrder
    creature_stats_id?: SortOrder
  }

  export type CreatureStatDetailAvgOrderByAggregateInput = {
    value?: SortOrder
  }

  export type CreatureStatDetailMaxOrderByAggregateInput = {
    id?: SortOrder
    ability?: SortOrder
    value?: SortOrder
    mastery?: SortOrder
    creature_stats_id?: SortOrder
  }

  export type CreatureStatDetailMinOrderByAggregateInput = {
    id?: SortOrder
    ability?: SortOrder
    value?: SortOrder
    mastery?: SortOrder
    creature_stats_id?: SortOrder
  }

  export type CreatureStatDetailSumOrderByAggregateInput = {
    value?: SortOrder
  }

  export type EnumAbilityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Ability | EnumAbilityFieldRefInput<$PrismaModel>
    in?: $Enums.Ability[] | ListEnumAbilityFieldRefInput<$PrismaModel>
    notIn?: $Enums.Ability[] | ListEnumAbilityFieldRefInput<$PrismaModel>
    not?: NestedEnumAbilityWithAggregatesFilter<$PrismaModel> | $Enums.Ability
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAbilityFilter<$PrismaModel>
    _max?: NestedEnumAbilityFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type CreatureSkillDetailListRelationFilter = {
    every?: CreatureSkillDetailWhereInput
    some?: CreatureSkillDetailWhereInput
    none?: CreatureSkillDetailWhereInput
  }

  export type CreatureSkillDetailOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CreatureSkillsCountOrderByAggregateInput = {
    id?: SortOrder
  }

  export type CreatureSkillsMaxOrderByAggregateInput = {
    id?: SortOrder
  }

  export type CreatureSkillsMinOrderByAggregateInput = {
    id?: SortOrder
  }

  export type EnumSkillFilter<$PrismaModel = never> = {
    equals?: $Enums.Skill | EnumSkillFieldRefInput<$PrismaModel>
    in?: $Enums.Skill[] | ListEnumSkillFieldRefInput<$PrismaModel>
    notIn?: $Enums.Skill[] | ListEnumSkillFieldRefInput<$PrismaModel>
    not?: NestedEnumSkillFilter<$PrismaModel> | $Enums.Skill
  }

  export type CreatureSkillsScalarRelationFilter = {
    is?: CreatureSkillsWhereInput
    isNot?: CreatureSkillsWhereInput
  }

  export type CreatureSkillDetailCreature_skills_idSkillCompoundUniqueInput = {
    creature_skills_id: string
    skill: $Enums.Skill
  }

  export type CreatureSkillDetailCountOrderByAggregateInput = {
    id?: SortOrder
    skill?: SortOrder
    value?: SortOrder
    mastery?: SortOrder
    creature_skills_id?: SortOrder
  }

  export type CreatureSkillDetailAvgOrderByAggregateInput = {
    value?: SortOrder
  }

  export type CreatureSkillDetailMaxOrderByAggregateInput = {
    id?: SortOrder
    skill?: SortOrder
    value?: SortOrder
    mastery?: SortOrder
    creature_skills_id?: SortOrder
  }

  export type CreatureSkillDetailMinOrderByAggregateInput = {
    id?: SortOrder
    skill?: SortOrder
    value?: SortOrder
    mastery?: SortOrder
    creature_skills_id?: SortOrder
  }

  export type CreatureSkillDetailSumOrderByAggregateInput = {
    value?: SortOrder
  }

  export type EnumSkillWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Skill | EnumSkillFieldRefInput<$PrismaModel>
    in?: $Enums.Skill[] | ListEnumSkillFieldRefInput<$PrismaModel>
    notIn?: $Enums.Skill[] | ListEnumSkillFieldRefInput<$PrismaModel>
    not?: NestedEnumSkillWithAggregatesFilter<$PrismaModel> | $Enums.Skill
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSkillFilter<$PrismaModel>
    _max?: NestedEnumSkillFilter<$PrismaModel>
  }

  export type SkillMetadataCountOrderByAggregateInput = {
    skill?: SortOrder
    display_name?: SortOrder
    ability?: SortOrder
  }

  export type SkillMetadataMaxOrderByAggregateInput = {
    skill?: SortOrder
    display_name?: SortOrder
    ability?: SortOrder
  }

  export type SkillMetadataMinOrderByAggregateInput = {
    skill?: SortOrder
    display_name?: SortOrder
    ability?: SortOrder
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type CreatureSpeedNullableScalarRelationFilter = {
    is?: CreatureSpeedWhereInput | null
    isNot?: CreatureSpeedWhereInput | null
  }

  export type CreatureStatsNullableScalarRelationFilter = {
    is?: CreatureStatsWhereInput | null
    isNot?: CreatureStatsWhereInput | null
  }

  export type CreatureSkillsNullableScalarRelationFilter = {
    is?: CreatureSkillsWhereInput | null
    isNot?: CreatureSkillsWhereInput | null
  }

  export type CreatureSensesNullableScalarRelationFilter = {
    is?: CreatureSensesWhereInput | null
    isNot?: CreatureSensesWhereInput | null
  }

  export type ChallengeRatingMetadataScalarRelationFilter = {
    is?: ChallengeRatingMetadataWhereInput
    isNot?: ChallengeRatingMetadataWhereInput
  }

  export type AlignmentNullableScalarRelationFilter = {
    is?: AlignmentWhereInput | null
    isNot?: AlignmentWhereInput | null
  }

  export type CreatureRaceNullableScalarRelationFilter = {
    is?: CreatureRaceWhereInput | null
    isNot?: CreatureRaceWhereInput | null
  }

  export type TypeNullableScalarRelationFilter = {
    is?: TypeWhereInput | null
    isNot?: TypeWhereInput | null
  }

  export type SizeNullableScalarRelationFilter = {
    is?: SizeWhereInput | null
    isNot?: SizeWhereInput | null
  }

  export type SourceNullableScalarRelationFilter = {
    is?: SourceWhereInput | null
    isNot?: SourceWhereInput | null
  }

  export type DamageTypeListRelationFilter = {
    every?: DamageTypeWhereInput
    some?: DamageTypeWhereInput
    none?: DamageTypeWhereInput
  }

  export type LanguageListRelationFilter = {
    every?: LanguageWhereInput
    some?: LanguageWhereInput
    none?: LanguageWhereInput
  }

  export type BiomeListRelationFilter = {
    every?: BiomeWhereInput
    some?: BiomeWhereInput
    none?: BiomeWhereInput
  }

  export type ActionListRelationFilter = {
    every?: ActionWhereInput
    some?: ActionWhereInput
    none?: ActionWhereInput
  }

  export type TraitListRelationFilter = {
    every?: TraitWhereInput
    some?: TraitWhereInput
    none?: TraitWhereInput
  }

  export type DamageTypeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LanguageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BiomeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ActionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TraitOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CreatureCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    creator_id?: SortOrder
    description?: SortOrder
    size?: SortOrder
    race_id?: SortOrder
    type_id?: SortOrder
    source_id?: SortOrder
    alignment_id?: SortOrder
    armor_class?: SortOrder
    hit_points?: SortOrder
    challenge_rating?: SortOrder
  }

  export type CreatureAvgOrderByAggregateInput = {
    race_id?: SortOrder
    type_id?: SortOrder
    source_id?: SortOrder
    alignment_id?: SortOrder
    armor_class?: SortOrder
    hit_points?: SortOrder
  }

  export type CreatureMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    creator_id?: SortOrder
    description?: SortOrder
    size?: SortOrder
    race_id?: SortOrder
    type_id?: SortOrder
    source_id?: SortOrder
    alignment_id?: SortOrder
    armor_class?: SortOrder
    hit_points?: SortOrder
    challenge_rating?: SortOrder
  }

  export type CreatureMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    creator_id?: SortOrder
    description?: SortOrder
    size?: SortOrder
    race_id?: SortOrder
    type_id?: SortOrder
    source_id?: SortOrder
    alignment_id?: SortOrder
    armor_class?: SortOrder
    hit_points?: SortOrder
    challenge_rating?: SortOrder
  }

  export type CreatureSumOrderByAggregateInput = {
    race_id?: SortOrder
    type_id?: SortOrder
    source_id?: SortOrder
    alignment_id?: SortOrder
    armor_class?: SortOrder
    hit_points?: SortOrder
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type CreatureSensesCountOrderByAggregateInput = {
    id?: SortOrder
    creature_id?: SortOrder
    passive_perception?: SortOrder
  }

  export type CreatureSensesAvgOrderByAggregateInput = {
    passive_perception?: SortOrder
  }

  export type CreatureSensesMaxOrderByAggregateInput = {
    id?: SortOrder
    creature_id?: SortOrder
    passive_perception?: SortOrder
  }

  export type CreatureSensesMinOrderByAggregateInput = {
    id?: SortOrder
    creature_id?: SortOrder
    passive_perception?: SortOrder
  }

  export type CreatureSensesSumOrderByAggregateInput = {
    passive_perception?: SortOrder
  }

  export type BoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type CreatureRaceListRelationFilter = {
    every?: CreatureRaceWhereInput
    some?: CreatureRaceWhereInput
    none?: CreatureRaceWhereInput
  }

  export type CreatureRaceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ActionCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    attack?: SortOrder
    is_template?: SortOrder
  }

  export type ActionAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type ActionMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    attack?: SortOrder
    is_template?: SortOrder
  }

  export type ActionMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    attack?: SortOrder
    is_template?: SortOrder
  }

  export type ActionSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type BoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type TraitCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    attack?: SortOrder
    is_template?: SortOrder
  }

  export type TraitAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type TraitMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    attack?: SortOrder
    is_template?: SortOrder
  }

  export type TraitMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    attack?: SortOrder
    is_template?: SortOrder
  }

  export type TraitSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type CreatureRaceCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
  }

  export type CreatureRaceAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type CreatureRaceMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
  }

  export type CreatureRaceMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
  }

  export type CreatureRaceSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type DamageTypeCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type DamageTypeMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type DamageTypeMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type EnumChallengeRatingEnumFilter<$PrismaModel = never> = {
    equals?: $Enums.ChallengeRatingEnum | EnumChallengeRatingEnumFieldRefInput<$PrismaModel>
    in?: $Enums.ChallengeRatingEnum[] | ListEnumChallengeRatingEnumFieldRefInput<$PrismaModel>
    notIn?: $Enums.ChallengeRatingEnum[] | ListEnumChallengeRatingEnumFieldRefInput<$PrismaModel>
    not?: NestedEnumChallengeRatingEnumFilter<$PrismaModel> | $Enums.ChallengeRatingEnum
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type ChallengeRatingMetadataCountOrderByAggregateInput = {
    cr?: SortOrder
    display?: SortOrder
    numeric?: SortOrder
    xp_reward?: SortOrder
  }

  export type ChallengeRatingMetadataAvgOrderByAggregateInput = {
    numeric?: SortOrder
    xp_reward?: SortOrder
  }

  export type ChallengeRatingMetadataMaxOrderByAggregateInput = {
    cr?: SortOrder
    display?: SortOrder
    numeric?: SortOrder
    xp_reward?: SortOrder
  }

  export type ChallengeRatingMetadataMinOrderByAggregateInput = {
    cr?: SortOrder
    display?: SortOrder
    numeric?: SortOrder
    xp_reward?: SortOrder
  }

  export type ChallengeRatingMetadataSumOrderByAggregateInput = {
    numeric?: SortOrder
    xp_reward?: SortOrder
  }

  export type EnumChallengeRatingEnumWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ChallengeRatingEnum | EnumChallengeRatingEnumFieldRefInput<$PrismaModel>
    in?: $Enums.ChallengeRatingEnum[] | ListEnumChallengeRatingEnumFieldRefInput<$PrismaModel>
    notIn?: $Enums.ChallengeRatingEnum[] | ListEnumChallengeRatingEnumFieldRefInput<$PrismaModel>
    not?: NestedEnumChallengeRatingEnumWithAggregatesFilter<$PrismaModel> | $Enums.ChallengeRatingEnum
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumChallengeRatingEnumFilter<$PrismaModel>
    _max?: NestedEnumChallengeRatingEnumFilter<$PrismaModel>
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type GenrationRequestCountOrderByAggregateInput = {
    id?: SortOrder
    request?: SortOrder
    danger?: SortOrder
    name?: SortOrder
  }

  export type GenrationRequestAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type GenrationRequestMaxOrderByAggregateInput = {
    id?: SortOrder
    request?: SortOrder
    danger?: SortOrder
    name?: SortOrder
  }

  export type GenrationRequestMinOrderByAggregateInput = {
    id?: SortOrder
    request?: SortOrder
    danger?: SortOrder
    name?: SortOrder
  }

  export type GenrationRequestSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type GPTMessageListRelationFilter = {
    every?: GPTMessageWhereInput
    some?: GPTMessageWhereInput
    none?: GPTMessageWhereInput
  }

  export type GPTMessageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type GPTMessageHistoryCountOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
  }

  export type GPTMessageHistoryMaxOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
  }

  export type GPTMessageHistoryMinOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
  }

  export type GPTMessageHistoryScalarRelationFilter = {
    is?: GPTMessageHistoryWhereInput
    isNot?: GPTMessageHistoryWhereInput
  }

  export type GPTMessageMessage_history_idNumberCompoundUniqueInput = {
    message_history_id: string
    number: number
  }

  export type GPTMessageCountOrderByAggregateInput = {
    message_history_id?: SortOrder
    number?: SortOrder
    text?: SortOrder
    role?: SortOrder
  }

  export type GPTMessageAvgOrderByAggregateInput = {
    number?: SortOrder
  }

  export type GPTMessageMaxOrderByAggregateInput = {
    message_history_id?: SortOrder
    number?: SortOrder
    text?: SortOrder
    role?: SortOrder
  }

  export type GPTMessageMinOrderByAggregateInput = {
    message_history_id?: SortOrder
    number?: SortOrder
    text?: SortOrder
    role?: SortOrder
  }

  export type GPTMessageSumOrderByAggregateInput = {
    number?: SortOrder
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type GenreScalarRelationFilter = {
    is?: GenreWhereInput
    isNot?: GenreWhereInput
  }

  export type KeywordListRelationFilter = {
    every?: KeywordWhereInput
    some?: KeywordWhereInput
    none?: KeywordWhereInput
  }

  export type KeywordOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AdventureCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    genre_id?: SortOrder
    creator_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type AdventureMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    genre_id?: SortOrder
    creator_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type AdventureMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    genre_id?: SortOrder
    creator_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type AdventureListRelationFilter = {
    every?: AdventureWhereInput
    some?: AdventureWhereInput
    none?: AdventureWhereInput
  }

  export type AdventureOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type KeywordCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    genre_id?: SortOrder
  }

  export type KeywordMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    genre_id?: SortOrder
  }

  export type KeywordMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    genre_id?: SortOrder
  }

  export type GenreCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type GenreMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type GenreMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type MagicItemTypeScalarRelationFilter = {
    is?: MagicItemTypeWhereInput
    isNot?: MagicItemTypeWhereInput
  }

  export type MagicItemRarityScalarRelationFilter = {
    is?: MagicItemRarityWhereInput
    isNot?: MagicItemRarityWhereInput
  }

  export type SourceScalarRelationFilter = {
    is?: SourceWhereInput
    isNot?: SourceWhereInput
  }

  export type MagicItemAttunementListRelationFilter = {
    every?: MagicItemAttunementWhereInput
    some?: MagicItemAttunementWhereInput
    none?: MagicItemAttunementWhereInput
  }

  export type MagicItemAttunementOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MagicItemCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    type_id?: SortOrder
    rarity_id?: SortOrder
    source_id?: SortOrder
    requires_attunement?: SortOrder
  }

  export type MagicItemAvgOrderByAggregateInput = {
    source_id?: SortOrder
  }

  export type MagicItemMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    type_id?: SortOrder
    rarity_id?: SortOrder
    source_id?: SortOrder
    requires_attunement?: SortOrder
  }

  export type MagicItemMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    type_id?: SortOrder
    rarity_id?: SortOrder
    source_id?: SortOrder
    requires_attunement?: SortOrder
  }

  export type MagicItemSumOrderByAggregateInput = {
    source_id?: SortOrder
  }

  export type MagicItemRarityCountOrderByAggregateInput = {
    id?: SortOrder
    cost?: SortOrder
    name?: SortOrder
    name_he?: SortOrder
    name_she?: SortOrder
    name_it?: SortOrder
    order?: SortOrder
  }

  export type MagicItemRarityAvgOrderByAggregateInput = {
    order?: SortOrder
  }

  export type MagicItemRarityMaxOrderByAggregateInput = {
    id?: SortOrder
    cost?: SortOrder
    name?: SortOrder
    name_he?: SortOrder
    name_she?: SortOrder
    name_it?: SortOrder
    order?: SortOrder
  }

  export type MagicItemRarityMinOrderByAggregateInput = {
    id?: SortOrder
    cost?: SortOrder
    name?: SortOrder
    name_he?: SortOrder
    name_she?: SortOrder
    name_it?: SortOrder
    order?: SortOrder
  }

  export type MagicItemRaritySumOrderByAggregateInput = {
    order?: SortOrder
  }

  export type EnumGenderFilter<$PrismaModel = never> = {
    equals?: $Enums.Gender | EnumGenderFieldRefInput<$PrismaModel>
    in?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel>
    notIn?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel>
    not?: NestedEnumGenderFilter<$PrismaModel> | $Enums.Gender
  }

  export type MagicItemTypeCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    gender?: SortOrder
  }

  export type MagicItemTypeMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    gender?: SortOrder
  }

  export type MagicItemTypeMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    gender?: SortOrder
  }

  export type EnumGenderWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Gender | EnumGenderFieldRefInput<$PrismaModel>
    in?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel>
    notIn?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel>
    not?: NestedEnumGenderWithAggregatesFilter<$PrismaModel> | $Enums.Gender
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumGenderFilter<$PrismaModel>
    _max?: NestedEnumGenderFilter<$PrismaModel>
  }

  export type AttunementConditionCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type AttunementConditionMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type AttunementConditionMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type MagicItemScalarRelationFilter = {
    is?: MagicItemWhereInput
    isNot?: MagicItemWhereInput
  }

  export type AttunementConditionScalarRelationFilter = {
    is?: AttunementConditionWhereInput
    isNot?: AttunementConditionWhereInput
  }

  export type MagicItemAttunementMagicItemIdAttunementIdCompoundUniqueInput = {
    magicItemId: string
    attunementId: string
  }

  export type MagicItemAttunementCountOrderByAggregateInput = {
    magicItemId?: SortOrder
    attunementId?: SortOrder
  }

  export type MagicItemAttunementMaxOrderByAggregateInput = {
    magicItemId?: SortOrder
    attunementId?: SortOrder
  }

  export type MagicItemAttunementMinOrderByAggregateInput = {
    magicItemId?: SortOrder
    attunementId?: SortOrder
  }

  export type CreatureCreateNestedManyWithoutSize_relationInput = {
    create?: XOR<CreatureCreateWithoutSize_relationInput, CreatureUncheckedCreateWithoutSize_relationInput> | CreatureCreateWithoutSize_relationInput[] | CreatureUncheckedCreateWithoutSize_relationInput[]
    connectOrCreate?: CreatureCreateOrConnectWithoutSize_relationInput | CreatureCreateOrConnectWithoutSize_relationInput[]
    createMany?: CreatureCreateManySize_relationInputEnvelope
    connect?: CreatureWhereUniqueInput | CreatureWhereUniqueInput[]
  }

  export type CreatureUncheckedCreateNestedManyWithoutSize_relationInput = {
    create?: XOR<CreatureCreateWithoutSize_relationInput, CreatureUncheckedCreateWithoutSize_relationInput> | CreatureCreateWithoutSize_relationInput[] | CreatureUncheckedCreateWithoutSize_relationInput[]
    connectOrCreate?: CreatureCreateOrConnectWithoutSize_relationInput | CreatureCreateOrConnectWithoutSize_relationInput[]
    createMany?: CreatureCreateManySize_relationInputEnvelope
    connect?: CreatureWhereUniqueInput | CreatureWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type CreatureUpdateManyWithoutSize_relationNestedInput = {
    create?: XOR<CreatureCreateWithoutSize_relationInput, CreatureUncheckedCreateWithoutSize_relationInput> | CreatureCreateWithoutSize_relationInput[] | CreatureUncheckedCreateWithoutSize_relationInput[]
    connectOrCreate?: CreatureCreateOrConnectWithoutSize_relationInput | CreatureCreateOrConnectWithoutSize_relationInput[]
    upsert?: CreatureUpsertWithWhereUniqueWithoutSize_relationInput | CreatureUpsertWithWhereUniqueWithoutSize_relationInput[]
    createMany?: CreatureCreateManySize_relationInputEnvelope
    set?: CreatureWhereUniqueInput | CreatureWhereUniqueInput[]
    disconnect?: CreatureWhereUniqueInput | CreatureWhereUniqueInput[]
    delete?: CreatureWhereUniqueInput | CreatureWhereUniqueInput[]
    connect?: CreatureWhereUniqueInput | CreatureWhereUniqueInput[]
    update?: CreatureUpdateWithWhereUniqueWithoutSize_relationInput | CreatureUpdateWithWhereUniqueWithoutSize_relationInput[]
    updateMany?: CreatureUpdateManyWithWhereWithoutSize_relationInput | CreatureUpdateManyWithWhereWithoutSize_relationInput[]
    deleteMany?: CreatureScalarWhereInput | CreatureScalarWhereInput[]
  }

  export type CreatureUncheckedUpdateManyWithoutSize_relationNestedInput = {
    create?: XOR<CreatureCreateWithoutSize_relationInput, CreatureUncheckedCreateWithoutSize_relationInput> | CreatureCreateWithoutSize_relationInput[] | CreatureUncheckedCreateWithoutSize_relationInput[]
    connectOrCreate?: CreatureCreateOrConnectWithoutSize_relationInput | CreatureCreateOrConnectWithoutSize_relationInput[]
    upsert?: CreatureUpsertWithWhereUniqueWithoutSize_relationInput | CreatureUpsertWithWhereUniqueWithoutSize_relationInput[]
    createMany?: CreatureCreateManySize_relationInputEnvelope
    set?: CreatureWhereUniqueInput | CreatureWhereUniqueInput[]
    disconnect?: CreatureWhereUniqueInput | CreatureWhereUniqueInput[]
    delete?: CreatureWhereUniqueInput | CreatureWhereUniqueInput[]
    connect?: CreatureWhereUniqueInput | CreatureWhereUniqueInput[]
    update?: CreatureUpdateWithWhereUniqueWithoutSize_relationInput | CreatureUpdateWithWhereUniqueWithoutSize_relationInput[]
    updateMany?: CreatureUpdateManyWithWhereWithoutSize_relationInput | CreatureUpdateManyWithWhereWithoutSize_relationInput[]
    deleteMany?: CreatureScalarWhereInput | CreatureScalarWhereInput[]
  }

  export type CreatureCreateNestedManyWithoutSource_relationInput = {
    create?: XOR<CreatureCreateWithoutSource_relationInput, CreatureUncheckedCreateWithoutSource_relationInput> | CreatureCreateWithoutSource_relationInput[] | CreatureUncheckedCreateWithoutSource_relationInput[]
    connectOrCreate?: CreatureCreateOrConnectWithoutSource_relationInput | CreatureCreateOrConnectWithoutSource_relationInput[]
    createMany?: CreatureCreateManySource_relationInputEnvelope
    connect?: CreatureWhereUniqueInput | CreatureWhereUniqueInput[]
  }

  export type MagicItemCreateNestedManyWithoutSource_relationInput = {
    create?: XOR<MagicItemCreateWithoutSource_relationInput, MagicItemUncheckedCreateWithoutSource_relationInput> | MagicItemCreateWithoutSource_relationInput[] | MagicItemUncheckedCreateWithoutSource_relationInput[]
    connectOrCreate?: MagicItemCreateOrConnectWithoutSource_relationInput | MagicItemCreateOrConnectWithoutSource_relationInput[]
    createMany?: MagicItemCreateManySource_relationInputEnvelope
    connect?: MagicItemWhereUniqueInput | MagicItemWhereUniqueInput[]
  }

  export type CreatureUncheckedCreateNestedManyWithoutSource_relationInput = {
    create?: XOR<CreatureCreateWithoutSource_relationInput, CreatureUncheckedCreateWithoutSource_relationInput> | CreatureCreateWithoutSource_relationInput[] | CreatureUncheckedCreateWithoutSource_relationInput[]
    connectOrCreate?: CreatureCreateOrConnectWithoutSource_relationInput | CreatureCreateOrConnectWithoutSource_relationInput[]
    createMany?: CreatureCreateManySource_relationInputEnvelope
    connect?: CreatureWhereUniqueInput | CreatureWhereUniqueInput[]
  }

  export type MagicItemUncheckedCreateNestedManyWithoutSource_relationInput = {
    create?: XOR<MagicItemCreateWithoutSource_relationInput, MagicItemUncheckedCreateWithoutSource_relationInput> | MagicItemCreateWithoutSource_relationInput[] | MagicItemUncheckedCreateWithoutSource_relationInput[]
    connectOrCreate?: MagicItemCreateOrConnectWithoutSource_relationInput | MagicItemCreateOrConnectWithoutSource_relationInput[]
    createMany?: MagicItemCreateManySource_relationInputEnvelope
    connect?: MagicItemWhereUniqueInput | MagicItemWhereUniqueInput[]
  }

  export type CreatureUpdateManyWithoutSource_relationNestedInput = {
    create?: XOR<CreatureCreateWithoutSource_relationInput, CreatureUncheckedCreateWithoutSource_relationInput> | CreatureCreateWithoutSource_relationInput[] | CreatureUncheckedCreateWithoutSource_relationInput[]
    connectOrCreate?: CreatureCreateOrConnectWithoutSource_relationInput | CreatureCreateOrConnectWithoutSource_relationInput[]
    upsert?: CreatureUpsertWithWhereUniqueWithoutSource_relationInput | CreatureUpsertWithWhereUniqueWithoutSource_relationInput[]
    createMany?: CreatureCreateManySource_relationInputEnvelope
    set?: CreatureWhereUniqueInput | CreatureWhereUniqueInput[]
    disconnect?: CreatureWhereUniqueInput | CreatureWhereUniqueInput[]
    delete?: CreatureWhereUniqueInput | CreatureWhereUniqueInput[]
    connect?: CreatureWhereUniqueInput | CreatureWhereUniqueInput[]
    update?: CreatureUpdateWithWhereUniqueWithoutSource_relationInput | CreatureUpdateWithWhereUniqueWithoutSource_relationInput[]
    updateMany?: CreatureUpdateManyWithWhereWithoutSource_relationInput | CreatureUpdateManyWithWhereWithoutSource_relationInput[]
    deleteMany?: CreatureScalarWhereInput | CreatureScalarWhereInput[]
  }

  export type MagicItemUpdateManyWithoutSource_relationNestedInput = {
    create?: XOR<MagicItemCreateWithoutSource_relationInput, MagicItemUncheckedCreateWithoutSource_relationInput> | MagicItemCreateWithoutSource_relationInput[] | MagicItemUncheckedCreateWithoutSource_relationInput[]
    connectOrCreate?: MagicItemCreateOrConnectWithoutSource_relationInput | MagicItemCreateOrConnectWithoutSource_relationInput[]
    upsert?: MagicItemUpsertWithWhereUniqueWithoutSource_relationInput | MagicItemUpsertWithWhereUniqueWithoutSource_relationInput[]
    createMany?: MagicItemCreateManySource_relationInputEnvelope
    set?: MagicItemWhereUniqueInput | MagicItemWhereUniqueInput[]
    disconnect?: MagicItemWhereUniqueInput | MagicItemWhereUniqueInput[]
    delete?: MagicItemWhereUniqueInput | MagicItemWhereUniqueInput[]
    connect?: MagicItemWhereUniqueInput | MagicItemWhereUniqueInput[]
    update?: MagicItemUpdateWithWhereUniqueWithoutSource_relationInput | MagicItemUpdateWithWhereUniqueWithoutSource_relationInput[]
    updateMany?: MagicItemUpdateManyWithWhereWithoutSource_relationInput | MagicItemUpdateManyWithWhereWithoutSource_relationInput[]
    deleteMany?: MagicItemScalarWhereInput | MagicItemScalarWhereInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type CreatureUncheckedUpdateManyWithoutSource_relationNestedInput = {
    create?: XOR<CreatureCreateWithoutSource_relationInput, CreatureUncheckedCreateWithoutSource_relationInput> | CreatureCreateWithoutSource_relationInput[] | CreatureUncheckedCreateWithoutSource_relationInput[]
    connectOrCreate?: CreatureCreateOrConnectWithoutSource_relationInput | CreatureCreateOrConnectWithoutSource_relationInput[]
    upsert?: CreatureUpsertWithWhereUniqueWithoutSource_relationInput | CreatureUpsertWithWhereUniqueWithoutSource_relationInput[]
    createMany?: CreatureCreateManySource_relationInputEnvelope
    set?: CreatureWhereUniqueInput | CreatureWhereUniqueInput[]
    disconnect?: CreatureWhereUniqueInput | CreatureWhereUniqueInput[]
    delete?: CreatureWhereUniqueInput | CreatureWhereUniqueInput[]
    connect?: CreatureWhereUniqueInput | CreatureWhereUniqueInput[]
    update?: CreatureUpdateWithWhereUniqueWithoutSource_relationInput | CreatureUpdateWithWhereUniqueWithoutSource_relationInput[]
    updateMany?: CreatureUpdateManyWithWhereWithoutSource_relationInput | CreatureUpdateManyWithWhereWithoutSource_relationInput[]
    deleteMany?: CreatureScalarWhereInput | CreatureScalarWhereInput[]
  }

  export type MagicItemUncheckedUpdateManyWithoutSource_relationNestedInput = {
    create?: XOR<MagicItemCreateWithoutSource_relationInput, MagicItemUncheckedCreateWithoutSource_relationInput> | MagicItemCreateWithoutSource_relationInput[] | MagicItemUncheckedCreateWithoutSource_relationInput[]
    connectOrCreate?: MagicItemCreateOrConnectWithoutSource_relationInput | MagicItemCreateOrConnectWithoutSource_relationInput[]
    upsert?: MagicItemUpsertWithWhereUniqueWithoutSource_relationInput | MagicItemUpsertWithWhereUniqueWithoutSource_relationInput[]
    createMany?: MagicItemCreateManySource_relationInputEnvelope
    set?: MagicItemWhereUniqueInput | MagicItemWhereUniqueInput[]
    disconnect?: MagicItemWhereUniqueInput | MagicItemWhereUniqueInput[]
    delete?: MagicItemWhereUniqueInput | MagicItemWhereUniqueInput[]
    connect?: MagicItemWhereUniqueInput | MagicItemWhereUniqueInput[]
    update?: MagicItemUpdateWithWhereUniqueWithoutSource_relationInput | MagicItemUpdateWithWhereUniqueWithoutSource_relationInput[]
    updateMany?: MagicItemUpdateManyWithWhereWithoutSource_relationInput | MagicItemUpdateManyWithWhereWithoutSource_relationInput[]
    deleteMany?: MagicItemScalarWhereInput | MagicItemScalarWhereInput[]
  }

  export type CreatureCreateNestedManyWithoutLanguages_relationInput = {
    create?: XOR<CreatureCreateWithoutLanguages_relationInput, CreatureUncheckedCreateWithoutLanguages_relationInput> | CreatureCreateWithoutLanguages_relationInput[] | CreatureUncheckedCreateWithoutLanguages_relationInput[]
    connectOrCreate?: CreatureCreateOrConnectWithoutLanguages_relationInput | CreatureCreateOrConnectWithoutLanguages_relationInput[]
    connect?: CreatureWhereUniqueInput | CreatureWhereUniqueInput[]
  }

  export type CreatureUncheckedCreateNestedManyWithoutLanguages_relationInput = {
    create?: XOR<CreatureCreateWithoutLanguages_relationInput, CreatureUncheckedCreateWithoutLanguages_relationInput> | CreatureCreateWithoutLanguages_relationInput[] | CreatureUncheckedCreateWithoutLanguages_relationInput[]
    connectOrCreate?: CreatureCreateOrConnectWithoutLanguages_relationInput | CreatureCreateOrConnectWithoutLanguages_relationInput[]
    connect?: CreatureWhereUniqueInput | CreatureWhereUniqueInput[]
  }

  export type CreatureUpdateManyWithoutLanguages_relationNestedInput = {
    create?: XOR<CreatureCreateWithoutLanguages_relationInput, CreatureUncheckedCreateWithoutLanguages_relationInput> | CreatureCreateWithoutLanguages_relationInput[] | CreatureUncheckedCreateWithoutLanguages_relationInput[]
    connectOrCreate?: CreatureCreateOrConnectWithoutLanguages_relationInput | CreatureCreateOrConnectWithoutLanguages_relationInput[]
    upsert?: CreatureUpsertWithWhereUniqueWithoutLanguages_relationInput | CreatureUpsertWithWhereUniqueWithoutLanguages_relationInput[]
    set?: CreatureWhereUniqueInput | CreatureWhereUniqueInput[]
    disconnect?: CreatureWhereUniqueInput | CreatureWhereUniqueInput[]
    delete?: CreatureWhereUniqueInput | CreatureWhereUniqueInput[]
    connect?: CreatureWhereUniqueInput | CreatureWhereUniqueInput[]
    update?: CreatureUpdateWithWhereUniqueWithoutLanguages_relationInput | CreatureUpdateWithWhereUniqueWithoutLanguages_relationInput[]
    updateMany?: CreatureUpdateManyWithWhereWithoutLanguages_relationInput | CreatureUpdateManyWithWhereWithoutLanguages_relationInput[]
    deleteMany?: CreatureScalarWhereInput | CreatureScalarWhereInput[]
  }

  export type CreatureUncheckedUpdateManyWithoutLanguages_relationNestedInput = {
    create?: XOR<CreatureCreateWithoutLanguages_relationInput, CreatureUncheckedCreateWithoutLanguages_relationInput> | CreatureCreateWithoutLanguages_relationInput[] | CreatureUncheckedCreateWithoutLanguages_relationInput[]
    connectOrCreate?: CreatureCreateOrConnectWithoutLanguages_relationInput | CreatureCreateOrConnectWithoutLanguages_relationInput[]
    upsert?: CreatureUpsertWithWhereUniqueWithoutLanguages_relationInput | CreatureUpsertWithWhereUniqueWithoutLanguages_relationInput[]
    set?: CreatureWhereUniqueInput | CreatureWhereUniqueInput[]
    disconnect?: CreatureWhereUniqueInput | CreatureWhereUniqueInput[]
    delete?: CreatureWhereUniqueInput | CreatureWhereUniqueInput[]
    connect?: CreatureWhereUniqueInput | CreatureWhereUniqueInput[]
    update?: CreatureUpdateWithWhereUniqueWithoutLanguages_relationInput | CreatureUpdateWithWhereUniqueWithoutLanguages_relationInput[]
    updateMany?: CreatureUpdateManyWithWhereWithoutLanguages_relationInput | CreatureUpdateManyWithWhereWithoutLanguages_relationInput[]
    deleteMany?: CreatureScalarWhereInput | CreatureScalarWhereInput[]
  }

  export type CreatureCreateNestedManyWithoutBiomes_relationInput = {
    create?: XOR<CreatureCreateWithoutBiomes_relationInput, CreatureUncheckedCreateWithoutBiomes_relationInput> | CreatureCreateWithoutBiomes_relationInput[] | CreatureUncheckedCreateWithoutBiomes_relationInput[]
    connectOrCreate?: CreatureCreateOrConnectWithoutBiomes_relationInput | CreatureCreateOrConnectWithoutBiomes_relationInput[]
    connect?: CreatureWhereUniqueInput | CreatureWhereUniqueInput[]
  }

  export type CreatureUncheckedCreateNestedManyWithoutBiomes_relationInput = {
    create?: XOR<CreatureCreateWithoutBiomes_relationInput, CreatureUncheckedCreateWithoutBiomes_relationInput> | CreatureCreateWithoutBiomes_relationInput[] | CreatureUncheckedCreateWithoutBiomes_relationInput[]
    connectOrCreate?: CreatureCreateOrConnectWithoutBiomes_relationInput | CreatureCreateOrConnectWithoutBiomes_relationInput[]
    connect?: CreatureWhereUniqueInput | CreatureWhereUniqueInput[]
  }

  export type CreatureUpdateManyWithoutBiomes_relationNestedInput = {
    create?: XOR<CreatureCreateWithoutBiomes_relationInput, CreatureUncheckedCreateWithoutBiomes_relationInput> | CreatureCreateWithoutBiomes_relationInput[] | CreatureUncheckedCreateWithoutBiomes_relationInput[]
    connectOrCreate?: CreatureCreateOrConnectWithoutBiomes_relationInput | CreatureCreateOrConnectWithoutBiomes_relationInput[]
    upsert?: CreatureUpsertWithWhereUniqueWithoutBiomes_relationInput | CreatureUpsertWithWhereUniqueWithoutBiomes_relationInput[]
    set?: CreatureWhereUniqueInput | CreatureWhereUniqueInput[]
    disconnect?: CreatureWhereUniqueInput | CreatureWhereUniqueInput[]
    delete?: CreatureWhereUniqueInput | CreatureWhereUniqueInput[]
    connect?: CreatureWhereUniqueInput | CreatureWhereUniqueInput[]
    update?: CreatureUpdateWithWhereUniqueWithoutBiomes_relationInput | CreatureUpdateWithWhereUniqueWithoutBiomes_relationInput[]
    updateMany?: CreatureUpdateManyWithWhereWithoutBiomes_relationInput | CreatureUpdateManyWithWhereWithoutBiomes_relationInput[]
    deleteMany?: CreatureScalarWhereInput | CreatureScalarWhereInput[]
  }

  export type CreatureUncheckedUpdateManyWithoutBiomes_relationNestedInput = {
    create?: XOR<CreatureCreateWithoutBiomes_relationInput, CreatureUncheckedCreateWithoutBiomes_relationInput> | CreatureCreateWithoutBiomes_relationInput[] | CreatureUncheckedCreateWithoutBiomes_relationInput[]
    connectOrCreate?: CreatureCreateOrConnectWithoutBiomes_relationInput | CreatureCreateOrConnectWithoutBiomes_relationInput[]
    upsert?: CreatureUpsertWithWhereUniqueWithoutBiomes_relationInput | CreatureUpsertWithWhereUniqueWithoutBiomes_relationInput[]
    set?: CreatureWhereUniqueInput | CreatureWhereUniqueInput[]
    disconnect?: CreatureWhereUniqueInput | CreatureWhereUniqueInput[]
    delete?: CreatureWhereUniqueInput | CreatureWhereUniqueInput[]
    connect?: CreatureWhereUniqueInput | CreatureWhereUniqueInput[]
    update?: CreatureUpdateWithWhereUniqueWithoutBiomes_relationInput | CreatureUpdateWithWhereUniqueWithoutBiomes_relationInput[]
    updateMany?: CreatureUpdateManyWithWhereWithoutBiomes_relationInput | CreatureUpdateManyWithWhereWithoutBiomes_relationInput[]
    deleteMany?: CreatureScalarWhereInput | CreatureScalarWhereInput[]
  }

  export type CreatureCreateNestedManyWithoutType_relationInput = {
    create?: XOR<CreatureCreateWithoutType_relationInput, CreatureUncheckedCreateWithoutType_relationInput> | CreatureCreateWithoutType_relationInput[] | CreatureUncheckedCreateWithoutType_relationInput[]
    connectOrCreate?: CreatureCreateOrConnectWithoutType_relationInput | CreatureCreateOrConnectWithoutType_relationInput[]
    createMany?: CreatureCreateManyType_relationInputEnvelope
    connect?: CreatureWhereUniqueInput | CreatureWhereUniqueInput[]
  }

  export type CreatureUncheckedCreateNestedManyWithoutType_relationInput = {
    create?: XOR<CreatureCreateWithoutType_relationInput, CreatureUncheckedCreateWithoutType_relationInput> | CreatureCreateWithoutType_relationInput[] | CreatureUncheckedCreateWithoutType_relationInput[]
    connectOrCreate?: CreatureCreateOrConnectWithoutType_relationInput | CreatureCreateOrConnectWithoutType_relationInput[]
    createMany?: CreatureCreateManyType_relationInputEnvelope
    connect?: CreatureWhereUniqueInput | CreatureWhereUniqueInput[]
  }

  export type CreatureUpdateManyWithoutType_relationNestedInput = {
    create?: XOR<CreatureCreateWithoutType_relationInput, CreatureUncheckedCreateWithoutType_relationInput> | CreatureCreateWithoutType_relationInput[] | CreatureUncheckedCreateWithoutType_relationInput[]
    connectOrCreate?: CreatureCreateOrConnectWithoutType_relationInput | CreatureCreateOrConnectWithoutType_relationInput[]
    upsert?: CreatureUpsertWithWhereUniqueWithoutType_relationInput | CreatureUpsertWithWhereUniqueWithoutType_relationInput[]
    createMany?: CreatureCreateManyType_relationInputEnvelope
    set?: CreatureWhereUniqueInput | CreatureWhereUniqueInput[]
    disconnect?: CreatureWhereUniqueInput | CreatureWhereUniqueInput[]
    delete?: CreatureWhereUniqueInput | CreatureWhereUniqueInput[]
    connect?: CreatureWhereUniqueInput | CreatureWhereUniqueInput[]
    update?: CreatureUpdateWithWhereUniqueWithoutType_relationInput | CreatureUpdateWithWhereUniqueWithoutType_relationInput[]
    updateMany?: CreatureUpdateManyWithWhereWithoutType_relationInput | CreatureUpdateManyWithWhereWithoutType_relationInput[]
    deleteMany?: CreatureScalarWhereInput | CreatureScalarWhereInput[]
  }

  export type CreatureUncheckedUpdateManyWithoutType_relationNestedInput = {
    create?: XOR<CreatureCreateWithoutType_relationInput, CreatureUncheckedCreateWithoutType_relationInput> | CreatureCreateWithoutType_relationInput[] | CreatureUncheckedCreateWithoutType_relationInput[]
    connectOrCreate?: CreatureCreateOrConnectWithoutType_relationInput | CreatureCreateOrConnectWithoutType_relationInput[]
    upsert?: CreatureUpsertWithWhereUniqueWithoutType_relationInput | CreatureUpsertWithWhereUniqueWithoutType_relationInput[]
    createMany?: CreatureCreateManyType_relationInputEnvelope
    set?: CreatureWhereUniqueInput | CreatureWhereUniqueInput[]
    disconnect?: CreatureWhereUniqueInput | CreatureWhereUniqueInput[]
    delete?: CreatureWhereUniqueInput | CreatureWhereUniqueInput[]
    connect?: CreatureWhereUniqueInput | CreatureWhereUniqueInput[]
    update?: CreatureUpdateWithWhereUniqueWithoutType_relationInput | CreatureUpdateWithWhereUniqueWithoutType_relationInput[]
    updateMany?: CreatureUpdateManyWithWhereWithoutType_relationInput | CreatureUpdateManyWithWhereWithoutType_relationInput[]
    deleteMany?: CreatureScalarWhereInput | CreatureScalarWhereInput[]
  }

  export type CreatureCreateNestedManyWithoutAlignment_relationInput = {
    create?: XOR<CreatureCreateWithoutAlignment_relationInput, CreatureUncheckedCreateWithoutAlignment_relationInput> | CreatureCreateWithoutAlignment_relationInput[] | CreatureUncheckedCreateWithoutAlignment_relationInput[]
    connectOrCreate?: CreatureCreateOrConnectWithoutAlignment_relationInput | CreatureCreateOrConnectWithoutAlignment_relationInput[]
    createMany?: CreatureCreateManyAlignment_relationInputEnvelope
    connect?: CreatureWhereUniqueInput | CreatureWhereUniqueInput[]
  }

  export type CreatureUncheckedCreateNestedManyWithoutAlignment_relationInput = {
    create?: XOR<CreatureCreateWithoutAlignment_relationInput, CreatureUncheckedCreateWithoutAlignment_relationInput> | CreatureCreateWithoutAlignment_relationInput[] | CreatureUncheckedCreateWithoutAlignment_relationInput[]
    connectOrCreate?: CreatureCreateOrConnectWithoutAlignment_relationInput | CreatureCreateOrConnectWithoutAlignment_relationInput[]
    createMany?: CreatureCreateManyAlignment_relationInputEnvelope
    connect?: CreatureWhereUniqueInput | CreatureWhereUniqueInput[]
  }

  export type CreatureUpdateManyWithoutAlignment_relationNestedInput = {
    create?: XOR<CreatureCreateWithoutAlignment_relationInput, CreatureUncheckedCreateWithoutAlignment_relationInput> | CreatureCreateWithoutAlignment_relationInput[] | CreatureUncheckedCreateWithoutAlignment_relationInput[]
    connectOrCreate?: CreatureCreateOrConnectWithoutAlignment_relationInput | CreatureCreateOrConnectWithoutAlignment_relationInput[]
    upsert?: CreatureUpsertWithWhereUniqueWithoutAlignment_relationInput | CreatureUpsertWithWhereUniqueWithoutAlignment_relationInput[]
    createMany?: CreatureCreateManyAlignment_relationInputEnvelope
    set?: CreatureWhereUniqueInput | CreatureWhereUniqueInput[]
    disconnect?: CreatureWhereUniqueInput | CreatureWhereUniqueInput[]
    delete?: CreatureWhereUniqueInput | CreatureWhereUniqueInput[]
    connect?: CreatureWhereUniqueInput | CreatureWhereUniqueInput[]
    update?: CreatureUpdateWithWhereUniqueWithoutAlignment_relationInput | CreatureUpdateWithWhereUniqueWithoutAlignment_relationInput[]
    updateMany?: CreatureUpdateManyWithWhereWithoutAlignment_relationInput | CreatureUpdateManyWithWhereWithoutAlignment_relationInput[]
    deleteMany?: CreatureScalarWhereInput | CreatureScalarWhereInput[]
  }

  export type CreatureUncheckedUpdateManyWithoutAlignment_relationNestedInput = {
    create?: XOR<CreatureCreateWithoutAlignment_relationInput, CreatureUncheckedCreateWithoutAlignment_relationInput> | CreatureCreateWithoutAlignment_relationInput[] | CreatureUncheckedCreateWithoutAlignment_relationInput[]
    connectOrCreate?: CreatureCreateOrConnectWithoutAlignment_relationInput | CreatureCreateOrConnectWithoutAlignment_relationInput[]
    upsert?: CreatureUpsertWithWhereUniqueWithoutAlignment_relationInput | CreatureUpsertWithWhereUniqueWithoutAlignment_relationInput[]
    createMany?: CreatureCreateManyAlignment_relationInputEnvelope
    set?: CreatureWhereUniqueInput | CreatureWhereUniqueInput[]
    disconnect?: CreatureWhereUniqueInput | CreatureWhereUniqueInput[]
    delete?: CreatureWhereUniqueInput | CreatureWhereUniqueInput[]
    connect?: CreatureWhereUniqueInput | CreatureWhereUniqueInput[]
    update?: CreatureUpdateWithWhereUniqueWithoutAlignment_relationInput | CreatureUpdateWithWhereUniqueWithoutAlignment_relationInput[]
    updateMany?: CreatureUpdateManyWithWhereWithoutAlignment_relationInput | CreatureUpdateManyWithWhereWithoutAlignment_relationInput[]
    deleteMany?: CreatureScalarWhereInput | CreatureScalarWhereInput[]
  }

  export type CreatureCreateNestedOneWithoutSpeedInput = {
    create?: XOR<CreatureCreateWithoutSpeedInput, CreatureUncheckedCreateWithoutSpeedInput>
    connectOrCreate?: CreatureCreateOrConnectWithoutSpeedInput
    connect?: CreatureWhereUniqueInput
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type CreatureUpdateOneRequiredWithoutSpeedNestedInput = {
    create?: XOR<CreatureCreateWithoutSpeedInput, CreatureUncheckedCreateWithoutSpeedInput>
    connectOrCreate?: CreatureCreateOrConnectWithoutSpeedInput
    upsert?: CreatureUpsertWithoutSpeedInput
    connect?: CreatureWhereUniqueInput
    update?: XOR<XOR<CreatureUpdateToOneWithWhereWithoutSpeedInput, CreatureUpdateWithoutSpeedInput>, CreatureUncheckedUpdateWithoutSpeedInput>
  }

  export type CreatureStatDetailCreateNestedManyWithoutCreature_stats_relationInput = {
    create?: XOR<CreatureStatDetailCreateWithoutCreature_stats_relationInput, CreatureStatDetailUncheckedCreateWithoutCreature_stats_relationInput> | CreatureStatDetailCreateWithoutCreature_stats_relationInput[] | CreatureStatDetailUncheckedCreateWithoutCreature_stats_relationInput[]
    connectOrCreate?: CreatureStatDetailCreateOrConnectWithoutCreature_stats_relationInput | CreatureStatDetailCreateOrConnectWithoutCreature_stats_relationInput[]
    createMany?: CreatureStatDetailCreateManyCreature_stats_relationInputEnvelope
    connect?: CreatureStatDetailWhereUniqueInput | CreatureStatDetailWhereUniqueInput[]
  }

  export type CreatureCreateNestedOneWithoutStatsInput = {
    create?: XOR<CreatureCreateWithoutStatsInput, CreatureUncheckedCreateWithoutStatsInput>
    connectOrCreate?: CreatureCreateOrConnectWithoutStatsInput
    connect?: CreatureWhereUniqueInput
  }

  export type CreatureStatDetailUncheckedCreateNestedManyWithoutCreature_stats_relationInput = {
    create?: XOR<CreatureStatDetailCreateWithoutCreature_stats_relationInput, CreatureStatDetailUncheckedCreateWithoutCreature_stats_relationInput> | CreatureStatDetailCreateWithoutCreature_stats_relationInput[] | CreatureStatDetailUncheckedCreateWithoutCreature_stats_relationInput[]
    connectOrCreate?: CreatureStatDetailCreateOrConnectWithoutCreature_stats_relationInput | CreatureStatDetailCreateOrConnectWithoutCreature_stats_relationInput[]
    createMany?: CreatureStatDetailCreateManyCreature_stats_relationInputEnvelope
    connect?: CreatureStatDetailWhereUniqueInput | CreatureStatDetailWhereUniqueInput[]
  }

  export type CreatureStatDetailUpdateManyWithoutCreature_stats_relationNestedInput = {
    create?: XOR<CreatureStatDetailCreateWithoutCreature_stats_relationInput, CreatureStatDetailUncheckedCreateWithoutCreature_stats_relationInput> | CreatureStatDetailCreateWithoutCreature_stats_relationInput[] | CreatureStatDetailUncheckedCreateWithoutCreature_stats_relationInput[]
    connectOrCreate?: CreatureStatDetailCreateOrConnectWithoutCreature_stats_relationInput | CreatureStatDetailCreateOrConnectWithoutCreature_stats_relationInput[]
    upsert?: CreatureStatDetailUpsertWithWhereUniqueWithoutCreature_stats_relationInput | CreatureStatDetailUpsertWithWhereUniqueWithoutCreature_stats_relationInput[]
    createMany?: CreatureStatDetailCreateManyCreature_stats_relationInputEnvelope
    set?: CreatureStatDetailWhereUniqueInput | CreatureStatDetailWhereUniqueInput[]
    disconnect?: CreatureStatDetailWhereUniqueInput | CreatureStatDetailWhereUniqueInput[]
    delete?: CreatureStatDetailWhereUniqueInput | CreatureStatDetailWhereUniqueInput[]
    connect?: CreatureStatDetailWhereUniqueInput | CreatureStatDetailWhereUniqueInput[]
    update?: CreatureStatDetailUpdateWithWhereUniqueWithoutCreature_stats_relationInput | CreatureStatDetailUpdateWithWhereUniqueWithoutCreature_stats_relationInput[]
    updateMany?: CreatureStatDetailUpdateManyWithWhereWithoutCreature_stats_relationInput | CreatureStatDetailUpdateManyWithWhereWithoutCreature_stats_relationInput[]
    deleteMany?: CreatureStatDetailScalarWhereInput | CreatureStatDetailScalarWhereInput[]
  }

  export type CreatureUpdateOneRequiredWithoutStatsNestedInput = {
    create?: XOR<CreatureCreateWithoutStatsInput, CreatureUncheckedCreateWithoutStatsInput>
    connectOrCreate?: CreatureCreateOrConnectWithoutStatsInput
    upsert?: CreatureUpsertWithoutStatsInput
    connect?: CreatureWhereUniqueInput
    update?: XOR<XOR<CreatureUpdateToOneWithWhereWithoutStatsInput, CreatureUpdateWithoutStatsInput>, CreatureUncheckedUpdateWithoutStatsInput>
  }

  export type CreatureStatDetailUncheckedUpdateManyWithoutCreature_stats_relationNestedInput = {
    create?: XOR<CreatureStatDetailCreateWithoutCreature_stats_relationInput, CreatureStatDetailUncheckedCreateWithoutCreature_stats_relationInput> | CreatureStatDetailCreateWithoutCreature_stats_relationInput[] | CreatureStatDetailUncheckedCreateWithoutCreature_stats_relationInput[]
    connectOrCreate?: CreatureStatDetailCreateOrConnectWithoutCreature_stats_relationInput | CreatureStatDetailCreateOrConnectWithoutCreature_stats_relationInput[]
    upsert?: CreatureStatDetailUpsertWithWhereUniqueWithoutCreature_stats_relationInput | CreatureStatDetailUpsertWithWhereUniqueWithoutCreature_stats_relationInput[]
    createMany?: CreatureStatDetailCreateManyCreature_stats_relationInputEnvelope
    set?: CreatureStatDetailWhereUniqueInput | CreatureStatDetailWhereUniqueInput[]
    disconnect?: CreatureStatDetailWhereUniqueInput | CreatureStatDetailWhereUniqueInput[]
    delete?: CreatureStatDetailWhereUniqueInput | CreatureStatDetailWhereUniqueInput[]
    connect?: CreatureStatDetailWhereUniqueInput | CreatureStatDetailWhereUniqueInput[]
    update?: CreatureStatDetailUpdateWithWhereUniqueWithoutCreature_stats_relationInput | CreatureStatDetailUpdateWithWhereUniqueWithoutCreature_stats_relationInput[]
    updateMany?: CreatureStatDetailUpdateManyWithWhereWithoutCreature_stats_relationInput | CreatureStatDetailUpdateManyWithWhereWithoutCreature_stats_relationInput[]
    deleteMany?: CreatureStatDetailScalarWhereInput | CreatureStatDetailScalarWhereInput[]
  }

  export type CreatureStatsCreateNestedOneWithoutStatsInput = {
    create?: XOR<CreatureStatsCreateWithoutStatsInput, CreatureStatsUncheckedCreateWithoutStatsInput>
    connectOrCreate?: CreatureStatsCreateOrConnectWithoutStatsInput
    connect?: CreatureStatsWhereUniqueInput
  }

  export type EnumAbilityFieldUpdateOperationsInput = {
    set?: $Enums.Ability
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type CreatureStatsUpdateOneRequiredWithoutStatsNestedInput = {
    create?: XOR<CreatureStatsCreateWithoutStatsInput, CreatureStatsUncheckedCreateWithoutStatsInput>
    connectOrCreate?: CreatureStatsCreateOrConnectWithoutStatsInput
    upsert?: CreatureStatsUpsertWithoutStatsInput
    connect?: CreatureStatsWhereUniqueInput
    update?: XOR<XOR<CreatureStatsUpdateToOneWithWhereWithoutStatsInput, CreatureStatsUpdateWithoutStatsInput>, CreatureStatsUncheckedUpdateWithoutStatsInput>
  }

  export type CreatureSkillDetailCreateNestedManyWithoutCreature_skills_relationInput = {
    create?: XOR<CreatureSkillDetailCreateWithoutCreature_skills_relationInput, CreatureSkillDetailUncheckedCreateWithoutCreature_skills_relationInput> | CreatureSkillDetailCreateWithoutCreature_skills_relationInput[] | CreatureSkillDetailUncheckedCreateWithoutCreature_skills_relationInput[]
    connectOrCreate?: CreatureSkillDetailCreateOrConnectWithoutCreature_skills_relationInput | CreatureSkillDetailCreateOrConnectWithoutCreature_skills_relationInput[]
    createMany?: CreatureSkillDetailCreateManyCreature_skills_relationInputEnvelope
    connect?: CreatureSkillDetailWhereUniqueInput | CreatureSkillDetailWhereUniqueInput[]
  }

  export type CreatureCreateNestedOneWithoutSkillsInput = {
    create?: XOR<CreatureCreateWithoutSkillsInput, CreatureUncheckedCreateWithoutSkillsInput>
    connectOrCreate?: CreatureCreateOrConnectWithoutSkillsInput
    connect?: CreatureWhereUniqueInput
  }

  export type CreatureSkillDetailUncheckedCreateNestedManyWithoutCreature_skills_relationInput = {
    create?: XOR<CreatureSkillDetailCreateWithoutCreature_skills_relationInput, CreatureSkillDetailUncheckedCreateWithoutCreature_skills_relationInput> | CreatureSkillDetailCreateWithoutCreature_skills_relationInput[] | CreatureSkillDetailUncheckedCreateWithoutCreature_skills_relationInput[]
    connectOrCreate?: CreatureSkillDetailCreateOrConnectWithoutCreature_skills_relationInput | CreatureSkillDetailCreateOrConnectWithoutCreature_skills_relationInput[]
    createMany?: CreatureSkillDetailCreateManyCreature_skills_relationInputEnvelope
    connect?: CreatureSkillDetailWhereUniqueInput | CreatureSkillDetailWhereUniqueInput[]
  }

  export type CreatureSkillDetailUpdateManyWithoutCreature_skills_relationNestedInput = {
    create?: XOR<CreatureSkillDetailCreateWithoutCreature_skills_relationInput, CreatureSkillDetailUncheckedCreateWithoutCreature_skills_relationInput> | CreatureSkillDetailCreateWithoutCreature_skills_relationInput[] | CreatureSkillDetailUncheckedCreateWithoutCreature_skills_relationInput[]
    connectOrCreate?: CreatureSkillDetailCreateOrConnectWithoutCreature_skills_relationInput | CreatureSkillDetailCreateOrConnectWithoutCreature_skills_relationInput[]
    upsert?: CreatureSkillDetailUpsertWithWhereUniqueWithoutCreature_skills_relationInput | CreatureSkillDetailUpsertWithWhereUniqueWithoutCreature_skills_relationInput[]
    createMany?: CreatureSkillDetailCreateManyCreature_skills_relationInputEnvelope
    set?: CreatureSkillDetailWhereUniqueInput | CreatureSkillDetailWhereUniqueInput[]
    disconnect?: CreatureSkillDetailWhereUniqueInput | CreatureSkillDetailWhereUniqueInput[]
    delete?: CreatureSkillDetailWhereUniqueInput | CreatureSkillDetailWhereUniqueInput[]
    connect?: CreatureSkillDetailWhereUniqueInput | CreatureSkillDetailWhereUniqueInput[]
    update?: CreatureSkillDetailUpdateWithWhereUniqueWithoutCreature_skills_relationInput | CreatureSkillDetailUpdateWithWhereUniqueWithoutCreature_skills_relationInput[]
    updateMany?: CreatureSkillDetailUpdateManyWithWhereWithoutCreature_skills_relationInput | CreatureSkillDetailUpdateManyWithWhereWithoutCreature_skills_relationInput[]
    deleteMany?: CreatureSkillDetailScalarWhereInput | CreatureSkillDetailScalarWhereInput[]
  }

  export type CreatureUpdateOneRequiredWithoutSkillsNestedInput = {
    create?: XOR<CreatureCreateWithoutSkillsInput, CreatureUncheckedCreateWithoutSkillsInput>
    connectOrCreate?: CreatureCreateOrConnectWithoutSkillsInput
    upsert?: CreatureUpsertWithoutSkillsInput
    connect?: CreatureWhereUniqueInput
    update?: XOR<XOR<CreatureUpdateToOneWithWhereWithoutSkillsInput, CreatureUpdateWithoutSkillsInput>, CreatureUncheckedUpdateWithoutSkillsInput>
  }

  export type CreatureSkillDetailUncheckedUpdateManyWithoutCreature_skills_relationNestedInput = {
    create?: XOR<CreatureSkillDetailCreateWithoutCreature_skills_relationInput, CreatureSkillDetailUncheckedCreateWithoutCreature_skills_relationInput> | CreatureSkillDetailCreateWithoutCreature_skills_relationInput[] | CreatureSkillDetailUncheckedCreateWithoutCreature_skills_relationInput[]
    connectOrCreate?: CreatureSkillDetailCreateOrConnectWithoutCreature_skills_relationInput | CreatureSkillDetailCreateOrConnectWithoutCreature_skills_relationInput[]
    upsert?: CreatureSkillDetailUpsertWithWhereUniqueWithoutCreature_skills_relationInput | CreatureSkillDetailUpsertWithWhereUniqueWithoutCreature_skills_relationInput[]
    createMany?: CreatureSkillDetailCreateManyCreature_skills_relationInputEnvelope
    set?: CreatureSkillDetailWhereUniqueInput | CreatureSkillDetailWhereUniqueInput[]
    disconnect?: CreatureSkillDetailWhereUniqueInput | CreatureSkillDetailWhereUniqueInput[]
    delete?: CreatureSkillDetailWhereUniqueInput | CreatureSkillDetailWhereUniqueInput[]
    connect?: CreatureSkillDetailWhereUniqueInput | CreatureSkillDetailWhereUniqueInput[]
    update?: CreatureSkillDetailUpdateWithWhereUniqueWithoutCreature_skills_relationInput | CreatureSkillDetailUpdateWithWhereUniqueWithoutCreature_skills_relationInput[]
    updateMany?: CreatureSkillDetailUpdateManyWithWhereWithoutCreature_skills_relationInput | CreatureSkillDetailUpdateManyWithWhereWithoutCreature_skills_relationInput[]
    deleteMany?: CreatureSkillDetailScalarWhereInput | CreatureSkillDetailScalarWhereInput[]
  }

  export type CreatureSkillsCreateNestedOneWithoutSkillsInput = {
    create?: XOR<CreatureSkillsCreateWithoutSkillsInput, CreatureSkillsUncheckedCreateWithoutSkillsInput>
    connectOrCreate?: CreatureSkillsCreateOrConnectWithoutSkillsInput
    connect?: CreatureSkillsWhereUniqueInput
  }

  export type EnumSkillFieldUpdateOperationsInput = {
    set?: $Enums.Skill
  }

  export type CreatureSkillsUpdateOneRequiredWithoutSkillsNestedInput = {
    create?: XOR<CreatureSkillsCreateWithoutSkillsInput, CreatureSkillsUncheckedCreateWithoutSkillsInput>
    connectOrCreate?: CreatureSkillsCreateOrConnectWithoutSkillsInput
    upsert?: CreatureSkillsUpsertWithoutSkillsInput
    connect?: CreatureSkillsWhereUniqueInput
    update?: XOR<XOR<CreatureSkillsUpdateToOneWithWhereWithoutSkillsInput, CreatureSkillsUpdateWithoutSkillsInput>, CreatureSkillsUncheckedUpdateWithoutSkillsInput>
  }

  export type CreatureSpeedCreateNestedOneWithoutCreature_relationInput = {
    create?: XOR<CreatureSpeedCreateWithoutCreature_relationInput, CreatureSpeedUncheckedCreateWithoutCreature_relationInput>
    connectOrCreate?: CreatureSpeedCreateOrConnectWithoutCreature_relationInput
    connect?: CreatureSpeedWhereUniqueInput
  }

  export type CreatureStatsCreateNestedOneWithoutCreature_relationInput = {
    create?: XOR<CreatureStatsCreateWithoutCreature_relationInput, CreatureStatsUncheckedCreateWithoutCreature_relationInput>
    connectOrCreate?: CreatureStatsCreateOrConnectWithoutCreature_relationInput
    connect?: CreatureStatsWhereUniqueInput
  }

  export type CreatureSkillsCreateNestedOneWithoutCreature_relationInput = {
    create?: XOR<CreatureSkillsCreateWithoutCreature_relationInput, CreatureSkillsUncheckedCreateWithoutCreature_relationInput>
    connectOrCreate?: CreatureSkillsCreateOrConnectWithoutCreature_relationInput
    connect?: CreatureSkillsWhereUniqueInput
  }

  export type CreatureSensesCreateNestedOneWithoutCreature_relationInput = {
    create?: XOR<CreatureSensesCreateWithoutCreature_relationInput, CreatureSensesUncheckedCreateWithoutCreature_relationInput>
    connectOrCreate?: CreatureSensesCreateOrConnectWithoutCreature_relationInput
    connect?: CreatureSensesWhereUniqueInput
  }

  export type ChallengeRatingMetadataCreateNestedOneWithoutCreaturesInput = {
    create?: XOR<ChallengeRatingMetadataCreateWithoutCreaturesInput, ChallengeRatingMetadataUncheckedCreateWithoutCreaturesInput>
    connectOrCreate?: ChallengeRatingMetadataCreateOrConnectWithoutCreaturesInput
    connect?: ChallengeRatingMetadataWhereUniqueInput
  }

  export type AlignmentCreateNestedOneWithoutCreaturesInput = {
    create?: XOR<AlignmentCreateWithoutCreaturesInput, AlignmentUncheckedCreateWithoutCreaturesInput>
    connectOrCreate?: AlignmentCreateOrConnectWithoutCreaturesInput
    connect?: AlignmentWhereUniqueInput
  }

  export type CreatureRaceCreateNestedOneWithoutCreatures_relationInput = {
    create?: XOR<CreatureRaceCreateWithoutCreatures_relationInput, CreatureRaceUncheckedCreateWithoutCreatures_relationInput>
    connectOrCreate?: CreatureRaceCreateOrConnectWithoutCreatures_relationInput
    connect?: CreatureRaceWhereUniqueInput
  }

  export type TypeCreateNestedOneWithoutCreaturesInput = {
    create?: XOR<TypeCreateWithoutCreaturesInput, TypeUncheckedCreateWithoutCreaturesInput>
    connectOrCreate?: TypeCreateOrConnectWithoutCreaturesInput
    connect?: TypeWhereUniqueInput
  }

  export type SizeCreateNestedOneWithoutCreatureInput = {
    create?: XOR<SizeCreateWithoutCreatureInput, SizeUncheckedCreateWithoutCreatureInput>
    connectOrCreate?: SizeCreateOrConnectWithoutCreatureInput
    connect?: SizeWhereUniqueInput
  }

  export type SourceCreateNestedOneWithoutCreaturesInput = {
    create?: XOR<SourceCreateWithoutCreaturesInput, SourceUncheckedCreateWithoutCreaturesInput>
    connectOrCreate?: SourceCreateOrConnectWithoutCreaturesInput
    connect?: SourceWhereUniqueInput
  }

  export type DamageTypeCreateNestedManyWithoutResistant_creatures_relationInput = {
    create?: XOR<DamageTypeCreateWithoutResistant_creatures_relationInput, DamageTypeUncheckedCreateWithoutResistant_creatures_relationInput> | DamageTypeCreateWithoutResistant_creatures_relationInput[] | DamageTypeUncheckedCreateWithoutResistant_creatures_relationInput[]
    connectOrCreate?: DamageTypeCreateOrConnectWithoutResistant_creatures_relationInput | DamageTypeCreateOrConnectWithoutResistant_creatures_relationInput[]
    connect?: DamageTypeWhereUniqueInput | DamageTypeWhereUniqueInput[]
  }

  export type DamageTypeCreateNestedManyWithoutImmune_creatures_relationInput = {
    create?: XOR<DamageTypeCreateWithoutImmune_creatures_relationInput, DamageTypeUncheckedCreateWithoutImmune_creatures_relationInput> | DamageTypeCreateWithoutImmune_creatures_relationInput[] | DamageTypeUncheckedCreateWithoutImmune_creatures_relationInput[]
    connectOrCreate?: DamageTypeCreateOrConnectWithoutImmune_creatures_relationInput | DamageTypeCreateOrConnectWithoutImmune_creatures_relationInput[]
    connect?: DamageTypeWhereUniqueInput | DamageTypeWhereUniqueInput[]
  }

  export type DamageTypeCreateNestedManyWithoutVulnerable_creatures_relationInput = {
    create?: XOR<DamageTypeCreateWithoutVulnerable_creatures_relationInput, DamageTypeUncheckedCreateWithoutVulnerable_creatures_relationInput> | DamageTypeCreateWithoutVulnerable_creatures_relationInput[] | DamageTypeUncheckedCreateWithoutVulnerable_creatures_relationInput[]
    connectOrCreate?: DamageTypeCreateOrConnectWithoutVulnerable_creatures_relationInput | DamageTypeCreateOrConnectWithoutVulnerable_creatures_relationInput[]
    connect?: DamageTypeWhereUniqueInput | DamageTypeWhereUniqueInput[]
  }

  export type LanguageCreateNestedManyWithoutCreatures_relationInput = {
    create?: XOR<LanguageCreateWithoutCreatures_relationInput, LanguageUncheckedCreateWithoutCreatures_relationInput> | LanguageCreateWithoutCreatures_relationInput[] | LanguageUncheckedCreateWithoutCreatures_relationInput[]
    connectOrCreate?: LanguageCreateOrConnectWithoutCreatures_relationInput | LanguageCreateOrConnectWithoutCreatures_relationInput[]
    connect?: LanguageWhereUniqueInput | LanguageWhereUniqueInput[]
  }

  export type BiomeCreateNestedManyWithoutCreatures_relationInput = {
    create?: XOR<BiomeCreateWithoutCreatures_relationInput, BiomeUncheckedCreateWithoutCreatures_relationInput> | BiomeCreateWithoutCreatures_relationInput[] | BiomeUncheckedCreateWithoutCreatures_relationInput[]
    connectOrCreate?: BiomeCreateOrConnectWithoutCreatures_relationInput | BiomeCreateOrConnectWithoutCreatures_relationInput[]
    connect?: BiomeWhereUniqueInput | BiomeWhereUniqueInput[]
  }

  export type ActionCreateNestedManyWithoutCreatures_relationInput = {
    create?: XOR<ActionCreateWithoutCreatures_relationInput, ActionUncheckedCreateWithoutCreatures_relationInput> | ActionCreateWithoutCreatures_relationInput[] | ActionUncheckedCreateWithoutCreatures_relationInput[]
    connectOrCreate?: ActionCreateOrConnectWithoutCreatures_relationInput | ActionCreateOrConnectWithoutCreatures_relationInput[]
    connect?: ActionWhereUniqueInput | ActionWhereUniqueInput[]
  }

  export type TraitCreateNestedManyWithoutCreatures_relationInput = {
    create?: XOR<TraitCreateWithoutCreatures_relationInput, TraitUncheckedCreateWithoutCreatures_relationInput> | TraitCreateWithoutCreatures_relationInput[] | TraitUncheckedCreateWithoutCreatures_relationInput[]
    connectOrCreate?: TraitCreateOrConnectWithoutCreatures_relationInput | TraitCreateOrConnectWithoutCreatures_relationInput[]
    connect?: TraitWhereUniqueInput | TraitWhereUniqueInput[]
  }

  export type CreatureSpeedUncheckedCreateNestedOneWithoutCreature_relationInput = {
    create?: XOR<CreatureSpeedCreateWithoutCreature_relationInput, CreatureSpeedUncheckedCreateWithoutCreature_relationInput>
    connectOrCreate?: CreatureSpeedCreateOrConnectWithoutCreature_relationInput
    connect?: CreatureSpeedWhereUniqueInput
  }

  export type CreatureStatsUncheckedCreateNestedOneWithoutCreature_relationInput = {
    create?: XOR<CreatureStatsCreateWithoutCreature_relationInput, CreatureStatsUncheckedCreateWithoutCreature_relationInput>
    connectOrCreate?: CreatureStatsCreateOrConnectWithoutCreature_relationInput
    connect?: CreatureStatsWhereUniqueInput
  }

  export type CreatureSkillsUncheckedCreateNestedOneWithoutCreature_relationInput = {
    create?: XOR<CreatureSkillsCreateWithoutCreature_relationInput, CreatureSkillsUncheckedCreateWithoutCreature_relationInput>
    connectOrCreate?: CreatureSkillsCreateOrConnectWithoutCreature_relationInput
    connect?: CreatureSkillsWhereUniqueInput
  }

  export type CreatureSensesUncheckedCreateNestedOneWithoutCreature_relationInput = {
    create?: XOR<CreatureSensesCreateWithoutCreature_relationInput, CreatureSensesUncheckedCreateWithoutCreature_relationInput>
    connectOrCreate?: CreatureSensesCreateOrConnectWithoutCreature_relationInput
    connect?: CreatureSensesWhereUniqueInput
  }

  export type DamageTypeUncheckedCreateNestedManyWithoutResistant_creatures_relationInput = {
    create?: XOR<DamageTypeCreateWithoutResistant_creatures_relationInput, DamageTypeUncheckedCreateWithoutResistant_creatures_relationInput> | DamageTypeCreateWithoutResistant_creatures_relationInput[] | DamageTypeUncheckedCreateWithoutResistant_creatures_relationInput[]
    connectOrCreate?: DamageTypeCreateOrConnectWithoutResistant_creatures_relationInput | DamageTypeCreateOrConnectWithoutResistant_creatures_relationInput[]
    connect?: DamageTypeWhereUniqueInput | DamageTypeWhereUniqueInput[]
  }

  export type DamageTypeUncheckedCreateNestedManyWithoutImmune_creatures_relationInput = {
    create?: XOR<DamageTypeCreateWithoutImmune_creatures_relationInput, DamageTypeUncheckedCreateWithoutImmune_creatures_relationInput> | DamageTypeCreateWithoutImmune_creatures_relationInput[] | DamageTypeUncheckedCreateWithoutImmune_creatures_relationInput[]
    connectOrCreate?: DamageTypeCreateOrConnectWithoutImmune_creatures_relationInput | DamageTypeCreateOrConnectWithoutImmune_creatures_relationInput[]
    connect?: DamageTypeWhereUniqueInput | DamageTypeWhereUniqueInput[]
  }

  export type DamageTypeUncheckedCreateNestedManyWithoutVulnerable_creatures_relationInput = {
    create?: XOR<DamageTypeCreateWithoutVulnerable_creatures_relationInput, DamageTypeUncheckedCreateWithoutVulnerable_creatures_relationInput> | DamageTypeCreateWithoutVulnerable_creatures_relationInput[] | DamageTypeUncheckedCreateWithoutVulnerable_creatures_relationInput[]
    connectOrCreate?: DamageTypeCreateOrConnectWithoutVulnerable_creatures_relationInput | DamageTypeCreateOrConnectWithoutVulnerable_creatures_relationInput[]
    connect?: DamageTypeWhereUniqueInput | DamageTypeWhereUniqueInput[]
  }

  export type LanguageUncheckedCreateNestedManyWithoutCreatures_relationInput = {
    create?: XOR<LanguageCreateWithoutCreatures_relationInput, LanguageUncheckedCreateWithoutCreatures_relationInput> | LanguageCreateWithoutCreatures_relationInput[] | LanguageUncheckedCreateWithoutCreatures_relationInput[]
    connectOrCreate?: LanguageCreateOrConnectWithoutCreatures_relationInput | LanguageCreateOrConnectWithoutCreatures_relationInput[]
    connect?: LanguageWhereUniqueInput | LanguageWhereUniqueInput[]
  }

  export type BiomeUncheckedCreateNestedManyWithoutCreatures_relationInput = {
    create?: XOR<BiomeCreateWithoutCreatures_relationInput, BiomeUncheckedCreateWithoutCreatures_relationInput> | BiomeCreateWithoutCreatures_relationInput[] | BiomeUncheckedCreateWithoutCreatures_relationInput[]
    connectOrCreate?: BiomeCreateOrConnectWithoutCreatures_relationInput | BiomeCreateOrConnectWithoutCreatures_relationInput[]
    connect?: BiomeWhereUniqueInput | BiomeWhereUniqueInput[]
  }

  export type ActionUncheckedCreateNestedManyWithoutCreatures_relationInput = {
    create?: XOR<ActionCreateWithoutCreatures_relationInput, ActionUncheckedCreateWithoutCreatures_relationInput> | ActionCreateWithoutCreatures_relationInput[] | ActionUncheckedCreateWithoutCreatures_relationInput[]
    connectOrCreate?: ActionCreateOrConnectWithoutCreatures_relationInput | ActionCreateOrConnectWithoutCreatures_relationInput[]
    connect?: ActionWhereUniqueInput | ActionWhereUniqueInput[]
  }

  export type TraitUncheckedCreateNestedManyWithoutCreatures_relationInput = {
    create?: XOR<TraitCreateWithoutCreatures_relationInput, TraitUncheckedCreateWithoutCreatures_relationInput> | TraitCreateWithoutCreatures_relationInput[] | TraitUncheckedCreateWithoutCreatures_relationInput[]
    connectOrCreate?: TraitCreateOrConnectWithoutCreatures_relationInput | TraitCreateOrConnectWithoutCreatures_relationInput[]
    connect?: TraitWhereUniqueInput | TraitWhereUniqueInput[]
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type CreatureSpeedUpdateOneWithoutCreature_relationNestedInput = {
    create?: XOR<CreatureSpeedCreateWithoutCreature_relationInput, CreatureSpeedUncheckedCreateWithoutCreature_relationInput>
    connectOrCreate?: CreatureSpeedCreateOrConnectWithoutCreature_relationInput
    upsert?: CreatureSpeedUpsertWithoutCreature_relationInput
    disconnect?: CreatureSpeedWhereInput | boolean
    delete?: CreatureSpeedWhereInput | boolean
    connect?: CreatureSpeedWhereUniqueInput
    update?: XOR<XOR<CreatureSpeedUpdateToOneWithWhereWithoutCreature_relationInput, CreatureSpeedUpdateWithoutCreature_relationInput>, CreatureSpeedUncheckedUpdateWithoutCreature_relationInput>
  }

  export type CreatureStatsUpdateOneWithoutCreature_relationNestedInput = {
    create?: XOR<CreatureStatsCreateWithoutCreature_relationInput, CreatureStatsUncheckedCreateWithoutCreature_relationInput>
    connectOrCreate?: CreatureStatsCreateOrConnectWithoutCreature_relationInput
    upsert?: CreatureStatsUpsertWithoutCreature_relationInput
    disconnect?: CreatureStatsWhereInput | boolean
    delete?: CreatureStatsWhereInput | boolean
    connect?: CreatureStatsWhereUniqueInput
    update?: XOR<XOR<CreatureStatsUpdateToOneWithWhereWithoutCreature_relationInput, CreatureStatsUpdateWithoutCreature_relationInput>, CreatureStatsUncheckedUpdateWithoutCreature_relationInput>
  }

  export type CreatureSkillsUpdateOneWithoutCreature_relationNestedInput = {
    create?: XOR<CreatureSkillsCreateWithoutCreature_relationInput, CreatureSkillsUncheckedCreateWithoutCreature_relationInput>
    connectOrCreate?: CreatureSkillsCreateOrConnectWithoutCreature_relationInput
    upsert?: CreatureSkillsUpsertWithoutCreature_relationInput
    disconnect?: CreatureSkillsWhereInput | boolean
    delete?: CreatureSkillsWhereInput | boolean
    connect?: CreatureSkillsWhereUniqueInput
    update?: XOR<XOR<CreatureSkillsUpdateToOneWithWhereWithoutCreature_relationInput, CreatureSkillsUpdateWithoutCreature_relationInput>, CreatureSkillsUncheckedUpdateWithoutCreature_relationInput>
  }

  export type CreatureSensesUpdateOneWithoutCreature_relationNestedInput = {
    create?: XOR<CreatureSensesCreateWithoutCreature_relationInput, CreatureSensesUncheckedCreateWithoutCreature_relationInput>
    connectOrCreate?: CreatureSensesCreateOrConnectWithoutCreature_relationInput
    upsert?: CreatureSensesUpsertWithoutCreature_relationInput
    disconnect?: CreatureSensesWhereInput | boolean
    delete?: CreatureSensesWhereInput | boolean
    connect?: CreatureSensesWhereUniqueInput
    update?: XOR<XOR<CreatureSensesUpdateToOneWithWhereWithoutCreature_relationInput, CreatureSensesUpdateWithoutCreature_relationInput>, CreatureSensesUncheckedUpdateWithoutCreature_relationInput>
  }

  export type ChallengeRatingMetadataUpdateOneRequiredWithoutCreaturesNestedInput = {
    create?: XOR<ChallengeRatingMetadataCreateWithoutCreaturesInput, ChallengeRatingMetadataUncheckedCreateWithoutCreaturesInput>
    connectOrCreate?: ChallengeRatingMetadataCreateOrConnectWithoutCreaturesInput
    upsert?: ChallengeRatingMetadataUpsertWithoutCreaturesInput
    connect?: ChallengeRatingMetadataWhereUniqueInput
    update?: XOR<XOR<ChallengeRatingMetadataUpdateToOneWithWhereWithoutCreaturesInput, ChallengeRatingMetadataUpdateWithoutCreaturesInput>, ChallengeRatingMetadataUncheckedUpdateWithoutCreaturesInput>
  }

  export type AlignmentUpdateOneWithoutCreaturesNestedInput = {
    create?: XOR<AlignmentCreateWithoutCreaturesInput, AlignmentUncheckedCreateWithoutCreaturesInput>
    connectOrCreate?: AlignmentCreateOrConnectWithoutCreaturesInput
    upsert?: AlignmentUpsertWithoutCreaturesInput
    disconnect?: AlignmentWhereInput | boolean
    delete?: AlignmentWhereInput | boolean
    connect?: AlignmentWhereUniqueInput
    update?: XOR<XOR<AlignmentUpdateToOneWithWhereWithoutCreaturesInput, AlignmentUpdateWithoutCreaturesInput>, AlignmentUncheckedUpdateWithoutCreaturesInput>
  }

  export type CreatureRaceUpdateOneWithoutCreatures_relationNestedInput = {
    create?: XOR<CreatureRaceCreateWithoutCreatures_relationInput, CreatureRaceUncheckedCreateWithoutCreatures_relationInput>
    connectOrCreate?: CreatureRaceCreateOrConnectWithoutCreatures_relationInput
    upsert?: CreatureRaceUpsertWithoutCreatures_relationInput
    disconnect?: CreatureRaceWhereInput | boolean
    delete?: CreatureRaceWhereInput | boolean
    connect?: CreatureRaceWhereUniqueInput
    update?: XOR<XOR<CreatureRaceUpdateToOneWithWhereWithoutCreatures_relationInput, CreatureRaceUpdateWithoutCreatures_relationInput>, CreatureRaceUncheckedUpdateWithoutCreatures_relationInput>
  }

  export type TypeUpdateOneWithoutCreaturesNestedInput = {
    create?: XOR<TypeCreateWithoutCreaturesInput, TypeUncheckedCreateWithoutCreaturesInput>
    connectOrCreate?: TypeCreateOrConnectWithoutCreaturesInput
    upsert?: TypeUpsertWithoutCreaturesInput
    disconnect?: TypeWhereInput | boolean
    delete?: TypeWhereInput | boolean
    connect?: TypeWhereUniqueInput
    update?: XOR<XOR<TypeUpdateToOneWithWhereWithoutCreaturesInput, TypeUpdateWithoutCreaturesInput>, TypeUncheckedUpdateWithoutCreaturesInput>
  }

  export type SizeUpdateOneWithoutCreatureNestedInput = {
    create?: XOR<SizeCreateWithoutCreatureInput, SizeUncheckedCreateWithoutCreatureInput>
    connectOrCreate?: SizeCreateOrConnectWithoutCreatureInput
    upsert?: SizeUpsertWithoutCreatureInput
    disconnect?: SizeWhereInput | boolean
    delete?: SizeWhereInput | boolean
    connect?: SizeWhereUniqueInput
    update?: XOR<XOR<SizeUpdateToOneWithWhereWithoutCreatureInput, SizeUpdateWithoutCreatureInput>, SizeUncheckedUpdateWithoutCreatureInput>
  }

  export type SourceUpdateOneWithoutCreaturesNestedInput = {
    create?: XOR<SourceCreateWithoutCreaturesInput, SourceUncheckedCreateWithoutCreaturesInput>
    connectOrCreate?: SourceCreateOrConnectWithoutCreaturesInput
    upsert?: SourceUpsertWithoutCreaturesInput
    disconnect?: SourceWhereInput | boolean
    delete?: SourceWhereInput | boolean
    connect?: SourceWhereUniqueInput
    update?: XOR<XOR<SourceUpdateToOneWithWhereWithoutCreaturesInput, SourceUpdateWithoutCreaturesInput>, SourceUncheckedUpdateWithoutCreaturesInput>
  }

  export type DamageTypeUpdateManyWithoutResistant_creatures_relationNestedInput = {
    create?: XOR<DamageTypeCreateWithoutResistant_creatures_relationInput, DamageTypeUncheckedCreateWithoutResistant_creatures_relationInput> | DamageTypeCreateWithoutResistant_creatures_relationInput[] | DamageTypeUncheckedCreateWithoutResistant_creatures_relationInput[]
    connectOrCreate?: DamageTypeCreateOrConnectWithoutResistant_creatures_relationInput | DamageTypeCreateOrConnectWithoutResistant_creatures_relationInput[]
    upsert?: DamageTypeUpsertWithWhereUniqueWithoutResistant_creatures_relationInput | DamageTypeUpsertWithWhereUniqueWithoutResistant_creatures_relationInput[]
    set?: DamageTypeWhereUniqueInput | DamageTypeWhereUniqueInput[]
    disconnect?: DamageTypeWhereUniqueInput | DamageTypeWhereUniqueInput[]
    delete?: DamageTypeWhereUniqueInput | DamageTypeWhereUniqueInput[]
    connect?: DamageTypeWhereUniqueInput | DamageTypeWhereUniqueInput[]
    update?: DamageTypeUpdateWithWhereUniqueWithoutResistant_creatures_relationInput | DamageTypeUpdateWithWhereUniqueWithoutResistant_creatures_relationInput[]
    updateMany?: DamageTypeUpdateManyWithWhereWithoutResistant_creatures_relationInput | DamageTypeUpdateManyWithWhereWithoutResistant_creatures_relationInput[]
    deleteMany?: DamageTypeScalarWhereInput | DamageTypeScalarWhereInput[]
  }

  export type DamageTypeUpdateManyWithoutImmune_creatures_relationNestedInput = {
    create?: XOR<DamageTypeCreateWithoutImmune_creatures_relationInput, DamageTypeUncheckedCreateWithoutImmune_creatures_relationInput> | DamageTypeCreateWithoutImmune_creatures_relationInput[] | DamageTypeUncheckedCreateWithoutImmune_creatures_relationInput[]
    connectOrCreate?: DamageTypeCreateOrConnectWithoutImmune_creatures_relationInput | DamageTypeCreateOrConnectWithoutImmune_creatures_relationInput[]
    upsert?: DamageTypeUpsertWithWhereUniqueWithoutImmune_creatures_relationInput | DamageTypeUpsertWithWhereUniqueWithoutImmune_creatures_relationInput[]
    set?: DamageTypeWhereUniqueInput | DamageTypeWhereUniqueInput[]
    disconnect?: DamageTypeWhereUniqueInput | DamageTypeWhereUniqueInput[]
    delete?: DamageTypeWhereUniqueInput | DamageTypeWhereUniqueInput[]
    connect?: DamageTypeWhereUniqueInput | DamageTypeWhereUniqueInput[]
    update?: DamageTypeUpdateWithWhereUniqueWithoutImmune_creatures_relationInput | DamageTypeUpdateWithWhereUniqueWithoutImmune_creatures_relationInput[]
    updateMany?: DamageTypeUpdateManyWithWhereWithoutImmune_creatures_relationInput | DamageTypeUpdateManyWithWhereWithoutImmune_creatures_relationInput[]
    deleteMany?: DamageTypeScalarWhereInput | DamageTypeScalarWhereInput[]
  }

  export type DamageTypeUpdateManyWithoutVulnerable_creatures_relationNestedInput = {
    create?: XOR<DamageTypeCreateWithoutVulnerable_creatures_relationInput, DamageTypeUncheckedCreateWithoutVulnerable_creatures_relationInput> | DamageTypeCreateWithoutVulnerable_creatures_relationInput[] | DamageTypeUncheckedCreateWithoutVulnerable_creatures_relationInput[]
    connectOrCreate?: DamageTypeCreateOrConnectWithoutVulnerable_creatures_relationInput | DamageTypeCreateOrConnectWithoutVulnerable_creatures_relationInput[]
    upsert?: DamageTypeUpsertWithWhereUniqueWithoutVulnerable_creatures_relationInput | DamageTypeUpsertWithWhereUniqueWithoutVulnerable_creatures_relationInput[]
    set?: DamageTypeWhereUniqueInput | DamageTypeWhereUniqueInput[]
    disconnect?: DamageTypeWhereUniqueInput | DamageTypeWhereUniqueInput[]
    delete?: DamageTypeWhereUniqueInput | DamageTypeWhereUniqueInput[]
    connect?: DamageTypeWhereUniqueInput | DamageTypeWhereUniqueInput[]
    update?: DamageTypeUpdateWithWhereUniqueWithoutVulnerable_creatures_relationInput | DamageTypeUpdateWithWhereUniqueWithoutVulnerable_creatures_relationInput[]
    updateMany?: DamageTypeUpdateManyWithWhereWithoutVulnerable_creatures_relationInput | DamageTypeUpdateManyWithWhereWithoutVulnerable_creatures_relationInput[]
    deleteMany?: DamageTypeScalarWhereInput | DamageTypeScalarWhereInput[]
  }

  export type LanguageUpdateManyWithoutCreatures_relationNestedInput = {
    create?: XOR<LanguageCreateWithoutCreatures_relationInput, LanguageUncheckedCreateWithoutCreatures_relationInput> | LanguageCreateWithoutCreatures_relationInput[] | LanguageUncheckedCreateWithoutCreatures_relationInput[]
    connectOrCreate?: LanguageCreateOrConnectWithoutCreatures_relationInput | LanguageCreateOrConnectWithoutCreatures_relationInput[]
    upsert?: LanguageUpsertWithWhereUniqueWithoutCreatures_relationInput | LanguageUpsertWithWhereUniqueWithoutCreatures_relationInput[]
    set?: LanguageWhereUniqueInput | LanguageWhereUniqueInput[]
    disconnect?: LanguageWhereUniqueInput | LanguageWhereUniqueInput[]
    delete?: LanguageWhereUniqueInput | LanguageWhereUniqueInput[]
    connect?: LanguageWhereUniqueInput | LanguageWhereUniqueInput[]
    update?: LanguageUpdateWithWhereUniqueWithoutCreatures_relationInput | LanguageUpdateWithWhereUniqueWithoutCreatures_relationInput[]
    updateMany?: LanguageUpdateManyWithWhereWithoutCreatures_relationInput | LanguageUpdateManyWithWhereWithoutCreatures_relationInput[]
    deleteMany?: LanguageScalarWhereInput | LanguageScalarWhereInput[]
  }

  export type BiomeUpdateManyWithoutCreatures_relationNestedInput = {
    create?: XOR<BiomeCreateWithoutCreatures_relationInput, BiomeUncheckedCreateWithoutCreatures_relationInput> | BiomeCreateWithoutCreatures_relationInput[] | BiomeUncheckedCreateWithoutCreatures_relationInput[]
    connectOrCreate?: BiomeCreateOrConnectWithoutCreatures_relationInput | BiomeCreateOrConnectWithoutCreatures_relationInput[]
    upsert?: BiomeUpsertWithWhereUniqueWithoutCreatures_relationInput | BiomeUpsertWithWhereUniqueWithoutCreatures_relationInput[]
    set?: BiomeWhereUniqueInput | BiomeWhereUniqueInput[]
    disconnect?: BiomeWhereUniqueInput | BiomeWhereUniqueInput[]
    delete?: BiomeWhereUniqueInput | BiomeWhereUniqueInput[]
    connect?: BiomeWhereUniqueInput | BiomeWhereUniqueInput[]
    update?: BiomeUpdateWithWhereUniqueWithoutCreatures_relationInput | BiomeUpdateWithWhereUniqueWithoutCreatures_relationInput[]
    updateMany?: BiomeUpdateManyWithWhereWithoutCreatures_relationInput | BiomeUpdateManyWithWhereWithoutCreatures_relationInput[]
    deleteMany?: BiomeScalarWhereInput | BiomeScalarWhereInput[]
  }

  export type ActionUpdateManyWithoutCreatures_relationNestedInput = {
    create?: XOR<ActionCreateWithoutCreatures_relationInput, ActionUncheckedCreateWithoutCreatures_relationInput> | ActionCreateWithoutCreatures_relationInput[] | ActionUncheckedCreateWithoutCreatures_relationInput[]
    connectOrCreate?: ActionCreateOrConnectWithoutCreatures_relationInput | ActionCreateOrConnectWithoutCreatures_relationInput[]
    upsert?: ActionUpsertWithWhereUniqueWithoutCreatures_relationInput | ActionUpsertWithWhereUniqueWithoutCreatures_relationInput[]
    set?: ActionWhereUniqueInput | ActionWhereUniqueInput[]
    disconnect?: ActionWhereUniqueInput | ActionWhereUniqueInput[]
    delete?: ActionWhereUniqueInput | ActionWhereUniqueInput[]
    connect?: ActionWhereUniqueInput | ActionWhereUniqueInput[]
    update?: ActionUpdateWithWhereUniqueWithoutCreatures_relationInput | ActionUpdateWithWhereUniqueWithoutCreatures_relationInput[]
    updateMany?: ActionUpdateManyWithWhereWithoutCreatures_relationInput | ActionUpdateManyWithWhereWithoutCreatures_relationInput[]
    deleteMany?: ActionScalarWhereInput | ActionScalarWhereInput[]
  }

  export type TraitUpdateManyWithoutCreatures_relationNestedInput = {
    create?: XOR<TraitCreateWithoutCreatures_relationInput, TraitUncheckedCreateWithoutCreatures_relationInput> | TraitCreateWithoutCreatures_relationInput[] | TraitUncheckedCreateWithoutCreatures_relationInput[]
    connectOrCreate?: TraitCreateOrConnectWithoutCreatures_relationInput | TraitCreateOrConnectWithoutCreatures_relationInput[]
    upsert?: TraitUpsertWithWhereUniqueWithoutCreatures_relationInput | TraitUpsertWithWhereUniqueWithoutCreatures_relationInput[]
    set?: TraitWhereUniqueInput | TraitWhereUniqueInput[]
    disconnect?: TraitWhereUniqueInput | TraitWhereUniqueInput[]
    delete?: TraitWhereUniqueInput | TraitWhereUniqueInput[]
    connect?: TraitWhereUniqueInput | TraitWhereUniqueInput[]
    update?: TraitUpdateWithWhereUniqueWithoutCreatures_relationInput | TraitUpdateWithWhereUniqueWithoutCreatures_relationInput[]
    updateMany?: TraitUpdateManyWithWhereWithoutCreatures_relationInput | TraitUpdateManyWithWhereWithoutCreatures_relationInput[]
    deleteMany?: TraitScalarWhereInput | TraitScalarWhereInput[]
  }

  export type CreatureSpeedUncheckedUpdateOneWithoutCreature_relationNestedInput = {
    create?: XOR<CreatureSpeedCreateWithoutCreature_relationInput, CreatureSpeedUncheckedCreateWithoutCreature_relationInput>
    connectOrCreate?: CreatureSpeedCreateOrConnectWithoutCreature_relationInput
    upsert?: CreatureSpeedUpsertWithoutCreature_relationInput
    disconnect?: CreatureSpeedWhereInput | boolean
    delete?: CreatureSpeedWhereInput | boolean
    connect?: CreatureSpeedWhereUniqueInput
    update?: XOR<XOR<CreatureSpeedUpdateToOneWithWhereWithoutCreature_relationInput, CreatureSpeedUpdateWithoutCreature_relationInput>, CreatureSpeedUncheckedUpdateWithoutCreature_relationInput>
  }

  export type CreatureStatsUncheckedUpdateOneWithoutCreature_relationNestedInput = {
    create?: XOR<CreatureStatsCreateWithoutCreature_relationInput, CreatureStatsUncheckedCreateWithoutCreature_relationInput>
    connectOrCreate?: CreatureStatsCreateOrConnectWithoutCreature_relationInput
    upsert?: CreatureStatsUpsertWithoutCreature_relationInput
    disconnect?: CreatureStatsWhereInput | boolean
    delete?: CreatureStatsWhereInput | boolean
    connect?: CreatureStatsWhereUniqueInput
    update?: XOR<XOR<CreatureStatsUpdateToOneWithWhereWithoutCreature_relationInput, CreatureStatsUpdateWithoutCreature_relationInput>, CreatureStatsUncheckedUpdateWithoutCreature_relationInput>
  }

  export type CreatureSkillsUncheckedUpdateOneWithoutCreature_relationNestedInput = {
    create?: XOR<CreatureSkillsCreateWithoutCreature_relationInput, CreatureSkillsUncheckedCreateWithoutCreature_relationInput>
    connectOrCreate?: CreatureSkillsCreateOrConnectWithoutCreature_relationInput
    upsert?: CreatureSkillsUpsertWithoutCreature_relationInput
    disconnect?: CreatureSkillsWhereInput | boolean
    delete?: CreatureSkillsWhereInput | boolean
    connect?: CreatureSkillsWhereUniqueInput
    update?: XOR<XOR<CreatureSkillsUpdateToOneWithWhereWithoutCreature_relationInput, CreatureSkillsUpdateWithoutCreature_relationInput>, CreatureSkillsUncheckedUpdateWithoutCreature_relationInput>
  }

  export type CreatureSensesUncheckedUpdateOneWithoutCreature_relationNestedInput = {
    create?: XOR<CreatureSensesCreateWithoutCreature_relationInput, CreatureSensesUncheckedCreateWithoutCreature_relationInput>
    connectOrCreate?: CreatureSensesCreateOrConnectWithoutCreature_relationInput
    upsert?: CreatureSensesUpsertWithoutCreature_relationInput
    disconnect?: CreatureSensesWhereInput | boolean
    delete?: CreatureSensesWhereInput | boolean
    connect?: CreatureSensesWhereUniqueInput
    update?: XOR<XOR<CreatureSensesUpdateToOneWithWhereWithoutCreature_relationInput, CreatureSensesUpdateWithoutCreature_relationInput>, CreatureSensesUncheckedUpdateWithoutCreature_relationInput>
  }

  export type DamageTypeUncheckedUpdateManyWithoutResistant_creatures_relationNestedInput = {
    create?: XOR<DamageTypeCreateWithoutResistant_creatures_relationInput, DamageTypeUncheckedCreateWithoutResistant_creatures_relationInput> | DamageTypeCreateWithoutResistant_creatures_relationInput[] | DamageTypeUncheckedCreateWithoutResistant_creatures_relationInput[]
    connectOrCreate?: DamageTypeCreateOrConnectWithoutResistant_creatures_relationInput | DamageTypeCreateOrConnectWithoutResistant_creatures_relationInput[]
    upsert?: DamageTypeUpsertWithWhereUniqueWithoutResistant_creatures_relationInput | DamageTypeUpsertWithWhereUniqueWithoutResistant_creatures_relationInput[]
    set?: DamageTypeWhereUniqueInput | DamageTypeWhereUniqueInput[]
    disconnect?: DamageTypeWhereUniqueInput | DamageTypeWhereUniqueInput[]
    delete?: DamageTypeWhereUniqueInput | DamageTypeWhereUniqueInput[]
    connect?: DamageTypeWhereUniqueInput | DamageTypeWhereUniqueInput[]
    update?: DamageTypeUpdateWithWhereUniqueWithoutResistant_creatures_relationInput | DamageTypeUpdateWithWhereUniqueWithoutResistant_creatures_relationInput[]
    updateMany?: DamageTypeUpdateManyWithWhereWithoutResistant_creatures_relationInput | DamageTypeUpdateManyWithWhereWithoutResistant_creatures_relationInput[]
    deleteMany?: DamageTypeScalarWhereInput | DamageTypeScalarWhereInput[]
  }

  export type DamageTypeUncheckedUpdateManyWithoutImmune_creatures_relationNestedInput = {
    create?: XOR<DamageTypeCreateWithoutImmune_creatures_relationInput, DamageTypeUncheckedCreateWithoutImmune_creatures_relationInput> | DamageTypeCreateWithoutImmune_creatures_relationInput[] | DamageTypeUncheckedCreateWithoutImmune_creatures_relationInput[]
    connectOrCreate?: DamageTypeCreateOrConnectWithoutImmune_creatures_relationInput | DamageTypeCreateOrConnectWithoutImmune_creatures_relationInput[]
    upsert?: DamageTypeUpsertWithWhereUniqueWithoutImmune_creatures_relationInput | DamageTypeUpsertWithWhereUniqueWithoutImmune_creatures_relationInput[]
    set?: DamageTypeWhereUniqueInput | DamageTypeWhereUniqueInput[]
    disconnect?: DamageTypeWhereUniqueInput | DamageTypeWhereUniqueInput[]
    delete?: DamageTypeWhereUniqueInput | DamageTypeWhereUniqueInput[]
    connect?: DamageTypeWhereUniqueInput | DamageTypeWhereUniqueInput[]
    update?: DamageTypeUpdateWithWhereUniqueWithoutImmune_creatures_relationInput | DamageTypeUpdateWithWhereUniqueWithoutImmune_creatures_relationInput[]
    updateMany?: DamageTypeUpdateManyWithWhereWithoutImmune_creatures_relationInput | DamageTypeUpdateManyWithWhereWithoutImmune_creatures_relationInput[]
    deleteMany?: DamageTypeScalarWhereInput | DamageTypeScalarWhereInput[]
  }

  export type DamageTypeUncheckedUpdateManyWithoutVulnerable_creatures_relationNestedInput = {
    create?: XOR<DamageTypeCreateWithoutVulnerable_creatures_relationInput, DamageTypeUncheckedCreateWithoutVulnerable_creatures_relationInput> | DamageTypeCreateWithoutVulnerable_creatures_relationInput[] | DamageTypeUncheckedCreateWithoutVulnerable_creatures_relationInput[]
    connectOrCreate?: DamageTypeCreateOrConnectWithoutVulnerable_creatures_relationInput | DamageTypeCreateOrConnectWithoutVulnerable_creatures_relationInput[]
    upsert?: DamageTypeUpsertWithWhereUniqueWithoutVulnerable_creatures_relationInput | DamageTypeUpsertWithWhereUniqueWithoutVulnerable_creatures_relationInput[]
    set?: DamageTypeWhereUniqueInput | DamageTypeWhereUniqueInput[]
    disconnect?: DamageTypeWhereUniqueInput | DamageTypeWhereUniqueInput[]
    delete?: DamageTypeWhereUniqueInput | DamageTypeWhereUniqueInput[]
    connect?: DamageTypeWhereUniqueInput | DamageTypeWhereUniqueInput[]
    update?: DamageTypeUpdateWithWhereUniqueWithoutVulnerable_creatures_relationInput | DamageTypeUpdateWithWhereUniqueWithoutVulnerable_creatures_relationInput[]
    updateMany?: DamageTypeUpdateManyWithWhereWithoutVulnerable_creatures_relationInput | DamageTypeUpdateManyWithWhereWithoutVulnerable_creatures_relationInput[]
    deleteMany?: DamageTypeScalarWhereInput | DamageTypeScalarWhereInput[]
  }

  export type LanguageUncheckedUpdateManyWithoutCreatures_relationNestedInput = {
    create?: XOR<LanguageCreateWithoutCreatures_relationInput, LanguageUncheckedCreateWithoutCreatures_relationInput> | LanguageCreateWithoutCreatures_relationInput[] | LanguageUncheckedCreateWithoutCreatures_relationInput[]
    connectOrCreate?: LanguageCreateOrConnectWithoutCreatures_relationInput | LanguageCreateOrConnectWithoutCreatures_relationInput[]
    upsert?: LanguageUpsertWithWhereUniqueWithoutCreatures_relationInput | LanguageUpsertWithWhereUniqueWithoutCreatures_relationInput[]
    set?: LanguageWhereUniqueInput | LanguageWhereUniqueInput[]
    disconnect?: LanguageWhereUniqueInput | LanguageWhereUniqueInput[]
    delete?: LanguageWhereUniqueInput | LanguageWhereUniqueInput[]
    connect?: LanguageWhereUniqueInput | LanguageWhereUniqueInput[]
    update?: LanguageUpdateWithWhereUniqueWithoutCreatures_relationInput | LanguageUpdateWithWhereUniqueWithoutCreatures_relationInput[]
    updateMany?: LanguageUpdateManyWithWhereWithoutCreatures_relationInput | LanguageUpdateManyWithWhereWithoutCreatures_relationInput[]
    deleteMany?: LanguageScalarWhereInput | LanguageScalarWhereInput[]
  }

  export type BiomeUncheckedUpdateManyWithoutCreatures_relationNestedInput = {
    create?: XOR<BiomeCreateWithoutCreatures_relationInput, BiomeUncheckedCreateWithoutCreatures_relationInput> | BiomeCreateWithoutCreatures_relationInput[] | BiomeUncheckedCreateWithoutCreatures_relationInput[]
    connectOrCreate?: BiomeCreateOrConnectWithoutCreatures_relationInput | BiomeCreateOrConnectWithoutCreatures_relationInput[]
    upsert?: BiomeUpsertWithWhereUniqueWithoutCreatures_relationInput | BiomeUpsertWithWhereUniqueWithoutCreatures_relationInput[]
    set?: BiomeWhereUniqueInput | BiomeWhereUniqueInput[]
    disconnect?: BiomeWhereUniqueInput | BiomeWhereUniqueInput[]
    delete?: BiomeWhereUniqueInput | BiomeWhereUniqueInput[]
    connect?: BiomeWhereUniqueInput | BiomeWhereUniqueInput[]
    update?: BiomeUpdateWithWhereUniqueWithoutCreatures_relationInput | BiomeUpdateWithWhereUniqueWithoutCreatures_relationInput[]
    updateMany?: BiomeUpdateManyWithWhereWithoutCreatures_relationInput | BiomeUpdateManyWithWhereWithoutCreatures_relationInput[]
    deleteMany?: BiomeScalarWhereInput | BiomeScalarWhereInput[]
  }

  export type ActionUncheckedUpdateManyWithoutCreatures_relationNestedInput = {
    create?: XOR<ActionCreateWithoutCreatures_relationInput, ActionUncheckedCreateWithoutCreatures_relationInput> | ActionCreateWithoutCreatures_relationInput[] | ActionUncheckedCreateWithoutCreatures_relationInput[]
    connectOrCreate?: ActionCreateOrConnectWithoutCreatures_relationInput | ActionCreateOrConnectWithoutCreatures_relationInput[]
    upsert?: ActionUpsertWithWhereUniqueWithoutCreatures_relationInput | ActionUpsertWithWhereUniqueWithoutCreatures_relationInput[]
    set?: ActionWhereUniqueInput | ActionWhereUniqueInput[]
    disconnect?: ActionWhereUniqueInput | ActionWhereUniqueInput[]
    delete?: ActionWhereUniqueInput | ActionWhereUniqueInput[]
    connect?: ActionWhereUniqueInput | ActionWhereUniqueInput[]
    update?: ActionUpdateWithWhereUniqueWithoutCreatures_relationInput | ActionUpdateWithWhereUniqueWithoutCreatures_relationInput[]
    updateMany?: ActionUpdateManyWithWhereWithoutCreatures_relationInput | ActionUpdateManyWithWhereWithoutCreatures_relationInput[]
    deleteMany?: ActionScalarWhereInput | ActionScalarWhereInput[]
  }

  export type TraitUncheckedUpdateManyWithoutCreatures_relationNestedInput = {
    create?: XOR<TraitCreateWithoutCreatures_relationInput, TraitUncheckedCreateWithoutCreatures_relationInput> | TraitCreateWithoutCreatures_relationInput[] | TraitUncheckedCreateWithoutCreatures_relationInput[]
    connectOrCreate?: TraitCreateOrConnectWithoutCreatures_relationInput | TraitCreateOrConnectWithoutCreatures_relationInput[]
    upsert?: TraitUpsertWithWhereUniqueWithoutCreatures_relationInput | TraitUpsertWithWhereUniqueWithoutCreatures_relationInput[]
    set?: TraitWhereUniqueInput | TraitWhereUniqueInput[]
    disconnect?: TraitWhereUniqueInput | TraitWhereUniqueInput[]
    delete?: TraitWhereUniqueInput | TraitWhereUniqueInput[]
    connect?: TraitWhereUniqueInput | TraitWhereUniqueInput[]
    update?: TraitUpdateWithWhereUniqueWithoutCreatures_relationInput | TraitUpdateWithWhereUniqueWithoutCreatures_relationInput[]
    updateMany?: TraitUpdateManyWithWhereWithoutCreatures_relationInput | TraitUpdateManyWithWhereWithoutCreatures_relationInput[]
    deleteMany?: TraitScalarWhereInput | TraitScalarWhereInput[]
  }

  export type CreatureCreateNestedOneWithoutSensesInput = {
    create?: XOR<CreatureCreateWithoutSensesInput, CreatureUncheckedCreateWithoutSensesInput>
    connectOrCreate?: CreatureCreateOrConnectWithoutSensesInput
    connect?: CreatureWhereUniqueInput
  }

  export type CreatureUpdateOneRequiredWithoutSensesNestedInput = {
    create?: XOR<CreatureCreateWithoutSensesInput, CreatureUncheckedCreateWithoutSensesInput>
    connectOrCreate?: CreatureCreateOrConnectWithoutSensesInput
    upsert?: CreatureUpsertWithoutSensesInput
    connect?: CreatureWhereUniqueInput
    update?: XOR<XOR<CreatureUpdateToOneWithWhereWithoutSensesInput, CreatureUpdateWithoutSensesInput>, CreatureUncheckedUpdateWithoutSensesInput>
  }

  export type CreatureCreateNestedManyWithoutActions_relationInput = {
    create?: XOR<CreatureCreateWithoutActions_relationInput, CreatureUncheckedCreateWithoutActions_relationInput> | CreatureCreateWithoutActions_relationInput[] | CreatureUncheckedCreateWithoutActions_relationInput[]
    connectOrCreate?: CreatureCreateOrConnectWithoutActions_relationInput | CreatureCreateOrConnectWithoutActions_relationInput[]
    connect?: CreatureWhereUniqueInput | CreatureWhereUniqueInput[]
  }

  export type CreatureRaceCreateNestedManyWithoutActions_relationInput = {
    create?: XOR<CreatureRaceCreateWithoutActions_relationInput, CreatureRaceUncheckedCreateWithoutActions_relationInput> | CreatureRaceCreateWithoutActions_relationInput[] | CreatureRaceUncheckedCreateWithoutActions_relationInput[]
    connectOrCreate?: CreatureRaceCreateOrConnectWithoutActions_relationInput | CreatureRaceCreateOrConnectWithoutActions_relationInput[]
    connect?: CreatureRaceWhereUniqueInput | CreatureRaceWhereUniqueInput[]
  }

  export type CreatureUncheckedCreateNestedManyWithoutActions_relationInput = {
    create?: XOR<CreatureCreateWithoutActions_relationInput, CreatureUncheckedCreateWithoutActions_relationInput> | CreatureCreateWithoutActions_relationInput[] | CreatureUncheckedCreateWithoutActions_relationInput[]
    connectOrCreate?: CreatureCreateOrConnectWithoutActions_relationInput | CreatureCreateOrConnectWithoutActions_relationInput[]
    connect?: CreatureWhereUniqueInput | CreatureWhereUniqueInput[]
  }

  export type CreatureRaceUncheckedCreateNestedManyWithoutActions_relationInput = {
    create?: XOR<CreatureRaceCreateWithoutActions_relationInput, CreatureRaceUncheckedCreateWithoutActions_relationInput> | CreatureRaceCreateWithoutActions_relationInput[] | CreatureRaceUncheckedCreateWithoutActions_relationInput[]
    connectOrCreate?: CreatureRaceCreateOrConnectWithoutActions_relationInput | CreatureRaceCreateOrConnectWithoutActions_relationInput[]
    connect?: CreatureRaceWhereUniqueInput | CreatureRaceWhereUniqueInput[]
  }

  export type NullableBoolFieldUpdateOperationsInput = {
    set?: boolean | null
  }

  export type CreatureUpdateManyWithoutActions_relationNestedInput = {
    create?: XOR<CreatureCreateWithoutActions_relationInput, CreatureUncheckedCreateWithoutActions_relationInput> | CreatureCreateWithoutActions_relationInput[] | CreatureUncheckedCreateWithoutActions_relationInput[]
    connectOrCreate?: CreatureCreateOrConnectWithoutActions_relationInput | CreatureCreateOrConnectWithoutActions_relationInput[]
    upsert?: CreatureUpsertWithWhereUniqueWithoutActions_relationInput | CreatureUpsertWithWhereUniqueWithoutActions_relationInput[]
    set?: CreatureWhereUniqueInput | CreatureWhereUniqueInput[]
    disconnect?: CreatureWhereUniqueInput | CreatureWhereUniqueInput[]
    delete?: CreatureWhereUniqueInput | CreatureWhereUniqueInput[]
    connect?: CreatureWhereUniqueInput | CreatureWhereUniqueInput[]
    update?: CreatureUpdateWithWhereUniqueWithoutActions_relationInput | CreatureUpdateWithWhereUniqueWithoutActions_relationInput[]
    updateMany?: CreatureUpdateManyWithWhereWithoutActions_relationInput | CreatureUpdateManyWithWhereWithoutActions_relationInput[]
    deleteMany?: CreatureScalarWhereInput | CreatureScalarWhereInput[]
  }

  export type CreatureRaceUpdateManyWithoutActions_relationNestedInput = {
    create?: XOR<CreatureRaceCreateWithoutActions_relationInput, CreatureRaceUncheckedCreateWithoutActions_relationInput> | CreatureRaceCreateWithoutActions_relationInput[] | CreatureRaceUncheckedCreateWithoutActions_relationInput[]
    connectOrCreate?: CreatureRaceCreateOrConnectWithoutActions_relationInput | CreatureRaceCreateOrConnectWithoutActions_relationInput[]
    upsert?: CreatureRaceUpsertWithWhereUniqueWithoutActions_relationInput | CreatureRaceUpsertWithWhereUniqueWithoutActions_relationInput[]
    set?: CreatureRaceWhereUniqueInput | CreatureRaceWhereUniqueInput[]
    disconnect?: CreatureRaceWhereUniqueInput | CreatureRaceWhereUniqueInput[]
    delete?: CreatureRaceWhereUniqueInput | CreatureRaceWhereUniqueInput[]
    connect?: CreatureRaceWhereUniqueInput | CreatureRaceWhereUniqueInput[]
    update?: CreatureRaceUpdateWithWhereUniqueWithoutActions_relationInput | CreatureRaceUpdateWithWhereUniqueWithoutActions_relationInput[]
    updateMany?: CreatureRaceUpdateManyWithWhereWithoutActions_relationInput | CreatureRaceUpdateManyWithWhereWithoutActions_relationInput[]
    deleteMany?: CreatureRaceScalarWhereInput | CreatureRaceScalarWhereInput[]
  }

  export type CreatureUncheckedUpdateManyWithoutActions_relationNestedInput = {
    create?: XOR<CreatureCreateWithoutActions_relationInput, CreatureUncheckedCreateWithoutActions_relationInput> | CreatureCreateWithoutActions_relationInput[] | CreatureUncheckedCreateWithoutActions_relationInput[]
    connectOrCreate?: CreatureCreateOrConnectWithoutActions_relationInput | CreatureCreateOrConnectWithoutActions_relationInput[]
    upsert?: CreatureUpsertWithWhereUniqueWithoutActions_relationInput | CreatureUpsertWithWhereUniqueWithoutActions_relationInput[]
    set?: CreatureWhereUniqueInput | CreatureWhereUniqueInput[]
    disconnect?: CreatureWhereUniqueInput | CreatureWhereUniqueInput[]
    delete?: CreatureWhereUniqueInput | CreatureWhereUniqueInput[]
    connect?: CreatureWhereUniqueInput | CreatureWhereUniqueInput[]
    update?: CreatureUpdateWithWhereUniqueWithoutActions_relationInput | CreatureUpdateWithWhereUniqueWithoutActions_relationInput[]
    updateMany?: CreatureUpdateManyWithWhereWithoutActions_relationInput | CreatureUpdateManyWithWhereWithoutActions_relationInput[]
    deleteMany?: CreatureScalarWhereInput | CreatureScalarWhereInput[]
  }

  export type CreatureRaceUncheckedUpdateManyWithoutActions_relationNestedInput = {
    create?: XOR<CreatureRaceCreateWithoutActions_relationInput, CreatureRaceUncheckedCreateWithoutActions_relationInput> | CreatureRaceCreateWithoutActions_relationInput[] | CreatureRaceUncheckedCreateWithoutActions_relationInput[]
    connectOrCreate?: CreatureRaceCreateOrConnectWithoutActions_relationInput | CreatureRaceCreateOrConnectWithoutActions_relationInput[]
    upsert?: CreatureRaceUpsertWithWhereUniqueWithoutActions_relationInput | CreatureRaceUpsertWithWhereUniqueWithoutActions_relationInput[]
    set?: CreatureRaceWhereUniqueInput | CreatureRaceWhereUniqueInput[]
    disconnect?: CreatureRaceWhereUniqueInput | CreatureRaceWhereUniqueInput[]
    delete?: CreatureRaceWhereUniqueInput | CreatureRaceWhereUniqueInput[]
    connect?: CreatureRaceWhereUniqueInput | CreatureRaceWhereUniqueInput[]
    update?: CreatureRaceUpdateWithWhereUniqueWithoutActions_relationInput | CreatureRaceUpdateWithWhereUniqueWithoutActions_relationInput[]
    updateMany?: CreatureRaceUpdateManyWithWhereWithoutActions_relationInput | CreatureRaceUpdateManyWithWhereWithoutActions_relationInput[]
    deleteMany?: CreatureRaceScalarWhereInput | CreatureRaceScalarWhereInput[]
  }

  export type CreatureCreateNestedManyWithoutTraits_relationInput = {
    create?: XOR<CreatureCreateWithoutTraits_relationInput, CreatureUncheckedCreateWithoutTraits_relationInput> | CreatureCreateWithoutTraits_relationInput[] | CreatureUncheckedCreateWithoutTraits_relationInput[]
    connectOrCreate?: CreatureCreateOrConnectWithoutTraits_relationInput | CreatureCreateOrConnectWithoutTraits_relationInput[]
    connect?: CreatureWhereUniqueInput | CreatureWhereUniqueInput[]
  }

  export type CreatureRaceCreateNestedManyWithoutTraits_relationInput = {
    create?: XOR<CreatureRaceCreateWithoutTraits_relationInput, CreatureRaceUncheckedCreateWithoutTraits_relationInput> | CreatureRaceCreateWithoutTraits_relationInput[] | CreatureRaceUncheckedCreateWithoutTraits_relationInput[]
    connectOrCreate?: CreatureRaceCreateOrConnectWithoutTraits_relationInput | CreatureRaceCreateOrConnectWithoutTraits_relationInput[]
    connect?: CreatureRaceWhereUniqueInput | CreatureRaceWhereUniqueInput[]
  }

  export type CreatureUncheckedCreateNestedManyWithoutTraits_relationInput = {
    create?: XOR<CreatureCreateWithoutTraits_relationInput, CreatureUncheckedCreateWithoutTraits_relationInput> | CreatureCreateWithoutTraits_relationInput[] | CreatureUncheckedCreateWithoutTraits_relationInput[]
    connectOrCreate?: CreatureCreateOrConnectWithoutTraits_relationInput | CreatureCreateOrConnectWithoutTraits_relationInput[]
    connect?: CreatureWhereUniqueInput | CreatureWhereUniqueInput[]
  }

  export type CreatureRaceUncheckedCreateNestedManyWithoutTraits_relationInput = {
    create?: XOR<CreatureRaceCreateWithoutTraits_relationInput, CreatureRaceUncheckedCreateWithoutTraits_relationInput> | CreatureRaceCreateWithoutTraits_relationInput[] | CreatureRaceUncheckedCreateWithoutTraits_relationInput[]
    connectOrCreate?: CreatureRaceCreateOrConnectWithoutTraits_relationInput | CreatureRaceCreateOrConnectWithoutTraits_relationInput[]
    connect?: CreatureRaceWhereUniqueInput | CreatureRaceWhereUniqueInput[]
  }

  export type CreatureUpdateManyWithoutTraits_relationNestedInput = {
    create?: XOR<CreatureCreateWithoutTraits_relationInput, CreatureUncheckedCreateWithoutTraits_relationInput> | CreatureCreateWithoutTraits_relationInput[] | CreatureUncheckedCreateWithoutTraits_relationInput[]
    connectOrCreate?: CreatureCreateOrConnectWithoutTraits_relationInput | CreatureCreateOrConnectWithoutTraits_relationInput[]
    upsert?: CreatureUpsertWithWhereUniqueWithoutTraits_relationInput | CreatureUpsertWithWhereUniqueWithoutTraits_relationInput[]
    set?: CreatureWhereUniqueInput | CreatureWhereUniqueInput[]
    disconnect?: CreatureWhereUniqueInput | CreatureWhereUniqueInput[]
    delete?: CreatureWhereUniqueInput | CreatureWhereUniqueInput[]
    connect?: CreatureWhereUniqueInput | CreatureWhereUniqueInput[]
    update?: CreatureUpdateWithWhereUniqueWithoutTraits_relationInput | CreatureUpdateWithWhereUniqueWithoutTraits_relationInput[]
    updateMany?: CreatureUpdateManyWithWhereWithoutTraits_relationInput | CreatureUpdateManyWithWhereWithoutTraits_relationInput[]
    deleteMany?: CreatureScalarWhereInput | CreatureScalarWhereInput[]
  }

  export type CreatureRaceUpdateManyWithoutTraits_relationNestedInput = {
    create?: XOR<CreatureRaceCreateWithoutTraits_relationInput, CreatureRaceUncheckedCreateWithoutTraits_relationInput> | CreatureRaceCreateWithoutTraits_relationInput[] | CreatureRaceUncheckedCreateWithoutTraits_relationInput[]
    connectOrCreate?: CreatureRaceCreateOrConnectWithoutTraits_relationInput | CreatureRaceCreateOrConnectWithoutTraits_relationInput[]
    upsert?: CreatureRaceUpsertWithWhereUniqueWithoutTraits_relationInput | CreatureRaceUpsertWithWhereUniqueWithoutTraits_relationInput[]
    set?: CreatureRaceWhereUniqueInput | CreatureRaceWhereUniqueInput[]
    disconnect?: CreatureRaceWhereUniqueInput | CreatureRaceWhereUniqueInput[]
    delete?: CreatureRaceWhereUniqueInput | CreatureRaceWhereUniqueInput[]
    connect?: CreatureRaceWhereUniqueInput | CreatureRaceWhereUniqueInput[]
    update?: CreatureRaceUpdateWithWhereUniqueWithoutTraits_relationInput | CreatureRaceUpdateWithWhereUniqueWithoutTraits_relationInput[]
    updateMany?: CreatureRaceUpdateManyWithWhereWithoutTraits_relationInput | CreatureRaceUpdateManyWithWhereWithoutTraits_relationInput[]
    deleteMany?: CreatureRaceScalarWhereInput | CreatureRaceScalarWhereInput[]
  }

  export type CreatureUncheckedUpdateManyWithoutTraits_relationNestedInput = {
    create?: XOR<CreatureCreateWithoutTraits_relationInput, CreatureUncheckedCreateWithoutTraits_relationInput> | CreatureCreateWithoutTraits_relationInput[] | CreatureUncheckedCreateWithoutTraits_relationInput[]
    connectOrCreate?: CreatureCreateOrConnectWithoutTraits_relationInput | CreatureCreateOrConnectWithoutTraits_relationInput[]
    upsert?: CreatureUpsertWithWhereUniqueWithoutTraits_relationInput | CreatureUpsertWithWhereUniqueWithoutTraits_relationInput[]
    set?: CreatureWhereUniqueInput | CreatureWhereUniqueInput[]
    disconnect?: CreatureWhereUniqueInput | CreatureWhereUniqueInput[]
    delete?: CreatureWhereUniqueInput | CreatureWhereUniqueInput[]
    connect?: CreatureWhereUniqueInput | CreatureWhereUniqueInput[]
    update?: CreatureUpdateWithWhereUniqueWithoutTraits_relationInput | CreatureUpdateWithWhereUniqueWithoutTraits_relationInput[]
    updateMany?: CreatureUpdateManyWithWhereWithoutTraits_relationInput | CreatureUpdateManyWithWhereWithoutTraits_relationInput[]
    deleteMany?: CreatureScalarWhereInput | CreatureScalarWhereInput[]
  }

  export type CreatureRaceUncheckedUpdateManyWithoutTraits_relationNestedInput = {
    create?: XOR<CreatureRaceCreateWithoutTraits_relationInput, CreatureRaceUncheckedCreateWithoutTraits_relationInput> | CreatureRaceCreateWithoutTraits_relationInput[] | CreatureRaceUncheckedCreateWithoutTraits_relationInput[]
    connectOrCreate?: CreatureRaceCreateOrConnectWithoutTraits_relationInput | CreatureRaceCreateOrConnectWithoutTraits_relationInput[]
    upsert?: CreatureRaceUpsertWithWhereUniqueWithoutTraits_relationInput | CreatureRaceUpsertWithWhereUniqueWithoutTraits_relationInput[]
    set?: CreatureRaceWhereUniqueInput | CreatureRaceWhereUniqueInput[]
    disconnect?: CreatureRaceWhereUniqueInput | CreatureRaceWhereUniqueInput[]
    delete?: CreatureRaceWhereUniqueInput | CreatureRaceWhereUniqueInput[]
    connect?: CreatureRaceWhereUniqueInput | CreatureRaceWhereUniqueInput[]
    update?: CreatureRaceUpdateWithWhereUniqueWithoutTraits_relationInput | CreatureRaceUpdateWithWhereUniqueWithoutTraits_relationInput[]
    updateMany?: CreatureRaceUpdateManyWithWhereWithoutTraits_relationInput | CreatureRaceUpdateManyWithWhereWithoutTraits_relationInput[]
    deleteMany?: CreatureRaceScalarWhereInput | CreatureRaceScalarWhereInput[]
  }

  export type TraitCreateNestedManyWithoutCreature_races_relationInput = {
    create?: XOR<TraitCreateWithoutCreature_races_relationInput, TraitUncheckedCreateWithoutCreature_races_relationInput> | TraitCreateWithoutCreature_races_relationInput[] | TraitUncheckedCreateWithoutCreature_races_relationInput[]
    connectOrCreate?: TraitCreateOrConnectWithoutCreature_races_relationInput | TraitCreateOrConnectWithoutCreature_races_relationInput[]
    connect?: TraitWhereUniqueInput | TraitWhereUniqueInput[]
  }

  export type ActionCreateNestedManyWithoutCreature_races_relationInput = {
    create?: XOR<ActionCreateWithoutCreature_races_relationInput, ActionUncheckedCreateWithoutCreature_races_relationInput> | ActionCreateWithoutCreature_races_relationInput[] | ActionUncheckedCreateWithoutCreature_races_relationInput[]
    connectOrCreate?: ActionCreateOrConnectWithoutCreature_races_relationInput | ActionCreateOrConnectWithoutCreature_races_relationInput[]
    connect?: ActionWhereUniqueInput | ActionWhereUniqueInput[]
  }

  export type CreatureCreateNestedManyWithoutRace_relationInput = {
    create?: XOR<CreatureCreateWithoutRace_relationInput, CreatureUncheckedCreateWithoutRace_relationInput> | CreatureCreateWithoutRace_relationInput[] | CreatureUncheckedCreateWithoutRace_relationInput[]
    connectOrCreate?: CreatureCreateOrConnectWithoutRace_relationInput | CreatureCreateOrConnectWithoutRace_relationInput[]
    createMany?: CreatureCreateManyRace_relationInputEnvelope
    connect?: CreatureWhereUniqueInput | CreatureWhereUniqueInput[]
  }

  export type TraitUncheckedCreateNestedManyWithoutCreature_races_relationInput = {
    create?: XOR<TraitCreateWithoutCreature_races_relationInput, TraitUncheckedCreateWithoutCreature_races_relationInput> | TraitCreateWithoutCreature_races_relationInput[] | TraitUncheckedCreateWithoutCreature_races_relationInput[]
    connectOrCreate?: TraitCreateOrConnectWithoutCreature_races_relationInput | TraitCreateOrConnectWithoutCreature_races_relationInput[]
    connect?: TraitWhereUniqueInput | TraitWhereUniqueInput[]
  }

  export type ActionUncheckedCreateNestedManyWithoutCreature_races_relationInput = {
    create?: XOR<ActionCreateWithoutCreature_races_relationInput, ActionUncheckedCreateWithoutCreature_races_relationInput> | ActionCreateWithoutCreature_races_relationInput[] | ActionUncheckedCreateWithoutCreature_races_relationInput[]
    connectOrCreate?: ActionCreateOrConnectWithoutCreature_races_relationInput | ActionCreateOrConnectWithoutCreature_races_relationInput[]
    connect?: ActionWhereUniqueInput | ActionWhereUniqueInput[]
  }

  export type CreatureUncheckedCreateNestedManyWithoutRace_relationInput = {
    create?: XOR<CreatureCreateWithoutRace_relationInput, CreatureUncheckedCreateWithoutRace_relationInput> | CreatureCreateWithoutRace_relationInput[] | CreatureUncheckedCreateWithoutRace_relationInput[]
    connectOrCreate?: CreatureCreateOrConnectWithoutRace_relationInput | CreatureCreateOrConnectWithoutRace_relationInput[]
    createMany?: CreatureCreateManyRace_relationInputEnvelope
    connect?: CreatureWhereUniqueInput | CreatureWhereUniqueInput[]
  }

  export type TraitUpdateManyWithoutCreature_races_relationNestedInput = {
    create?: XOR<TraitCreateWithoutCreature_races_relationInput, TraitUncheckedCreateWithoutCreature_races_relationInput> | TraitCreateWithoutCreature_races_relationInput[] | TraitUncheckedCreateWithoutCreature_races_relationInput[]
    connectOrCreate?: TraitCreateOrConnectWithoutCreature_races_relationInput | TraitCreateOrConnectWithoutCreature_races_relationInput[]
    upsert?: TraitUpsertWithWhereUniqueWithoutCreature_races_relationInput | TraitUpsertWithWhereUniqueWithoutCreature_races_relationInput[]
    set?: TraitWhereUniqueInput | TraitWhereUniqueInput[]
    disconnect?: TraitWhereUniqueInput | TraitWhereUniqueInput[]
    delete?: TraitWhereUniqueInput | TraitWhereUniqueInput[]
    connect?: TraitWhereUniqueInput | TraitWhereUniqueInput[]
    update?: TraitUpdateWithWhereUniqueWithoutCreature_races_relationInput | TraitUpdateWithWhereUniqueWithoutCreature_races_relationInput[]
    updateMany?: TraitUpdateManyWithWhereWithoutCreature_races_relationInput | TraitUpdateManyWithWhereWithoutCreature_races_relationInput[]
    deleteMany?: TraitScalarWhereInput | TraitScalarWhereInput[]
  }

  export type ActionUpdateManyWithoutCreature_races_relationNestedInput = {
    create?: XOR<ActionCreateWithoutCreature_races_relationInput, ActionUncheckedCreateWithoutCreature_races_relationInput> | ActionCreateWithoutCreature_races_relationInput[] | ActionUncheckedCreateWithoutCreature_races_relationInput[]
    connectOrCreate?: ActionCreateOrConnectWithoutCreature_races_relationInput | ActionCreateOrConnectWithoutCreature_races_relationInput[]
    upsert?: ActionUpsertWithWhereUniqueWithoutCreature_races_relationInput | ActionUpsertWithWhereUniqueWithoutCreature_races_relationInput[]
    set?: ActionWhereUniqueInput | ActionWhereUniqueInput[]
    disconnect?: ActionWhereUniqueInput | ActionWhereUniqueInput[]
    delete?: ActionWhereUniqueInput | ActionWhereUniqueInput[]
    connect?: ActionWhereUniqueInput | ActionWhereUniqueInput[]
    update?: ActionUpdateWithWhereUniqueWithoutCreature_races_relationInput | ActionUpdateWithWhereUniqueWithoutCreature_races_relationInput[]
    updateMany?: ActionUpdateManyWithWhereWithoutCreature_races_relationInput | ActionUpdateManyWithWhereWithoutCreature_races_relationInput[]
    deleteMany?: ActionScalarWhereInput | ActionScalarWhereInput[]
  }

  export type CreatureUpdateManyWithoutRace_relationNestedInput = {
    create?: XOR<CreatureCreateWithoutRace_relationInput, CreatureUncheckedCreateWithoutRace_relationInput> | CreatureCreateWithoutRace_relationInput[] | CreatureUncheckedCreateWithoutRace_relationInput[]
    connectOrCreate?: CreatureCreateOrConnectWithoutRace_relationInput | CreatureCreateOrConnectWithoutRace_relationInput[]
    upsert?: CreatureUpsertWithWhereUniqueWithoutRace_relationInput | CreatureUpsertWithWhereUniqueWithoutRace_relationInput[]
    createMany?: CreatureCreateManyRace_relationInputEnvelope
    set?: CreatureWhereUniqueInput | CreatureWhereUniqueInput[]
    disconnect?: CreatureWhereUniqueInput | CreatureWhereUniqueInput[]
    delete?: CreatureWhereUniqueInput | CreatureWhereUniqueInput[]
    connect?: CreatureWhereUniqueInput | CreatureWhereUniqueInput[]
    update?: CreatureUpdateWithWhereUniqueWithoutRace_relationInput | CreatureUpdateWithWhereUniqueWithoutRace_relationInput[]
    updateMany?: CreatureUpdateManyWithWhereWithoutRace_relationInput | CreatureUpdateManyWithWhereWithoutRace_relationInput[]
    deleteMany?: CreatureScalarWhereInput | CreatureScalarWhereInput[]
  }

  export type TraitUncheckedUpdateManyWithoutCreature_races_relationNestedInput = {
    create?: XOR<TraitCreateWithoutCreature_races_relationInput, TraitUncheckedCreateWithoutCreature_races_relationInput> | TraitCreateWithoutCreature_races_relationInput[] | TraitUncheckedCreateWithoutCreature_races_relationInput[]
    connectOrCreate?: TraitCreateOrConnectWithoutCreature_races_relationInput | TraitCreateOrConnectWithoutCreature_races_relationInput[]
    upsert?: TraitUpsertWithWhereUniqueWithoutCreature_races_relationInput | TraitUpsertWithWhereUniqueWithoutCreature_races_relationInput[]
    set?: TraitWhereUniqueInput | TraitWhereUniqueInput[]
    disconnect?: TraitWhereUniqueInput | TraitWhereUniqueInput[]
    delete?: TraitWhereUniqueInput | TraitWhereUniqueInput[]
    connect?: TraitWhereUniqueInput | TraitWhereUniqueInput[]
    update?: TraitUpdateWithWhereUniqueWithoutCreature_races_relationInput | TraitUpdateWithWhereUniqueWithoutCreature_races_relationInput[]
    updateMany?: TraitUpdateManyWithWhereWithoutCreature_races_relationInput | TraitUpdateManyWithWhereWithoutCreature_races_relationInput[]
    deleteMany?: TraitScalarWhereInput | TraitScalarWhereInput[]
  }

  export type ActionUncheckedUpdateManyWithoutCreature_races_relationNestedInput = {
    create?: XOR<ActionCreateWithoutCreature_races_relationInput, ActionUncheckedCreateWithoutCreature_races_relationInput> | ActionCreateWithoutCreature_races_relationInput[] | ActionUncheckedCreateWithoutCreature_races_relationInput[]
    connectOrCreate?: ActionCreateOrConnectWithoutCreature_races_relationInput | ActionCreateOrConnectWithoutCreature_races_relationInput[]
    upsert?: ActionUpsertWithWhereUniqueWithoutCreature_races_relationInput | ActionUpsertWithWhereUniqueWithoutCreature_races_relationInput[]
    set?: ActionWhereUniqueInput | ActionWhereUniqueInput[]
    disconnect?: ActionWhereUniqueInput | ActionWhereUniqueInput[]
    delete?: ActionWhereUniqueInput | ActionWhereUniqueInput[]
    connect?: ActionWhereUniqueInput | ActionWhereUniqueInput[]
    update?: ActionUpdateWithWhereUniqueWithoutCreature_races_relationInput | ActionUpdateWithWhereUniqueWithoutCreature_races_relationInput[]
    updateMany?: ActionUpdateManyWithWhereWithoutCreature_races_relationInput | ActionUpdateManyWithWhereWithoutCreature_races_relationInput[]
    deleteMany?: ActionScalarWhereInput | ActionScalarWhereInput[]
  }

  export type CreatureUncheckedUpdateManyWithoutRace_relationNestedInput = {
    create?: XOR<CreatureCreateWithoutRace_relationInput, CreatureUncheckedCreateWithoutRace_relationInput> | CreatureCreateWithoutRace_relationInput[] | CreatureUncheckedCreateWithoutRace_relationInput[]
    connectOrCreate?: CreatureCreateOrConnectWithoutRace_relationInput | CreatureCreateOrConnectWithoutRace_relationInput[]
    upsert?: CreatureUpsertWithWhereUniqueWithoutRace_relationInput | CreatureUpsertWithWhereUniqueWithoutRace_relationInput[]
    createMany?: CreatureCreateManyRace_relationInputEnvelope
    set?: CreatureWhereUniqueInput | CreatureWhereUniqueInput[]
    disconnect?: CreatureWhereUniqueInput | CreatureWhereUniqueInput[]
    delete?: CreatureWhereUniqueInput | CreatureWhereUniqueInput[]
    connect?: CreatureWhereUniqueInput | CreatureWhereUniqueInput[]
    update?: CreatureUpdateWithWhereUniqueWithoutRace_relationInput | CreatureUpdateWithWhereUniqueWithoutRace_relationInput[]
    updateMany?: CreatureUpdateManyWithWhereWithoutRace_relationInput | CreatureUpdateManyWithWhereWithoutRace_relationInput[]
    deleteMany?: CreatureScalarWhereInput | CreatureScalarWhereInput[]
  }

  export type CreatureCreateNestedManyWithoutResistancesInput = {
    create?: XOR<CreatureCreateWithoutResistancesInput, CreatureUncheckedCreateWithoutResistancesInput> | CreatureCreateWithoutResistancesInput[] | CreatureUncheckedCreateWithoutResistancesInput[]
    connectOrCreate?: CreatureCreateOrConnectWithoutResistancesInput | CreatureCreateOrConnectWithoutResistancesInput[]
    connect?: CreatureWhereUniqueInput | CreatureWhereUniqueInput[]
  }

  export type CreatureCreateNestedManyWithoutImmunitiesInput = {
    create?: XOR<CreatureCreateWithoutImmunitiesInput, CreatureUncheckedCreateWithoutImmunitiesInput> | CreatureCreateWithoutImmunitiesInput[] | CreatureUncheckedCreateWithoutImmunitiesInput[]
    connectOrCreate?: CreatureCreateOrConnectWithoutImmunitiesInput | CreatureCreateOrConnectWithoutImmunitiesInput[]
    connect?: CreatureWhereUniqueInput | CreatureWhereUniqueInput[]
  }

  export type CreatureCreateNestedManyWithoutVulnerabilitiesInput = {
    create?: XOR<CreatureCreateWithoutVulnerabilitiesInput, CreatureUncheckedCreateWithoutVulnerabilitiesInput> | CreatureCreateWithoutVulnerabilitiesInput[] | CreatureUncheckedCreateWithoutVulnerabilitiesInput[]
    connectOrCreate?: CreatureCreateOrConnectWithoutVulnerabilitiesInput | CreatureCreateOrConnectWithoutVulnerabilitiesInput[]
    connect?: CreatureWhereUniqueInput | CreatureWhereUniqueInput[]
  }

  export type CreatureUncheckedCreateNestedManyWithoutResistancesInput = {
    create?: XOR<CreatureCreateWithoutResistancesInput, CreatureUncheckedCreateWithoutResistancesInput> | CreatureCreateWithoutResistancesInput[] | CreatureUncheckedCreateWithoutResistancesInput[]
    connectOrCreate?: CreatureCreateOrConnectWithoutResistancesInput | CreatureCreateOrConnectWithoutResistancesInput[]
    connect?: CreatureWhereUniqueInput | CreatureWhereUniqueInput[]
  }

  export type CreatureUncheckedCreateNestedManyWithoutImmunitiesInput = {
    create?: XOR<CreatureCreateWithoutImmunitiesInput, CreatureUncheckedCreateWithoutImmunitiesInput> | CreatureCreateWithoutImmunitiesInput[] | CreatureUncheckedCreateWithoutImmunitiesInput[]
    connectOrCreate?: CreatureCreateOrConnectWithoutImmunitiesInput | CreatureCreateOrConnectWithoutImmunitiesInput[]
    connect?: CreatureWhereUniqueInput | CreatureWhereUniqueInput[]
  }

  export type CreatureUncheckedCreateNestedManyWithoutVulnerabilitiesInput = {
    create?: XOR<CreatureCreateWithoutVulnerabilitiesInput, CreatureUncheckedCreateWithoutVulnerabilitiesInput> | CreatureCreateWithoutVulnerabilitiesInput[] | CreatureUncheckedCreateWithoutVulnerabilitiesInput[]
    connectOrCreate?: CreatureCreateOrConnectWithoutVulnerabilitiesInput | CreatureCreateOrConnectWithoutVulnerabilitiesInput[]
    connect?: CreatureWhereUniqueInput | CreatureWhereUniqueInput[]
  }

  export type CreatureUpdateManyWithoutResistancesNestedInput = {
    create?: XOR<CreatureCreateWithoutResistancesInput, CreatureUncheckedCreateWithoutResistancesInput> | CreatureCreateWithoutResistancesInput[] | CreatureUncheckedCreateWithoutResistancesInput[]
    connectOrCreate?: CreatureCreateOrConnectWithoutResistancesInput | CreatureCreateOrConnectWithoutResistancesInput[]
    upsert?: CreatureUpsertWithWhereUniqueWithoutResistancesInput | CreatureUpsertWithWhereUniqueWithoutResistancesInput[]
    set?: CreatureWhereUniqueInput | CreatureWhereUniqueInput[]
    disconnect?: CreatureWhereUniqueInput | CreatureWhereUniqueInput[]
    delete?: CreatureWhereUniqueInput | CreatureWhereUniqueInput[]
    connect?: CreatureWhereUniqueInput | CreatureWhereUniqueInput[]
    update?: CreatureUpdateWithWhereUniqueWithoutResistancesInput | CreatureUpdateWithWhereUniqueWithoutResistancesInput[]
    updateMany?: CreatureUpdateManyWithWhereWithoutResistancesInput | CreatureUpdateManyWithWhereWithoutResistancesInput[]
    deleteMany?: CreatureScalarWhereInput | CreatureScalarWhereInput[]
  }

  export type CreatureUpdateManyWithoutImmunitiesNestedInput = {
    create?: XOR<CreatureCreateWithoutImmunitiesInput, CreatureUncheckedCreateWithoutImmunitiesInput> | CreatureCreateWithoutImmunitiesInput[] | CreatureUncheckedCreateWithoutImmunitiesInput[]
    connectOrCreate?: CreatureCreateOrConnectWithoutImmunitiesInput | CreatureCreateOrConnectWithoutImmunitiesInput[]
    upsert?: CreatureUpsertWithWhereUniqueWithoutImmunitiesInput | CreatureUpsertWithWhereUniqueWithoutImmunitiesInput[]
    set?: CreatureWhereUniqueInput | CreatureWhereUniqueInput[]
    disconnect?: CreatureWhereUniqueInput | CreatureWhereUniqueInput[]
    delete?: CreatureWhereUniqueInput | CreatureWhereUniqueInput[]
    connect?: CreatureWhereUniqueInput | CreatureWhereUniqueInput[]
    update?: CreatureUpdateWithWhereUniqueWithoutImmunitiesInput | CreatureUpdateWithWhereUniqueWithoutImmunitiesInput[]
    updateMany?: CreatureUpdateManyWithWhereWithoutImmunitiesInput | CreatureUpdateManyWithWhereWithoutImmunitiesInput[]
    deleteMany?: CreatureScalarWhereInput | CreatureScalarWhereInput[]
  }

  export type CreatureUpdateManyWithoutVulnerabilitiesNestedInput = {
    create?: XOR<CreatureCreateWithoutVulnerabilitiesInput, CreatureUncheckedCreateWithoutVulnerabilitiesInput> | CreatureCreateWithoutVulnerabilitiesInput[] | CreatureUncheckedCreateWithoutVulnerabilitiesInput[]
    connectOrCreate?: CreatureCreateOrConnectWithoutVulnerabilitiesInput | CreatureCreateOrConnectWithoutVulnerabilitiesInput[]
    upsert?: CreatureUpsertWithWhereUniqueWithoutVulnerabilitiesInput | CreatureUpsertWithWhereUniqueWithoutVulnerabilitiesInput[]
    set?: CreatureWhereUniqueInput | CreatureWhereUniqueInput[]
    disconnect?: CreatureWhereUniqueInput | CreatureWhereUniqueInput[]
    delete?: CreatureWhereUniqueInput | CreatureWhereUniqueInput[]
    connect?: CreatureWhereUniqueInput | CreatureWhereUniqueInput[]
    update?: CreatureUpdateWithWhereUniqueWithoutVulnerabilitiesInput | CreatureUpdateWithWhereUniqueWithoutVulnerabilitiesInput[]
    updateMany?: CreatureUpdateManyWithWhereWithoutVulnerabilitiesInput | CreatureUpdateManyWithWhereWithoutVulnerabilitiesInput[]
    deleteMany?: CreatureScalarWhereInput | CreatureScalarWhereInput[]
  }

  export type CreatureUncheckedUpdateManyWithoutResistancesNestedInput = {
    create?: XOR<CreatureCreateWithoutResistancesInput, CreatureUncheckedCreateWithoutResistancesInput> | CreatureCreateWithoutResistancesInput[] | CreatureUncheckedCreateWithoutResistancesInput[]
    connectOrCreate?: CreatureCreateOrConnectWithoutResistancesInput | CreatureCreateOrConnectWithoutResistancesInput[]
    upsert?: CreatureUpsertWithWhereUniqueWithoutResistancesInput | CreatureUpsertWithWhereUniqueWithoutResistancesInput[]
    set?: CreatureWhereUniqueInput | CreatureWhereUniqueInput[]
    disconnect?: CreatureWhereUniqueInput | CreatureWhereUniqueInput[]
    delete?: CreatureWhereUniqueInput | CreatureWhereUniqueInput[]
    connect?: CreatureWhereUniqueInput | CreatureWhereUniqueInput[]
    update?: CreatureUpdateWithWhereUniqueWithoutResistancesInput | CreatureUpdateWithWhereUniqueWithoutResistancesInput[]
    updateMany?: CreatureUpdateManyWithWhereWithoutResistancesInput | CreatureUpdateManyWithWhereWithoutResistancesInput[]
    deleteMany?: CreatureScalarWhereInput | CreatureScalarWhereInput[]
  }

  export type CreatureUncheckedUpdateManyWithoutImmunitiesNestedInput = {
    create?: XOR<CreatureCreateWithoutImmunitiesInput, CreatureUncheckedCreateWithoutImmunitiesInput> | CreatureCreateWithoutImmunitiesInput[] | CreatureUncheckedCreateWithoutImmunitiesInput[]
    connectOrCreate?: CreatureCreateOrConnectWithoutImmunitiesInput | CreatureCreateOrConnectWithoutImmunitiesInput[]
    upsert?: CreatureUpsertWithWhereUniqueWithoutImmunitiesInput | CreatureUpsertWithWhereUniqueWithoutImmunitiesInput[]
    set?: CreatureWhereUniqueInput | CreatureWhereUniqueInput[]
    disconnect?: CreatureWhereUniqueInput | CreatureWhereUniqueInput[]
    delete?: CreatureWhereUniqueInput | CreatureWhereUniqueInput[]
    connect?: CreatureWhereUniqueInput | CreatureWhereUniqueInput[]
    update?: CreatureUpdateWithWhereUniqueWithoutImmunitiesInput | CreatureUpdateWithWhereUniqueWithoutImmunitiesInput[]
    updateMany?: CreatureUpdateManyWithWhereWithoutImmunitiesInput | CreatureUpdateManyWithWhereWithoutImmunitiesInput[]
    deleteMany?: CreatureScalarWhereInput | CreatureScalarWhereInput[]
  }

  export type CreatureUncheckedUpdateManyWithoutVulnerabilitiesNestedInput = {
    create?: XOR<CreatureCreateWithoutVulnerabilitiesInput, CreatureUncheckedCreateWithoutVulnerabilitiesInput> | CreatureCreateWithoutVulnerabilitiesInput[] | CreatureUncheckedCreateWithoutVulnerabilitiesInput[]
    connectOrCreate?: CreatureCreateOrConnectWithoutVulnerabilitiesInput | CreatureCreateOrConnectWithoutVulnerabilitiesInput[]
    upsert?: CreatureUpsertWithWhereUniqueWithoutVulnerabilitiesInput | CreatureUpsertWithWhereUniqueWithoutVulnerabilitiesInput[]
    set?: CreatureWhereUniqueInput | CreatureWhereUniqueInput[]
    disconnect?: CreatureWhereUniqueInput | CreatureWhereUniqueInput[]
    delete?: CreatureWhereUniqueInput | CreatureWhereUniqueInput[]
    connect?: CreatureWhereUniqueInput | CreatureWhereUniqueInput[]
    update?: CreatureUpdateWithWhereUniqueWithoutVulnerabilitiesInput | CreatureUpdateWithWhereUniqueWithoutVulnerabilitiesInput[]
    updateMany?: CreatureUpdateManyWithWhereWithoutVulnerabilitiesInput | CreatureUpdateManyWithWhereWithoutVulnerabilitiesInput[]
    deleteMany?: CreatureScalarWhereInput | CreatureScalarWhereInput[]
  }

  export type CreatureCreateNestedManyWithoutChallenge_rating_metaInput = {
    create?: XOR<CreatureCreateWithoutChallenge_rating_metaInput, CreatureUncheckedCreateWithoutChallenge_rating_metaInput> | CreatureCreateWithoutChallenge_rating_metaInput[] | CreatureUncheckedCreateWithoutChallenge_rating_metaInput[]
    connectOrCreate?: CreatureCreateOrConnectWithoutChallenge_rating_metaInput | CreatureCreateOrConnectWithoutChallenge_rating_metaInput[]
    createMany?: CreatureCreateManyChallenge_rating_metaInputEnvelope
    connect?: CreatureWhereUniqueInput | CreatureWhereUniqueInput[]
  }

  export type CreatureUncheckedCreateNestedManyWithoutChallenge_rating_metaInput = {
    create?: XOR<CreatureCreateWithoutChallenge_rating_metaInput, CreatureUncheckedCreateWithoutChallenge_rating_metaInput> | CreatureCreateWithoutChallenge_rating_metaInput[] | CreatureUncheckedCreateWithoutChallenge_rating_metaInput[]
    connectOrCreate?: CreatureCreateOrConnectWithoutChallenge_rating_metaInput | CreatureCreateOrConnectWithoutChallenge_rating_metaInput[]
    createMany?: CreatureCreateManyChallenge_rating_metaInputEnvelope
    connect?: CreatureWhereUniqueInput | CreatureWhereUniqueInput[]
  }

  export type EnumChallengeRatingEnumFieldUpdateOperationsInput = {
    set?: $Enums.ChallengeRatingEnum
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type CreatureUpdateManyWithoutChallenge_rating_metaNestedInput = {
    create?: XOR<CreatureCreateWithoutChallenge_rating_metaInput, CreatureUncheckedCreateWithoutChallenge_rating_metaInput> | CreatureCreateWithoutChallenge_rating_metaInput[] | CreatureUncheckedCreateWithoutChallenge_rating_metaInput[]
    connectOrCreate?: CreatureCreateOrConnectWithoutChallenge_rating_metaInput | CreatureCreateOrConnectWithoutChallenge_rating_metaInput[]
    upsert?: CreatureUpsertWithWhereUniqueWithoutChallenge_rating_metaInput | CreatureUpsertWithWhereUniqueWithoutChallenge_rating_metaInput[]
    createMany?: CreatureCreateManyChallenge_rating_metaInputEnvelope
    set?: CreatureWhereUniqueInput | CreatureWhereUniqueInput[]
    disconnect?: CreatureWhereUniqueInput | CreatureWhereUniqueInput[]
    delete?: CreatureWhereUniqueInput | CreatureWhereUniqueInput[]
    connect?: CreatureWhereUniqueInput | CreatureWhereUniqueInput[]
    update?: CreatureUpdateWithWhereUniqueWithoutChallenge_rating_metaInput | CreatureUpdateWithWhereUniqueWithoutChallenge_rating_metaInput[]
    updateMany?: CreatureUpdateManyWithWhereWithoutChallenge_rating_metaInput | CreatureUpdateManyWithWhereWithoutChallenge_rating_metaInput[]
    deleteMany?: CreatureScalarWhereInput | CreatureScalarWhereInput[]
  }

  export type CreatureUncheckedUpdateManyWithoutChallenge_rating_metaNestedInput = {
    create?: XOR<CreatureCreateWithoutChallenge_rating_metaInput, CreatureUncheckedCreateWithoutChallenge_rating_metaInput> | CreatureCreateWithoutChallenge_rating_metaInput[] | CreatureUncheckedCreateWithoutChallenge_rating_metaInput[]
    connectOrCreate?: CreatureCreateOrConnectWithoutChallenge_rating_metaInput | CreatureCreateOrConnectWithoutChallenge_rating_metaInput[]
    upsert?: CreatureUpsertWithWhereUniqueWithoutChallenge_rating_metaInput | CreatureUpsertWithWhereUniqueWithoutChallenge_rating_metaInput[]
    createMany?: CreatureCreateManyChallenge_rating_metaInputEnvelope
    set?: CreatureWhereUniqueInput | CreatureWhereUniqueInput[]
    disconnect?: CreatureWhereUniqueInput | CreatureWhereUniqueInput[]
    delete?: CreatureWhereUniqueInput | CreatureWhereUniqueInput[]
    connect?: CreatureWhereUniqueInput | CreatureWhereUniqueInput[]
    update?: CreatureUpdateWithWhereUniqueWithoutChallenge_rating_metaInput | CreatureUpdateWithWhereUniqueWithoutChallenge_rating_metaInput[]
    updateMany?: CreatureUpdateManyWithWhereWithoutChallenge_rating_metaInput | CreatureUpdateManyWithWhereWithoutChallenge_rating_metaInput[]
    deleteMany?: CreatureScalarWhereInput | CreatureScalarWhereInput[]
  }

  export type GPTMessageCreateNestedManyWithoutMessage_history_relationInput = {
    create?: XOR<GPTMessageCreateWithoutMessage_history_relationInput, GPTMessageUncheckedCreateWithoutMessage_history_relationInput> | GPTMessageCreateWithoutMessage_history_relationInput[] | GPTMessageUncheckedCreateWithoutMessage_history_relationInput[]
    connectOrCreate?: GPTMessageCreateOrConnectWithoutMessage_history_relationInput | GPTMessageCreateOrConnectWithoutMessage_history_relationInput[]
    createMany?: GPTMessageCreateManyMessage_history_relationInputEnvelope
    connect?: GPTMessageWhereUniqueInput | GPTMessageWhereUniqueInput[]
  }

  export type GPTMessageUncheckedCreateNestedManyWithoutMessage_history_relationInput = {
    create?: XOR<GPTMessageCreateWithoutMessage_history_relationInput, GPTMessageUncheckedCreateWithoutMessage_history_relationInput> | GPTMessageCreateWithoutMessage_history_relationInput[] | GPTMessageUncheckedCreateWithoutMessage_history_relationInput[]
    connectOrCreate?: GPTMessageCreateOrConnectWithoutMessage_history_relationInput | GPTMessageCreateOrConnectWithoutMessage_history_relationInput[]
    createMany?: GPTMessageCreateManyMessage_history_relationInputEnvelope
    connect?: GPTMessageWhereUniqueInput | GPTMessageWhereUniqueInput[]
  }

  export type GPTMessageUpdateManyWithoutMessage_history_relationNestedInput = {
    create?: XOR<GPTMessageCreateWithoutMessage_history_relationInput, GPTMessageUncheckedCreateWithoutMessage_history_relationInput> | GPTMessageCreateWithoutMessage_history_relationInput[] | GPTMessageUncheckedCreateWithoutMessage_history_relationInput[]
    connectOrCreate?: GPTMessageCreateOrConnectWithoutMessage_history_relationInput | GPTMessageCreateOrConnectWithoutMessage_history_relationInput[]
    upsert?: GPTMessageUpsertWithWhereUniqueWithoutMessage_history_relationInput | GPTMessageUpsertWithWhereUniqueWithoutMessage_history_relationInput[]
    createMany?: GPTMessageCreateManyMessage_history_relationInputEnvelope
    set?: GPTMessageWhereUniqueInput | GPTMessageWhereUniqueInput[]
    disconnect?: GPTMessageWhereUniqueInput | GPTMessageWhereUniqueInput[]
    delete?: GPTMessageWhereUniqueInput | GPTMessageWhereUniqueInput[]
    connect?: GPTMessageWhereUniqueInput | GPTMessageWhereUniqueInput[]
    update?: GPTMessageUpdateWithWhereUniqueWithoutMessage_history_relationInput | GPTMessageUpdateWithWhereUniqueWithoutMessage_history_relationInput[]
    updateMany?: GPTMessageUpdateManyWithWhereWithoutMessage_history_relationInput | GPTMessageUpdateManyWithWhereWithoutMessage_history_relationInput[]
    deleteMany?: GPTMessageScalarWhereInput | GPTMessageScalarWhereInput[]
  }

  export type GPTMessageUncheckedUpdateManyWithoutMessage_history_relationNestedInput = {
    create?: XOR<GPTMessageCreateWithoutMessage_history_relationInput, GPTMessageUncheckedCreateWithoutMessage_history_relationInput> | GPTMessageCreateWithoutMessage_history_relationInput[] | GPTMessageUncheckedCreateWithoutMessage_history_relationInput[]
    connectOrCreate?: GPTMessageCreateOrConnectWithoutMessage_history_relationInput | GPTMessageCreateOrConnectWithoutMessage_history_relationInput[]
    upsert?: GPTMessageUpsertWithWhereUniqueWithoutMessage_history_relationInput | GPTMessageUpsertWithWhereUniqueWithoutMessage_history_relationInput[]
    createMany?: GPTMessageCreateManyMessage_history_relationInputEnvelope
    set?: GPTMessageWhereUniqueInput | GPTMessageWhereUniqueInput[]
    disconnect?: GPTMessageWhereUniqueInput | GPTMessageWhereUniqueInput[]
    delete?: GPTMessageWhereUniqueInput | GPTMessageWhereUniqueInput[]
    connect?: GPTMessageWhereUniqueInput | GPTMessageWhereUniqueInput[]
    update?: GPTMessageUpdateWithWhereUniqueWithoutMessage_history_relationInput | GPTMessageUpdateWithWhereUniqueWithoutMessage_history_relationInput[]
    updateMany?: GPTMessageUpdateManyWithWhereWithoutMessage_history_relationInput | GPTMessageUpdateManyWithWhereWithoutMessage_history_relationInput[]
    deleteMany?: GPTMessageScalarWhereInput | GPTMessageScalarWhereInput[]
  }

  export type GPTMessageHistoryCreateNestedOneWithoutMessages_relationInput = {
    create?: XOR<GPTMessageHistoryCreateWithoutMessages_relationInput, GPTMessageHistoryUncheckedCreateWithoutMessages_relationInput>
    connectOrCreate?: GPTMessageHistoryCreateOrConnectWithoutMessages_relationInput
    connect?: GPTMessageHistoryWhereUniqueInput
  }

  export type GPTMessageHistoryUpdateOneRequiredWithoutMessages_relationNestedInput = {
    create?: XOR<GPTMessageHistoryCreateWithoutMessages_relationInput, GPTMessageHistoryUncheckedCreateWithoutMessages_relationInput>
    connectOrCreate?: GPTMessageHistoryCreateOrConnectWithoutMessages_relationInput
    upsert?: GPTMessageHistoryUpsertWithoutMessages_relationInput
    connect?: GPTMessageHistoryWhereUniqueInput
    update?: XOR<XOR<GPTMessageHistoryUpdateToOneWithWhereWithoutMessages_relationInput, GPTMessageHistoryUpdateWithoutMessages_relationInput>, GPTMessageHistoryUncheckedUpdateWithoutMessages_relationInput>
  }

  export type GenreCreateNestedOneWithoutAdventures_relationInput = {
    create?: XOR<GenreCreateWithoutAdventures_relationInput, GenreUncheckedCreateWithoutAdventures_relationInput>
    connectOrCreate?: GenreCreateOrConnectWithoutAdventures_relationInput
    connect?: GenreWhereUniqueInput
  }

  export type KeywordCreateNestedManyWithoutAdventures_relationInput = {
    create?: XOR<KeywordCreateWithoutAdventures_relationInput, KeywordUncheckedCreateWithoutAdventures_relationInput> | KeywordCreateWithoutAdventures_relationInput[] | KeywordUncheckedCreateWithoutAdventures_relationInput[]
    connectOrCreate?: KeywordCreateOrConnectWithoutAdventures_relationInput | KeywordCreateOrConnectWithoutAdventures_relationInput[]
    connect?: KeywordWhereUniqueInput | KeywordWhereUniqueInput[]
  }

  export type KeywordUncheckedCreateNestedManyWithoutAdventures_relationInput = {
    create?: XOR<KeywordCreateWithoutAdventures_relationInput, KeywordUncheckedCreateWithoutAdventures_relationInput> | KeywordCreateWithoutAdventures_relationInput[] | KeywordUncheckedCreateWithoutAdventures_relationInput[]
    connectOrCreate?: KeywordCreateOrConnectWithoutAdventures_relationInput | KeywordCreateOrConnectWithoutAdventures_relationInput[]
    connect?: KeywordWhereUniqueInput | KeywordWhereUniqueInput[]
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type GenreUpdateOneRequiredWithoutAdventures_relationNestedInput = {
    create?: XOR<GenreCreateWithoutAdventures_relationInput, GenreUncheckedCreateWithoutAdventures_relationInput>
    connectOrCreate?: GenreCreateOrConnectWithoutAdventures_relationInput
    upsert?: GenreUpsertWithoutAdventures_relationInput
    connect?: GenreWhereUniqueInput
    update?: XOR<XOR<GenreUpdateToOneWithWhereWithoutAdventures_relationInput, GenreUpdateWithoutAdventures_relationInput>, GenreUncheckedUpdateWithoutAdventures_relationInput>
  }

  export type KeywordUpdateManyWithoutAdventures_relationNestedInput = {
    create?: XOR<KeywordCreateWithoutAdventures_relationInput, KeywordUncheckedCreateWithoutAdventures_relationInput> | KeywordCreateWithoutAdventures_relationInput[] | KeywordUncheckedCreateWithoutAdventures_relationInput[]
    connectOrCreate?: KeywordCreateOrConnectWithoutAdventures_relationInput | KeywordCreateOrConnectWithoutAdventures_relationInput[]
    upsert?: KeywordUpsertWithWhereUniqueWithoutAdventures_relationInput | KeywordUpsertWithWhereUniqueWithoutAdventures_relationInput[]
    set?: KeywordWhereUniqueInput | KeywordWhereUniqueInput[]
    disconnect?: KeywordWhereUniqueInput | KeywordWhereUniqueInput[]
    delete?: KeywordWhereUniqueInput | KeywordWhereUniqueInput[]
    connect?: KeywordWhereUniqueInput | KeywordWhereUniqueInput[]
    update?: KeywordUpdateWithWhereUniqueWithoutAdventures_relationInput | KeywordUpdateWithWhereUniqueWithoutAdventures_relationInput[]
    updateMany?: KeywordUpdateManyWithWhereWithoutAdventures_relationInput | KeywordUpdateManyWithWhereWithoutAdventures_relationInput[]
    deleteMany?: KeywordScalarWhereInput | KeywordScalarWhereInput[]
  }

  export type KeywordUncheckedUpdateManyWithoutAdventures_relationNestedInput = {
    create?: XOR<KeywordCreateWithoutAdventures_relationInput, KeywordUncheckedCreateWithoutAdventures_relationInput> | KeywordCreateWithoutAdventures_relationInput[] | KeywordUncheckedCreateWithoutAdventures_relationInput[]
    connectOrCreate?: KeywordCreateOrConnectWithoutAdventures_relationInput | KeywordCreateOrConnectWithoutAdventures_relationInput[]
    upsert?: KeywordUpsertWithWhereUniqueWithoutAdventures_relationInput | KeywordUpsertWithWhereUniqueWithoutAdventures_relationInput[]
    set?: KeywordWhereUniqueInput | KeywordWhereUniqueInput[]
    disconnect?: KeywordWhereUniqueInput | KeywordWhereUniqueInput[]
    delete?: KeywordWhereUniqueInput | KeywordWhereUniqueInput[]
    connect?: KeywordWhereUniqueInput | KeywordWhereUniqueInput[]
    update?: KeywordUpdateWithWhereUniqueWithoutAdventures_relationInput | KeywordUpdateWithWhereUniqueWithoutAdventures_relationInput[]
    updateMany?: KeywordUpdateManyWithWhereWithoutAdventures_relationInput | KeywordUpdateManyWithWhereWithoutAdventures_relationInput[]
    deleteMany?: KeywordScalarWhereInput | KeywordScalarWhereInput[]
  }

  export type GenreCreateNestedOneWithoutKeywords_relationInput = {
    create?: XOR<GenreCreateWithoutKeywords_relationInput, GenreUncheckedCreateWithoutKeywords_relationInput>
    connectOrCreate?: GenreCreateOrConnectWithoutKeywords_relationInput
    connect?: GenreWhereUniqueInput
  }

  export type AdventureCreateNestedManyWithoutKeywords_relationInput = {
    create?: XOR<AdventureCreateWithoutKeywords_relationInput, AdventureUncheckedCreateWithoutKeywords_relationInput> | AdventureCreateWithoutKeywords_relationInput[] | AdventureUncheckedCreateWithoutKeywords_relationInput[]
    connectOrCreate?: AdventureCreateOrConnectWithoutKeywords_relationInput | AdventureCreateOrConnectWithoutKeywords_relationInput[]
    connect?: AdventureWhereUniqueInput | AdventureWhereUniqueInput[]
  }

  export type AdventureUncheckedCreateNestedManyWithoutKeywords_relationInput = {
    create?: XOR<AdventureCreateWithoutKeywords_relationInput, AdventureUncheckedCreateWithoutKeywords_relationInput> | AdventureCreateWithoutKeywords_relationInput[] | AdventureUncheckedCreateWithoutKeywords_relationInput[]
    connectOrCreate?: AdventureCreateOrConnectWithoutKeywords_relationInput | AdventureCreateOrConnectWithoutKeywords_relationInput[]
    connect?: AdventureWhereUniqueInput | AdventureWhereUniqueInput[]
  }

  export type GenreUpdateOneRequiredWithoutKeywords_relationNestedInput = {
    create?: XOR<GenreCreateWithoutKeywords_relationInput, GenreUncheckedCreateWithoutKeywords_relationInput>
    connectOrCreate?: GenreCreateOrConnectWithoutKeywords_relationInput
    upsert?: GenreUpsertWithoutKeywords_relationInput
    connect?: GenreWhereUniqueInput
    update?: XOR<XOR<GenreUpdateToOneWithWhereWithoutKeywords_relationInput, GenreUpdateWithoutKeywords_relationInput>, GenreUncheckedUpdateWithoutKeywords_relationInput>
  }

  export type AdventureUpdateManyWithoutKeywords_relationNestedInput = {
    create?: XOR<AdventureCreateWithoutKeywords_relationInput, AdventureUncheckedCreateWithoutKeywords_relationInput> | AdventureCreateWithoutKeywords_relationInput[] | AdventureUncheckedCreateWithoutKeywords_relationInput[]
    connectOrCreate?: AdventureCreateOrConnectWithoutKeywords_relationInput | AdventureCreateOrConnectWithoutKeywords_relationInput[]
    upsert?: AdventureUpsertWithWhereUniqueWithoutKeywords_relationInput | AdventureUpsertWithWhereUniqueWithoutKeywords_relationInput[]
    set?: AdventureWhereUniqueInput | AdventureWhereUniqueInput[]
    disconnect?: AdventureWhereUniqueInput | AdventureWhereUniqueInput[]
    delete?: AdventureWhereUniqueInput | AdventureWhereUniqueInput[]
    connect?: AdventureWhereUniqueInput | AdventureWhereUniqueInput[]
    update?: AdventureUpdateWithWhereUniqueWithoutKeywords_relationInput | AdventureUpdateWithWhereUniqueWithoutKeywords_relationInput[]
    updateMany?: AdventureUpdateManyWithWhereWithoutKeywords_relationInput | AdventureUpdateManyWithWhereWithoutKeywords_relationInput[]
    deleteMany?: AdventureScalarWhereInput | AdventureScalarWhereInput[]
  }

  export type AdventureUncheckedUpdateManyWithoutKeywords_relationNestedInput = {
    create?: XOR<AdventureCreateWithoutKeywords_relationInput, AdventureUncheckedCreateWithoutKeywords_relationInput> | AdventureCreateWithoutKeywords_relationInput[] | AdventureUncheckedCreateWithoutKeywords_relationInput[]
    connectOrCreate?: AdventureCreateOrConnectWithoutKeywords_relationInput | AdventureCreateOrConnectWithoutKeywords_relationInput[]
    upsert?: AdventureUpsertWithWhereUniqueWithoutKeywords_relationInput | AdventureUpsertWithWhereUniqueWithoutKeywords_relationInput[]
    set?: AdventureWhereUniqueInput | AdventureWhereUniqueInput[]
    disconnect?: AdventureWhereUniqueInput | AdventureWhereUniqueInput[]
    delete?: AdventureWhereUniqueInput | AdventureWhereUniqueInput[]
    connect?: AdventureWhereUniqueInput | AdventureWhereUniqueInput[]
    update?: AdventureUpdateWithWhereUniqueWithoutKeywords_relationInput | AdventureUpdateWithWhereUniqueWithoutKeywords_relationInput[]
    updateMany?: AdventureUpdateManyWithWhereWithoutKeywords_relationInput | AdventureUpdateManyWithWhereWithoutKeywords_relationInput[]
    deleteMany?: AdventureScalarWhereInput | AdventureScalarWhereInput[]
  }

  export type KeywordCreateNestedManyWithoutGenre_relationInput = {
    create?: XOR<KeywordCreateWithoutGenre_relationInput, KeywordUncheckedCreateWithoutGenre_relationInput> | KeywordCreateWithoutGenre_relationInput[] | KeywordUncheckedCreateWithoutGenre_relationInput[]
    connectOrCreate?: KeywordCreateOrConnectWithoutGenre_relationInput | KeywordCreateOrConnectWithoutGenre_relationInput[]
    createMany?: KeywordCreateManyGenre_relationInputEnvelope
    connect?: KeywordWhereUniqueInput | KeywordWhereUniqueInput[]
  }

  export type AdventureCreateNestedManyWithoutGenre_relationInput = {
    create?: XOR<AdventureCreateWithoutGenre_relationInput, AdventureUncheckedCreateWithoutGenre_relationInput> | AdventureCreateWithoutGenre_relationInput[] | AdventureUncheckedCreateWithoutGenre_relationInput[]
    connectOrCreate?: AdventureCreateOrConnectWithoutGenre_relationInput | AdventureCreateOrConnectWithoutGenre_relationInput[]
    createMany?: AdventureCreateManyGenre_relationInputEnvelope
    connect?: AdventureWhereUniqueInput | AdventureWhereUniqueInput[]
  }

  export type KeywordUncheckedCreateNestedManyWithoutGenre_relationInput = {
    create?: XOR<KeywordCreateWithoutGenre_relationInput, KeywordUncheckedCreateWithoutGenre_relationInput> | KeywordCreateWithoutGenre_relationInput[] | KeywordUncheckedCreateWithoutGenre_relationInput[]
    connectOrCreate?: KeywordCreateOrConnectWithoutGenre_relationInput | KeywordCreateOrConnectWithoutGenre_relationInput[]
    createMany?: KeywordCreateManyGenre_relationInputEnvelope
    connect?: KeywordWhereUniqueInput | KeywordWhereUniqueInput[]
  }

  export type AdventureUncheckedCreateNestedManyWithoutGenre_relationInput = {
    create?: XOR<AdventureCreateWithoutGenre_relationInput, AdventureUncheckedCreateWithoutGenre_relationInput> | AdventureCreateWithoutGenre_relationInput[] | AdventureUncheckedCreateWithoutGenre_relationInput[]
    connectOrCreate?: AdventureCreateOrConnectWithoutGenre_relationInput | AdventureCreateOrConnectWithoutGenre_relationInput[]
    createMany?: AdventureCreateManyGenre_relationInputEnvelope
    connect?: AdventureWhereUniqueInput | AdventureWhereUniqueInput[]
  }

  export type KeywordUpdateManyWithoutGenre_relationNestedInput = {
    create?: XOR<KeywordCreateWithoutGenre_relationInput, KeywordUncheckedCreateWithoutGenre_relationInput> | KeywordCreateWithoutGenre_relationInput[] | KeywordUncheckedCreateWithoutGenre_relationInput[]
    connectOrCreate?: KeywordCreateOrConnectWithoutGenre_relationInput | KeywordCreateOrConnectWithoutGenre_relationInput[]
    upsert?: KeywordUpsertWithWhereUniqueWithoutGenre_relationInput | KeywordUpsertWithWhereUniqueWithoutGenre_relationInput[]
    createMany?: KeywordCreateManyGenre_relationInputEnvelope
    set?: KeywordWhereUniqueInput | KeywordWhereUniqueInput[]
    disconnect?: KeywordWhereUniqueInput | KeywordWhereUniqueInput[]
    delete?: KeywordWhereUniqueInput | KeywordWhereUniqueInput[]
    connect?: KeywordWhereUniqueInput | KeywordWhereUniqueInput[]
    update?: KeywordUpdateWithWhereUniqueWithoutGenre_relationInput | KeywordUpdateWithWhereUniqueWithoutGenre_relationInput[]
    updateMany?: KeywordUpdateManyWithWhereWithoutGenre_relationInput | KeywordUpdateManyWithWhereWithoutGenre_relationInput[]
    deleteMany?: KeywordScalarWhereInput | KeywordScalarWhereInput[]
  }

  export type AdventureUpdateManyWithoutGenre_relationNestedInput = {
    create?: XOR<AdventureCreateWithoutGenre_relationInput, AdventureUncheckedCreateWithoutGenre_relationInput> | AdventureCreateWithoutGenre_relationInput[] | AdventureUncheckedCreateWithoutGenre_relationInput[]
    connectOrCreate?: AdventureCreateOrConnectWithoutGenre_relationInput | AdventureCreateOrConnectWithoutGenre_relationInput[]
    upsert?: AdventureUpsertWithWhereUniqueWithoutGenre_relationInput | AdventureUpsertWithWhereUniqueWithoutGenre_relationInput[]
    createMany?: AdventureCreateManyGenre_relationInputEnvelope
    set?: AdventureWhereUniqueInput | AdventureWhereUniqueInput[]
    disconnect?: AdventureWhereUniqueInput | AdventureWhereUniqueInput[]
    delete?: AdventureWhereUniqueInput | AdventureWhereUniqueInput[]
    connect?: AdventureWhereUniqueInput | AdventureWhereUniqueInput[]
    update?: AdventureUpdateWithWhereUniqueWithoutGenre_relationInput | AdventureUpdateWithWhereUniqueWithoutGenre_relationInput[]
    updateMany?: AdventureUpdateManyWithWhereWithoutGenre_relationInput | AdventureUpdateManyWithWhereWithoutGenre_relationInput[]
    deleteMany?: AdventureScalarWhereInput | AdventureScalarWhereInput[]
  }

  export type KeywordUncheckedUpdateManyWithoutGenre_relationNestedInput = {
    create?: XOR<KeywordCreateWithoutGenre_relationInput, KeywordUncheckedCreateWithoutGenre_relationInput> | KeywordCreateWithoutGenre_relationInput[] | KeywordUncheckedCreateWithoutGenre_relationInput[]
    connectOrCreate?: KeywordCreateOrConnectWithoutGenre_relationInput | KeywordCreateOrConnectWithoutGenre_relationInput[]
    upsert?: KeywordUpsertWithWhereUniqueWithoutGenre_relationInput | KeywordUpsertWithWhereUniqueWithoutGenre_relationInput[]
    createMany?: KeywordCreateManyGenre_relationInputEnvelope
    set?: KeywordWhereUniqueInput | KeywordWhereUniqueInput[]
    disconnect?: KeywordWhereUniqueInput | KeywordWhereUniqueInput[]
    delete?: KeywordWhereUniqueInput | KeywordWhereUniqueInput[]
    connect?: KeywordWhereUniqueInput | KeywordWhereUniqueInput[]
    update?: KeywordUpdateWithWhereUniqueWithoutGenre_relationInput | KeywordUpdateWithWhereUniqueWithoutGenre_relationInput[]
    updateMany?: KeywordUpdateManyWithWhereWithoutGenre_relationInput | KeywordUpdateManyWithWhereWithoutGenre_relationInput[]
    deleteMany?: KeywordScalarWhereInput | KeywordScalarWhereInput[]
  }

  export type AdventureUncheckedUpdateManyWithoutGenre_relationNestedInput = {
    create?: XOR<AdventureCreateWithoutGenre_relationInput, AdventureUncheckedCreateWithoutGenre_relationInput> | AdventureCreateWithoutGenre_relationInput[] | AdventureUncheckedCreateWithoutGenre_relationInput[]
    connectOrCreate?: AdventureCreateOrConnectWithoutGenre_relationInput | AdventureCreateOrConnectWithoutGenre_relationInput[]
    upsert?: AdventureUpsertWithWhereUniqueWithoutGenre_relationInput | AdventureUpsertWithWhereUniqueWithoutGenre_relationInput[]
    createMany?: AdventureCreateManyGenre_relationInputEnvelope
    set?: AdventureWhereUniqueInput | AdventureWhereUniqueInput[]
    disconnect?: AdventureWhereUniqueInput | AdventureWhereUniqueInput[]
    delete?: AdventureWhereUniqueInput | AdventureWhereUniqueInput[]
    connect?: AdventureWhereUniqueInput | AdventureWhereUniqueInput[]
    update?: AdventureUpdateWithWhereUniqueWithoutGenre_relationInput | AdventureUpdateWithWhereUniqueWithoutGenre_relationInput[]
    updateMany?: AdventureUpdateManyWithWhereWithoutGenre_relationInput | AdventureUpdateManyWithWhereWithoutGenre_relationInput[]
    deleteMany?: AdventureScalarWhereInput | AdventureScalarWhereInput[]
  }

  export type MagicItemTypeCreateNestedOneWithoutMagicItemsInput = {
    create?: XOR<MagicItemTypeCreateWithoutMagicItemsInput, MagicItemTypeUncheckedCreateWithoutMagicItemsInput>
    connectOrCreate?: MagicItemTypeCreateOrConnectWithoutMagicItemsInput
    connect?: MagicItemTypeWhereUniqueInput
  }

  export type MagicItemRarityCreateNestedOneWithoutMagicItemsInput = {
    create?: XOR<MagicItemRarityCreateWithoutMagicItemsInput, MagicItemRarityUncheckedCreateWithoutMagicItemsInput>
    connectOrCreate?: MagicItemRarityCreateOrConnectWithoutMagicItemsInput
    connect?: MagicItemRarityWhereUniqueInput
  }

  export type SourceCreateNestedOneWithoutMagicItemsInput = {
    create?: XOR<SourceCreateWithoutMagicItemsInput, SourceUncheckedCreateWithoutMagicItemsInput>
    connectOrCreate?: SourceCreateOrConnectWithoutMagicItemsInput
    connect?: SourceWhereUniqueInput
  }

  export type MagicItemAttunementCreateNestedManyWithoutMagicItemInput = {
    create?: XOR<MagicItemAttunementCreateWithoutMagicItemInput, MagicItemAttunementUncheckedCreateWithoutMagicItemInput> | MagicItemAttunementCreateWithoutMagicItemInput[] | MagicItemAttunementUncheckedCreateWithoutMagicItemInput[]
    connectOrCreate?: MagicItemAttunementCreateOrConnectWithoutMagicItemInput | MagicItemAttunementCreateOrConnectWithoutMagicItemInput[]
    createMany?: MagicItemAttunementCreateManyMagicItemInputEnvelope
    connect?: MagicItemAttunementWhereUniqueInput | MagicItemAttunementWhereUniqueInput[]
  }

  export type MagicItemAttunementUncheckedCreateNestedManyWithoutMagicItemInput = {
    create?: XOR<MagicItemAttunementCreateWithoutMagicItemInput, MagicItemAttunementUncheckedCreateWithoutMagicItemInput> | MagicItemAttunementCreateWithoutMagicItemInput[] | MagicItemAttunementUncheckedCreateWithoutMagicItemInput[]
    connectOrCreate?: MagicItemAttunementCreateOrConnectWithoutMagicItemInput | MagicItemAttunementCreateOrConnectWithoutMagicItemInput[]
    createMany?: MagicItemAttunementCreateManyMagicItemInputEnvelope
    connect?: MagicItemAttunementWhereUniqueInput | MagicItemAttunementWhereUniqueInput[]
  }

  export type MagicItemTypeUpdateOneRequiredWithoutMagicItemsNestedInput = {
    create?: XOR<MagicItemTypeCreateWithoutMagicItemsInput, MagicItemTypeUncheckedCreateWithoutMagicItemsInput>
    connectOrCreate?: MagicItemTypeCreateOrConnectWithoutMagicItemsInput
    upsert?: MagicItemTypeUpsertWithoutMagicItemsInput
    connect?: MagicItemTypeWhereUniqueInput
    update?: XOR<XOR<MagicItemTypeUpdateToOneWithWhereWithoutMagicItemsInput, MagicItemTypeUpdateWithoutMagicItemsInput>, MagicItemTypeUncheckedUpdateWithoutMagicItemsInput>
  }

  export type MagicItemRarityUpdateOneRequiredWithoutMagicItemsNestedInput = {
    create?: XOR<MagicItemRarityCreateWithoutMagicItemsInput, MagicItemRarityUncheckedCreateWithoutMagicItemsInput>
    connectOrCreate?: MagicItemRarityCreateOrConnectWithoutMagicItemsInput
    upsert?: MagicItemRarityUpsertWithoutMagicItemsInput
    connect?: MagicItemRarityWhereUniqueInput
    update?: XOR<XOR<MagicItemRarityUpdateToOneWithWhereWithoutMagicItemsInput, MagicItemRarityUpdateWithoutMagicItemsInput>, MagicItemRarityUncheckedUpdateWithoutMagicItemsInput>
  }

  export type SourceUpdateOneRequiredWithoutMagicItemsNestedInput = {
    create?: XOR<SourceCreateWithoutMagicItemsInput, SourceUncheckedCreateWithoutMagicItemsInput>
    connectOrCreate?: SourceCreateOrConnectWithoutMagicItemsInput
    upsert?: SourceUpsertWithoutMagicItemsInput
    connect?: SourceWhereUniqueInput
    update?: XOR<XOR<SourceUpdateToOneWithWhereWithoutMagicItemsInput, SourceUpdateWithoutMagicItemsInput>, SourceUncheckedUpdateWithoutMagicItemsInput>
  }

  export type MagicItemAttunementUpdateManyWithoutMagicItemNestedInput = {
    create?: XOR<MagicItemAttunementCreateWithoutMagicItemInput, MagicItemAttunementUncheckedCreateWithoutMagicItemInput> | MagicItemAttunementCreateWithoutMagicItemInput[] | MagicItemAttunementUncheckedCreateWithoutMagicItemInput[]
    connectOrCreate?: MagicItemAttunementCreateOrConnectWithoutMagicItemInput | MagicItemAttunementCreateOrConnectWithoutMagicItemInput[]
    upsert?: MagicItemAttunementUpsertWithWhereUniqueWithoutMagicItemInput | MagicItemAttunementUpsertWithWhereUniqueWithoutMagicItemInput[]
    createMany?: MagicItemAttunementCreateManyMagicItemInputEnvelope
    set?: MagicItemAttunementWhereUniqueInput | MagicItemAttunementWhereUniqueInput[]
    disconnect?: MagicItemAttunementWhereUniqueInput | MagicItemAttunementWhereUniqueInput[]
    delete?: MagicItemAttunementWhereUniqueInput | MagicItemAttunementWhereUniqueInput[]
    connect?: MagicItemAttunementWhereUniqueInput | MagicItemAttunementWhereUniqueInput[]
    update?: MagicItemAttunementUpdateWithWhereUniqueWithoutMagicItemInput | MagicItemAttunementUpdateWithWhereUniqueWithoutMagicItemInput[]
    updateMany?: MagicItemAttunementUpdateManyWithWhereWithoutMagicItemInput | MagicItemAttunementUpdateManyWithWhereWithoutMagicItemInput[]
    deleteMany?: MagicItemAttunementScalarWhereInput | MagicItemAttunementScalarWhereInput[]
  }

  export type MagicItemAttunementUncheckedUpdateManyWithoutMagicItemNestedInput = {
    create?: XOR<MagicItemAttunementCreateWithoutMagicItemInput, MagicItemAttunementUncheckedCreateWithoutMagicItemInput> | MagicItemAttunementCreateWithoutMagicItemInput[] | MagicItemAttunementUncheckedCreateWithoutMagicItemInput[]
    connectOrCreate?: MagicItemAttunementCreateOrConnectWithoutMagicItemInput | MagicItemAttunementCreateOrConnectWithoutMagicItemInput[]
    upsert?: MagicItemAttunementUpsertWithWhereUniqueWithoutMagicItemInput | MagicItemAttunementUpsertWithWhereUniqueWithoutMagicItemInput[]
    createMany?: MagicItemAttunementCreateManyMagicItemInputEnvelope
    set?: MagicItemAttunementWhereUniqueInput | MagicItemAttunementWhereUniqueInput[]
    disconnect?: MagicItemAttunementWhereUniqueInput | MagicItemAttunementWhereUniqueInput[]
    delete?: MagicItemAttunementWhereUniqueInput | MagicItemAttunementWhereUniqueInput[]
    connect?: MagicItemAttunementWhereUniqueInput | MagicItemAttunementWhereUniqueInput[]
    update?: MagicItemAttunementUpdateWithWhereUniqueWithoutMagicItemInput | MagicItemAttunementUpdateWithWhereUniqueWithoutMagicItemInput[]
    updateMany?: MagicItemAttunementUpdateManyWithWhereWithoutMagicItemInput | MagicItemAttunementUpdateManyWithWhereWithoutMagicItemInput[]
    deleteMany?: MagicItemAttunementScalarWhereInput | MagicItemAttunementScalarWhereInput[]
  }

  export type MagicItemCreateNestedManyWithoutRarity_relationInput = {
    create?: XOR<MagicItemCreateWithoutRarity_relationInput, MagicItemUncheckedCreateWithoutRarity_relationInput> | MagicItemCreateWithoutRarity_relationInput[] | MagicItemUncheckedCreateWithoutRarity_relationInput[]
    connectOrCreate?: MagicItemCreateOrConnectWithoutRarity_relationInput | MagicItemCreateOrConnectWithoutRarity_relationInput[]
    createMany?: MagicItemCreateManyRarity_relationInputEnvelope
    connect?: MagicItemWhereUniqueInput | MagicItemWhereUniqueInput[]
  }

  export type MagicItemUncheckedCreateNestedManyWithoutRarity_relationInput = {
    create?: XOR<MagicItemCreateWithoutRarity_relationInput, MagicItemUncheckedCreateWithoutRarity_relationInput> | MagicItemCreateWithoutRarity_relationInput[] | MagicItemUncheckedCreateWithoutRarity_relationInput[]
    connectOrCreate?: MagicItemCreateOrConnectWithoutRarity_relationInput | MagicItemCreateOrConnectWithoutRarity_relationInput[]
    createMany?: MagicItemCreateManyRarity_relationInputEnvelope
    connect?: MagicItemWhereUniqueInput | MagicItemWhereUniqueInput[]
  }

  export type MagicItemUpdateManyWithoutRarity_relationNestedInput = {
    create?: XOR<MagicItemCreateWithoutRarity_relationInput, MagicItemUncheckedCreateWithoutRarity_relationInput> | MagicItemCreateWithoutRarity_relationInput[] | MagicItemUncheckedCreateWithoutRarity_relationInput[]
    connectOrCreate?: MagicItemCreateOrConnectWithoutRarity_relationInput | MagicItemCreateOrConnectWithoutRarity_relationInput[]
    upsert?: MagicItemUpsertWithWhereUniqueWithoutRarity_relationInput | MagicItemUpsertWithWhereUniqueWithoutRarity_relationInput[]
    createMany?: MagicItemCreateManyRarity_relationInputEnvelope
    set?: MagicItemWhereUniqueInput | MagicItemWhereUniqueInput[]
    disconnect?: MagicItemWhereUniqueInput | MagicItemWhereUniqueInput[]
    delete?: MagicItemWhereUniqueInput | MagicItemWhereUniqueInput[]
    connect?: MagicItemWhereUniqueInput | MagicItemWhereUniqueInput[]
    update?: MagicItemUpdateWithWhereUniqueWithoutRarity_relationInput | MagicItemUpdateWithWhereUniqueWithoutRarity_relationInput[]
    updateMany?: MagicItemUpdateManyWithWhereWithoutRarity_relationInput | MagicItemUpdateManyWithWhereWithoutRarity_relationInput[]
    deleteMany?: MagicItemScalarWhereInput | MagicItemScalarWhereInput[]
  }

  export type MagicItemUncheckedUpdateManyWithoutRarity_relationNestedInput = {
    create?: XOR<MagicItemCreateWithoutRarity_relationInput, MagicItemUncheckedCreateWithoutRarity_relationInput> | MagicItemCreateWithoutRarity_relationInput[] | MagicItemUncheckedCreateWithoutRarity_relationInput[]
    connectOrCreate?: MagicItemCreateOrConnectWithoutRarity_relationInput | MagicItemCreateOrConnectWithoutRarity_relationInput[]
    upsert?: MagicItemUpsertWithWhereUniqueWithoutRarity_relationInput | MagicItemUpsertWithWhereUniqueWithoutRarity_relationInput[]
    createMany?: MagicItemCreateManyRarity_relationInputEnvelope
    set?: MagicItemWhereUniqueInput | MagicItemWhereUniqueInput[]
    disconnect?: MagicItemWhereUniqueInput | MagicItemWhereUniqueInput[]
    delete?: MagicItemWhereUniqueInput | MagicItemWhereUniqueInput[]
    connect?: MagicItemWhereUniqueInput | MagicItemWhereUniqueInput[]
    update?: MagicItemUpdateWithWhereUniqueWithoutRarity_relationInput | MagicItemUpdateWithWhereUniqueWithoutRarity_relationInput[]
    updateMany?: MagicItemUpdateManyWithWhereWithoutRarity_relationInput | MagicItemUpdateManyWithWhereWithoutRarity_relationInput[]
    deleteMany?: MagicItemScalarWhereInput | MagicItemScalarWhereInput[]
  }

  export type MagicItemCreateNestedManyWithoutType_relationInput = {
    create?: XOR<MagicItemCreateWithoutType_relationInput, MagicItemUncheckedCreateWithoutType_relationInput> | MagicItemCreateWithoutType_relationInput[] | MagicItemUncheckedCreateWithoutType_relationInput[]
    connectOrCreate?: MagicItemCreateOrConnectWithoutType_relationInput | MagicItemCreateOrConnectWithoutType_relationInput[]
    createMany?: MagicItemCreateManyType_relationInputEnvelope
    connect?: MagicItemWhereUniqueInput | MagicItemWhereUniqueInput[]
  }

  export type MagicItemUncheckedCreateNestedManyWithoutType_relationInput = {
    create?: XOR<MagicItemCreateWithoutType_relationInput, MagicItemUncheckedCreateWithoutType_relationInput> | MagicItemCreateWithoutType_relationInput[] | MagicItemUncheckedCreateWithoutType_relationInput[]
    connectOrCreate?: MagicItemCreateOrConnectWithoutType_relationInput | MagicItemCreateOrConnectWithoutType_relationInput[]
    createMany?: MagicItemCreateManyType_relationInputEnvelope
    connect?: MagicItemWhereUniqueInput | MagicItemWhereUniqueInput[]
  }

  export type EnumGenderFieldUpdateOperationsInput = {
    set?: $Enums.Gender
  }

  export type MagicItemUpdateManyWithoutType_relationNestedInput = {
    create?: XOR<MagicItemCreateWithoutType_relationInput, MagicItemUncheckedCreateWithoutType_relationInput> | MagicItemCreateWithoutType_relationInput[] | MagicItemUncheckedCreateWithoutType_relationInput[]
    connectOrCreate?: MagicItemCreateOrConnectWithoutType_relationInput | MagicItemCreateOrConnectWithoutType_relationInput[]
    upsert?: MagicItemUpsertWithWhereUniqueWithoutType_relationInput | MagicItemUpsertWithWhereUniqueWithoutType_relationInput[]
    createMany?: MagicItemCreateManyType_relationInputEnvelope
    set?: MagicItemWhereUniqueInput | MagicItemWhereUniqueInput[]
    disconnect?: MagicItemWhereUniqueInput | MagicItemWhereUniqueInput[]
    delete?: MagicItemWhereUniqueInput | MagicItemWhereUniqueInput[]
    connect?: MagicItemWhereUniqueInput | MagicItemWhereUniqueInput[]
    update?: MagicItemUpdateWithWhereUniqueWithoutType_relationInput | MagicItemUpdateWithWhereUniqueWithoutType_relationInput[]
    updateMany?: MagicItemUpdateManyWithWhereWithoutType_relationInput | MagicItemUpdateManyWithWhereWithoutType_relationInput[]
    deleteMany?: MagicItemScalarWhereInput | MagicItemScalarWhereInput[]
  }

  export type MagicItemUncheckedUpdateManyWithoutType_relationNestedInput = {
    create?: XOR<MagicItemCreateWithoutType_relationInput, MagicItemUncheckedCreateWithoutType_relationInput> | MagicItemCreateWithoutType_relationInput[] | MagicItemUncheckedCreateWithoutType_relationInput[]
    connectOrCreate?: MagicItemCreateOrConnectWithoutType_relationInput | MagicItemCreateOrConnectWithoutType_relationInput[]
    upsert?: MagicItemUpsertWithWhereUniqueWithoutType_relationInput | MagicItemUpsertWithWhereUniqueWithoutType_relationInput[]
    createMany?: MagicItemCreateManyType_relationInputEnvelope
    set?: MagicItemWhereUniqueInput | MagicItemWhereUniqueInput[]
    disconnect?: MagicItemWhereUniqueInput | MagicItemWhereUniqueInput[]
    delete?: MagicItemWhereUniqueInput | MagicItemWhereUniqueInput[]
    connect?: MagicItemWhereUniqueInput | MagicItemWhereUniqueInput[]
    update?: MagicItemUpdateWithWhereUniqueWithoutType_relationInput | MagicItemUpdateWithWhereUniqueWithoutType_relationInput[]
    updateMany?: MagicItemUpdateManyWithWhereWithoutType_relationInput | MagicItemUpdateManyWithWhereWithoutType_relationInput[]
    deleteMany?: MagicItemScalarWhereInput | MagicItemScalarWhereInput[]
  }

  export type MagicItemAttunementCreateNestedManyWithoutAttunementInput = {
    create?: XOR<MagicItemAttunementCreateWithoutAttunementInput, MagicItemAttunementUncheckedCreateWithoutAttunementInput> | MagicItemAttunementCreateWithoutAttunementInput[] | MagicItemAttunementUncheckedCreateWithoutAttunementInput[]
    connectOrCreate?: MagicItemAttunementCreateOrConnectWithoutAttunementInput | MagicItemAttunementCreateOrConnectWithoutAttunementInput[]
    createMany?: MagicItemAttunementCreateManyAttunementInputEnvelope
    connect?: MagicItemAttunementWhereUniqueInput | MagicItemAttunementWhereUniqueInput[]
  }

  export type MagicItemAttunementUncheckedCreateNestedManyWithoutAttunementInput = {
    create?: XOR<MagicItemAttunementCreateWithoutAttunementInput, MagicItemAttunementUncheckedCreateWithoutAttunementInput> | MagicItemAttunementCreateWithoutAttunementInput[] | MagicItemAttunementUncheckedCreateWithoutAttunementInput[]
    connectOrCreate?: MagicItemAttunementCreateOrConnectWithoutAttunementInput | MagicItemAttunementCreateOrConnectWithoutAttunementInput[]
    createMany?: MagicItemAttunementCreateManyAttunementInputEnvelope
    connect?: MagicItemAttunementWhereUniqueInput | MagicItemAttunementWhereUniqueInput[]
  }

  export type MagicItemAttunementUpdateManyWithoutAttunementNestedInput = {
    create?: XOR<MagicItemAttunementCreateWithoutAttunementInput, MagicItemAttunementUncheckedCreateWithoutAttunementInput> | MagicItemAttunementCreateWithoutAttunementInput[] | MagicItemAttunementUncheckedCreateWithoutAttunementInput[]
    connectOrCreate?: MagicItemAttunementCreateOrConnectWithoutAttunementInput | MagicItemAttunementCreateOrConnectWithoutAttunementInput[]
    upsert?: MagicItemAttunementUpsertWithWhereUniqueWithoutAttunementInput | MagicItemAttunementUpsertWithWhereUniqueWithoutAttunementInput[]
    createMany?: MagicItemAttunementCreateManyAttunementInputEnvelope
    set?: MagicItemAttunementWhereUniqueInput | MagicItemAttunementWhereUniqueInput[]
    disconnect?: MagicItemAttunementWhereUniqueInput | MagicItemAttunementWhereUniqueInput[]
    delete?: MagicItemAttunementWhereUniqueInput | MagicItemAttunementWhereUniqueInput[]
    connect?: MagicItemAttunementWhereUniqueInput | MagicItemAttunementWhereUniqueInput[]
    update?: MagicItemAttunementUpdateWithWhereUniqueWithoutAttunementInput | MagicItemAttunementUpdateWithWhereUniqueWithoutAttunementInput[]
    updateMany?: MagicItemAttunementUpdateManyWithWhereWithoutAttunementInput | MagicItemAttunementUpdateManyWithWhereWithoutAttunementInput[]
    deleteMany?: MagicItemAttunementScalarWhereInput | MagicItemAttunementScalarWhereInput[]
  }

  export type MagicItemAttunementUncheckedUpdateManyWithoutAttunementNestedInput = {
    create?: XOR<MagicItemAttunementCreateWithoutAttunementInput, MagicItemAttunementUncheckedCreateWithoutAttunementInput> | MagicItemAttunementCreateWithoutAttunementInput[] | MagicItemAttunementUncheckedCreateWithoutAttunementInput[]
    connectOrCreate?: MagicItemAttunementCreateOrConnectWithoutAttunementInput | MagicItemAttunementCreateOrConnectWithoutAttunementInput[]
    upsert?: MagicItemAttunementUpsertWithWhereUniqueWithoutAttunementInput | MagicItemAttunementUpsertWithWhereUniqueWithoutAttunementInput[]
    createMany?: MagicItemAttunementCreateManyAttunementInputEnvelope
    set?: MagicItemAttunementWhereUniqueInput | MagicItemAttunementWhereUniqueInput[]
    disconnect?: MagicItemAttunementWhereUniqueInput | MagicItemAttunementWhereUniqueInput[]
    delete?: MagicItemAttunementWhereUniqueInput | MagicItemAttunementWhereUniqueInput[]
    connect?: MagicItemAttunementWhereUniqueInput | MagicItemAttunementWhereUniqueInput[]
    update?: MagicItemAttunementUpdateWithWhereUniqueWithoutAttunementInput | MagicItemAttunementUpdateWithWhereUniqueWithoutAttunementInput[]
    updateMany?: MagicItemAttunementUpdateManyWithWhereWithoutAttunementInput | MagicItemAttunementUpdateManyWithWhereWithoutAttunementInput[]
    deleteMany?: MagicItemAttunementScalarWhereInput | MagicItemAttunementScalarWhereInput[]
  }

  export type MagicItemCreateNestedOneWithoutAttunements_relationInput = {
    create?: XOR<MagicItemCreateWithoutAttunements_relationInput, MagicItemUncheckedCreateWithoutAttunements_relationInput>
    connectOrCreate?: MagicItemCreateOrConnectWithoutAttunements_relationInput
    connect?: MagicItemWhereUniqueInput
  }

  export type AttunementConditionCreateNestedOneWithoutMagicItemsInput = {
    create?: XOR<AttunementConditionCreateWithoutMagicItemsInput, AttunementConditionUncheckedCreateWithoutMagicItemsInput>
    connectOrCreate?: AttunementConditionCreateOrConnectWithoutMagicItemsInput
    connect?: AttunementConditionWhereUniqueInput
  }

  export type MagicItemUpdateOneRequiredWithoutAttunements_relationNestedInput = {
    create?: XOR<MagicItemCreateWithoutAttunements_relationInput, MagicItemUncheckedCreateWithoutAttunements_relationInput>
    connectOrCreate?: MagicItemCreateOrConnectWithoutAttunements_relationInput
    upsert?: MagicItemUpsertWithoutAttunements_relationInput
    connect?: MagicItemWhereUniqueInput
    update?: XOR<XOR<MagicItemUpdateToOneWithWhereWithoutAttunements_relationInput, MagicItemUpdateWithoutAttunements_relationInput>, MagicItemUncheckedUpdateWithoutAttunements_relationInput>
  }

  export type AttunementConditionUpdateOneRequiredWithoutMagicItemsNestedInput = {
    create?: XOR<AttunementConditionCreateWithoutMagicItemsInput, AttunementConditionUncheckedCreateWithoutMagicItemsInput>
    connectOrCreate?: AttunementConditionCreateOrConnectWithoutMagicItemsInput
    upsert?: AttunementConditionUpsertWithoutMagicItemsInput
    connect?: AttunementConditionWhereUniqueInput
    update?: XOR<XOR<AttunementConditionUpdateToOneWithWhereWithoutMagicItemsInput, AttunementConditionUpdateWithoutMagicItemsInput>, AttunementConditionUncheckedUpdateWithoutMagicItemsInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumAbilityFilter<$PrismaModel = never> = {
    equals?: $Enums.Ability | EnumAbilityFieldRefInput<$PrismaModel>
    in?: $Enums.Ability[] | ListEnumAbilityFieldRefInput<$PrismaModel>
    notIn?: $Enums.Ability[] | ListEnumAbilityFieldRefInput<$PrismaModel>
    not?: NestedEnumAbilityFilter<$PrismaModel> | $Enums.Ability
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedEnumAbilityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Ability | EnumAbilityFieldRefInput<$PrismaModel>
    in?: $Enums.Ability[] | ListEnumAbilityFieldRefInput<$PrismaModel>
    notIn?: $Enums.Ability[] | ListEnumAbilityFieldRefInput<$PrismaModel>
    not?: NestedEnumAbilityWithAggregatesFilter<$PrismaModel> | $Enums.Ability
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAbilityFilter<$PrismaModel>
    _max?: NestedEnumAbilityFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedEnumSkillFilter<$PrismaModel = never> = {
    equals?: $Enums.Skill | EnumSkillFieldRefInput<$PrismaModel>
    in?: $Enums.Skill[] | ListEnumSkillFieldRefInput<$PrismaModel>
    notIn?: $Enums.Skill[] | ListEnumSkillFieldRefInput<$PrismaModel>
    not?: NestedEnumSkillFilter<$PrismaModel> | $Enums.Skill
  }

  export type NestedEnumSkillWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Skill | EnumSkillFieldRefInput<$PrismaModel>
    in?: $Enums.Skill[] | ListEnumSkillFieldRefInput<$PrismaModel>
    notIn?: $Enums.Skill[] | ListEnumSkillFieldRefInput<$PrismaModel>
    not?: NestedEnumSkillWithAggregatesFilter<$PrismaModel> | $Enums.Skill
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSkillFilter<$PrismaModel>
    _max?: NestedEnumSkillFilter<$PrismaModel>
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedBoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type NestedBoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type NestedEnumChallengeRatingEnumFilter<$PrismaModel = never> = {
    equals?: $Enums.ChallengeRatingEnum | EnumChallengeRatingEnumFieldRefInput<$PrismaModel>
    in?: $Enums.ChallengeRatingEnum[] | ListEnumChallengeRatingEnumFieldRefInput<$PrismaModel>
    notIn?: $Enums.ChallengeRatingEnum[] | ListEnumChallengeRatingEnumFieldRefInput<$PrismaModel>
    not?: NestedEnumChallengeRatingEnumFilter<$PrismaModel> | $Enums.ChallengeRatingEnum
  }

  export type NestedEnumChallengeRatingEnumWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ChallengeRatingEnum | EnumChallengeRatingEnumFieldRefInput<$PrismaModel>
    in?: $Enums.ChallengeRatingEnum[] | ListEnumChallengeRatingEnumFieldRefInput<$PrismaModel>
    notIn?: $Enums.ChallengeRatingEnum[] | ListEnumChallengeRatingEnumFieldRefInput<$PrismaModel>
    not?: NestedEnumChallengeRatingEnumWithAggregatesFilter<$PrismaModel> | $Enums.ChallengeRatingEnum
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumChallengeRatingEnumFilter<$PrismaModel>
    _max?: NestedEnumChallengeRatingEnumFilter<$PrismaModel>
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedEnumGenderFilter<$PrismaModel = never> = {
    equals?: $Enums.Gender | EnumGenderFieldRefInput<$PrismaModel>
    in?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel>
    notIn?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel>
    not?: NestedEnumGenderFilter<$PrismaModel> | $Enums.Gender
  }

  export type NestedEnumGenderWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Gender | EnumGenderFieldRefInput<$PrismaModel>
    in?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel>
    notIn?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel>
    not?: NestedEnumGenderWithAggregatesFilter<$PrismaModel> | $Enums.Gender
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumGenderFilter<$PrismaModel>
    _max?: NestedEnumGenderFilter<$PrismaModel>
  }

  export type CreatureCreateWithoutSize_relationInput = {
    id?: string
    name: string
    creator_id?: string | null
    description?: string | null
    armor_class?: number | null
    hit_points?: number | null
    speed?: CreatureSpeedCreateNestedOneWithoutCreature_relationInput
    stats?: CreatureStatsCreateNestedOneWithoutCreature_relationInput
    skills?: CreatureSkillsCreateNestedOneWithoutCreature_relationInput
    senses?: CreatureSensesCreateNestedOneWithoutCreature_relationInput
    challenge_rating_meta: ChallengeRatingMetadataCreateNestedOneWithoutCreaturesInput
    alignment_relation?: AlignmentCreateNestedOneWithoutCreaturesInput
    race_relation?: CreatureRaceCreateNestedOneWithoutCreatures_relationInput
    type_relation?: TypeCreateNestedOneWithoutCreaturesInput
    source_relation?: SourceCreateNestedOneWithoutCreaturesInput
    resistances?: DamageTypeCreateNestedManyWithoutResistant_creatures_relationInput
    immunities?: DamageTypeCreateNestedManyWithoutImmune_creatures_relationInput
    vulnerabilities?: DamageTypeCreateNestedManyWithoutVulnerable_creatures_relationInput
    languages_relation?: LanguageCreateNestedManyWithoutCreatures_relationInput
    biomes_relation?: BiomeCreateNestedManyWithoutCreatures_relationInput
    actions_relation?: ActionCreateNestedManyWithoutCreatures_relationInput
    traits_relation?: TraitCreateNestedManyWithoutCreatures_relationInput
  }

  export type CreatureUncheckedCreateWithoutSize_relationInput = {
    id?: string
    name: string
    creator_id?: string | null
    description?: string | null
    race_id?: number | null
    type_id?: number | null
    source_id?: number | null
    alignment_id?: number | null
    armor_class?: number | null
    hit_points?: number | null
    challenge_rating: string
    speed?: CreatureSpeedUncheckedCreateNestedOneWithoutCreature_relationInput
    stats?: CreatureStatsUncheckedCreateNestedOneWithoutCreature_relationInput
    skills?: CreatureSkillsUncheckedCreateNestedOneWithoutCreature_relationInput
    senses?: CreatureSensesUncheckedCreateNestedOneWithoutCreature_relationInput
    resistances?: DamageTypeUncheckedCreateNestedManyWithoutResistant_creatures_relationInput
    immunities?: DamageTypeUncheckedCreateNestedManyWithoutImmune_creatures_relationInput
    vulnerabilities?: DamageTypeUncheckedCreateNestedManyWithoutVulnerable_creatures_relationInput
    languages_relation?: LanguageUncheckedCreateNestedManyWithoutCreatures_relationInput
    biomes_relation?: BiomeUncheckedCreateNestedManyWithoutCreatures_relationInput
    actions_relation?: ActionUncheckedCreateNestedManyWithoutCreatures_relationInput
    traits_relation?: TraitUncheckedCreateNestedManyWithoutCreatures_relationInput
  }

  export type CreatureCreateOrConnectWithoutSize_relationInput = {
    where: CreatureWhereUniqueInput
    create: XOR<CreatureCreateWithoutSize_relationInput, CreatureUncheckedCreateWithoutSize_relationInput>
  }

  export type CreatureCreateManySize_relationInputEnvelope = {
    data: CreatureCreateManySize_relationInput | CreatureCreateManySize_relationInput[]
    skipDuplicates?: boolean
  }

  export type CreatureUpsertWithWhereUniqueWithoutSize_relationInput = {
    where: CreatureWhereUniqueInput
    update: XOR<CreatureUpdateWithoutSize_relationInput, CreatureUncheckedUpdateWithoutSize_relationInput>
    create: XOR<CreatureCreateWithoutSize_relationInput, CreatureUncheckedCreateWithoutSize_relationInput>
  }

  export type CreatureUpdateWithWhereUniqueWithoutSize_relationInput = {
    where: CreatureWhereUniqueInput
    data: XOR<CreatureUpdateWithoutSize_relationInput, CreatureUncheckedUpdateWithoutSize_relationInput>
  }

  export type CreatureUpdateManyWithWhereWithoutSize_relationInput = {
    where: CreatureScalarWhereInput
    data: XOR<CreatureUpdateManyMutationInput, CreatureUncheckedUpdateManyWithoutSize_relationInput>
  }

  export type CreatureScalarWhereInput = {
    AND?: CreatureScalarWhereInput | CreatureScalarWhereInput[]
    OR?: CreatureScalarWhereInput[]
    NOT?: CreatureScalarWhereInput | CreatureScalarWhereInput[]
    id?: StringFilter<"Creature"> | string
    name?: StringFilter<"Creature"> | string
    creator_id?: StringNullableFilter<"Creature"> | string | null
    description?: StringNullableFilter<"Creature"> | string | null
    size?: StringNullableFilter<"Creature"> | string | null
    race_id?: IntNullableFilter<"Creature"> | number | null
    type_id?: IntNullableFilter<"Creature"> | number | null
    source_id?: IntNullableFilter<"Creature"> | number | null
    alignment_id?: IntNullableFilter<"Creature"> | number | null
    armor_class?: IntNullableFilter<"Creature"> | number | null
    hit_points?: IntNullableFilter<"Creature"> | number | null
    challenge_rating?: StringFilter<"Creature"> | string
  }

  export type CreatureCreateWithoutSource_relationInput = {
    id?: string
    name: string
    creator_id?: string | null
    description?: string | null
    armor_class?: number | null
    hit_points?: number | null
    speed?: CreatureSpeedCreateNestedOneWithoutCreature_relationInput
    stats?: CreatureStatsCreateNestedOneWithoutCreature_relationInput
    skills?: CreatureSkillsCreateNestedOneWithoutCreature_relationInput
    senses?: CreatureSensesCreateNestedOneWithoutCreature_relationInput
    challenge_rating_meta: ChallengeRatingMetadataCreateNestedOneWithoutCreaturesInput
    alignment_relation?: AlignmentCreateNestedOneWithoutCreaturesInput
    race_relation?: CreatureRaceCreateNestedOneWithoutCreatures_relationInput
    type_relation?: TypeCreateNestedOneWithoutCreaturesInput
    size_relation?: SizeCreateNestedOneWithoutCreatureInput
    resistances?: DamageTypeCreateNestedManyWithoutResistant_creatures_relationInput
    immunities?: DamageTypeCreateNestedManyWithoutImmune_creatures_relationInput
    vulnerabilities?: DamageTypeCreateNestedManyWithoutVulnerable_creatures_relationInput
    languages_relation?: LanguageCreateNestedManyWithoutCreatures_relationInput
    biomes_relation?: BiomeCreateNestedManyWithoutCreatures_relationInput
    actions_relation?: ActionCreateNestedManyWithoutCreatures_relationInput
    traits_relation?: TraitCreateNestedManyWithoutCreatures_relationInput
  }

  export type CreatureUncheckedCreateWithoutSource_relationInput = {
    id?: string
    name: string
    creator_id?: string | null
    description?: string | null
    size?: string | null
    race_id?: number | null
    type_id?: number | null
    alignment_id?: number | null
    armor_class?: number | null
    hit_points?: number | null
    challenge_rating: string
    speed?: CreatureSpeedUncheckedCreateNestedOneWithoutCreature_relationInput
    stats?: CreatureStatsUncheckedCreateNestedOneWithoutCreature_relationInput
    skills?: CreatureSkillsUncheckedCreateNestedOneWithoutCreature_relationInput
    senses?: CreatureSensesUncheckedCreateNestedOneWithoutCreature_relationInput
    resistances?: DamageTypeUncheckedCreateNestedManyWithoutResistant_creatures_relationInput
    immunities?: DamageTypeUncheckedCreateNestedManyWithoutImmune_creatures_relationInput
    vulnerabilities?: DamageTypeUncheckedCreateNestedManyWithoutVulnerable_creatures_relationInput
    languages_relation?: LanguageUncheckedCreateNestedManyWithoutCreatures_relationInput
    biomes_relation?: BiomeUncheckedCreateNestedManyWithoutCreatures_relationInput
    actions_relation?: ActionUncheckedCreateNestedManyWithoutCreatures_relationInput
    traits_relation?: TraitUncheckedCreateNestedManyWithoutCreatures_relationInput
  }

  export type CreatureCreateOrConnectWithoutSource_relationInput = {
    where: CreatureWhereUniqueInput
    create: XOR<CreatureCreateWithoutSource_relationInput, CreatureUncheckedCreateWithoutSource_relationInput>
  }

  export type CreatureCreateManySource_relationInputEnvelope = {
    data: CreatureCreateManySource_relationInput | CreatureCreateManySource_relationInput[]
    skipDuplicates?: boolean
  }

  export type MagicItemCreateWithoutSource_relationInput = {
    id?: string
    name: string
    description: string
    requires_attunement?: boolean
    type_relation: MagicItemTypeCreateNestedOneWithoutMagicItemsInput
    rarity_relation: MagicItemRarityCreateNestedOneWithoutMagicItemsInput
    attunements_relation?: MagicItemAttunementCreateNestedManyWithoutMagicItemInput
  }

  export type MagicItemUncheckedCreateWithoutSource_relationInput = {
    id?: string
    name: string
    description: string
    type_id: string
    rarity_id: string
    requires_attunement?: boolean
    attunements_relation?: MagicItemAttunementUncheckedCreateNestedManyWithoutMagicItemInput
  }

  export type MagicItemCreateOrConnectWithoutSource_relationInput = {
    where: MagicItemWhereUniqueInput
    create: XOR<MagicItemCreateWithoutSource_relationInput, MagicItemUncheckedCreateWithoutSource_relationInput>
  }

  export type MagicItemCreateManySource_relationInputEnvelope = {
    data: MagicItemCreateManySource_relationInput | MagicItemCreateManySource_relationInput[]
    skipDuplicates?: boolean
  }

  export type CreatureUpsertWithWhereUniqueWithoutSource_relationInput = {
    where: CreatureWhereUniqueInput
    update: XOR<CreatureUpdateWithoutSource_relationInput, CreatureUncheckedUpdateWithoutSource_relationInput>
    create: XOR<CreatureCreateWithoutSource_relationInput, CreatureUncheckedCreateWithoutSource_relationInput>
  }

  export type CreatureUpdateWithWhereUniqueWithoutSource_relationInput = {
    where: CreatureWhereUniqueInput
    data: XOR<CreatureUpdateWithoutSource_relationInput, CreatureUncheckedUpdateWithoutSource_relationInput>
  }

  export type CreatureUpdateManyWithWhereWithoutSource_relationInput = {
    where: CreatureScalarWhereInput
    data: XOR<CreatureUpdateManyMutationInput, CreatureUncheckedUpdateManyWithoutSource_relationInput>
  }

  export type MagicItemUpsertWithWhereUniqueWithoutSource_relationInput = {
    where: MagicItemWhereUniqueInput
    update: XOR<MagicItemUpdateWithoutSource_relationInput, MagicItemUncheckedUpdateWithoutSource_relationInput>
    create: XOR<MagicItemCreateWithoutSource_relationInput, MagicItemUncheckedCreateWithoutSource_relationInput>
  }

  export type MagicItemUpdateWithWhereUniqueWithoutSource_relationInput = {
    where: MagicItemWhereUniqueInput
    data: XOR<MagicItemUpdateWithoutSource_relationInput, MagicItemUncheckedUpdateWithoutSource_relationInput>
  }

  export type MagicItemUpdateManyWithWhereWithoutSource_relationInput = {
    where: MagicItemScalarWhereInput
    data: XOR<MagicItemUpdateManyMutationInput, MagicItemUncheckedUpdateManyWithoutSource_relationInput>
  }

  export type MagicItemScalarWhereInput = {
    AND?: MagicItemScalarWhereInput | MagicItemScalarWhereInput[]
    OR?: MagicItemScalarWhereInput[]
    NOT?: MagicItemScalarWhereInput | MagicItemScalarWhereInput[]
    id?: StringFilter<"MagicItem"> | string
    name?: StringFilter<"MagicItem"> | string
    description?: StringFilter<"MagicItem"> | string
    type_id?: StringFilter<"MagicItem"> | string
    rarity_id?: StringFilter<"MagicItem"> | string
    source_id?: IntFilter<"MagicItem"> | number
    requires_attunement?: BoolFilter<"MagicItem"> | boolean
  }

  export type CreatureCreateWithoutLanguages_relationInput = {
    id?: string
    name: string
    creator_id?: string | null
    description?: string | null
    armor_class?: number | null
    hit_points?: number | null
    speed?: CreatureSpeedCreateNestedOneWithoutCreature_relationInput
    stats?: CreatureStatsCreateNestedOneWithoutCreature_relationInput
    skills?: CreatureSkillsCreateNestedOneWithoutCreature_relationInput
    senses?: CreatureSensesCreateNestedOneWithoutCreature_relationInput
    challenge_rating_meta: ChallengeRatingMetadataCreateNestedOneWithoutCreaturesInput
    alignment_relation?: AlignmentCreateNestedOneWithoutCreaturesInput
    race_relation?: CreatureRaceCreateNestedOneWithoutCreatures_relationInput
    type_relation?: TypeCreateNestedOneWithoutCreaturesInput
    size_relation?: SizeCreateNestedOneWithoutCreatureInput
    source_relation?: SourceCreateNestedOneWithoutCreaturesInput
    resistances?: DamageTypeCreateNestedManyWithoutResistant_creatures_relationInput
    immunities?: DamageTypeCreateNestedManyWithoutImmune_creatures_relationInput
    vulnerabilities?: DamageTypeCreateNestedManyWithoutVulnerable_creatures_relationInput
    biomes_relation?: BiomeCreateNestedManyWithoutCreatures_relationInput
    actions_relation?: ActionCreateNestedManyWithoutCreatures_relationInput
    traits_relation?: TraitCreateNestedManyWithoutCreatures_relationInput
  }

  export type CreatureUncheckedCreateWithoutLanguages_relationInput = {
    id?: string
    name: string
    creator_id?: string | null
    description?: string | null
    size?: string | null
    race_id?: number | null
    type_id?: number | null
    source_id?: number | null
    alignment_id?: number | null
    armor_class?: number | null
    hit_points?: number | null
    challenge_rating: string
    speed?: CreatureSpeedUncheckedCreateNestedOneWithoutCreature_relationInput
    stats?: CreatureStatsUncheckedCreateNestedOneWithoutCreature_relationInput
    skills?: CreatureSkillsUncheckedCreateNestedOneWithoutCreature_relationInput
    senses?: CreatureSensesUncheckedCreateNestedOneWithoutCreature_relationInput
    resistances?: DamageTypeUncheckedCreateNestedManyWithoutResistant_creatures_relationInput
    immunities?: DamageTypeUncheckedCreateNestedManyWithoutImmune_creatures_relationInput
    vulnerabilities?: DamageTypeUncheckedCreateNestedManyWithoutVulnerable_creatures_relationInput
    biomes_relation?: BiomeUncheckedCreateNestedManyWithoutCreatures_relationInput
    actions_relation?: ActionUncheckedCreateNestedManyWithoutCreatures_relationInput
    traits_relation?: TraitUncheckedCreateNestedManyWithoutCreatures_relationInput
  }

  export type CreatureCreateOrConnectWithoutLanguages_relationInput = {
    where: CreatureWhereUniqueInput
    create: XOR<CreatureCreateWithoutLanguages_relationInput, CreatureUncheckedCreateWithoutLanguages_relationInput>
  }

  export type CreatureUpsertWithWhereUniqueWithoutLanguages_relationInput = {
    where: CreatureWhereUniqueInput
    update: XOR<CreatureUpdateWithoutLanguages_relationInput, CreatureUncheckedUpdateWithoutLanguages_relationInput>
    create: XOR<CreatureCreateWithoutLanguages_relationInput, CreatureUncheckedCreateWithoutLanguages_relationInput>
  }

  export type CreatureUpdateWithWhereUniqueWithoutLanguages_relationInput = {
    where: CreatureWhereUniqueInput
    data: XOR<CreatureUpdateWithoutLanguages_relationInput, CreatureUncheckedUpdateWithoutLanguages_relationInput>
  }

  export type CreatureUpdateManyWithWhereWithoutLanguages_relationInput = {
    where: CreatureScalarWhereInput
    data: XOR<CreatureUpdateManyMutationInput, CreatureUncheckedUpdateManyWithoutLanguages_relationInput>
  }

  export type CreatureCreateWithoutBiomes_relationInput = {
    id?: string
    name: string
    creator_id?: string | null
    description?: string | null
    armor_class?: number | null
    hit_points?: number | null
    speed?: CreatureSpeedCreateNestedOneWithoutCreature_relationInput
    stats?: CreatureStatsCreateNestedOneWithoutCreature_relationInput
    skills?: CreatureSkillsCreateNestedOneWithoutCreature_relationInput
    senses?: CreatureSensesCreateNestedOneWithoutCreature_relationInput
    challenge_rating_meta: ChallengeRatingMetadataCreateNestedOneWithoutCreaturesInput
    alignment_relation?: AlignmentCreateNestedOneWithoutCreaturesInput
    race_relation?: CreatureRaceCreateNestedOneWithoutCreatures_relationInput
    type_relation?: TypeCreateNestedOneWithoutCreaturesInput
    size_relation?: SizeCreateNestedOneWithoutCreatureInput
    source_relation?: SourceCreateNestedOneWithoutCreaturesInput
    resistances?: DamageTypeCreateNestedManyWithoutResistant_creatures_relationInput
    immunities?: DamageTypeCreateNestedManyWithoutImmune_creatures_relationInput
    vulnerabilities?: DamageTypeCreateNestedManyWithoutVulnerable_creatures_relationInput
    languages_relation?: LanguageCreateNestedManyWithoutCreatures_relationInput
    actions_relation?: ActionCreateNestedManyWithoutCreatures_relationInput
    traits_relation?: TraitCreateNestedManyWithoutCreatures_relationInput
  }

  export type CreatureUncheckedCreateWithoutBiomes_relationInput = {
    id?: string
    name: string
    creator_id?: string | null
    description?: string | null
    size?: string | null
    race_id?: number | null
    type_id?: number | null
    source_id?: number | null
    alignment_id?: number | null
    armor_class?: number | null
    hit_points?: number | null
    challenge_rating: string
    speed?: CreatureSpeedUncheckedCreateNestedOneWithoutCreature_relationInput
    stats?: CreatureStatsUncheckedCreateNestedOneWithoutCreature_relationInput
    skills?: CreatureSkillsUncheckedCreateNestedOneWithoutCreature_relationInput
    senses?: CreatureSensesUncheckedCreateNestedOneWithoutCreature_relationInput
    resistances?: DamageTypeUncheckedCreateNestedManyWithoutResistant_creatures_relationInput
    immunities?: DamageTypeUncheckedCreateNestedManyWithoutImmune_creatures_relationInput
    vulnerabilities?: DamageTypeUncheckedCreateNestedManyWithoutVulnerable_creatures_relationInput
    languages_relation?: LanguageUncheckedCreateNestedManyWithoutCreatures_relationInput
    actions_relation?: ActionUncheckedCreateNestedManyWithoutCreatures_relationInput
    traits_relation?: TraitUncheckedCreateNestedManyWithoutCreatures_relationInput
  }

  export type CreatureCreateOrConnectWithoutBiomes_relationInput = {
    where: CreatureWhereUniqueInput
    create: XOR<CreatureCreateWithoutBiomes_relationInput, CreatureUncheckedCreateWithoutBiomes_relationInput>
  }

  export type CreatureUpsertWithWhereUniqueWithoutBiomes_relationInput = {
    where: CreatureWhereUniqueInput
    update: XOR<CreatureUpdateWithoutBiomes_relationInput, CreatureUncheckedUpdateWithoutBiomes_relationInput>
    create: XOR<CreatureCreateWithoutBiomes_relationInput, CreatureUncheckedCreateWithoutBiomes_relationInput>
  }

  export type CreatureUpdateWithWhereUniqueWithoutBiomes_relationInput = {
    where: CreatureWhereUniqueInput
    data: XOR<CreatureUpdateWithoutBiomes_relationInput, CreatureUncheckedUpdateWithoutBiomes_relationInput>
  }

  export type CreatureUpdateManyWithWhereWithoutBiomes_relationInput = {
    where: CreatureScalarWhereInput
    data: XOR<CreatureUpdateManyMutationInput, CreatureUncheckedUpdateManyWithoutBiomes_relationInput>
  }

  export type CreatureCreateWithoutType_relationInput = {
    id?: string
    name: string
    creator_id?: string | null
    description?: string | null
    armor_class?: number | null
    hit_points?: number | null
    speed?: CreatureSpeedCreateNestedOneWithoutCreature_relationInput
    stats?: CreatureStatsCreateNestedOneWithoutCreature_relationInput
    skills?: CreatureSkillsCreateNestedOneWithoutCreature_relationInput
    senses?: CreatureSensesCreateNestedOneWithoutCreature_relationInput
    challenge_rating_meta: ChallengeRatingMetadataCreateNestedOneWithoutCreaturesInput
    alignment_relation?: AlignmentCreateNestedOneWithoutCreaturesInput
    race_relation?: CreatureRaceCreateNestedOneWithoutCreatures_relationInput
    size_relation?: SizeCreateNestedOneWithoutCreatureInput
    source_relation?: SourceCreateNestedOneWithoutCreaturesInput
    resistances?: DamageTypeCreateNestedManyWithoutResistant_creatures_relationInput
    immunities?: DamageTypeCreateNestedManyWithoutImmune_creatures_relationInput
    vulnerabilities?: DamageTypeCreateNestedManyWithoutVulnerable_creatures_relationInput
    languages_relation?: LanguageCreateNestedManyWithoutCreatures_relationInput
    biomes_relation?: BiomeCreateNestedManyWithoutCreatures_relationInput
    actions_relation?: ActionCreateNestedManyWithoutCreatures_relationInput
    traits_relation?: TraitCreateNestedManyWithoutCreatures_relationInput
  }

  export type CreatureUncheckedCreateWithoutType_relationInput = {
    id?: string
    name: string
    creator_id?: string | null
    description?: string | null
    size?: string | null
    race_id?: number | null
    source_id?: number | null
    alignment_id?: number | null
    armor_class?: number | null
    hit_points?: number | null
    challenge_rating: string
    speed?: CreatureSpeedUncheckedCreateNestedOneWithoutCreature_relationInput
    stats?: CreatureStatsUncheckedCreateNestedOneWithoutCreature_relationInput
    skills?: CreatureSkillsUncheckedCreateNestedOneWithoutCreature_relationInput
    senses?: CreatureSensesUncheckedCreateNestedOneWithoutCreature_relationInput
    resistances?: DamageTypeUncheckedCreateNestedManyWithoutResistant_creatures_relationInput
    immunities?: DamageTypeUncheckedCreateNestedManyWithoutImmune_creatures_relationInput
    vulnerabilities?: DamageTypeUncheckedCreateNestedManyWithoutVulnerable_creatures_relationInput
    languages_relation?: LanguageUncheckedCreateNestedManyWithoutCreatures_relationInput
    biomes_relation?: BiomeUncheckedCreateNestedManyWithoutCreatures_relationInput
    actions_relation?: ActionUncheckedCreateNestedManyWithoutCreatures_relationInput
    traits_relation?: TraitUncheckedCreateNestedManyWithoutCreatures_relationInput
  }

  export type CreatureCreateOrConnectWithoutType_relationInput = {
    where: CreatureWhereUniqueInput
    create: XOR<CreatureCreateWithoutType_relationInput, CreatureUncheckedCreateWithoutType_relationInput>
  }

  export type CreatureCreateManyType_relationInputEnvelope = {
    data: CreatureCreateManyType_relationInput | CreatureCreateManyType_relationInput[]
    skipDuplicates?: boolean
  }

  export type CreatureUpsertWithWhereUniqueWithoutType_relationInput = {
    where: CreatureWhereUniqueInput
    update: XOR<CreatureUpdateWithoutType_relationInput, CreatureUncheckedUpdateWithoutType_relationInput>
    create: XOR<CreatureCreateWithoutType_relationInput, CreatureUncheckedCreateWithoutType_relationInput>
  }

  export type CreatureUpdateWithWhereUniqueWithoutType_relationInput = {
    where: CreatureWhereUniqueInput
    data: XOR<CreatureUpdateWithoutType_relationInput, CreatureUncheckedUpdateWithoutType_relationInput>
  }

  export type CreatureUpdateManyWithWhereWithoutType_relationInput = {
    where: CreatureScalarWhereInput
    data: XOR<CreatureUpdateManyMutationInput, CreatureUncheckedUpdateManyWithoutType_relationInput>
  }

  export type CreatureCreateWithoutAlignment_relationInput = {
    id?: string
    name: string
    creator_id?: string | null
    description?: string | null
    armor_class?: number | null
    hit_points?: number | null
    speed?: CreatureSpeedCreateNestedOneWithoutCreature_relationInput
    stats?: CreatureStatsCreateNestedOneWithoutCreature_relationInput
    skills?: CreatureSkillsCreateNestedOneWithoutCreature_relationInput
    senses?: CreatureSensesCreateNestedOneWithoutCreature_relationInput
    challenge_rating_meta: ChallengeRatingMetadataCreateNestedOneWithoutCreaturesInput
    race_relation?: CreatureRaceCreateNestedOneWithoutCreatures_relationInput
    type_relation?: TypeCreateNestedOneWithoutCreaturesInput
    size_relation?: SizeCreateNestedOneWithoutCreatureInput
    source_relation?: SourceCreateNestedOneWithoutCreaturesInput
    resistances?: DamageTypeCreateNestedManyWithoutResistant_creatures_relationInput
    immunities?: DamageTypeCreateNestedManyWithoutImmune_creatures_relationInput
    vulnerabilities?: DamageTypeCreateNestedManyWithoutVulnerable_creatures_relationInput
    languages_relation?: LanguageCreateNestedManyWithoutCreatures_relationInput
    biomes_relation?: BiomeCreateNestedManyWithoutCreatures_relationInput
    actions_relation?: ActionCreateNestedManyWithoutCreatures_relationInput
    traits_relation?: TraitCreateNestedManyWithoutCreatures_relationInput
  }

  export type CreatureUncheckedCreateWithoutAlignment_relationInput = {
    id?: string
    name: string
    creator_id?: string | null
    description?: string | null
    size?: string | null
    race_id?: number | null
    type_id?: number | null
    source_id?: number | null
    armor_class?: number | null
    hit_points?: number | null
    challenge_rating: string
    speed?: CreatureSpeedUncheckedCreateNestedOneWithoutCreature_relationInput
    stats?: CreatureStatsUncheckedCreateNestedOneWithoutCreature_relationInput
    skills?: CreatureSkillsUncheckedCreateNestedOneWithoutCreature_relationInput
    senses?: CreatureSensesUncheckedCreateNestedOneWithoutCreature_relationInput
    resistances?: DamageTypeUncheckedCreateNestedManyWithoutResistant_creatures_relationInput
    immunities?: DamageTypeUncheckedCreateNestedManyWithoutImmune_creatures_relationInput
    vulnerabilities?: DamageTypeUncheckedCreateNestedManyWithoutVulnerable_creatures_relationInput
    languages_relation?: LanguageUncheckedCreateNestedManyWithoutCreatures_relationInput
    biomes_relation?: BiomeUncheckedCreateNestedManyWithoutCreatures_relationInput
    actions_relation?: ActionUncheckedCreateNestedManyWithoutCreatures_relationInput
    traits_relation?: TraitUncheckedCreateNestedManyWithoutCreatures_relationInput
  }

  export type CreatureCreateOrConnectWithoutAlignment_relationInput = {
    where: CreatureWhereUniqueInput
    create: XOR<CreatureCreateWithoutAlignment_relationInput, CreatureUncheckedCreateWithoutAlignment_relationInput>
  }

  export type CreatureCreateManyAlignment_relationInputEnvelope = {
    data: CreatureCreateManyAlignment_relationInput | CreatureCreateManyAlignment_relationInput[]
    skipDuplicates?: boolean
  }

  export type CreatureUpsertWithWhereUniqueWithoutAlignment_relationInput = {
    where: CreatureWhereUniqueInput
    update: XOR<CreatureUpdateWithoutAlignment_relationInput, CreatureUncheckedUpdateWithoutAlignment_relationInput>
    create: XOR<CreatureCreateWithoutAlignment_relationInput, CreatureUncheckedCreateWithoutAlignment_relationInput>
  }

  export type CreatureUpdateWithWhereUniqueWithoutAlignment_relationInput = {
    where: CreatureWhereUniqueInput
    data: XOR<CreatureUpdateWithoutAlignment_relationInput, CreatureUncheckedUpdateWithoutAlignment_relationInput>
  }

  export type CreatureUpdateManyWithWhereWithoutAlignment_relationInput = {
    where: CreatureScalarWhereInput
    data: XOR<CreatureUpdateManyMutationInput, CreatureUncheckedUpdateManyWithoutAlignment_relationInput>
  }

  export type CreatureCreateWithoutSpeedInput = {
    id?: string
    name: string
    creator_id?: string | null
    description?: string | null
    armor_class?: number | null
    hit_points?: number | null
    stats?: CreatureStatsCreateNestedOneWithoutCreature_relationInput
    skills?: CreatureSkillsCreateNestedOneWithoutCreature_relationInput
    senses?: CreatureSensesCreateNestedOneWithoutCreature_relationInput
    challenge_rating_meta: ChallengeRatingMetadataCreateNestedOneWithoutCreaturesInput
    alignment_relation?: AlignmentCreateNestedOneWithoutCreaturesInput
    race_relation?: CreatureRaceCreateNestedOneWithoutCreatures_relationInput
    type_relation?: TypeCreateNestedOneWithoutCreaturesInput
    size_relation?: SizeCreateNestedOneWithoutCreatureInput
    source_relation?: SourceCreateNestedOneWithoutCreaturesInput
    resistances?: DamageTypeCreateNestedManyWithoutResistant_creatures_relationInput
    immunities?: DamageTypeCreateNestedManyWithoutImmune_creatures_relationInput
    vulnerabilities?: DamageTypeCreateNestedManyWithoutVulnerable_creatures_relationInput
    languages_relation?: LanguageCreateNestedManyWithoutCreatures_relationInput
    biomes_relation?: BiomeCreateNestedManyWithoutCreatures_relationInput
    actions_relation?: ActionCreateNestedManyWithoutCreatures_relationInput
    traits_relation?: TraitCreateNestedManyWithoutCreatures_relationInput
  }

  export type CreatureUncheckedCreateWithoutSpeedInput = {
    id?: string
    name: string
    creator_id?: string | null
    description?: string | null
    size?: string | null
    race_id?: number | null
    type_id?: number | null
    source_id?: number | null
    alignment_id?: number | null
    armor_class?: number | null
    hit_points?: number | null
    challenge_rating: string
    stats?: CreatureStatsUncheckedCreateNestedOneWithoutCreature_relationInput
    skills?: CreatureSkillsUncheckedCreateNestedOneWithoutCreature_relationInput
    senses?: CreatureSensesUncheckedCreateNestedOneWithoutCreature_relationInput
    resistances?: DamageTypeUncheckedCreateNestedManyWithoutResistant_creatures_relationInput
    immunities?: DamageTypeUncheckedCreateNestedManyWithoutImmune_creatures_relationInput
    vulnerabilities?: DamageTypeUncheckedCreateNestedManyWithoutVulnerable_creatures_relationInput
    languages_relation?: LanguageUncheckedCreateNestedManyWithoutCreatures_relationInput
    biomes_relation?: BiomeUncheckedCreateNestedManyWithoutCreatures_relationInput
    actions_relation?: ActionUncheckedCreateNestedManyWithoutCreatures_relationInput
    traits_relation?: TraitUncheckedCreateNestedManyWithoutCreatures_relationInput
  }

  export type CreatureCreateOrConnectWithoutSpeedInput = {
    where: CreatureWhereUniqueInput
    create: XOR<CreatureCreateWithoutSpeedInput, CreatureUncheckedCreateWithoutSpeedInput>
  }

  export type CreatureUpsertWithoutSpeedInput = {
    update: XOR<CreatureUpdateWithoutSpeedInput, CreatureUncheckedUpdateWithoutSpeedInput>
    create: XOR<CreatureCreateWithoutSpeedInput, CreatureUncheckedCreateWithoutSpeedInput>
    where?: CreatureWhereInput
  }

  export type CreatureUpdateToOneWithWhereWithoutSpeedInput = {
    where?: CreatureWhereInput
    data: XOR<CreatureUpdateWithoutSpeedInput, CreatureUncheckedUpdateWithoutSpeedInput>
  }

  export type CreatureUpdateWithoutSpeedInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    creator_id?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    armor_class?: NullableIntFieldUpdateOperationsInput | number | null
    hit_points?: NullableIntFieldUpdateOperationsInput | number | null
    stats?: CreatureStatsUpdateOneWithoutCreature_relationNestedInput
    skills?: CreatureSkillsUpdateOneWithoutCreature_relationNestedInput
    senses?: CreatureSensesUpdateOneWithoutCreature_relationNestedInput
    challenge_rating_meta?: ChallengeRatingMetadataUpdateOneRequiredWithoutCreaturesNestedInput
    alignment_relation?: AlignmentUpdateOneWithoutCreaturesNestedInput
    race_relation?: CreatureRaceUpdateOneWithoutCreatures_relationNestedInput
    type_relation?: TypeUpdateOneWithoutCreaturesNestedInput
    size_relation?: SizeUpdateOneWithoutCreatureNestedInput
    source_relation?: SourceUpdateOneWithoutCreaturesNestedInput
    resistances?: DamageTypeUpdateManyWithoutResistant_creatures_relationNestedInput
    immunities?: DamageTypeUpdateManyWithoutImmune_creatures_relationNestedInput
    vulnerabilities?: DamageTypeUpdateManyWithoutVulnerable_creatures_relationNestedInput
    languages_relation?: LanguageUpdateManyWithoutCreatures_relationNestedInput
    biomes_relation?: BiomeUpdateManyWithoutCreatures_relationNestedInput
    actions_relation?: ActionUpdateManyWithoutCreatures_relationNestedInput
    traits_relation?: TraitUpdateManyWithoutCreatures_relationNestedInput
  }

  export type CreatureUncheckedUpdateWithoutSpeedInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    creator_id?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableStringFieldUpdateOperationsInput | string | null
    race_id?: NullableIntFieldUpdateOperationsInput | number | null
    type_id?: NullableIntFieldUpdateOperationsInput | number | null
    source_id?: NullableIntFieldUpdateOperationsInput | number | null
    alignment_id?: NullableIntFieldUpdateOperationsInput | number | null
    armor_class?: NullableIntFieldUpdateOperationsInput | number | null
    hit_points?: NullableIntFieldUpdateOperationsInput | number | null
    challenge_rating?: StringFieldUpdateOperationsInput | string
    stats?: CreatureStatsUncheckedUpdateOneWithoutCreature_relationNestedInput
    skills?: CreatureSkillsUncheckedUpdateOneWithoutCreature_relationNestedInput
    senses?: CreatureSensesUncheckedUpdateOneWithoutCreature_relationNestedInput
    resistances?: DamageTypeUncheckedUpdateManyWithoutResistant_creatures_relationNestedInput
    immunities?: DamageTypeUncheckedUpdateManyWithoutImmune_creatures_relationNestedInput
    vulnerabilities?: DamageTypeUncheckedUpdateManyWithoutVulnerable_creatures_relationNestedInput
    languages_relation?: LanguageUncheckedUpdateManyWithoutCreatures_relationNestedInput
    biomes_relation?: BiomeUncheckedUpdateManyWithoutCreatures_relationNestedInput
    actions_relation?: ActionUncheckedUpdateManyWithoutCreatures_relationNestedInput
    traits_relation?: TraitUncheckedUpdateManyWithoutCreatures_relationNestedInput
  }

  export type CreatureStatDetailCreateWithoutCreature_stats_relationInput = {
    id?: string
    ability: $Enums.Ability
    value: number
    mastery: boolean
  }

  export type CreatureStatDetailUncheckedCreateWithoutCreature_stats_relationInput = {
    id?: string
    ability: $Enums.Ability
    value: number
    mastery: boolean
  }

  export type CreatureStatDetailCreateOrConnectWithoutCreature_stats_relationInput = {
    where: CreatureStatDetailWhereUniqueInput
    create: XOR<CreatureStatDetailCreateWithoutCreature_stats_relationInput, CreatureStatDetailUncheckedCreateWithoutCreature_stats_relationInput>
  }

  export type CreatureStatDetailCreateManyCreature_stats_relationInputEnvelope = {
    data: CreatureStatDetailCreateManyCreature_stats_relationInput | CreatureStatDetailCreateManyCreature_stats_relationInput[]
    skipDuplicates?: boolean
  }

  export type CreatureCreateWithoutStatsInput = {
    id?: string
    name: string
    creator_id?: string | null
    description?: string | null
    armor_class?: number | null
    hit_points?: number | null
    speed?: CreatureSpeedCreateNestedOneWithoutCreature_relationInput
    skills?: CreatureSkillsCreateNestedOneWithoutCreature_relationInput
    senses?: CreatureSensesCreateNestedOneWithoutCreature_relationInput
    challenge_rating_meta: ChallengeRatingMetadataCreateNestedOneWithoutCreaturesInput
    alignment_relation?: AlignmentCreateNestedOneWithoutCreaturesInput
    race_relation?: CreatureRaceCreateNestedOneWithoutCreatures_relationInput
    type_relation?: TypeCreateNestedOneWithoutCreaturesInput
    size_relation?: SizeCreateNestedOneWithoutCreatureInput
    source_relation?: SourceCreateNestedOneWithoutCreaturesInput
    resistances?: DamageTypeCreateNestedManyWithoutResistant_creatures_relationInput
    immunities?: DamageTypeCreateNestedManyWithoutImmune_creatures_relationInput
    vulnerabilities?: DamageTypeCreateNestedManyWithoutVulnerable_creatures_relationInput
    languages_relation?: LanguageCreateNestedManyWithoutCreatures_relationInput
    biomes_relation?: BiomeCreateNestedManyWithoutCreatures_relationInput
    actions_relation?: ActionCreateNestedManyWithoutCreatures_relationInput
    traits_relation?: TraitCreateNestedManyWithoutCreatures_relationInput
  }

  export type CreatureUncheckedCreateWithoutStatsInput = {
    id?: string
    name: string
    creator_id?: string | null
    description?: string | null
    size?: string | null
    race_id?: number | null
    type_id?: number | null
    source_id?: number | null
    alignment_id?: number | null
    armor_class?: number | null
    hit_points?: number | null
    challenge_rating: string
    speed?: CreatureSpeedUncheckedCreateNestedOneWithoutCreature_relationInput
    skills?: CreatureSkillsUncheckedCreateNestedOneWithoutCreature_relationInput
    senses?: CreatureSensesUncheckedCreateNestedOneWithoutCreature_relationInput
    resistances?: DamageTypeUncheckedCreateNestedManyWithoutResistant_creatures_relationInput
    immunities?: DamageTypeUncheckedCreateNestedManyWithoutImmune_creatures_relationInput
    vulnerabilities?: DamageTypeUncheckedCreateNestedManyWithoutVulnerable_creatures_relationInput
    languages_relation?: LanguageUncheckedCreateNestedManyWithoutCreatures_relationInput
    biomes_relation?: BiomeUncheckedCreateNestedManyWithoutCreatures_relationInput
    actions_relation?: ActionUncheckedCreateNestedManyWithoutCreatures_relationInput
    traits_relation?: TraitUncheckedCreateNestedManyWithoutCreatures_relationInput
  }

  export type CreatureCreateOrConnectWithoutStatsInput = {
    where: CreatureWhereUniqueInput
    create: XOR<CreatureCreateWithoutStatsInput, CreatureUncheckedCreateWithoutStatsInput>
  }

  export type CreatureStatDetailUpsertWithWhereUniqueWithoutCreature_stats_relationInput = {
    where: CreatureStatDetailWhereUniqueInput
    update: XOR<CreatureStatDetailUpdateWithoutCreature_stats_relationInput, CreatureStatDetailUncheckedUpdateWithoutCreature_stats_relationInput>
    create: XOR<CreatureStatDetailCreateWithoutCreature_stats_relationInput, CreatureStatDetailUncheckedCreateWithoutCreature_stats_relationInput>
  }

  export type CreatureStatDetailUpdateWithWhereUniqueWithoutCreature_stats_relationInput = {
    where: CreatureStatDetailWhereUniqueInput
    data: XOR<CreatureStatDetailUpdateWithoutCreature_stats_relationInput, CreatureStatDetailUncheckedUpdateWithoutCreature_stats_relationInput>
  }

  export type CreatureStatDetailUpdateManyWithWhereWithoutCreature_stats_relationInput = {
    where: CreatureStatDetailScalarWhereInput
    data: XOR<CreatureStatDetailUpdateManyMutationInput, CreatureStatDetailUncheckedUpdateManyWithoutCreature_stats_relationInput>
  }

  export type CreatureStatDetailScalarWhereInput = {
    AND?: CreatureStatDetailScalarWhereInput | CreatureStatDetailScalarWhereInput[]
    OR?: CreatureStatDetailScalarWhereInput[]
    NOT?: CreatureStatDetailScalarWhereInput | CreatureStatDetailScalarWhereInput[]
    id?: StringFilter<"CreatureStatDetail"> | string
    ability?: EnumAbilityFilter<"CreatureStatDetail"> | $Enums.Ability
    value?: IntFilter<"CreatureStatDetail"> | number
    mastery?: BoolFilter<"CreatureStatDetail"> | boolean
    creature_stats_id?: StringFilter<"CreatureStatDetail"> | string
  }

  export type CreatureUpsertWithoutStatsInput = {
    update: XOR<CreatureUpdateWithoutStatsInput, CreatureUncheckedUpdateWithoutStatsInput>
    create: XOR<CreatureCreateWithoutStatsInput, CreatureUncheckedCreateWithoutStatsInput>
    where?: CreatureWhereInput
  }

  export type CreatureUpdateToOneWithWhereWithoutStatsInput = {
    where?: CreatureWhereInput
    data: XOR<CreatureUpdateWithoutStatsInput, CreatureUncheckedUpdateWithoutStatsInput>
  }

  export type CreatureUpdateWithoutStatsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    creator_id?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    armor_class?: NullableIntFieldUpdateOperationsInput | number | null
    hit_points?: NullableIntFieldUpdateOperationsInput | number | null
    speed?: CreatureSpeedUpdateOneWithoutCreature_relationNestedInput
    skills?: CreatureSkillsUpdateOneWithoutCreature_relationNestedInput
    senses?: CreatureSensesUpdateOneWithoutCreature_relationNestedInput
    challenge_rating_meta?: ChallengeRatingMetadataUpdateOneRequiredWithoutCreaturesNestedInput
    alignment_relation?: AlignmentUpdateOneWithoutCreaturesNestedInput
    race_relation?: CreatureRaceUpdateOneWithoutCreatures_relationNestedInput
    type_relation?: TypeUpdateOneWithoutCreaturesNestedInput
    size_relation?: SizeUpdateOneWithoutCreatureNestedInput
    source_relation?: SourceUpdateOneWithoutCreaturesNestedInput
    resistances?: DamageTypeUpdateManyWithoutResistant_creatures_relationNestedInput
    immunities?: DamageTypeUpdateManyWithoutImmune_creatures_relationNestedInput
    vulnerabilities?: DamageTypeUpdateManyWithoutVulnerable_creatures_relationNestedInput
    languages_relation?: LanguageUpdateManyWithoutCreatures_relationNestedInput
    biomes_relation?: BiomeUpdateManyWithoutCreatures_relationNestedInput
    actions_relation?: ActionUpdateManyWithoutCreatures_relationNestedInput
    traits_relation?: TraitUpdateManyWithoutCreatures_relationNestedInput
  }

  export type CreatureUncheckedUpdateWithoutStatsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    creator_id?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableStringFieldUpdateOperationsInput | string | null
    race_id?: NullableIntFieldUpdateOperationsInput | number | null
    type_id?: NullableIntFieldUpdateOperationsInput | number | null
    source_id?: NullableIntFieldUpdateOperationsInput | number | null
    alignment_id?: NullableIntFieldUpdateOperationsInput | number | null
    armor_class?: NullableIntFieldUpdateOperationsInput | number | null
    hit_points?: NullableIntFieldUpdateOperationsInput | number | null
    challenge_rating?: StringFieldUpdateOperationsInput | string
    speed?: CreatureSpeedUncheckedUpdateOneWithoutCreature_relationNestedInput
    skills?: CreatureSkillsUncheckedUpdateOneWithoutCreature_relationNestedInput
    senses?: CreatureSensesUncheckedUpdateOneWithoutCreature_relationNestedInput
    resistances?: DamageTypeUncheckedUpdateManyWithoutResistant_creatures_relationNestedInput
    immunities?: DamageTypeUncheckedUpdateManyWithoutImmune_creatures_relationNestedInput
    vulnerabilities?: DamageTypeUncheckedUpdateManyWithoutVulnerable_creatures_relationNestedInput
    languages_relation?: LanguageUncheckedUpdateManyWithoutCreatures_relationNestedInput
    biomes_relation?: BiomeUncheckedUpdateManyWithoutCreatures_relationNestedInput
    actions_relation?: ActionUncheckedUpdateManyWithoutCreatures_relationNestedInput
    traits_relation?: TraitUncheckedUpdateManyWithoutCreatures_relationNestedInput
  }

  export type CreatureStatsCreateWithoutStatsInput = {
    creature_relation: CreatureCreateNestedOneWithoutStatsInput
  }

  export type CreatureStatsUncheckedCreateWithoutStatsInput = {
    id: string
  }

  export type CreatureStatsCreateOrConnectWithoutStatsInput = {
    where: CreatureStatsWhereUniqueInput
    create: XOR<CreatureStatsCreateWithoutStatsInput, CreatureStatsUncheckedCreateWithoutStatsInput>
  }

  export type CreatureStatsUpsertWithoutStatsInput = {
    update: XOR<CreatureStatsUpdateWithoutStatsInput, CreatureStatsUncheckedUpdateWithoutStatsInput>
    create: XOR<CreatureStatsCreateWithoutStatsInput, CreatureStatsUncheckedCreateWithoutStatsInput>
    where?: CreatureStatsWhereInput
  }

  export type CreatureStatsUpdateToOneWithWhereWithoutStatsInput = {
    where?: CreatureStatsWhereInput
    data: XOR<CreatureStatsUpdateWithoutStatsInput, CreatureStatsUncheckedUpdateWithoutStatsInput>
  }

  export type CreatureStatsUpdateWithoutStatsInput = {
    creature_relation?: CreatureUpdateOneRequiredWithoutStatsNestedInput
  }

  export type CreatureStatsUncheckedUpdateWithoutStatsInput = {
    id?: StringFieldUpdateOperationsInput | string
  }

  export type CreatureSkillDetailCreateWithoutCreature_skills_relationInput = {
    id?: string
    skill: $Enums.Skill
    value?: number | null
    mastery: boolean
  }

  export type CreatureSkillDetailUncheckedCreateWithoutCreature_skills_relationInput = {
    id?: string
    skill: $Enums.Skill
    value?: number | null
    mastery: boolean
  }

  export type CreatureSkillDetailCreateOrConnectWithoutCreature_skills_relationInput = {
    where: CreatureSkillDetailWhereUniqueInput
    create: XOR<CreatureSkillDetailCreateWithoutCreature_skills_relationInput, CreatureSkillDetailUncheckedCreateWithoutCreature_skills_relationInput>
  }

  export type CreatureSkillDetailCreateManyCreature_skills_relationInputEnvelope = {
    data: CreatureSkillDetailCreateManyCreature_skills_relationInput | CreatureSkillDetailCreateManyCreature_skills_relationInput[]
    skipDuplicates?: boolean
  }

  export type CreatureCreateWithoutSkillsInput = {
    id?: string
    name: string
    creator_id?: string | null
    description?: string | null
    armor_class?: number | null
    hit_points?: number | null
    speed?: CreatureSpeedCreateNestedOneWithoutCreature_relationInput
    stats?: CreatureStatsCreateNestedOneWithoutCreature_relationInput
    senses?: CreatureSensesCreateNestedOneWithoutCreature_relationInput
    challenge_rating_meta: ChallengeRatingMetadataCreateNestedOneWithoutCreaturesInput
    alignment_relation?: AlignmentCreateNestedOneWithoutCreaturesInput
    race_relation?: CreatureRaceCreateNestedOneWithoutCreatures_relationInput
    type_relation?: TypeCreateNestedOneWithoutCreaturesInput
    size_relation?: SizeCreateNestedOneWithoutCreatureInput
    source_relation?: SourceCreateNestedOneWithoutCreaturesInput
    resistances?: DamageTypeCreateNestedManyWithoutResistant_creatures_relationInput
    immunities?: DamageTypeCreateNestedManyWithoutImmune_creatures_relationInput
    vulnerabilities?: DamageTypeCreateNestedManyWithoutVulnerable_creatures_relationInput
    languages_relation?: LanguageCreateNestedManyWithoutCreatures_relationInput
    biomes_relation?: BiomeCreateNestedManyWithoutCreatures_relationInput
    actions_relation?: ActionCreateNestedManyWithoutCreatures_relationInput
    traits_relation?: TraitCreateNestedManyWithoutCreatures_relationInput
  }

  export type CreatureUncheckedCreateWithoutSkillsInput = {
    id?: string
    name: string
    creator_id?: string | null
    description?: string | null
    size?: string | null
    race_id?: number | null
    type_id?: number | null
    source_id?: number | null
    alignment_id?: number | null
    armor_class?: number | null
    hit_points?: number | null
    challenge_rating: string
    speed?: CreatureSpeedUncheckedCreateNestedOneWithoutCreature_relationInput
    stats?: CreatureStatsUncheckedCreateNestedOneWithoutCreature_relationInput
    senses?: CreatureSensesUncheckedCreateNestedOneWithoutCreature_relationInput
    resistances?: DamageTypeUncheckedCreateNestedManyWithoutResistant_creatures_relationInput
    immunities?: DamageTypeUncheckedCreateNestedManyWithoutImmune_creatures_relationInput
    vulnerabilities?: DamageTypeUncheckedCreateNestedManyWithoutVulnerable_creatures_relationInput
    languages_relation?: LanguageUncheckedCreateNestedManyWithoutCreatures_relationInput
    biomes_relation?: BiomeUncheckedCreateNestedManyWithoutCreatures_relationInput
    actions_relation?: ActionUncheckedCreateNestedManyWithoutCreatures_relationInput
    traits_relation?: TraitUncheckedCreateNestedManyWithoutCreatures_relationInput
  }

  export type CreatureCreateOrConnectWithoutSkillsInput = {
    where: CreatureWhereUniqueInput
    create: XOR<CreatureCreateWithoutSkillsInput, CreatureUncheckedCreateWithoutSkillsInput>
  }

  export type CreatureSkillDetailUpsertWithWhereUniqueWithoutCreature_skills_relationInput = {
    where: CreatureSkillDetailWhereUniqueInput
    update: XOR<CreatureSkillDetailUpdateWithoutCreature_skills_relationInput, CreatureSkillDetailUncheckedUpdateWithoutCreature_skills_relationInput>
    create: XOR<CreatureSkillDetailCreateWithoutCreature_skills_relationInput, CreatureSkillDetailUncheckedCreateWithoutCreature_skills_relationInput>
  }

  export type CreatureSkillDetailUpdateWithWhereUniqueWithoutCreature_skills_relationInput = {
    where: CreatureSkillDetailWhereUniqueInput
    data: XOR<CreatureSkillDetailUpdateWithoutCreature_skills_relationInput, CreatureSkillDetailUncheckedUpdateWithoutCreature_skills_relationInput>
  }

  export type CreatureSkillDetailUpdateManyWithWhereWithoutCreature_skills_relationInput = {
    where: CreatureSkillDetailScalarWhereInput
    data: XOR<CreatureSkillDetailUpdateManyMutationInput, CreatureSkillDetailUncheckedUpdateManyWithoutCreature_skills_relationInput>
  }

  export type CreatureSkillDetailScalarWhereInput = {
    AND?: CreatureSkillDetailScalarWhereInput | CreatureSkillDetailScalarWhereInput[]
    OR?: CreatureSkillDetailScalarWhereInput[]
    NOT?: CreatureSkillDetailScalarWhereInput | CreatureSkillDetailScalarWhereInput[]
    id?: StringFilter<"CreatureSkillDetail"> | string
    skill?: EnumSkillFilter<"CreatureSkillDetail"> | $Enums.Skill
    value?: IntNullableFilter<"CreatureSkillDetail"> | number | null
    mastery?: BoolFilter<"CreatureSkillDetail"> | boolean
    creature_skills_id?: StringFilter<"CreatureSkillDetail"> | string
  }

  export type CreatureUpsertWithoutSkillsInput = {
    update: XOR<CreatureUpdateWithoutSkillsInput, CreatureUncheckedUpdateWithoutSkillsInput>
    create: XOR<CreatureCreateWithoutSkillsInput, CreatureUncheckedCreateWithoutSkillsInput>
    where?: CreatureWhereInput
  }

  export type CreatureUpdateToOneWithWhereWithoutSkillsInput = {
    where?: CreatureWhereInput
    data: XOR<CreatureUpdateWithoutSkillsInput, CreatureUncheckedUpdateWithoutSkillsInput>
  }

  export type CreatureUpdateWithoutSkillsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    creator_id?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    armor_class?: NullableIntFieldUpdateOperationsInput | number | null
    hit_points?: NullableIntFieldUpdateOperationsInput | number | null
    speed?: CreatureSpeedUpdateOneWithoutCreature_relationNestedInput
    stats?: CreatureStatsUpdateOneWithoutCreature_relationNestedInput
    senses?: CreatureSensesUpdateOneWithoutCreature_relationNestedInput
    challenge_rating_meta?: ChallengeRatingMetadataUpdateOneRequiredWithoutCreaturesNestedInput
    alignment_relation?: AlignmentUpdateOneWithoutCreaturesNestedInput
    race_relation?: CreatureRaceUpdateOneWithoutCreatures_relationNestedInput
    type_relation?: TypeUpdateOneWithoutCreaturesNestedInput
    size_relation?: SizeUpdateOneWithoutCreatureNestedInput
    source_relation?: SourceUpdateOneWithoutCreaturesNestedInput
    resistances?: DamageTypeUpdateManyWithoutResistant_creatures_relationNestedInput
    immunities?: DamageTypeUpdateManyWithoutImmune_creatures_relationNestedInput
    vulnerabilities?: DamageTypeUpdateManyWithoutVulnerable_creatures_relationNestedInput
    languages_relation?: LanguageUpdateManyWithoutCreatures_relationNestedInput
    biomes_relation?: BiomeUpdateManyWithoutCreatures_relationNestedInput
    actions_relation?: ActionUpdateManyWithoutCreatures_relationNestedInput
    traits_relation?: TraitUpdateManyWithoutCreatures_relationNestedInput
  }

  export type CreatureUncheckedUpdateWithoutSkillsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    creator_id?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableStringFieldUpdateOperationsInput | string | null
    race_id?: NullableIntFieldUpdateOperationsInput | number | null
    type_id?: NullableIntFieldUpdateOperationsInput | number | null
    source_id?: NullableIntFieldUpdateOperationsInput | number | null
    alignment_id?: NullableIntFieldUpdateOperationsInput | number | null
    armor_class?: NullableIntFieldUpdateOperationsInput | number | null
    hit_points?: NullableIntFieldUpdateOperationsInput | number | null
    challenge_rating?: StringFieldUpdateOperationsInput | string
    speed?: CreatureSpeedUncheckedUpdateOneWithoutCreature_relationNestedInput
    stats?: CreatureStatsUncheckedUpdateOneWithoutCreature_relationNestedInput
    senses?: CreatureSensesUncheckedUpdateOneWithoutCreature_relationNestedInput
    resistances?: DamageTypeUncheckedUpdateManyWithoutResistant_creatures_relationNestedInput
    immunities?: DamageTypeUncheckedUpdateManyWithoutImmune_creatures_relationNestedInput
    vulnerabilities?: DamageTypeUncheckedUpdateManyWithoutVulnerable_creatures_relationNestedInput
    languages_relation?: LanguageUncheckedUpdateManyWithoutCreatures_relationNestedInput
    biomes_relation?: BiomeUncheckedUpdateManyWithoutCreatures_relationNestedInput
    actions_relation?: ActionUncheckedUpdateManyWithoutCreatures_relationNestedInput
    traits_relation?: TraitUncheckedUpdateManyWithoutCreatures_relationNestedInput
  }

  export type CreatureSkillsCreateWithoutSkillsInput = {
    creature_relation: CreatureCreateNestedOneWithoutSkillsInput
  }

  export type CreatureSkillsUncheckedCreateWithoutSkillsInput = {
    id: string
  }

  export type CreatureSkillsCreateOrConnectWithoutSkillsInput = {
    where: CreatureSkillsWhereUniqueInput
    create: XOR<CreatureSkillsCreateWithoutSkillsInput, CreatureSkillsUncheckedCreateWithoutSkillsInput>
  }

  export type CreatureSkillsUpsertWithoutSkillsInput = {
    update: XOR<CreatureSkillsUpdateWithoutSkillsInput, CreatureSkillsUncheckedUpdateWithoutSkillsInput>
    create: XOR<CreatureSkillsCreateWithoutSkillsInput, CreatureSkillsUncheckedCreateWithoutSkillsInput>
    where?: CreatureSkillsWhereInput
  }

  export type CreatureSkillsUpdateToOneWithWhereWithoutSkillsInput = {
    where?: CreatureSkillsWhereInput
    data: XOR<CreatureSkillsUpdateWithoutSkillsInput, CreatureSkillsUncheckedUpdateWithoutSkillsInput>
  }

  export type CreatureSkillsUpdateWithoutSkillsInput = {
    creature_relation?: CreatureUpdateOneRequiredWithoutSkillsNestedInput
  }

  export type CreatureSkillsUncheckedUpdateWithoutSkillsInput = {
    id?: StringFieldUpdateOperationsInput | string
  }

  export type CreatureSpeedCreateWithoutCreature_relationInput = {
    walk?: number | null
    fly?: number | null
    swim?: number | null
    burrow?: number | null
    climb?: number | null
  }

  export type CreatureSpeedUncheckedCreateWithoutCreature_relationInput = {
    walk?: number | null
    fly?: number | null
    swim?: number | null
    burrow?: number | null
    climb?: number | null
  }

  export type CreatureSpeedCreateOrConnectWithoutCreature_relationInput = {
    where: CreatureSpeedWhereUniqueInput
    create: XOR<CreatureSpeedCreateWithoutCreature_relationInput, CreatureSpeedUncheckedCreateWithoutCreature_relationInput>
  }

  export type CreatureStatsCreateWithoutCreature_relationInput = {
    stats?: CreatureStatDetailCreateNestedManyWithoutCreature_stats_relationInput
  }

  export type CreatureStatsUncheckedCreateWithoutCreature_relationInput = {
    stats?: CreatureStatDetailUncheckedCreateNestedManyWithoutCreature_stats_relationInput
  }

  export type CreatureStatsCreateOrConnectWithoutCreature_relationInput = {
    where: CreatureStatsWhereUniqueInput
    create: XOR<CreatureStatsCreateWithoutCreature_relationInput, CreatureStatsUncheckedCreateWithoutCreature_relationInput>
  }

  export type CreatureSkillsCreateWithoutCreature_relationInput = {
    skills?: CreatureSkillDetailCreateNestedManyWithoutCreature_skills_relationInput
  }

  export type CreatureSkillsUncheckedCreateWithoutCreature_relationInput = {
    skills?: CreatureSkillDetailUncheckedCreateNestedManyWithoutCreature_skills_relationInput
  }

  export type CreatureSkillsCreateOrConnectWithoutCreature_relationInput = {
    where: CreatureSkillsWhereUniqueInput
    create: XOR<CreatureSkillsCreateWithoutCreature_relationInput, CreatureSkillsUncheckedCreateWithoutCreature_relationInput>
  }

  export type CreatureSensesCreateWithoutCreature_relationInput = {
    id?: string
    passive_perception?: number | null
  }

  export type CreatureSensesUncheckedCreateWithoutCreature_relationInput = {
    id?: string
    passive_perception?: number | null
  }

  export type CreatureSensesCreateOrConnectWithoutCreature_relationInput = {
    where: CreatureSensesWhereUniqueInput
    create: XOR<CreatureSensesCreateWithoutCreature_relationInput, CreatureSensesUncheckedCreateWithoutCreature_relationInput>
  }

  export type ChallengeRatingMetadataCreateWithoutCreaturesInput = {
    cr: $Enums.ChallengeRatingEnum
    display: string
    numeric: number
    xp_reward: number
  }

  export type ChallengeRatingMetadataUncheckedCreateWithoutCreaturesInput = {
    cr: $Enums.ChallengeRatingEnum
    display: string
    numeric: number
    xp_reward: number
  }

  export type ChallengeRatingMetadataCreateOrConnectWithoutCreaturesInput = {
    where: ChallengeRatingMetadataWhereUniqueInput
    create: XOR<ChallengeRatingMetadataCreateWithoutCreaturesInput, ChallengeRatingMetadataUncheckedCreateWithoutCreaturesInput>
  }

  export type AlignmentCreateWithoutCreaturesInput = {
    name: string
  }

  export type AlignmentUncheckedCreateWithoutCreaturesInput = {
    id?: number
    name: string
  }

  export type AlignmentCreateOrConnectWithoutCreaturesInput = {
    where: AlignmentWhereUniqueInput
    create: XOR<AlignmentCreateWithoutCreaturesInput, AlignmentUncheckedCreateWithoutCreaturesInput>
  }

  export type CreatureRaceCreateWithoutCreatures_relationInput = {
    name: string
    description: string
    traits_relation?: TraitCreateNestedManyWithoutCreature_races_relationInput
    actions_relation?: ActionCreateNestedManyWithoutCreature_races_relationInput
  }

  export type CreatureRaceUncheckedCreateWithoutCreatures_relationInput = {
    id?: number
    name: string
    description: string
    traits_relation?: TraitUncheckedCreateNestedManyWithoutCreature_races_relationInput
    actions_relation?: ActionUncheckedCreateNestedManyWithoutCreature_races_relationInput
  }

  export type CreatureRaceCreateOrConnectWithoutCreatures_relationInput = {
    where: CreatureRaceWhereUniqueInput
    create: XOR<CreatureRaceCreateWithoutCreatures_relationInput, CreatureRaceUncheckedCreateWithoutCreatures_relationInput>
  }

  export type TypeCreateWithoutCreaturesInput = {
    name: string
  }

  export type TypeUncheckedCreateWithoutCreaturesInput = {
    id?: number
    name: string
  }

  export type TypeCreateOrConnectWithoutCreaturesInput = {
    where: TypeWhereUniqueInput
    create: XOR<TypeCreateWithoutCreaturesInput, TypeUncheckedCreateWithoutCreaturesInput>
  }

  export type SizeCreateWithoutCreatureInput = {
    id: string
    name: string
  }

  export type SizeUncheckedCreateWithoutCreatureInput = {
    id: string
    name: string
  }

  export type SizeCreateOrConnectWithoutCreatureInput = {
    where: SizeWhereUniqueInput
    create: XOR<SizeCreateWithoutCreatureInput, SizeUncheckedCreateWithoutCreatureInput>
  }

  export type SourceCreateWithoutCreaturesInput = {
    short_name: string
    name: string
    magicItems?: MagicItemCreateNestedManyWithoutSource_relationInput
  }

  export type SourceUncheckedCreateWithoutCreaturesInput = {
    id?: number
    short_name: string
    name: string
    magicItems?: MagicItemUncheckedCreateNestedManyWithoutSource_relationInput
  }

  export type SourceCreateOrConnectWithoutCreaturesInput = {
    where: SourceWhereUniqueInput
    create: XOR<SourceCreateWithoutCreaturesInput, SourceUncheckedCreateWithoutCreaturesInput>
  }

  export type DamageTypeCreateWithoutResistant_creatures_relationInput = {
    id: string
    name: string
    immune_creatures_relation?: CreatureCreateNestedManyWithoutImmunitiesInput
    vulnerable_creatures_relation?: CreatureCreateNestedManyWithoutVulnerabilitiesInput
  }

  export type DamageTypeUncheckedCreateWithoutResistant_creatures_relationInput = {
    id: string
    name: string
    immune_creatures_relation?: CreatureUncheckedCreateNestedManyWithoutImmunitiesInput
    vulnerable_creatures_relation?: CreatureUncheckedCreateNestedManyWithoutVulnerabilitiesInput
  }

  export type DamageTypeCreateOrConnectWithoutResistant_creatures_relationInput = {
    where: DamageTypeWhereUniqueInput
    create: XOR<DamageTypeCreateWithoutResistant_creatures_relationInput, DamageTypeUncheckedCreateWithoutResistant_creatures_relationInput>
  }

  export type DamageTypeCreateWithoutImmune_creatures_relationInput = {
    id: string
    name: string
    resistant_creatures_relation?: CreatureCreateNestedManyWithoutResistancesInput
    vulnerable_creatures_relation?: CreatureCreateNestedManyWithoutVulnerabilitiesInput
  }

  export type DamageTypeUncheckedCreateWithoutImmune_creatures_relationInput = {
    id: string
    name: string
    resistant_creatures_relation?: CreatureUncheckedCreateNestedManyWithoutResistancesInput
    vulnerable_creatures_relation?: CreatureUncheckedCreateNestedManyWithoutVulnerabilitiesInput
  }

  export type DamageTypeCreateOrConnectWithoutImmune_creatures_relationInput = {
    where: DamageTypeWhereUniqueInput
    create: XOR<DamageTypeCreateWithoutImmune_creatures_relationInput, DamageTypeUncheckedCreateWithoutImmune_creatures_relationInput>
  }

  export type DamageTypeCreateWithoutVulnerable_creatures_relationInput = {
    id: string
    name: string
    resistant_creatures_relation?: CreatureCreateNestedManyWithoutResistancesInput
    immune_creatures_relation?: CreatureCreateNestedManyWithoutImmunitiesInput
  }

  export type DamageTypeUncheckedCreateWithoutVulnerable_creatures_relationInput = {
    id: string
    name: string
    resistant_creatures_relation?: CreatureUncheckedCreateNestedManyWithoutResistancesInput
    immune_creatures_relation?: CreatureUncheckedCreateNestedManyWithoutImmunitiesInput
  }

  export type DamageTypeCreateOrConnectWithoutVulnerable_creatures_relationInput = {
    where: DamageTypeWhereUniqueInput
    create: XOR<DamageTypeCreateWithoutVulnerable_creatures_relationInput, DamageTypeUncheckedCreateWithoutVulnerable_creatures_relationInput>
  }

  export type LanguageCreateWithoutCreatures_relationInput = {
    name: string
  }

  export type LanguageUncheckedCreateWithoutCreatures_relationInput = {
    id?: number
    name: string
  }

  export type LanguageCreateOrConnectWithoutCreatures_relationInput = {
    where: LanguageWhereUniqueInput
    create: XOR<LanguageCreateWithoutCreatures_relationInput, LanguageUncheckedCreateWithoutCreatures_relationInput>
  }

  export type BiomeCreateWithoutCreatures_relationInput = {
    short_name: string
    name: string
  }

  export type BiomeUncheckedCreateWithoutCreatures_relationInput = {
    id?: number
    short_name: string
    name: string
  }

  export type BiomeCreateOrConnectWithoutCreatures_relationInput = {
    where: BiomeWhereUniqueInput
    create: XOR<BiomeCreateWithoutCreatures_relationInput, BiomeUncheckedCreateWithoutCreatures_relationInput>
  }

  export type ActionCreateWithoutCreatures_relationInput = {
    name: string
    description: string
    attack?: string | null
    is_template?: boolean | null
    creature_races_relation?: CreatureRaceCreateNestedManyWithoutActions_relationInput
  }

  export type ActionUncheckedCreateWithoutCreatures_relationInput = {
    id?: number
    name: string
    description: string
    attack?: string | null
    is_template?: boolean | null
    creature_races_relation?: CreatureRaceUncheckedCreateNestedManyWithoutActions_relationInput
  }

  export type ActionCreateOrConnectWithoutCreatures_relationInput = {
    where: ActionWhereUniqueInput
    create: XOR<ActionCreateWithoutCreatures_relationInput, ActionUncheckedCreateWithoutCreatures_relationInput>
  }

  export type TraitCreateWithoutCreatures_relationInput = {
    name: string
    description: string
    attack?: string | null
    is_template?: boolean | null
    creature_races_relation?: CreatureRaceCreateNestedManyWithoutTraits_relationInput
  }

  export type TraitUncheckedCreateWithoutCreatures_relationInput = {
    id?: number
    name: string
    description: string
    attack?: string | null
    is_template?: boolean | null
    creature_races_relation?: CreatureRaceUncheckedCreateNestedManyWithoutTraits_relationInput
  }

  export type TraitCreateOrConnectWithoutCreatures_relationInput = {
    where: TraitWhereUniqueInput
    create: XOR<TraitCreateWithoutCreatures_relationInput, TraitUncheckedCreateWithoutCreatures_relationInput>
  }

  export type CreatureSpeedUpsertWithoutCreature_relationInput = {
    update: XOR<CreatureSpeedUpdateWithoutCreature_relationInput, CreatureSpeedUncheckedUpdateWithoutCreature_relationInput>
    create: XOR<CreatureSpeedCreateWithoutCreature_relationInput, CreatureSpeedUncheckedCreateWithoutCreature_relationInput>
    where?: CreatureSpeedWhereInput
  }

  export type CreatureSpeedUpdateToOneWithWhereWithoutCreature_relationInput = {
    where?: CreatureSpeedWhereInput
    data: XOR<CreatureSpeedUpdateWithoutCreature_relationInput, CreatureSpeedUncheckedUpdateWithoutCreature_relationInput>
  }

  export type CreatureSpeedUpdateWithoutCreature_relationInput = {
    walk?: NullableIntFieldUpdateOperationsInput | number | null
    fly?: NullableIntFieldUpdateOperationsInput | number | null
    swim?: NullableIntFieldUpdateOperationsInput | number | null
    burrow?: NullableIntFieldUpdateOperationsInput | number | null
    climb?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type CreatureSpeedUncheckedUpdateWithoutCreature_relationInput = {
    walk?: NullableIntFieldUpdateOperationsInput | number | null
    fly?: NullableIntFieldUpdateOperationsInput | number | null
    swim?: NullableIntFieldUpdateOperationsInput | number | null
    burrow?: NullableIntFieldUpdateOperationsInput | number | null
    climb?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type CreatureStatsUpsertWithoutCreature_relationInput = {
    update: XOR<CreatureStatsUpdateWithoutCreature_relationInput, CreatureStatsUncheckedUpdateWithoutCreature_relationInput>
    create: XOR<CreatureStatsCreateWithoutCreature_relationInput, CreatureStatsUncheckedCreateWithoutCreature_relationInput>
    where?: CreatureStatsWhereInput
  }

  export type CreatureStatsUpdateToOneWithWhereWithoutCreature_relationInput = {
    where?: CreatureStatsWhereInput
    data: XOR<CreatureStatsUpdateWithoutCreature_relationInput, CreatureStatsUncheckedUpdateWithoutCreature_relationInput>
  }

  export type CreatureStatsUpdateWithoutCreature_relationInput = {
    stats?: CreatureStatDetailUpdateManyWithoutCreature_stats_relationNestedInput
  }

  export type CreatureStatsUncheckedUpdateWithoutCreature_relationInput = {
    stats?: CreatureStatDetailUncheckedUpdateManyWithoutCreature_stats_relationNestedInput
  }

  export type CreatureSkillsUpsertWithoutCreature_relationInput = {
    update: XOR<CreatureSkillsUpdateWithoutCreature_relationInput, CreatureSkillsUncheckedUpdateWithoutCreature_relationInput>
    create: XOR<CreatureSkillsCreateWithoutCreature_relationInput, CreatureSkillsUncheckedCreateWithoutCreature_relationInput>
    where?: CreatureSkillsWhereInput
  }

  export type CreatureSkillsUpdateToOneWithWhereWithoutCreature_relationInput = {
    where?: CreatureSkillsWhereInput
    data: XOR<CreatureSkillsUpdateWithoutCreature_relationInput, CreatureSkillsUncheckedUpdateWithoutCreature_relationInput>
  }

  export type CreatureSkillsUpdateWithoutCreature_relationInput = {
    skills?: CreatureSkillDetailUpdateManyWithoutCreature_skills_relationNestedInput
  }

  export type CreatureSkillsUncheckedUpdateWithoutCreature_relationInput = {
    skills?: CreatureSkillDetailUncheckedUpdateManyWithoutCreature_skills_relationNestedInput
  }

  export type CreatureSensesUpsertWithoutCreature_relationInput = {
    update: XOR<CreatureSensesUpdateWithoutCreature_relationInput, CreatureSensesUncheckedUpdateWithoutCreature_relationInput>
    create: XOR<CreatureSensesCreateWithoutCreature_relationInput, CreatureSensesUncheckedCreateWithoutCreature_relationInput>
    where?: CreatureSensesWhereInput
  }

  export type CreatureSensesUpdateToOneWithWhereWithoutCreature_relationInput = {
    where?: CreatureSensesWhereInput
    data: XOR<CreatureSensesUpdateWithoutCreature_relationInput, CreatureSensesUncheckedUpdateWithoutCreature_relationInput>
  }

  export type CreatureSensesUpdateWithoutCreature_relationInput = {
    id?: StringFieldUpdateOperationsInput | string
    passive_perception?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type CreatureSensesUncheckedUpdateWithoutCreature_relationInput = {
    id?: StringFieldUpdateOperationsInput | string
    passive_perception?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ChallengeRatingMetadataUpsertWithoutCreaturesInput = {
    update: XOR<ChallengeRatingMetadataUpdateWithoutCreaturesInput, ChallengeRatingMetadataUncheckedUpdateWithoutCreaturesInput>
    create: XOR<ChallengeRatingMetadataCreateWithoutCreaturesInput, ChallengeRatingMetadataUncheckedCreateWithoutCreaturesInput>
    where?: ChallengeRatingMetadataWhereInput
  }

  export type ChallengeRatingMetadataUpdateToOneWithWhereWithoutCreaturesInput = {
    where?: ChallengeRatingMetadataWhereInput
    data: XOR<ChallengeRatingMetadataUpdateWithoutCreaturesInput, ChallengeRatingMetadataUncheckedUpdateWithoutCreaturesInput>
  }

  export type ChallengeRatingMetadataUpdateWithoutCreaturesInput = {
    cr?: EnumChallengeRatingEnumFieldUpdateOperationsInput | $Enums.ChallengeRatingEnum
    display?: StringFieldUpdateOperationsInput | string
    numeric?: FloatFieldUpdateOperationsInput | number
    xp_reward?: IntFieldUpdateOperationsInput | number
  }

  export type ChallengeRatingMetadataUncheckedUpdateWithoutCreaturesInput = {
    cr?: EnumChallengeRatingEnumFieldUpdateOperationsInput | $Enums.ChallengeRatingEnum
    display?: StringFieldUpdateOperationsInput | string
    numeric?: FloatFieldUpdateOperationsInput | number
    xp_reward?: IntFieldUpdateOperationsInput | number
  }

  export type AlignmentUpsertWithoutCreaturesInput = {
    update: XOR<AlignmentUpdateWithoutCreaturesInput, AlignmentUncheckedUpdateWithoutCreaturesInput>
    create: XOR<AlignmentCreateWithoutCreaturesInput, AlignmentUncheckedCreateWithoutCreaturesInput>
    where?: AlignmentWhereInput
  }

  export type AlignmentUpdateToOneWithWhereWithoutCreaturesInput = {
    where?: AlignmentWhereInput
    data: XOR<AlignmentUpdateWithoutCreaturesInput, AlignmentUncheckedUpdateWithoutCreaturesInput>
  }

  export type AlignmentUpdateWithoutCreaturesInput = {
    name?: StringFieldUpdateOperationsInput | string
  }

  export type AlignmentUncheckedUpdateWithoutCreaturesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type CreatureRaceUpsertWithoutCreatures_relationInput = {
    update: XOR<CreatureRaceUpdateWithoutCreatures_relationInput, CreatureRaceUncheckedUpdateWithoutCreatures_relationInput>
    create: XOR<CreatureRaceCreateWithoutCreatures_relationInput, CreatureRaceUncheckedCreateWithoutCreatures_relationInput>
    where?: CreatureRaceWhereInput
  }

  export type CreatureRaceUpdateToOneWithWhereWithoutCreatures_relationInput = {
    where?: CreatureRaceWhereInput
    data: XOR<CreatureRaceUpdateWithoutCreatures_relationInput, CreatureRaceUncheckedUpdateWithoutCreatures_relationInput>
  }

  export type CreatureRaceUpdateWithoutCreatures_relationInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    traits_relation?: TraitUpdateManyWithoutCreature_races_relationNestedInput
    actions_relation?: ActionUpdateManyWithoutCreature_races_relationNestedInput
  }

  export type CreatureRaceUncheckedUpdateWithoutCreatures_relationInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    traits_relation?: TraitUncheckedUpdateManyWithoutCreature_races_relationNestedInput
    actions_relation?: ActionUncheckedUpdateManyWithoutCreature_races_relationNestedInput
  }

  export type TypeUpsertWithoutCreaturesInput = {
    update: XOR<TypeUpdateWithoutCreaturesInput, TypeUncheckedUpdateWithoutCreaturesInput>
    create: XOR<TypeCreateWithoutCreaturesInput, TypeUncheckedCreateWithoutCreaturesInput>
    where?: TypeWhereInput
  }

  export type TypeUpdateToOneWithWhereWithoutCreaturesInput = {
    where?: TypeWhereInput
    data: XOR<TypeUpdateWithoutCreaturesInput, TypeUncheckedUpdateWithoutCreaturesInput>
  }

  export type TypeUpdateWithoutCreaturesInput = {
    name?: StringFieldUpdateOperationsInput | string
  }

  export type TypeUncheckedUpdateWithoutCreaturesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type SizeUpsertWithoutCreatureInput = {
    update: XOR<SizeUpdateWithoutCreatureInput, SizeUncheckedUpdateWithoutCreatureInput>
    create: XOR<SizeCreateWithoutCreatureInput, SizeUncheckedCreateWithoutCreatureInput>
    where?: SizeWhereInput
  }

  export type SizeUpdateToOneWithWhereWithoutCreatureInput = {
    where?: SizeWhereInput
    data: XOR<SizeUpdateWithoutCreatureInput, SizeUncheckedUpdateWithoutCreatureInput>
  }

  export type SizeUpdateWithoutCreatureInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type SizeUncheckedUpdateWithoutCreatureInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type SourceUpsertWithoutCreaturesInput = {
    update: XOR<SourceUpdateWithoutCreaturesInput, SourceUncheckedUpdateWithoutCreaturesInput>
    create: XOR<SourceCreateWithoutCreaturesInput, SourceUncheckedCreateWithoutCreaturesInput>
    where?: SourceWhereInput
  }

  export type SourceUpdateToOneWithWhereWithoutCreaturesInput = {
    where?: SourceWhereInput
    data: XOR<SourceUpdateWithoutCreaturesInput, SourceUncheckedUpdateWithoutCreaturesInput>
  }

  export type SourceUpdateWithoutCreaturesInput = {
    short_name?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    magicItems?: MagicItemUpdateManyWithoutSource_relationNestedInput
  }

  export type SourceUncheckedUpdateWithoutCreaturesInput = {
    id?: IntFieldUpdateOperationsInput | number
    short_name?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    magicItems?: MagicItemUncheckedUpdateManyWithoutSource_relationNestedInput
  }

  export type DamageTypeUpsertWithWhereUniqueWithoutResistant_creatures_relationInput = {
    where: DamageTypeWhereUniqueInput
    update: XOR<DamageTypeUpdateWithoutResistant_creatures_relationInput, DamageTypeUncheckedUpdateWithoutResistant_creatures_relationInput>
    create: XOR<DamageTypeCreateWithoutResistant_creatures_relationInput, DamageTypeUncheckedCreateWithoutResistant_creatures_relationInput>
  }

  export type DamageTypeUpdateWithWhereUniqueWithoutResistant_creatures_relationInput = {
    where: DamageTypeWhereUniqueInput
    data: XOR<DamageTypeUpdateWithoutResistant_creatures_relationInput, DamageTypeUncheckedUpdateWithoutResistant_creatures_relationInput>
  }

  export type DamageTypeUpdateManyWithWhereWithoutResistant_creatures_relationInput = {
    where: DamageTypeScalarWhereInput
    data: XOR<DamageTypeUpdateManyMutationInput, DamageTypeUncheckedUpdateManyWithoutResistant_creatures_relationInput>
  }

  export type DamageTypeScalarWhereInput = {
    AND?: DamageTypeScalarWhereInput | DamageTypeScalarWhereInput[]
    OR?: DamageTypeScalarWhereInput[]
    NOT?: DamageTypeScalarWhereInput | DamageTypeScalarWhereInput[]
    id?: StringFilter<"DamageType"> | string
    name?: StringFilter<"DamageType"> | string
  }

  export type DamageTypeUpsertWithWhereUniqueWithoutImmune_creatures_relationInput = {
    where: DamageTypeWhereUniqueInput
    update: XOR<DamageTypeUpdateWithoutImmune_creatures_relationInput, DamageTypeUncheckedUpdateWithoutImmune_creatures_relationInput>
    create: XOR<DamageTypeCreateWithoutImmune_creatures_relationInput, DamageTypeUncheckedCreateWithoutImmune_creatures_relationInput>
  }

  export type DamageTypeUpdateWithWhereUniqueWithoutImmune_creatures_relationInput = {
    where: DamageTypeWhereUniqueInput
    data: XOR<DamageTypeUpdateWithoutImmune_creatures_relationInput, DamageTypeUncheckedUpdateWithoutImmune_creatures_relationInput>
  }

  export type DamageTypeUpdateManyWithWhereWithoutImmune_creatures_relationInput = {
    where: DamageTypeScalarWhereInput
    data: XOR<DamageTypeUpdateManyMutationInput, DamageTypeUncheckedUpdateManyWithoutImmune_creatures_relationInput>
  }

  export type DamageTypeUpsertWithWhereUniqueWithoutVulnerable_creatures_relationInput = {
    where: DamageTypeWhereUniqueInput
    update: XOR<DamageTypeUpdateWithoutVulnerable_creatures_relationInput, DamageTypeUncheckedUpdateWithoutVulnerable_creatures_relationInput>
    create: XOR<DamageTypeCreateWithoutVulnerable_creatures_relationInput, DamageTypeUncheckedCreateWithoutVulnerable_creatures_relationInput>
  }

  export type DamageTypeUpdateWithWhereUniqueWithoutVulnerable_creatures_relationInput = {
    where: DamageTypeWhereUniqueInput
    data: XOR<DamageTypeUpdateWithoutVulnerable_creatures_relationInput, DamageTypeUncheckedUpdateWithoutVulnerable_creatures_relationInput>
  }

  export type DamageTypeUpdateManyWithWhereWithoutVulnerable_creatures_relationInput = {
    where: DamageTypeScalarWhereInput
    data: XOR<DamageTypeUpdateManyMutationInput, DamageTypeUncheckedUpdateManyWithoutVulnerable_creatures_relationInput>
  }

  export type LanguageUpsertWithWhereUniqueWithoutCreatures_relationInput = {
    where: LanguageWhereUniqueInput
    update: XOR<LanguageUpdateWithoutCreatures_relationInput, LanguageUncheckedUpdateWithoutCreatures_relationInput>
    create: XOR<LanguageCreateWithoutCreatures_relationInput, LanguageUncheckedCreateWithoutCreatures_relationInput>
  }

  export type LanguageUpdateWithWhereUniqueWithoutCreatures_relationInput = {
    where: LanguageWhereUniqueInput
    data: XOR<LanguageUpdateWithoutCreatures_relationInput, LanguageUncheckedUpdateWithoutCreatures_relationInput>
  }

  export type LanguageUpdateManyWithWhereWithoutCreatures_relationInput = {
    where: LanguageScalarWhereInput
    data: XOR<LanguageUpdateManyMutationInput, LanguageUncheckedUpdateManyWithoutCreatures_relationInput>
  }

  export type LanguageScalarWhereInput = {
    AND?: LanguageScalarWhereInput | LanguageScalarWhereInput[]
    OR?: LanguageScalarWhereInput[]
    NOT?: LanguageScalarWhereInput | LanguageScalarWhereInput[]
    id?: IntFilter<"Language"> | number
    name?: StringFilter<"Language"> | string
  }

  export type BiomeUpsertWithWhereUniqueWithoutCreatures_relationInput = {
    where: BiomeWhereUniqueInput
    update: XOR<BiomeUpdateWithoutCreatures_relationInput, BiomeUncheckedUpdateWithoutCreatures_relationInput>
    create: XOR<BiomeCreateWithoutCreatures_relationInput, BiomeUncheckedCreateWithoutCreatures_relationInput>
  }

  export type BiomeUpdateWithWhereUniqueWithoutCreatures_relationInput = {
    where: BiomeWhereUniqueInput
    data: XOR<BiomeUpdateWithoutCreatures_relationInput, BiomeUncheckedUpdateWithoutCreatures_relationInput>
  }

  export type BiomeUpdateManyWithWhereWithoutCreatures_relationInput = {
    where: BiomeScalarWhereInput
    data: XOR<BiomeUpdateManyMutationInput, BiomeUncheckedUpdateManyWithoutCreatures_relationInput>
  }

  export type BiomeScalarWhereInput = {
    AND?: BiomeScalarWhereInput | BiomeScalarWhereInput[]
    OR?: BiomeScalarWhereInput[]
    NOT?: BiomeScalarWhereInput | BiomeScalarWhereInput[]
    id?: IntFilter<"Biome"> | number
    short_name?: StringFilter<"Biome"> | string
    name?: StringFilter<"Biome"> | string
  }

  export type ActionUpsertWithWhereUniqueWithoutCreatures_relationInput = {
    where: ActionWhereUniqueInput
    update: XOR<ActionUpdateWithoutCreatures_relationInput, ActionUncheckedUpdateWithoutCreatures_relationInput>
    create: XOR<ActionCreateWithoutCreatures_relationInput, ActionUncheckedCreateWithoutCreatures_relationInput>
  }

  export type ActionUpdateWithWhereUniqueWithoutCreatures_relationInput = {
    where: ActionWhereUniqueInput
    data: XOR<ActionUpdateWithoutCreatures_relationInput, ActionUncheckedUpdateWithoutCreatures_relationInput>
  }

  export type ActionUpdateManyWithWhereWithoutCreatures_relationInput = {
    where: ActionScalarWhereInput
    data: XOR<ActionUpdateManyMutationInput, ActionUncheckedUpdateManyWithoutCreatures_relationInput>
  }

  export type ActionScalarWhereInput = {
    AND?: ActionScalarWhereInput | ActionScalarWhereInput[]
    OR?: ActionScalarWhereInput[]
    NOT?: ActionScalarWhereInput | ActionScalarWhereInput[]
    id?: IntFilter<"Action"> | number
    name?: StringFilter<"Action"> | string
    description?: StringFilter<"Action"> | string
    attack?: StringNullableFilter<"Action"> | string | null
    is_template?: BoolNullableFilter<"Action"> | boolean | null
  }

  export type TraitUpsertWithWhereUniqueWithoutCreatures_relationInput = {
    where: TraitWhereUniqueInput
    update: XOR<TraitUpdateWithoutCreatures_relationInput, TraitUncheckedUpdateWithoutCreatures_relationInput>
    create: XOR<TraitCreateWithoutCreatures_relationInput, TraitUncheckedCreateWithoutCreatures_relationInput>
  }

  export type TraitUpdateWithWhereUniqueWithoutCreatures_relationInput = {
    where: TraitWhereUniqueInput
    data: XOR<TraitUpdateWithoutCreatures_relationInput, TraitUncheckedUpdateWithoutCreatures_relationInput>
  }

  export type TraitUpdateManyWithWhereWithoutCreatures_relationInput = {
    where: TraitScalarWhereInput
    data: XOR<TraitUpdateManyMutationInput, TraitUncheckedUpdateManyWithoutCreatures_relationInput>
  }

  export type TraitScalarWhereInput = {
    AND?: TraitScalarWhereInput | TraitScalarWhereInput[]
    OR?: TraitScalarWhereInput[]
    NOT?: TraitScalarWhereInput | TraitScalarWhereInput[]
    id?: IntFilter<"Trait"> | number
    name?: StringFilter<"Trait"> | string
    description?: StringFilter<"Trait"> | string
    attack?: StringNullableFilter<"Trait"> | string | null
    is_template?: BoolNullableFilter<"Trait"> | boolean | null
  }

  export type CreatureCreateWithoutSensesInput = {
    id?: string
    name: string
    creator_id?: string | null
    description?: string | null
    armor_class?: number | null
    hit_points?: number | null
    speed?: CreatureSpeedCreateNestedOneWithoutCreature_relationInput
    stats?: CreatureStatsCreateNestedOneWithoutCreature_relationInput
    skills?: CreatureSkillsCreateNestedOneWithoutCreature_relationInput
    challenge_rating_meta: ChallengeRatingMetadataCreateNestedOneWithoutCreaturesInput
    alignment_relation?: AlignmentCreateNestedOneWithoutCreaturesInput
    race_relation?: CreatureRaceCreateNestedOneWithoutCreatures_relationInput
    type_relation?: TypeCreateNestedOneWithoutCreaturesInput
    size_relation?: SizeCreateNestedOneWithoutCreatureInput
    source_relation?: SourceCreateNestedOneWithoutCreaturesInput
    resistances?: DamageTypeCreateNestedManyWithoutResistant_creatures_relationInput
    immunities?: DamageTypeCreateNestedManyWithoutImmune_creatures_relationInput
    vulnerabilities?: DamageTypeCreateNestedManyWithoutVulnerable_creatures_relationInput
    languages_relation?: LanguageCreateNestedManyWithoutCreatures_relationInput
    biomes_relation?: BiomeCreateNestedManyWithoutCreatures_relationInput
    actions_relation?: ActionCreateNestedManyWithoutCreatures_relationInput
    traits_relation?: TraitCreateNestedManyWithoutCreatures_relationInput
  }

  export type CreatureUncheckedCreateWithoutSensesInput = {
    id?: string
    name: string
    creator_id?: string | null
    description?: string | null
    size?: string | null
    race_id?: number | null
    type_id?: number | null
    source_id?: number | null
    alignment_id?: number | null
    armor_class?: number | null
    hit_points?: number | null
    challenge_rating: string
    speed?: CreatureSpeedUncheckedCreateNestedOneWithoutCreature_relationInput
    stats?: CreatureStatsUncheckedCreateNestedOneWithoutCreature_relationInput
    skills?: CreatureSkillsUncheckedCreateNestedOneWithoutCreature_relationInput
    resistances?: DamageTypeUncheckedCreateNestedManyWithoutResistant_creatures_relationInput
    immunities?: DamageTypeUncheckedCreateNestedManyWithoutImmune_creatures_relationInput
    vulnerabilities?: DamageTypeUncheckedCreateNestedManyWithoutVulnerable_creatures_relationInput
    languages_relation?: LanguageUncheckedCreateNestedManyWithoutCreatures_relationInput
    biomes_relation?: BiomeUncheckedCreateNestedManyWithoutCreatures_relationInput
    actions_relation?: ActionUncheckedCreateNestedManyWithoutCreatures_relationInput
    traits_relation?: TraitUncheckedCreateNestedManyWithoutCreatures_relationInput
  }

  export type CreatureCreateOrConnectWithoutSensesInput = {
    where: CreatureWhereUniqueInput
    create: XOR<CreatureCreateWithoutSensesInput, CreatureUncheckedCreateWithoutSensesInput>
  }

  export type CreatureUpsertWithoutSensesInput = {
    update: XOR<CreatureUpdateWithoutSensesInput, CreatureUncheckedUpdateWithoutSensesInput>
    create: XOR<CreatureCreateWithoutSensesInput, CreatureUncheckedCreateWithoutSensesInput>
    where?: CreatureWhereInput
  }

  export type CreatureUpdateToOneWithWhereWithoutSensesInput = {
    where?: CreatureWhereInput
    data: XOR<CreatureUpdateWithoutSensesInput, CreatureUncheckedUpdateWithoutSensesInput>
  }

  export type CreatureUpdateWithoutSensesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    creator_id?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    armor_class?: NullableIntFieldUpdateOperationsInput | number | null
    hit_points?: NullableIntFieldUpdateOperationsInput | number | null
    speed?: CreatureSpeedUpdateOneWithoutCreature_relationNestedInput
    stats?: CreatureStatsUpdateOneWithoutCreature_relationNestedInput
    skills?: CreatureSkillsUpdateOneWithoutCreature_relationNestedInput
    challenge_rating_meta?: ChallengeRatingMetadataUpdateOneRequiredWithoutCreaturesNestedInput
    alignment_relation?: AlignmentUpdateOneWithoutCreaturesNestedInput
    race_relation?: CreatureRaceUpdateOneWithoutCreatures_relationNestedInput
    type_relation?: TypeUpdateOneWithoutCreaturesNestedInput
    size_relation?: SizeUpdateOneWithoutCreatureNestedInput
    source_relation?: SourceUpdateOneWithoutCreaturesNestedInput
    resistances?: DamageTypeUpdateManyWithoutResistant_creatures_relationNestedInput
    immunities?: DamageTypeUpdateManyWithoutImmune_creatures_relationNestedInput
    vulnerabilities?: DamageTypeUpdateManyWithoutVulnerable_creatures_relationNestedInput
    languages_relation?: LanguageUpdateManyWithoutCreatures_relationNestedInput
    biomes_relation?: BiomeUpdateManyWithoutCreatures_relationNestedInput
    actions_relation?: ActionUpdateManyWithoutCreatures_relationNestedInput
    traits_relation?: TraitUpdateManyWithoutCreatures_relationNestedInput
  }

  export type CreatureUncheckedUpdateWithoutSensesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    creator_id?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableStringFieldUpdateOperationsInput | string | null
    race_id?: NullableIntFieldUpdateOperationsInput | number | null
    type_id?: NullableIntFieldUpdateOperationsInput | number | null
    source_id?: NullableIntFieldUpdateOperationsInput | number | null
    alignment_id?: NullableIntFieldUpdateOperationsInput | number | null
    armor_class?: NullableIntFieldUpdateOperationsInput | number | null
    hit_points?: NullableIntFieldUpdateOperationsInput | number | null
    challenge_rating?: StringFieldUpdateOperationsInput | string
    speed?: CreatureSpeedUncheckedUpdateOneWithoutCreature_relationNestedInput
    stats?: CreatureStatsUncheckedUpdateOneWithoutCreature_relationNestedInput
    skills?: CreatureSkillsUncheckedUpdateOneWithoutCreature_relationNestedInput
    resistances?: DamageTypeUncheckedUpdateManyWithoutResistant_creatures_relationNestedInput
    immunities?: DamageTypeUncheckedUpdateManyWithoutImmune_creatures_relationNestedInput
    vulnerabilities?: DamageTypeUncheckedUpdateManyWithoutVulnerable_creatures_relationNestedInput
    languages_relation?: LanguageUncheckedUpdateManyWithoutCreatures_relationNestedInput
    biomes_relation?: BiomeUncheckedUpdateManyWithoutCreatures_relationNestedInput
    actions_relation?: ActionUncheckedUpdateManyWithoutCreatures_relationNestedInput
    traits_relation?: TraitUncheckedUpdateManyWithoutCreatures_relationNestedInput
  }

  export type CreatureCreateWithoutActions_relationInput = {
    id?: string
    name: string
    creator_id?: string | null
    description?: string | null
    armor_class?: number | null
    hit_points?: number | null
    speed?: CreatureSpeedCreateNestedOneWithoutCreature_relationInput
    stats?: CreatureStatsCreateNestedOneWithoutCreature_relationInput
    skills?: CreatureSkillsCreateNestedOneWithoutCreature_relationInput
    senses?: CreatureSensesCreateNestedOneWithoutCreature_relationInput
    challenge_rating_meta: ChallengeRatingMetadataCreateNestedOneWithoutCreaturesInput
    alignment_relation?: AlignmentCreateNestedOneWithoutCreaturesInput
    race_relation?: CreatureRaceCreateNestedOneWithoutCreatures_relationInput
    type_relation?: TypeCreateNestedOneWithoutCreaturesInput
    size_relation?: SizeCreateNestedOneWithoutCreatureInput
    source_relation?: SourceCreateNestedOneWithoutCreaturesInput
    resistances?: DamageTypeCreateNestedManyWithoutResistant_creatures_relationInput
    immunities?: DamageTypeCreateNestedManyWithoutImmune_creatures_relationInput
    vulnerabilities?: DamageTypeCreateNestedManyWithoutVulnerable_creatures_relationInput
    languages_relation?: LanguageCreateNestedManyWithoutCreatures_relationInput
    biomes_relation?: BiomeCreateNestedManyWithoutCreatures_relationInput
    traits_relation?: TraitCreateNestedManyWithoutCreatures_relationInput
  }

  export type CreatureUncheckedCreateWithoutActions_relationInput = {
    id?: string
    name: string
    creator_id?: string | null
    description?: string | null
    size?: string | null
    race_id?: number | null
    type_id?: number | null
    source_id?: number | null
    alignment_id?: number | null
    armor_class?: number | null
    hit_points?: number | null
    challenge_rating: string
    speed?: CreatureSpeedUncheckedCreateNestedOneWithoutCreature_relationInput
    stats?: CreatureStatsUncheckedCreateNestedOneWithoutCreature_relationInput
    skills?: CreatureSkillsUncheckedCreateNestedOneWithoutCreature_relationInput
    senses?: CreatureSensesUncheckedCreateNestedOneWithoutCreature_relationInput
    resistances?: DamageTypeUncheckedCreateNestedManyWithoutResistant_creatures_relationInput
    immunities?: DamageTypeUncheckedCreateNestedManyWithoutImmune_creatures_relationInput
    vulnerabilities?: DamageTypeUncheckedCreateNestedManyWithoutVulnerable_creatures_relationInput
    languages_relation?: LanguageUncheckedCreateNestedManyWithoutCreatures_relationInput
    biomes_relation?: BiomeUncheckedCreateNestedManyWithoutCreatures_relationInput
    traits_relation?: TraitUncheckedCreateNestedManyWithoutCreatures_relationInput
  }

  export type CreatureCreateOrConnectWithoutActions_relationInput = {
    where: CreatureWhereUniqueInput
    create: XOR<CreatureCreateWithoutActions_relationInput, CreatureUncheckedCreateWithoutActions_relationInput>
  }

  export type CreatureRaceCreateWithoutActions_relationInput = {
    name: string
    description: string
    traits_relation?: TraitCreateNestedManyWithoutCreature_races_relationInput
    creatures_relation?: CreatureCreateNestedManyWithoutRace_relationInput
  }

  export type CreatureRaceUncheckedCreateWithoutActions_relationInput = {
    id?: number
    name: string
    description: string
    traits_relation?: TraitUncheckedCreateNestedManyWithoutCreature_races_relationInput
    creatures_relation?: CreatureUncheckedCreateNestedManyWithoutRace_relationInput
  }

  export type CreatureRaceCreateOrConnectWithoutActions_relationInput = {
    where: CreatureRaceWhereUniqueInput
    create: XOR<CreatureRaceCreateWithoutActions_relationInput, CreatureRaceUncheckedCreateWithoutActions_relationInput>
  }

  export type CreatureUpsertWithWhereUniqueWithoutActions_relationInput = {
    where: CreatureWhereUniqueInput
    update: XOR<CreatureUpdateWithoutActions_relationInput, CreatureUncheckedUpdateWithoutActions_relationInput>
    create: XOR<CreatureCreateWithoutActions_relationInput, CreatureUncheckedCreateWithoutActions_relationInput>
  }

  export type CreatureUpdateWithWhereUniqueWithoutActions_relationInput = {
    where: CreatureWhereUniqueInput
    data: XOR<CreatureUpdateWithoutActions_relationInput, CreatureUncheckedUpdateWithoutActions_relationInput>
  }

  export type CreatureUpdateManyWithWhereWithoutActions_relationInput = {
    where: CreatureScalarWhereInput
    data: XOR<CreatureUpdateManyMutationInput, CreatureUncheckedUpdateManyWithoutActions_relationInput>
  }

  export type CreatureRaceUpsertWithWhereUniqueWithoutActions_relationInput = {
    where: CreatureRaceWhereUniqueInput
    update: XOR<CreatureRaceUpdateWithoutActions_relationInput, CreatureRaceUncheckedUpdateWithoutActions_relationInput>
    create: XOR<CreatureRaceCreateWithoutActions_relationInput, CreatureRaceUncheckedCreateWithoutActions_relationInput>
  }

  export type CreatureRaceUpdateWithWhereUniqueWithoutActions_relationInput = {
    where: CreatureRaceWhereUniqueInput
    data: XOR<CreatureRaceUpdateWithoutActions_relationInput, CreatureRaceUncheckedUpdateWithoutActions_relationInput>
  }

  export type CreatureRaceUpdateManyWithWhereWithoutActions_relationInput = {
    where: CreatureRaceScalarWhereInput
    data: XOR<CreatureRaceUpdateManyMutationInput, CreatureRaceUncheckedUpdateManyWithoutActions_relationInput>
  }

  export type CreatureRaceScalarWhereInput = {
    AND?: CreatureRaceScalarWhereInput | CreatureRaceScalarWhereInput[]
    OR?: CreatureRaceScalarWhereInput[]
    NOT?: CreatureRaceScalarWhereInput | CreatureRaceScalarWhereInput[]
    id?: IntFilter<"CreatureRace"> | number
    name?: StringFilter<"CreatureRace"> | string
    description?: StringFilter<"CreatureRace"> | string
  }

  export type CreatureCreateWithoutTraits_relationInput = {
    id?: string
    name: string
    creator_id?: string | null
    description?: string | null
    armor_class?: number | null
    hit_points?: number | null
    speed?: CreatureSpeedCreateNestedOneWithoutCreature_relationInput
    stats?: CreatureStatsCreateNestedOneWithoutCreature_relationInput
    skills?: CreatureSkillsCreateNestedOneWithoutCreature_relationInput
    senses?: CreatureSensesCreateNestedOneWithoutCreature_relationInput
    challenge_rating_meta: ChallengeRatingMetadataCreateNestedOneWithoutCreaturesInput
    alignment_relation?: AlignmentCreateNestedOneWithoutCreaturesInput
    race_relation?: CreatureRaceCreateNestedOneWithoutCreatures_relationInput
    type_relation?: TypeCreateNestedOneWithoutCreaturesInput
    size_relation?: SizeCreateNestedOneWithoutCreatureInput
    source_relation?: SourceCreateNestedOneWithoutCreaturesInput
    resistances?: DamageTypeCreateNestedManyWithoutResistant_creatures_relationInput
    immunities?: DamageTypeCreateNestedManyWithoutImmune_creatures_relationInput
    vulnerabilities?: DamageTypeCreateNestedManyWithoutVulnerable_creatures_relationInput
    languages_relation?: LanguageCreateNestedManyWithoutCreatures_relationInput
    biomes_relation?: BiomeCreateNestedManyWithoutCreatures_relationInput
    actions_relation?: ActionCreateNestedManyWithoutCreatures_relationInput
  }

  export type CreatureUncheckedCreateWithoutTraits_relationInput = {
    id?: string
    name: string
    creator_id?: string | null
    description?: string | null
    size?: string | null
    race_id?: number | null
    type_id?: number | null
    source_id?: number | null
    alignment_id?: number | null
    armor_class?: number | null
    hit_points?: number | null
    challenge_rating: string
    speed?: CreatureSpeedUncheckedCreateNestedOneWithoutCreature_relationInput
    stats?: CreatureStatsUncheckedCreateNestedOneWithoutCreature_relationInput
    skills?: CreatureSkillsUncheckedCreateNestedOneWithoutCreature_relationInput
    senses?: CreatureSensesUncheckedCreateNestedOneWithoutCreature_relationInput
    resistances?: DamageTypeUncheckedCreateNestedManyWithoutResistant_creatures_relationInput
    immunities?: DamageTypeUncheckedCreateNestedManyWithoutImmune_creatures_relationInput
    vulnerabilities?: DamageTypeUncheckedCreateNestedManyWithoutVulnerable_creatures_relationInput
    languages_relation?: LanguageUncheckedCreateNestedManyWithoutCreatures_relationInput
    biomes_relation?: BiomeUncheckedCreateNestedManyWithoutCreatures_relationInput
    actions_relation?: ActionUncheckedCreateNestedManyWithoutCreatures_relationInput
  }

  export type CreatureCreateOrConnectWithoutTraits_relationInput = {
    where: CreatureWhereUniqueInput
    create: XOR<CreatureCreateWithoutTraits_relationInput, CreatureUncheckedCreateWithoutTraits_relationInput>
  }

  export type CreatureRaceCreateWithoutTraits_relationInput = {
    name: string
    description: string
    actions_relation?: ActionCreateNestedManyWithoutCreature_races_relationInput
    creatures_relation?: CreatureCreateNestedManyWithoutRace_relationInput
  }

  export type CreatureRaceUncheckedCreateWithoutTraits_relationInput = {
    id?: number
    name: string
    description: string
    actions_relation?: ActionUncheckedCreateNestedManyWithoutCreature_races_relationInput
    creatures_relation?: CreatureUncheckedCreateNestedManyWithoutRace_relationInput
  }

  export type CreatureRaceCreateOrConnectWithoutTraits_relationInput = {
    where: CreatureRaceWhereUniqueInput
    create: XOR<CreatureRaceCreateWithoutTraits_relationInput, CreatureRaceUncheckedCreateWithoutTraits_relationInput>
  }

  export type CreatureUpsertWithWhereUniqueWithoutTraits_relationInput = {
    where: CreatureWhereUniqueInput
    update: XOR<CreatureUpdateWithoutTraits_relationInput, CreatureUncheckedUpdateWithoutTraits_relationInput>
    create: XOR<CreatureCreateWithoutTraits_relationInput, CreatureUncheckedCreateWithoutTraits_relationInput>
  }

  export type CreatureUpdateWithWhereUniqueWithoutTraits_relationInput = {
    where: CreatureWhereUniqueInput
    data: XOR<CreatureUpdateWithoutTraits_relationInput, CreatureUncheckedUpdateWithoutTraits_relationInput>
  }

  export type CreatureUpdateManyWithWhereWithoutTraits_relationInput = {
    where: CreatureScalarWhereInput
    data: XOR<CreatureUpdateManyMutationInput, CreatureUncheckedUpdateManyWithoutTraits_relationInput>
  }

  export type CreatureRaceUpsertWithWhereUniqueWithoutTraits_relationInput = {
    where: CreatureRaceWhereUniqueInput
    update: XOR<CreatureRaceUpdateWithoutTraits_relationInput, CreatureRaceUncheckedUpdateWithoutTraits_relationInput>
    create: XOR<CreatureRaceCreateWithoutTraits_relationInput, CreatureRaceUncheckedCreateWithoutTraits_relationInput>
  }

  export type CreatureRaceUpdateWithWhereUniqueWithoutTraits_relationInput = {
    where: CreatureRaceWhereUniqueInput
    data: XOR<CreatureRaceUpdateWithoutTraits_relationInput, CreatureRaceUncheckedUpdateWithoutTraits_relationInput>
  }

  export type CreatureRaceUpdateManyWithWhereWithoutTraits_relationInput = {
    where: CreatureRaceScalarWhereInput
    data: XOR<CreatureRaceUpdateManyMutationInput, CreatureRaceUncheckedUpdateManyWithoutTraits_relationInput>
  }

  export type TraitCreateWithoutCreature_races_relationInput = {
    name: string
    description: string
    attack?: string | null
    is_template?: boolean | null
    creatures_relation?: CreatureCreateNestedManyWithoutTraits_relationInput
  }

  export type TraitUncheckedCreateWithoutCreature_races_relationInput = {
    id?: number
    name: string
    description: string
    attack?: string | null
    is_template?: boolean | null
    creatures_relation?: CreatureUncheckedCreateNestedManyWithoutTraits_relationInput
  }

  export type TraitCreateOrConnectWithoutCreature_races_relationInput = {
    where: TraitWhereUniqueInput
    create: XOR<TraitCreateWithoutCreature_races_relationInput, TraitUncheckedCreateWithoutCreature_races_relationInput>
  }

  export type ActionCreateWithoutCreature_races_relationInput = {
    name: string
    description: string
    attack?: string | null
    is_template?: boolean | null
    creatures_relation?: CreatureCreateNestedManyWithoutActions_relationInput
  }

  export type ActionUncheckedCreateWithoutCreature_races_relationInput = {
    id?: number
    name: string
    description: string
    attack?: string | null
    is_template?: boolean | null
    creatures_relation?: CreatureUncheckedCreateNestedManyWithoutActions_relationInput
  }

  export type ActionCreateOrConnectWithoutCreature_races_relationInput = {
    where: ActionWhereUniqueInput
    create: XOR<ActionCreateWithoutCreature_races_relationInput, ActionUncheckedCreateWithoutCreature_races_relationInput>
  }

  export type CreatureCreateWithoutRace_relationInput = {
    id?: string
    name: string
    creator_id?: string | null
    description?: string | null
    armor_class?: number | null
    hit_points?: number | null
    speed?: CreatureSpeedCreateNestedOneWithoutCreature_relationInput
    stats?: CreatureStatsCreateNestedOneWithoutCreature_relationInput
    skills?: CreatureSkillsCreateNestedOneWithoutCreature_relationInput
    senses?: CreatureSensesCreateNestedOneWithoutCreature_relationInput
    challenge_rating_meta: ChallengeRatingMetadataCreateNestedOneWithoutCreaturesInput
    alignment_relation?: AlignmentCreateNestedOneWithoutCreaturesInput
    type_relation?: TypeCreateNestedOneWithoutCreaturesInput
    size_relation?: SizeCreateNestedOneWithoutCreatureInput
    source_relation?: SourceCreateNestedOneWithoutCreaturesInput
    resistances?: DamageTypeCreateNestedManyWithoutResistant_creatures_relationInput
    immunities?: DamageTypeCreateNestedManyWithoutImmune_creatures_relationInput
    vulnerabilities?: DamageTypeCreateNestedManyWithoutVulnerable_creatures_relationInput
    languages_relation?: LanguageCreateNestedManyWithoutCreatures_relationInput
    biomes_relation?: BiomeCreateNestedManyWithoutCreatures_relationInput
    actions_relation?: ActionCreateNestedManyWithoutCreatures_relationInput
    traits_relation?: TraitCreateNestedManyWithoutCreatures_relationInput
  }

  export type CreatureUncheckedCreateWithoutRace_relationInput = {
    id?: string
    name: string
    creator_id?: string | null
    description?: string | null
    size?: string | null
    type_id?: number | null
    source_id?: number | null
    alignment_id?: number | null
    armor_class?: number | null
    hit_points?: number | null
    challenge_rating: string
    speed?: CreatureSpeedUncheckedCreateNestedOneWithoutCreature_relationInput
    stats?: CreatureStatsUncheckedCreateNestedOneWithoutCreature_relationInput
    skills?: CreatureSkillsUncheckedCreateNestedOneWithoutCreature_relationInput
    senses?: CreatureSensesUncheckedCreateNestedOneWithoutCreature_relationInput
    resistances?: DamageTypeUncheckedCreateNestedManyWithoutResistant_creatures_relationInput
    immunities?: DamageTypeUncheckedCreateNestedManyWithoutImmune_creatures_relationInput
    vulnerabilities?: DamageTypeUncheckedCreateNestedManyWithoutVulnerable_creatures_relationInput
    languages_relation?: LanguageUncheckedCreateNestedManyWithoutCreatures_relationInput
    biomes_relation?: BiomeUncheckedCreateNestedManyWithoutCreatures_relationInput
    actions_relation?: ActionUncheckedCreateNestedManyWithoutCreatures_relationInput
    traits_relation?: TraitUncheckedCreateNestedManyWithoutCreatures_relationInput
  }

  export type CreatureCreateOrConnectWithoutRace_relationInput = {
    where: CreatureWhereUniqueInput
    create: XOR<CreatureCreateWithoutRace_relationInput, CreatureUncheckedCreateWithoutRace_relationInput>
  }

  export type CreatureCreateManyRace_relationInputEnvelope = {
    data: CreatureCreateManyRace_relationInput | CreatureCreateManyRace_relationInput[]
    skipDuplicates?: boolean
  }

  export type TraitUpsertWithWhereUniqueWithoutCreature_races_relationInput = {
    where: TraitWhereUniqueInput
    update: XOR<TraitUpdateWithoutCreature_races_relationInput, TraitUncheckedUpdateWithoutCreature_races_relationInput>
    create: XOR<TraitCreateWithoutCreature_races_relationInput, TraitUncheckedCreateWithoutCreature_races_relationInput>
  }

  export type TraitUpdateWithWhereUniqueWithoutCreature_races_relationInput = {
    where: TraitWhereUniqueInput
    data: XOR<TraitUpdateWithoutCreature_races_relationInput, TraitUncheckedUpdateWithoutCreature_races_relationInput>
  }

  export type TraitUpdateManyWithWhereWithoutCreature_races_relationInput = {
    where: TraitScalarWhereInput
    data: XOR<TraitUpdateManyMutationInput, TraitUncheckedUpdateManyWithoutCreature_races_relationInput>
  }

  export type ActionUpsertWithWhereUniqueWithoutCreature_races_relationInput = {
    where: ActionWhereUniqueInput
    update: XOR<ActionUpdateWithoutCreature_races_relationInput, ActionUncheckedUpdateWithoutCreature_races_relationInput>
    create: XOR<ActionCreateWithoutCreature_races_relationInput, ActionUncheckedCreateWithoutCreature_races_relationInput>
  }

  export type ActionUpdateWithWhereUniqueWithoutCreature_races_relationInput = {
    where: ActionWhereUniqueInput
    data: XOR<ActionUpdateWithoutCreature_races_relationInput, ActionUncheckedUpdateWithoutCreature_races_relationInput>
  }

  export type ActionUpdateManyWithWhereWithoutCreature_races_relationInput = {
    where: ActionScalarWhereInput
    data: XOR<ActionUpdateManyMutationInput, ActionUncheckedUpdateManyWithoutCreature_races_relationInput>
  }

  export type CreatureUpsertWithWhereUniqueWithoutRace_relationInput = {
    where: CreatureWhereUniqueInput
    update: XOR<CreatureUpdateWithoutRace_relationInput, CreatureUncheckedUpdateWithoutRace_relationInput>
    create: XOR<CreatureCreateWithoutRace_relationInput, CreatureUncheckedCreateWithoutRace_relationInput>
  }

  export type CreatureUpdateWithWhereUniqueWithoutRace_relationInput = {
    where: CreatureWhereUniqueInput
    data: XOR<CreatureUpdateWithoutRace_relationInput, CreatureUncheckedUpdateWithoutRace_relationInput>
  }

  export type CreatureUpdateManyWithWhereWithoutRace_relationInput = {
    where: CreatureScalarWhereInput
    data: XOR<CreatureUpdateManyMutationInput, CreatureUncheckedUpdateManyWithoutRace_relationInput>
  }

  export type CreatureCreateWithoutResistancesInput = {
    id?: string
    name: string
    creator_id?: string | null
    description?: string | null
    armor_class?: number | null
    hit_points?: number | null
    speed?: CreatureSpeedCreateNestedOneWithoutCreature_relationInput
    stats?: CreatureStatsCreateNestedOneWithoutCreature_relationInput
    skills?: CreatureSkillsCreateNestedOneWithoutCreature_relationInput
    senses?: CreatureSensesCreateNestedOneWithoutCreature_relationInput
    challenge_rating_meta: ChallengeRatingMetadataCreateNestedOneWithoutCreaturesInput
    alignment_relation?: AlignmentCreateNestedOneWithoutCreaturesInput
    race_relation?: CreatureRaceCreateNestedOneWithoutCreatures_relationInput
    type_relation?: TypeCreateNestedOneWithoutCreaturesInput
    size_relation?: SizeCreateNestedOneWithoutCreatureInput
    source_relation?: SourceCreateNestedOneWithoutCreaturesInput
    immunities?: DamageTypeCreateNestedManyWithoutImmune_creatures_relationInput
    vulnerabilities?: DamageTypeCreateNestedManyWithoutVulnerable_creatures_relationInput
    languages_relation?: LanguageCreateNestedManyWithoutCreatures_relationInput
    biomes_relation?: BiomeCreateNestedManyWithoutCreatures_relationInput
    actions_relation?: ActionCreateNestedManyWithoutCreatures_relationInput
    traits_relation?: TraitCreateNestedManyWithoutCreatures_relationInput
  }

  export type CreatureUncheckedCreateWithoutResistancesInput = {
    id?: string
    name: string
    creator_id?: string | null
    description?: string | null
    size?: string | null
    race_id?: number | null
    type_id?: number | null
    source_id?: number | null
    alignment_id?: number | null
    armor_class?: number | null
    hit_points?: number | null
    challenge_rating: string
    speed?: CreatureSpeedUncheckedCreateNestedOneWithoutCreature_relationInput
    stats?: CreatureStatsUncheckedCreateNestedOneWithoutCreature_relationInput
    skills?: CreatureSkillsUncheckedCreateNestedOneWithoutCreature_relationInput
    senses?: CreatureSensesUncheckedCreateNestedOneWithoutCreature_relationInput
    immunities?: DamageTypeUncheckedCreateNestedManyWithoutImmune_creatures_relationInput
    vulnerabilities?: DamageTypeUncheckedCreateNestedManyWithoutVulnerable_creatures_relationInput
    languages_relation?: LanguageUncheckedCreateNestedManyWithoutCreatures_relationInput
    biomes_relation?: BiomeUncheckedCreateNestedManyWithoutCreatures_relationInput
    actions_relation?: ActionUncheckedCreateNestedManyWithoutCreatures_relationInput
    traits_relation?: TraitUncheckedCreateNestedManyWithoutCreatures_relationInput
  }

  export type CreatureCreateOrConnectWithoutResistancesInput = {
    where: CreatureWhereUniqueInput
    create: XOR<CreatureCreateWithoutResistancesInput, CreatureUncheckedCreateWithoutResistancesInput>
  }

  export type CreatureCreateWithoutImmunitiesInput = {
    id?: string
    name: string
    creator_id?: string | null
    description?: string | null
    armor_class?: number | null
    hit_points?: number | null
    speed?: CreatureSpeedCreateNestedOneWithoutCreature_relationInput
    stats?: CreatureStatsCreateNestedOneWithoutCreature_relationInput
    skills?: CreatureSkillsCreateNestedOneWithoutCreature_relationInput
    senses?: CreatureSensesCreateNestedOneWithoutCreature_relationInput
    challenge_rating_meta: ChallengeRatingMetadataCreateNestedOneWithoutCreaturesInput
    alignment_relation?: AlignmentCreateNestedOneWithoutCreaturesInput
    race_relation?: CreatureRaceCreateNestedOneWithoutCreatures_relationInput
    type_relation?: TypeCreateNestedOneWithoutCreaturesInput
    size_relation?: SizeCreateNestedOneWithoutCreatureInput
    source_relation?: SourceCreateNestedOneWithoutCreaturesInput
    resistances?: DamageTypeCreateNestedManyWithoutResistant_creatures_relationInput
    vulnerabilities?: DamageTypeCreateNestedManyWithoutVulnerable_creatures_relationInput
    languages_relation?: LanguageCreateNestedManyWithoutCreatures_relationInput
    biomes_relation?: BiomeCreateNestedManyWithoutCreatures_relationInput
    actions_relation?: ActionCreateNestedManyWithoutCreatures_relationInput
    traits_relation?: TraitCreateNestedManyWithoutCreatures_relationInput
  }

  export type CreatureUncheckedCreateWithoutImmunitiesInput = {
    id?: string
    name: string
    creator_id?: string | null
    description?: string | null
    size?: string | null
    race_id?: number | null
    type_id?: number | null
    source_id?: number | null
    alignment_id?: number | null
    armor_class?: number | null
    hit_points?: number | null
    challenge_rating: string
    speed?: CreatureSpeedUncheckedCreateNestedOneWithoutCreature_relationInput
    stats?: CreatureStatsUncheckedCreateNestedOneWithoutCreature_relationInput
    skills?: CreatureSkillsUncheckedCreateNestedOneWithoutCreature_relationInput
    senses?: CreatureSensesUncheckedCreateNestedOneWithoutCreature_relationInput
    resistances?: DamageTypeUncheckedCreateNestedManyWithoutResistant_creatures_relationInput
    vulnerabilities?: DamageTypeUncheckedCreateNestedManyWithoutVulnerable_creatures_relationInput
    languages_relation?: LanguageUncheckedCreateNestedManyWithoutCreatures_relationInput
    biomes_relation?: BiomeUncheckedCreateNestedManyWithoutCreatures_relationInput
    actions_relation?: ActionUncheckedCreateNestedManyWithoutCreatures_relationInput
    traits_relation?: TraitUncheckedCreateNestedManyWithoutCreatures_relationInput
  }

  export type CreatureCreateOrConnectWithoutImmunitiesInput = {
    where: CreatureWhereUniqueInput
    create: XOR<CreatureCreateWithoutImmunitiesInput, CreatureUncheckedCreateWithoutImmunitiesInput>
  }

  export type CreatureCreateWithoutVulnerabilitiesInput = {
    id?: string
    name: string
    creator_id?: string | null
    description?: string | null
    armor_class?: number | null
    hit_points?: number | null
    speed?: CreatureSpeedCreateNestedOneWithoutCreature_relationInput
    stats?: CreatureStatsCreateNestedOneWithoutCreature_relationInput
    skills?: CreatureSkillsCreateNestedOneWithoutCreature_relationInput
    senses?: CreatureSensesCreateNestedOneWithoutCreature_relationInput
    challenge_rating_meta: ChallengeRatingMetadataCreateNestedOneWithoutCreaturesInput
    alignment_relation?: AlignmentCreateNestedOneWithoutCreaturesInput
    race_relation?: CreatureRaceCreateNestedOneWithoutCreatures_relationInput
    type_relation?: TypeCreateNestedOneWithoutCreaturesInput
    size_relation?: SizeCreateNestedOneWithoutCreatureInput
    source_relation?: SourceCreateNestedOneWithoutCreaturesInput
    resistances?: DamageTypeCreateNestedManyWithoutResistant_creatures_relationInput
    immunities?: DamageTypeCreateNestedManyWithoutImmune_creatures_relationInput
    languages_relation?: LanguageCreateNestedManyWithoutCreatures_relationInput
    biomes_relation?: BiomeCreateNestedManyWithoutCreatures_relationInput
    actions_relation?: ActionCreateNestedManyWithoutCreatures_relationInput
    traits_relation?: TraitCreateNestedManyWithoutCreatures_relationInput
  }

  export type CreatureUncheckedCreateWithoutVulnerabilitiesInput = {
    id?: string
    name: string
    creator_id?: string | null
    description?: string | null
    size?: string | null
    race_id?: number | null
    type_id?: number | null
    source_id?: number | null
    alignment_id?: number | null
    armor_class?: number | null
    hit_points?: number | null
    challenge_rating: string
    speed?: CreatureSpeedUncheckedCreateNestedOneWithoutCreature_relationInput
    stats?: CreatureStatsUncheckedCreateNestedOneWithoutCreature_relationInput
    skills?: CreatureSkillsUncheckedCreateNestedOneWithoutCreature_relationInput
    senses?: CreatureSensesUncheckedCreateNestedOneWithoutCreature_relationInput
    resistances?: DamageTypeUncheckedCreateNestedManyWithoutResistant_creatures_relationInput
    immunities?: DamageTypeUncheckedCreateNestedManyWithoutImmune_creatures_relationInput
    languages_relation?: LanguageUncheckedCreateNestedManyWithoutCreatures_relationInput
    biomes_relation?: BiomeUncheckedCreateNestedManyWithoutCreatures_relationInput
    actions_relation?: ActionUncheckedCreateNestedManyWithoutCreatures_relationInput
    traits_relation?: TraitUncheckedCreateNestedManyWithoutCreatures_relationInput
  }

  export type CreatureCreateOrConnectWithoutVulnerabilitiesInput = {
    where: CreatureWhereUniqueInput
    create: XOR<CreatureCreateWithoutVulnerabilitiesInput, CreatureUncheckedCreateWithoutVulnerabilitiesInput>
  }

  export type CreatureUpsertWithWhereUniqueWithoutResistancesInput = {
    where: CreatureWhereUniqueInput
    update: XOR<CreatureUpdateWithoutResistancesInput, CreatureUncheckedUpdateWithoutResistancesInput>
    create: XOR<CreatureCreateWithoutResistancesInput, CreatureUncheckedCreateWithoutResistancesInput>
  }

  export type CreatureUpdateWithWhereUniqueWithoutResistancesInput = {
    where: CreatureWhereUniqueInput
    data: XOR<CreatureUpdateWithoutResistancesInput, CreatureUncheckedUpdateWithoutResistancesInput>
  }

  export type CreatureUpdateManyWithWhereWithoutResistancesInput = {
    where: CreatureScalarWhereInput
    data: XOR<CreatureUpdateManyMutationInput, CreatureUncheckedUpdateManyWithoutResistancesInput>
  }

  export type CreatureUpsertWithWhereUniqueWithoutImmunitiesInput = {
    where: CreatureWhereUniqueInput
    update: XOR<CreatureUpdateWithoutImmunitiesInput, CreatureUncheckedUpdateWithoutImmunitiesInput>
    create: XOR<CreatureCreateWithoutImmunitiesInput, CreatureUncheckedCreateWithoutImmunitiesInput>
  }

  export type CreatureUpdateWithWhereUniqueWithoutImmunitiesInput = {
    where: CreatureWhereUniqueInput
    data: XOR<CreatureUpdateWithoutImmunitiesInput, CreatureUncheckedUpdateWithoutImmunitiesInput>
  }

  export type CreatureUpdateManyWithWhereWithoutImmunitiesInput = {
    where: CreatureScalarWhereInput
    data: XOR<CreatureUpdateManyMutationInput, CreatureUncheckedUpdateManyWithoutImmunitiesInput>
  }

  export type CreatureUpsertWithWhereUniqueWithoutVulnerabilitiesInput = {
    where: CreatureWhereUniqueInput
    update: XOR<CreatureUpdateWithoutVulnerabilitiesInput, CreatureUncheckedUpdateWithoutVulnerabilitiesInput>
    create: XOR<CreatureCreateWithoutVulnerabilitiesInput, CreatureUncheckedCreateWithoutVulnerabilitiesInput>
  }

  export type CreatureUpdateWithWhereUniqueWithoutVulnerabilitiesInput = {
    where: CreatureWhereUniqueInput
    data: XOR<CreatureUpdateWithoutVulnerabilitiesInput, CreatureUncheckedUpdateWithoutVulnerabilitiesInput>
  }

  export type CreatureUpdateManyWithWhereWithoutVulnerabilitiesInput = {
    where: CreatureScalarWhereInput
    data: XOR<CreatureUpdateManyMutationInput, CreatureUncheckedUpdateManyWithoutVulnerabilitiesInput>
  }

  export type CreatureCreateWithoutChallenge_rating_metaInput = {
    id?: string
    name: string
    creator_id?: string | null
    description?: string | null
    armor_class?: number | null
    hit_points?: number | null
    speed?: CreatureSpeedCreateNestedOneWithoutCreature_relationInput
    stats?: CreatureStatsCreateNestedOneWithoutCreature_relationInput
    skills?: CreatureSkillsCreateNestedOneWithoutCreature_relationInput
    senses?: CreatureSensesCreateNestedOneWithoutCreature_relationInput
    alignment_relation?: AlignmentCreateNestedOneWithoutCreaturesInput
    race_relation?: CreatureRaceCreateNestedOneWithoutCreatures_relationInput
    type_relation?: TypeCreateNestedOneWithoutCreaturesInput
    size_relation?: SizeCreateNestedOneWithoutCreatureInput
    source_relation?: SourceCreateNestedOneWithoutCreaturesInput
    resistances?: DamageTypeCreateNestedManyWithoutResistant_creatures_relationInput
    immunities?: DamageTypeCreateNestedManyWithoutImmune_creatures_relationInput
    vulnerabilities?: DamageTypeCreateNestedManyWithoutVulnerable_creatures_relationInput
    languages_relation?: LanguageCreateNestedManyWithoutCreatures_relationInput
    biomes_relation?: BiomeCreateNestedManyWithoutCreatures_relationInput
    actions_relation?: ActionCreateNestedManyWithoutCreatures_relationInput
    traits_relation?: TraitCreateNestedManyWithoutCreatures_relationInput
  }

  export type CreatureUncheckedCreateWithoutChallenge_rating_metaInput = {
    id?: string
    name: string
    creator_id?: string | null
    description?: string | null
    size?: string | null
    race_id?: number | null
    type_id?: number | null
    source_id?: number | null
    alignment_id?: number | null
    armor_class?: number | null
    hit_points?: number | null
    speed?: CreatureSpeedUncheckedCreateNestedOneWithoutCreature_relationInput
    stats?: CreatureStatsUncheckedCreateNestedOneWithoutCreature_relationInput
    skills?: CreatureSkillsUncheckedCreateNestedOneWithoutCreature_relationInput
    senses?: CreatureSensesUncheckedCreateNestedOneWithoutCreature_relationInput
    resistances?: DamageTypeUncheckedCreateNestedManyWithoutResistant_creatures_relationInput
    immunities?: DamageTypeUncheckedCreateNestedManyWithoutImmune_creatures_relationInput
    vulnerabilities?: DamageTypeUncheckedCreateNestedManyWithoutVulnerable_creatures_relationInput
    languages_relation?: LanguageUncheckedCreateNestedManyWithoutCreatures_relationInput
    biomes_relation?: BiomeUncheckedCreateNestedManyWithoutCreatures_relationInput
    actions_relation?: ActionUncheckedCreateNestedManyWithoutCreatures_relationInput
    traits_relation?: TraitUncheckedCreateNestedManyWithoutCreatures_relationInput
  }

  export type CreatureCreateOrConnectWithoutChallenge_rating_metaInput = {
    where: CreatureWhereUniqueInput
    create: XOR<CreatureCreateWithoutChallenge_rating_metaInput, CreatureUncheckedCreateWithoutChallenge_rating_metaInput>
  }

  export type CreatureCreateManyChallenge_rating_metaInputEnvelope = {
    data: CreatureCreateManyChallenge_rating_metaInput | CreatureCreateManyChallenge_rating_metaInput[]
    skipDuplicates?: boolean
  }

  export type CreatureUpsertWithWhereUniqueWithoutChallenge_rating_metaInput = {
    where: CreatureWhereUniqueInput
    update: XOR<CreatureUpdateWithoutChallenge_rating_metaInput, CreatureUncheckedUpdateWithoutChallenge_rating_metaInput>
    create: XOR<CreatureCreateWithoutChallenge_rating_metaInput, CreatureUncheckedCreateWithoutChallenge_rating_metaInput>
  }

  export type CreatureUpdateWithWhereUniqueWithoutChallenge_rating_metaInput = {
    where: CreatureWhereUniqueInput
    data: XOR<CreatureUpdateWithoutChallenge_rating_metaInput, CreatureUncheckedUpdateWithoutChallenge_rating_metaInput>
  }

  export type CreatureUpdateManyWithWhereWithoutChallenge_rating_metaInput = {
    where: CreatureScalarWhereInput
    data: XOR<CreatureUpdateManyMutationInput, CreatureUncheckedUpdateManyWithoutChallenge_rating_metaInput>
  }

  export type GPTMessageCreateWithoutMessage_history_relationInput = {
    number: number
    text: string
    role: string
  }

  export type GPTMessageUncheckedCreateWithoutMessage_history_relationInput = {
    number: number
    text: string
    role: string
  }

  export type GPTMessageCreateOrConnectWithoutMessage_history_relationInput = {
    where: GPTMessageWhereUniqueInput
    create: XOR<GPTMessageCreateWithoutMessage_history_relationInput, GPTMessageUncheckedCreateWithoutMessage_history_relationInput>
  }

  export type GPTMessageCreateManyMessage_history_relationInputEnvelope = {
    data: GPTMessageCreateManyMessage_history_relationInput | GPTMessageCreateManyMessage_history_relationInput[]
    skipDuplicates?: boolean
  }

  export type GPTMessageUpsertWithWhereUniqueWithoutMessage_history_relationInput = {
    where: GPTMessageWhereUniqueInput
    update: XOR<GPTMessageUpdateWithoutMessage_history_relationInput, GPTMessageUncheckedUpdateWithoutMessage_history_relationInput>
    create: XOR<GPTMessageCreateWithoutMessage_history_relationInput, GPTMessageUncheckedCreateWithoutMessage_history_relationInput>
  }

  export type GPTMessageUpdateWithWhereUniqueWithoutMessage_history_relationInput = {
    where: GPTMessageWhereUniqueInput
    data: XOR<GPTMessageUpdateWithoutMessage_history_relationInput, GPTMessageUncheckedUpdateWithoutMessage_history_relationInput>
  }

  export type GPTMessageUpdateManyWithWhereWithoutMessage_history_relationInput = {
    where: GPTMessageScalarWhereInput
    data: XOR<GPTMessageUpdateManyMutationInput, GPTMessageUncheckedUpdateManyWithoutMessage_history_relationInput>
  }

  export type GPTMessageScalarWhereInput = {
    AND?: GPTMessageScalarWhereInput | GPTMessageScalarWhereInput[]
    OR?: GPTMessageScalarWhereInput[]
    NOT?: GPTMessageScalarWhereInput | GPTMessageScalarWhereInput[]
    message_history_id?: StringFilter<"GPTMessage"> | string
    number?: IntFilter<"GPTMessage"> | number
    text?: StringFilter<"GPTMessage"> | string
    role?: StringFilter<"GPTMessage"> | string
  }

  export type GPTMessageHistoryCreateWithoutMessages_relationInput = {
    id?: string
    type: string
  }

  export type GPTMessageHistoryUncheckedCreateWithoutMessages_relationInput = {
    id?: string
    type: string
  }

  export type GPTMessageHistoryCreateOrConnectWithoutMessages_relationInput = {
    where: GPTMessageHistoryWhereUniqueInput
    create: XOR<GPTMessageHistoryCreateWithoutMessages_relationInput, GPTMessageHistoryUncheckedCreateWithoutMessages_relationInput>
  }

  export type GPTMessageHistoryUpsertWithoutMessages_relationInput = {
    update: XOR<GPTMessageHistoryUpdateWithoutMessages_relationInput, GPTMessageHistoryUncheckedUpdateWithoutMessages_relationInput>
    create: XOR<GPTMessageHistoryCreateWithoutMessages_relationInput, GPTMessageHistoryUncheckedCreateWithoutMessages_relationInput>
    where?: GPTMessageHistoryWhereInput
  }

  export type GPTMessageHistoryUpdateToOneWithWhereWithoutMessages_relationInput = {
    where?: GPTMessageHistoryWhereInput
    data: XOR<GPTMessageHistoryUpdateWithoutMessages_relationInput, GPTMessageHistoryUncheckedUpdateWithoutMessages_relationInput>
  }

  export type GPTMessageHistoryUpdateWithoutMessages_relationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
  }

  export type GPTMessageHistoryUncheckedUpdateWithoutMessages_relationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
  }

  export type GenreCreateWithoutAdventures_relationInput = {
    id?: string
    name: string
    keywords_relation?: KeywordCreateNestedManyWithoutGenre_relationInput
  }

  export type GenreUncheckedCreateWithoutAdventures_relationInput = {
    id?: string
    name: string
    keywords_relation?: KeywordUncheckedCreateNestedManyWithoutGenre_relationInput
  }

  export type GenreCreateOrConnectWithoutAdventures_relationInput = {
    where: GenreWhereUniqueInput
    create: XOR<GenreCreateWithoutAdventures_relationInput, GenreUncheckedCreateWithoutAdventures_relationInput>
  }

  export type KeywordCreateWithoutAdventures_relationInput = {
    id?: string
    name: string
    genre_relation: GenreCreateNestedOneWithoutKeywords_relationInput
  }

  export type KeywordUncheckedCreateWithoutAdventures_relationInput = {
    id?: string
    name: string
    genre_id: string
  }

  export type KeywordCreateOrConnectWithoutAdventures_relationInput = {
    where: KeywordWhereUniqueInput
    create: XOR<KeywordCreateWithoutAdventures_relationInput, KeywordUncheckedCreateWithoutAdventures_relationInput>
  }

  export type GenreUpsertWithoutAdventures_relationInput = {
    update: XOR<GenreUpdateWithoutAdventures_relationInput, GenreUncheckedUpdateWithoutAdventures_relationInput>
    create: XOR<GenreCreateWithoutAdventures_relationInput, GenreUncheckedCreateWithoutAdventures_relationInput>
    where?: GenreWhereInput
  }

  export type GenreUpdateToOneWithWhereWithoutAdventures_relationInput = {
    where?: GenreWhereInput
    data: XOR<GenreUpdateWithoutAdventures_relationInput, GenreUncheckedUpdateWithoutAdventures_relationInput>
  }

  export type GenreUpdateWithoutAdventures_relationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    keywords_relation?: KeywordUpdateManyWithoutGenre_relationNestedInput
  }

  export type GenreUncheckedUpdateWithoutAdventures_relationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    keywords_relation?: KeywordUncheckedUpdateManyWithoutGenre_relationNestedInput
  }

  export type KeywordUpsertWithWhereUniqueWithoutAdventures_relationInput = {
    where: KeywordWhereUniqueInput
    update: XOR<KeywordUpdateWithoutAdventures_relationInput, KeywordUncheckedUpdateWithoutAdventures_relationInput>
    create: XOR<KeywordCreateWithoutAdventures_relationInput, KeywordUncheckedCreateWithoutAdventures_relationInput>
  }

  export type KeywordUpdateWithWhereUniqueWithoutAdventures_relationInput = {
    where: KeywordWhereUniqueInput
    data: XOR<KeywordUpdateWithoutAdventures_relationInput, KeywordUncheckedUpdateWithoutAdventures_relationInput>
  }

  export type KeywordUpdateManyWithWhereWithoutAdventures_relationInput = {
    where: KeywordScalarWhereInput
    data: XOR<KeywordUpdateManyMutationInput, KeywordUncheckedUpdateManyWithoutAdventures_relationInput>
  }

  export type KeywordScalarWhereInput = {
    AND?: KeywordScalarWhereInput | KeywordScalarWhereInput[]
    OR?: KeywordScalarWhereInput[]
    NOT?: KeywordScalarWhereInput | KeywordScalarWhereInput[]
    id?: StringFilter<"Keyword"> | string
    name?: StringFilter<"Keyword"> | string
    genre_id?: StringFilter<"Keyword"> | string
  }

  export type GenreCreateWithoutKeywords_relationInput = {
    id?: string
    name: string
    adventures_relation?: AdventureCreateNestedManyWithoutGenre_relationInput
  }

  export type GenreUncheckedCreateWithoutKeywords_relationInput = {
    id?: string
    name: string
    adventures_relation?: AdventureUncheckedCreateNestedManyWithoutGenre_relationInput
  }

  export type GenreCreateOrConnectWithoutKeywords_relationInput = {
    where: GenreWhereUniqueInput
    create: XOR<GenreCreateWithoutKeywords_relationInput, GenreUncheckedCreateWithoutKeywords_relationInput>
  }

  export type AdventureCreateWithoutKeywords_relationInput = {
    id?: string
    name: string
    creator_id: string
    created_at?: Date | string
    updated_at?: Date | string
    genre_relation: GenreCreateNestedOneWithoutAdventures_relationInput
  }

  export type AdventureUncheckedCreateWithoutKeywords_relationInput = {
    id?: string
    name: string
    genre_id: string
    creator_id: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type AdventureCreateOrConnectWithoutKeywords_relationInput = {
    where: AdventureWhereUniqueInput
    create: XOR<AdventureCreateWithoutKeywords_relationInput, AdventureUncheckedCreateWithoutKeywords_relationInput>
  }

  export type GenreUpsertWithoutKeywords_relationInput = {
    update: XOR<GenreUpdateWithoutKeywords_relationInput, GenreUncheckedUpdateWithoutKeywords_relationInput>
    create: XOR<GenreCreateWithoutKeywords_relationInput, GenreUncheckedCreateWithoutKeywords_relationInput>
    where?: GenreWhereInput
  }

  export type GenreUpdateToOneWithWhereWithoutKeywords_relationInput = {
    where?: GenreWhereInput
    data: XOR<GenreUpdateWithoutKeywords_relationInput, GenreUncheckedUpdateWithoutKeywords_relationInput>
  }

  export type GenreUpdateWithoutKeywords_relationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    adventures_relation?: AdventureUpdateManyWithoutGenre_relationNestedInput
  }

  export type GenreUncheckedUpdateWithoutKeywords_relationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    adventures_relation?: AdventureUncheckedUpdateManyWithoutGenre_relationNestedInput
  }

  export type AdventureUpsertWithWhereUniqueWithoutKeywords_relationInput = {
    where: AdventureWhereUniqueInput
    update: XOR<AdventureUpdateWithoutKeywords_relationInput, AdventureUncheckedUpdateWithoutKeywords_relationInput>
    create: XOR<AdventureCreateWithoutKeywords_relationInput, AdventureUncheckedCreateWithoutKeywords_relationInput>
  }

  export type AdventureUpdateWithWhereUniqueWithoutKeywords_relationInput = {
    where: AdventureWhereUniqueInput
    data: XOR<AdventureUpdateWithoutKeywords_relationInput, AdventureUncheckedUpdateWithoutKeywords_relationInput>
  }

  export type AdventureUpdateManyWithWhereWithoutKeywords_relationInput = {
    where: AdventureScalarWhereInput
    data: XOR<AdventureUpdateManyMutationInput, AdventureUncheckedUpdateManyWithoutKeywords_relationInput>
  }

  export type AdventureScalarWhereInput = {
    AND?: AdventureScalarWhereInput | AdventureScalarWhereInput[]
    OR?: AdventureScalarWhereInput[]
    NOT?: AdventureScalarWhereInput | AdventureScalarWhereInput[]
    id?: StringFilter<"Adventure"> | string
    name?: StringFilter<"Adventure"> | string
    genre_id?: StringFilter<"Adventure"> | string
    creator_id?: StringFilter<"Adventure"> | string
    created_at?: DateTimeFilter<"Adventure"> | Date | string
    updated_at?: DateTimeFilter<"Adventure"> | Date | string
  }

  export type KeywordCreateWithoutGenre_relationInput = {
    id?: string
    name: string
    adventures_relation?: AdventureCreateNestedManyWithoutKeywords_relationInput
  }

  export type KeywordUncheckedCreateWithoutGenre_relationInput = {
    id?: string
    name: string
    adventures_relation?: AdventureUncheckedCreateNestedManyWithoutKeywords_relationInput
  }

  export type KeywordCreateOrConnectWithoutGenre_relationInput = {
    where: KeywordWhereUniqueInput
    create: XOR<KeywordCreateWithoutGenre_relationInput, KeywordUncheckedCreateWithoutGenre_relationInput>
  }

  export type KeywordCreateManyGenre_relationInputEnvelope = {
    data: KeywordCreateManyGenre_relationInput | KeywordCreateManyGenre_relationInput[]
    skipDuplicates?: boolean
  }

  export type AdventureCreateWithoutGenre_relationInput = {
    id?: string
    name: string
    creator_id: string
    created_at?: Date | string
    updated_at?: Date | string
    keywords_relation?: KeywordCreateNestedManyWithoutAdventures_relationInput
  }

  export type AdventureUncheckedCreateWithoutGenre_relationInput = {
    id?: string
    name: string
    creator_id: string
    created_at?: Date | string
    updated_at?: Date | string
    keywords_relation?: KeywordUncheckedCreateNestedManyWithoutAdventures_relationInput
  }

  export type AdventureCreateOrConnectWithoutGenre_relationInput = {
    where: AdventureWhereUniqueInput
    create: XOR<AdventureCreateWithoutGenre_relationInput, AdventureUncheckedCreateWithoutGenre_relationInput>
  }

  export type AdventureCreateManyGenre_relationInputEnvelope = {
    data: AdventureCreateManyGenre_relationInput | AdventureCreateManyGenre_relationInput[]
    skipDuplicates?: boolean
  }

  export type KeywordUpsertWithWhereUniqueWithoutGenre_relationInput = {
    where: KeywordWhereUniqueInput
    update: XOR<KeywordUpdateWithoutGenre_relationInput, KeywordUncheckedUpdateWithoutGenre_relationInput>
    create: XOR<KeywordCreateWithoutGenre_relationInput, KeywordUncheckedCreateWithoutGenre_relationInput>
  }

  export type KeywordUpdateWithWhereUniqueWithoutGenre_relationInput = {
    where: KeywordWhereUniqueInput
    data: XOR<KeywordUpdateWithoutGenre_relationInput, KeywordUncheckedUpdateWithoutGenre_relationInput>
  }

  export type KeywordUpdateManyWithWhereWithoutGenre_relationInput = {
    where: KeywordScalarWhereInput
    data: XOR<KeywordUpdateManyMutationInput, KeywordUncheckedUpdateManyWithoutGenre_relationInput>
  }

  export type AdventureUpsertWithWhereUniqueWithoutGenre_relationInput = {
    where: AdventureWhereUniqueInput
    update: XOR<AdventureUpdateWithoutGenre_relationInput, AdventureUncheckedUpdateWithoutGenre_relationInput>
    create: XOR<AdventureCreateWithoutGenre_relationInput, AdventureUncheckedCreateWithoutGenre_relationInput>
  }

  export type AdventureUpdateWithWhereUniqueWithoutGenre_relationInput = {
    where: AdventureWhereUniqueInput
    data: XOR<AdventureUpdateWithoutGenre_relationInput, AdventureUncheckedUpdateWithoutGenre_relationInput>
  }

  export type AdventureUpdateManyWithWhereWithoutGenre_relationInput = {
    where: AdventureScalarWhereInput
    data: XOR<AdventureUpdateManyMutationInput, AdventureUncheckedUpdateManyWithoutGenre_relationInput>
  }

  export type MagicItemTypeCreateWithoutMagicItemsInput = {
    id: string
    name: string
    gender: $Enums.Gender
  }

  export type MagicItemTypeUncheckedCreateWithoutMagicItemsInput = {
    id: string
    name: string
    gender: $Enums.Gender
  }

  export type MagicItemTypeCreateOrConnectWithoutMagicItemsInput = {
    where: MagicItemTypeWhereUniqueInput
    create: XOR<MagicItemTypeCreateWithoutMagicItemsInput, MagicItemTypeUncheckedCreateWithoutMagicItemsInput>
  }

  export type MagicItemRarityCreateWithoutMagicItemsInput = {
    id: string
    cost: string
    name: string
    name_he: string
    name_she: string
    name_it: string
    order: number
  }

  export type MagicItemRarityUncheckedCreateWithoutMagicItemsInput = {
    id: string
    cost: string
    name: string
    name_he: string
    name_she: string
    name_it: string
    order: number
  }

  export type MagicItemRarityCreateOrConnectWithoutMagicItemsInput = {
    where: MagicItemRarityWhereUniqueInput
    create: XOR<MagicItemRarityCreateWithoutMagicItemsInput, MagicItemRarityUncheckedCreateWithoutMagicItemsInput>
  }

  export type SourceCreateWithoutMagicItemsInput = {
    short_name: string
    name: string
    creatures?: CreatureCreateNestedManyWithoutSource_relationInput
  }

  export type SourceUncheckedCreateWithoutMagicItemsInput = {
    id?: number
    short_name: string
    name: string
    creatures?: CreatureUncheckedCreateNestedManyWithoutSource_relationInput
  }

  export type SourceCreateOrConnectWithoutMagicItemsInput = {
    where: SourceWhereUniqueInput
    create: XOR<SourceCreateWithoutMagicItemsInput, SourceUncheckedCreateWithoutMagicItemsInput>
  }

  export type MagicItemAttunementCreateWithoutMagicItemInput = {
    attunement: AttunementConditionCreateNestedOneWithoutMagicItemsInput
  }

  export type MagicItemAttunementUncheckedCreateWithoutMagicItemInput = {
    attunementId: string
  }

  export type MagicItemAttunementCreateOrConnectWithoutMagicItemInput = {
    where: MagicItemAttunementWhereUniqueInput
    create: XOR<MagicItemAttunementCreateWithoutMagicItemInput, MagicItemAttunementUncheckedCreateWithoutMagicItemInput>
  }

  export type MagicItemAttunementCreateManyMagicItemInputEnvelope = {
    data: MagicItemAttunementCreateManyMagicItemInput | MagicItemAttunementCreateManyMagicItemInput[]
    skipDuplicates?: boolean
  }

  export type MagicItemTypeUpsertWithoutMagicItemsInput = {
    update: XOR<MagicItemTypeUpdateWithoutMagicItemsInput, MagicItemTypeUncheckedUpdateWithoutMagicItemsInput>
    create: XOR<MagicItemTypeCreateWithoutMagicItemsInput, MagicItemTypeUncheckedCreateWithoutMagicItemsInput>
    where?: MagicItemTypeWhereInput
  }

  export type MagicItemTypeUpdateToOneWithWhereWithoutMagicItemsInput = {
    where?: MagicItemTypeWhereInput
    data: XOR<MagicItemTypeUpdateWithoutMagicItemsInput, MagicItemTypeUncheckedUpdateWithoutMagicItemsInput>
  }

  export type MagicItemTypeUpdateWithoutMagicItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
  }

  export type MagicItemTypeUncheckedUpdateWithoutMagicItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
  }

  export type MagicItemRarityUpsertWithoutMagicItemsInput = {
    update: XOR<MagicItemRarityUpdateWithoutMagicItemsInput, MagicItemRarityUncheckedUpdateWithoutMagicItemsInput>
    create: XOR<MagicItemRarityCreateWithoutMagicItemsInput, MagicItemRarityUncheckedCreateWithoutMagicItemsInput>
    where?: MagicItemRarityWhereInput
  }

  export type MagicItemRarityUpdateToOneWithWhereWithoutMagicItemsInput = {
    where?: MagicItemRarityWhereInput
    data: XOR<MagicItemRarityUpdateWithoutMagicItemsInput, MagicItemRarityUncheckedUpdateWithoutMagicItemsInput>
  }

  export type MagicItemRarityUpdateWithoutMagicItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    cost?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    name_he?: StringFieldUpdateOperationsInput | string
    name_she?: StringFieldUpdateOperationsInput | string
    name_it?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
  }

  export type MagicItemRarityUncheckedUpdateWithoutMagicItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    cost?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    name_he?: StringFieldUpdateOperationsInput | string
    name_she?: StringFieldUpdateOperationsInput | string
    name_it?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
  }

  export type SourceUpsertWithoutMagicItemsInput = {
    update: XOR<SourceUpdateWithoutMagicItemsInput, SourceUncheckedUpdateWithoutMagicItemsInput>
    create: XOR<SourceCreateWithoutMagicItemsInput, SourceUncheckedCreateWithoutMagicItemsInput>
    where?: SourceWhereInput
  }

  export type SourceUpdateToOneWithWhereWithoutMagicItemsInput = {
    where?: SourceWhereInput
    data: XOR<SourceUpdateWithoutMagicItemsInput, SourceUncheckedUpdateWithoutMagicItemsInput>
  }

  export type SourceUpdateWithoutMagicItemsInput = {
    short_name?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    creatures?: CreatureUpdateManyWithoutSource_relationNestedInput
  }

  export type SourceUncheckedUpdateWithoutMagicItemsInput = {
    id?: IntFieldUpdateOperationsInput | number
    short_name?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    creatures?: CreatureUncheckedUpdateManyWithoutSource_relationNestedInput
  }

  export type MagicItemAttunementUpsertWithWhereUniqueWithoutMagicItemInput = {
    where: MagicItemAttunementWhereUniqueInput
    update: XOR<MagicItemAttunementUpdateWithoutMagicItemInput, MagicItemAttunementUncheckedUpdateWithoutMagicItemInput>
    create: XOR<MagicItemAttunementCreateWithoutMagicItemInput, MagicItemAttunementUncheckedCreateWithoutMagicItemInput>
  }

  export type MagicItemAttunementUpdateWithWhereUniqueWithoutMagicItemInput = {
    where: MagicItemAttunementWhereUniqueInput
    data: XOR<MagicItemAttunementUpdateWithoutMagicItemInput, MagicItemAttunementUncheckedUpdateWithoutMagicItemInput>
  }

  export type MagicItemAttunementUpdateManyWithWhereWithoutMagicItemInput = {
    where: MagicItemAttunementScalarWhereInput
    data: XOR<MagicItemAttunementUpdateManyMutationInput, MagicItemAttunementUncheckedUpdateManyWithoutMagicItemInput>
  }

  export type MagicItemAttunementScalarWhereInput = {
    AND?: MagicItemAttunementScalarWhereInput | MagicItemAttunementScalarWhereInput[]
    OR?: MagicItemAttunementScalarWhereInput[]
    NOT?: MagicItemAttunementScalarWhereInput | MagicItemAttunementScalarWhereInput[]
    magicItemId?: StringFilter<"MagicItemAttunement"> | string
    attunementId?: StringFilter<"MagicItemAttunement"> | string
  }

  export type MagicItemCreateWithoutRarity_relationInput = {
    id?: string
    name: string
    description: string
    requires_attunement?: boolean
    type_relation: MagicItemTypeCreateNestedOneWithoutMagicItemsInput
    source_relation: SourceCreateNestedOneWithoutMagicItemsInput
    attunements_relation?: MagicItemAttunementCreateNestedManyWithoutMagicItemInput
  }

  export type MagicItemUncheckedCreateWithoutRarity_relationInput = {
    id?: string
    name: string
    description: string
    type_id: string
    source_id: number
    requires_attunement?: boolean
    attunements_relation?: MagicItemAttunementUncheckedCreateNestedManyWithoutMagicItemInput
  }

  export type MagicItemCreateOrConnectWithoutRarity_relationInput = {
    where: MagicItemWhereUniqueInput
    create: XOR<MagicItemCreateWithoutRarity_relationInput, MagicItemUncheckedCreateWithoutRarity_relationInput>
  }

  export type MagicItemCreateManyRarity_relationInputEnvelope = {
    data: MagicItemCreateManyRarity_relationInput | MagicItemCreateManyRarity_relationInput[]
    skipDuplicates?: boolean
  }

  export type MagicItemUpsertWithWhereUniqueWithoutRarity_relationInput = {
    where: MagicItemWhereUniqueInput
    update: XOR<MagicItemUpdateWithoutRarity_relationInput, MagicItemUncheckedUpdateWithoutRarity_relationInput>
    create: XOR<MagicItemCreateWithoutRarity_relationInput, MagicItemUncheckedCreateWithoutRarity_relationInput>
  }

  export type MagicItemUpdateWithWhereUniqueWithoutRarity_relationInput = {
    where: MagicItemWhereUniqueInput
    data: XOR<MagicItemUpdateWithoutRarity_relationInput, MagicItemUncheckedUpdateWithoutRarity_relationInput>
  }

  export type MagicItemUpdateManyWithWhereWithoutRarity_relationInput = {
    where: MagicItemScalarWhereInput
    data: XOR<MagicItemUpdateManyMutationInput, MagicItemUncheckedUpdateManyWithoutRarity_relationInput>
  }

  export type MagicItemCreateWithoutType_relationInput = {
    id?: string
    name: string
    description: string
    requires_attunement?: boolean
    rarity_relation: MagicItemRarityCreateNestedOneWithoutMagicItemsInput
    source_relation: SourceCreateNestedOneWithoutMagicItemsInput
    attunements_relation?: MagicItemAttunementCreateNestedManyWithoutMagicItemInput
  }

  export type MagicItemUncheckedCreateWithoutType_relationInput = {
    id?: string
    name: string
    description: string
    rarity_id: string
    source_id: number
    requires_attunement?: boolean
    attunements_relation?: MagicItemAttunementUncheckedCreateNestedManyWithoutMagicItemInput
  }

  export type MagicItemCreateOrConnectWithoutType_relationInput = {
    where: MagicItemWhereUniqueInput
    create: XOR<MagicItemCreateWithoutType_relationInput, MagicItemUncheckedCreateWithoutType_relationInput>
  }

  export type MagicItemCreateManyType_relationInputEnvelope = {
    data: MagicItemCreateManyType_relationInput | MagicItemCreateManyType_relationInput[]
    skipDuplicates?: boolean
  }

  export type MagicItemUpsertWithWhereUniqueWithoutType_relationInput = {
    where: MagicItemWhereUniqueInput
    update: XOR<MagicItemUpdateWithoutType_relationInput, MagicItemUncheckedUpdateWithoutType_relationInput>
    create: XOR<MagicItemCreateWithoutType_relationInput, MagicItemUncheckedCreateWithoutType_relationInput>
  }

  export type MagicItemUpdateWithWhereUniqueWithoutType_relationInput = {
    where: MagicItemWhereUniqueInput
    data: XOR<MagicItemUpdateWithoutType_relationInput, MagicItemUncheckedUpdateWithoutType_relationInput>
  }

  export type MagicItemUpdateManyWithWhereWithoutType_relationInput = {
    where: MagicItemScalarWhereInput
    data: XOR<MagicItemUpdateManyMutationInput, MagicItemUncheckedUpdateManyWithoutType_relationInput>
  }

  export type MagicItemAttunementCreateWithoutAttunementInput = {
    magicItem: MagicItemCreateNestedOneWithoutAttunements_relationInput
  }

  export type MagicItemAttunementUncheckedCreateWithoutAttunementInput = {
    magicItemId: string
  }

  export type MagicItemAttunementCreateOrConnectWithoutAttunementInput = {
    where: MagicItemAttunementWhereUniqueInput
    create: XOR<MagicItemAttunementCreateWithoutAttunementInput, MagicItemAttunementUncheckedCreateWithoutAttunementInput>
  }

  export type MagicItemAttunementCreateManyAttunementInputEnvelope = {
    data: MagicItemAttunementCreateManyAttunementInput | MagicItemAttunementCreateManyAttunementInput[]
    skipDuplicates?: boolean
  }

  export type MagicItemAttunementUpsertWithWhereUniqueWithoutAttunementInput = {
    where: MagicItemAttunementWhereUniqueInput
    update: XOR<MagicItemAttunementUpdateWithoutAttunementInput, MagicItemAttunementUncheckedUpdateWithoutAttunementInput>
    create: XOR<MagicItemAttunementCreateWithoutAttunementInput, MagicItemAttunementUncheckedCreateWithoutAttunementInput>
  }

  export type MagicItemAttunementUpdateWithWhereUniqueWithoutAttunementInput = {
    where: MagicItemAttunementWhereUniqueInput
    data: XOR<MagicItemAttunementUpdateWithoutAttunementInput, MagicItemAttunementUncheckedUpdateWithoutAttunementInput>
  }

  export type MagicItemAttunementUpdateManyWithWhereWithoutAttunementInput = {
    where: MagicItemAttunementScalarWhereInput
    data: XOR<MagicItemAttunementUpdateManyMutationInput, MagicItemAttunementUncheckedUpdateManyWithoutAttunementInput>
  }

  export type MagicItemCreateWithoutAttunements_relationInput = {
    id?: string
    name: string
    description: string
    requires_attunement?: boolean
    type_relation: MagicItemTypeCreateNestedOneWithoutMagicItemsInput
    rarity_relation: MagicItemRarityCreateNestedOneWithoutMagicItemsInput
    source_relation: SourceCreateNestedOneWithoutMagicItemsInput
  }

  export type MagicItemUncheckedCreateWithoutAttunements_relationInput = {
    id?: string
    name: string
    description: string
    type_id: string
    rarity_id: string
    source_id: number
    requires_attunement?: boolean
  }

  export type MagicItemCreateOrConnectWithoutAttunements_relationInput = {
    where: MagicItemWhereUniqueInput
    create: XOR<MagicItemCreateWithoutAttunements_relationInput, MagicItemUncheckedCreateWithoutAttunements_relationInput>
  }

  export type AttunementConditionCreateWithoutMagicItemsInput = {
    id?: string
    name: string
  }

  export type AttunementConditionUncheckedCreateWithoutMagicItemsInput = {
    id?: string
    name: string
  }

  export type AttunementConditionCreateOrConnectWithoutMagicItemsInput = {
    where: AttunementConditionWhereUniqueInput
    create: XOR<AttunementConditionCreateWithoutMagicItemsInput, AttunementConditionUncheckedCreateWithoutMagicItemsInput>
  }

  export type MagicItemUpsertWithoutAttunements_relationInput = {
    update: XOR<MagicItemUpdateWithoutAttunements_relationInput, MagicItemUncheckedUpdateWithoutAttunements_relationInput>
    create: XOR<MagicItemCreateWithoutAttunements_relationInput, MagicItemUncheckedCreateWithoutAttunements_relationInput>
    where?: MagicItemWhereInput
  }

  export type MagicItemUpdateToOneWithWhereWithoutAttunements_relationInput = {
    where?: MagicItemWhereInput
    data: XOR<MagicItemUpdateWithoutAttunements_relationInput, MagicItemUncheckedUpdateWithoutAttunements_relationInput>
  }

  export type MagicItemUpdateWithoutAttunements_relationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    requires_attunement?: BoolFieldUpdateOperationsInput | boolean
    type_relation?: MagicItemTypeUpdateOneRequiredWithoutMagicItemsNestedInput
    rarity_relation?: MagicItemRarityUpdateOneRequiredWithoutMagicItemsNestedInput
    source_relation?: SourceUpdateOneRequiredWithoutMagicItemsNestedInput
  }

  export type MagicItemUncheckedUpdateWithoutAttunements_relationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type_id?: StringFieldUpdateOperationsInput | string
    rarity_id?: StringFieldUpdateOperationsInput | string
    source_id?: IntFieldUpdateOperationsInput | number
    requires_attunement?: BoolFieldUpdateOperationsInput | boolean
  }

  export type AttunementConditionUpsertWithoutMagicItemsInput = {
    update: XOR<AttunementConditionUpdateWithoutMagicItemsInput, AttunementConditionUncheckedUpdateWithoutMagicItemsInput>
    create: XOR<AttunementConditionCreateWithoutMagicItemsInput, AttunementConditionUncheckedCreateWithoutMagicItemsInput>
    where?: AttunementConditionWhereInput
  }

  export type AttunementConditionUpdateToOneWithWhereWithoutMagicItemsInput = {
    where?: AttunementConditionWhereInput
    data: XOR<AttunementConditionUpdateWithoutMagicItemsInput, AttunementConditionUncheckedUpdateWithoutMagicItemsInput>
  }

  export type AttunementConditionUpdateWithoutMagicItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type AttunementConditionUncheckedUpdateWithoutMagicItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type CreatureCreateManySize_relationInput = {
    id?: string
    name: string
    creator_id?: string | null
    description?: string | null
    race_id?: number | null
    type_id?: number | null
    source_id?: number | null
    alignment_id?: number | null
    armor_class?: number | null
    hit_points?: number | null
    challenge_rating: string
  }

  export type CreatureUpdateWithoutSize_relationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    creator_id?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    armor_class?: NullableIntFieldUpdateOperationsInput | number | null
    hit_points?: NullableIntFieldUpdateOperationsInput | number | null
    speed?: CreatureSpeedUpdateOneWithoutCreature_relationNestedInput
    stats?: CreatureStatsUpdateOneWithoutCreature_relationNestedInput
    skills?: CreatureSkillsUpdateOneWithoutCreature_relationNestedInput
    senses?: CreatureSensesUpdateOneWithoutCreature_relationNestedInput
    challenge_rating_meta?: ChallengeRatingMetadataUpdateOneRequiredWithoutCreaturesNestedInput
    alignment_relation?: AlignmentUpdateOneWithoutCreaturesNestedInput
    race_relation?: CreatureRaceUpdateOneWithoutCreatures_relationNestedInput
    type_relation?: TypeUpdateOneWithoutCreaturesNestedInput
    source_relation?: SourceUpdateOneWithoutCreaturesNestedInput
    resistances?: DamageTypeUpdateManyWithoutResistant_creatures_relationNestedInput
    immunities?: DamageTypeUpdateManyWithoutImmune_creatures_relationNestedInput
    vulnerabilities?: DamageTypeUpdateManyWithoutVulnerable_creatures_relationNestedInput
    languages_relation?: LanguageUpdateManyWithoutCreatures_relationNestedInput
    biomes_relation?: BiomeUpdateManyWithoutCreatures_relationNestedInput
    actions_relation?: ActionUpdateManyWithoutCreatures_relationNestedInput
    traits_relation?: TraitUpdateManyWithoutCreatures_relationNestedInput
  }

  export type CreatureUncheckedUpdateWithoutSize_relationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    creator_id?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    race_id?: NullableIntFieldUpdateOperationsInput | number | null
    type_id?: NullableIntFieldUpdateOperationsInput | number | null
    source_id?: NullableIntFieldUpdateOperationsInput | number | null
    alignment_id?: NullableIntFieldUpdateOperationsInput | number | null
    armor_class?: NullableIntFieldUpdateOperationsInput | number | null
    hit_points?: NullableIntFieldUpdateOperationsInput | number | null
    challenge_rating?: StringFieldUpdateOperationsInput | string
    speed?: CreatureSpeedUncheckedUpdateOneWithoutCreature_relationNestedInput
    stats?: CreatureStatsUncheckedUpdateOneWithoutCreature_relationNestedInput
    skills?: CreatureSkillsUncheckedUpdateOneWithoutCreature_relationNestedInput
    senses?: CreatureSensesUncheckedUpdateOneWithoutCreature_relationNestedInput
    resistances?: DamageTypeUncheckedUpdateManyWithoutResistant_creatures_relationNestedInput
    immunities?: DamageTypeUncheckedUpdateManyWithoutImmune_creatures_relationNestedInput
    vulnerabilities?: DamageTypeUncheckedUpdateManyWithoutVulnerable_creatures_relationNestedInput
    languages_relation?: LanguageUncheckedUpdateManyWithoutCreatures_relationNestedInput
    biomes_relation?: BiomeUncheckedUpdateManyWithoutCreatures_relationNestedInput
    actions_relation?: ActionUncheckedUpdateManyWithoutCreatures_relationNestedInput
    traits_relation?: TraitUncheckedUpdateManyWithoutCreatures_relationNestedInput
  }

  export type CreatureUncheckedUpdateManyWithoutSize_relationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    creator_id?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    race_id?: NullableIntFieldUpdateOperationsInput | number | null
    type_id?: NullableIntFieldUpdateOperationsInput | number | null
    source_id?: NullableIntFieldUpdateOperationsInput | number | null
    alignment_id?: NullableIntFieldUpdateOperationsInput | number | null
    armor_class?: NullableIntFieldUpdateOperationsInput | number | null
    hit_points?: NullableIntFieldUpdateOperationsInput | number | null
    challenge_rating?: StringFieldUpdateOperationsInput | string
  }

  export type CreatureCreateManySource_relationInput = {
    id?: string
    name: string
    creator_id?: string | null
    description?: string | null
    size?: string | null
    race_id?: number | null
    type_id?: number | null
    alignment_id?: number | null
    armor_class?: number | null
    hit_points?: number | null
    challenge_rating: string
  }

  export type MagicItemCreateManySource_relationInput = {
    id?: string
    name: string
    description: string
    type_id: string
    rarity_id: string
    requires_attunement?: boolean
  }

  export type CreatureUpdateWithoutSource_relationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    creator_id?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    armor_class?: NullableIntFieldUpdateOperationsInput | number | null
    hit_points?: NullableIntFieldUpdateOperationsInput | number | null
    speed?: CreatureSpeedUpdateOneWithoutCreature_relationNestedInput
    stats?: CreatureStatsUpdateOneWithoutCreature_relationNestedInput
    skills?: CreatureSkillsUpdateOneWithoutCreature_relationNestedInput
    senses?: CreatureSensesUpdateOneWithoutCreature_relationNestedInput
    challenge_rating_meta?: ChallengeRatingMetadataUpdateOneRequiredWithoutCreaturesNestedInput
    alignment_relation?: AlignmentUpdateOneWithoutCreaturesNestedInput
    race_relation?: CreatureRaceUpdateOneWithoutCreatures_relationNestedInput
    type_relation?: TypeUpdateOneWithoutCreaturesNestedInput
    size_relation?: SizeUpdateOneWithoutCreatureNestedInput
    resistances?: DamageTypeUpdateManyWithoutResistant_creatures_relationNestedInput
    immunities?: DamageTypeUpdateManyWithoutImmune_creatures_relationNestedInput
    vulnerabilities?: DamageTypeUpdateManyWithoutVulnerable_creatures_relationNestedInput
    languages_relation?: LanguageUpdateManyWithoutCreatures_relationNestedInput
    biomes_relation?: BiomeUpdateManyWithoutCreatures_relationNestedInput
    actions_relation?: ActionUpdateManyWithoutCreatures_relationNestedInput
    traits_relation?: TraitUpdateManyWithoutCreatures_relationNestedInput
  }

  export type CreatureUncheckedUpdateWithoutSource_relationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    creator_id?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableStringFieldUpdateOperationsInput | string | null
    race_id?: NullableIntFieldUpdateOperationsInput | number | null
    type_id?: NullableIntFieldUpdateOperationsInput | number | null
    alignment_id?: NullableIntFieldUpdateOperationsInput | number | null
    armor_class?: NullableIntFieldUpdateOperationsInput | number | null
    hit_points?: NullableIntFieldUpdateOperationsInput | number | null
    challenge_rating?: StringFieldUpdateOperationsInput | string
    speed?: CreatureSpeedUncheckedUpdateOneWithoutCreature_relationNestedInput
    stats?: CreatureStatsUncheckedUpdateOneWithoutCreature_relationNestedInput
    skills?: CreatureSkillsUncheckedUpdateOneWithoutCreature_relationNestedInput
    senses?: CreatureSensesUncheckedUpdateOneWithoutCreature_relationNestedInput
    resistances?: DamageTypeUncheckedUpdateManyWithoutResistant_creatures_relationNestedInput
    immunities?: DamageTypeUncheckedUpdateManyWithoutImmune_creatures_relationNestedInput
    vulnerabilities?: DamageTypeUncheckedUpdateManyWithoutVulnerable_creatures_relationNestedInput
    languages_relation?: LanguageUncheckedUpdateManyWithoutCreatures_relationNestedInput
    biomes_relation?: BiomeUncheckedUpdateManyWithoutCreatures_relationNestedInput
    actions_relation?: ActionUncheckedUpdateManyWithoutCreatures_relationNestedInput
    traits_relation?: TraitUncheckedUpdateManyWithoutCreatures_relationNestedInput
  }

  export type CreatureUncheckedUpdateManyWithoutSource_relationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    creator_id?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableStringFieldUpdateOperationsInput | string | null
    race_id?: NullableIntFieldUpdateOperationsInput | number | null
    type_id?: NullableIntFieldUpdateOperationsInput | number | null
    alignment_id?: NullableIntFieldUpdateOperationsInput | number | null
    armor_class?: NullableIntFieldUpdateOperationsInput | number | null
    hit_points?: NullableIntFieldUpdateOperationsInput | number | null
    challenge_rating?: StringFieldUpdateOperationsInput | string
  }

  export type MagicItemUpdateWithoutSource_relationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    requires_attunement?: BoolFieldUpdateOperationsInput | boolean
    type_relation?: MagicItemTypeUpdateOneRequiredWithoutMagicItemsNestedInput
    rarity_relation?: MagicItemRarityUpdateOneRequiredWithoutMagicItemsNestedInput
    attunements_relation?: MagicItemAttunementUpdateManyWithoutMagicItemNestedInput
  }

  export type MagicItemUncheckedUpdateWithoutSource_relationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type_id?: StringFieldUpdateOperationsInput | string
    rarity_id?: StringFieldUpdateOperationsInput | string
    requires_attunement?: BoolFieldUpdateOperationsInput | boolean
    attunements_relation?: MagicItemAttunementUncheckedUpdateManyWithoutMagicItemNestedInput
  }

  export type MagicItemUncheckedUpdateManyWithoutSource_relationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type_id?: StringFieldUpdateOperationsInput | string
    rarity_id?: StringFieldUpdateOperationsInput | string
    requires_attunement?: BoolFieldUpdateOperationsInput | boolean
  }

  export type CreatureUpdateWithoutLanguages_relationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    creator_id?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    armor_class?: NullableIntFieldUpdateOperationsInput | number | null
    hit_points?: NullableIntFieldUpdateOperationsInput | number | null
    speed?: CreatureSpeedUpdateOneWithoutCreature_relationNestedInput
    stats?: CreatureStatsUpdateOneWithoutCreature_relationNestedInput
    skills?: CreatureSkillsUpdateOneWithoutCreature_relationNestedInput
    senses?: CreatureSensesUpdateOneWithoutCreature_relationNestedInput
    challenge_rating_meta?: ChallengeRatingMetadataUpdateOneRequiredWithoutCreaturesNestedInput
    alignment_relation?: AlignmentUpdateOneWithoutCreaturesNestedInput
    race_relation?: CreatureRaceUpdateOneWithoutCreatures_relationNestedInput
    type_relation?: TypeUpdateOneWithoutCreaturesNestedInput
    size_relation?: SizeUpdateOneWithoutCreatureNestedInput
    source_relation?: SourceUpdateOneWithoutCreaturesNestedInput
    resistances?: DamageTypeUpdateManyWithoutResistant_creatures_relationNestedInput
    immunities?: DamageTypeUpdateManyWithoutImmune_creatures_relationNestedInput
    vulnerabilities?: DamageTypeUpdateManyWithoutVulnerable_creatures_relationNestedInput
    biomes_relation?: BiomeUpdateManyWithoutCreatures_relationNestedInput
    actions_relation?: ActionUpdateManyWithoutCreatures_relationNestedInput
    traits_relation?: TraitUpdateManyWithoutCreatures_relationNestedInput
  }

  export type CreatureUncheckedUpdateWithoutLanguages_relationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    creator_id?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableStringFieldUpdateOperationsInput | string | null
    race_id?: NullableIntFieldUpdateOperationsInput | number | null
    type_id?: NullableIntFieldUpdateOperationsInput | number | null
    source_id?: NullableIntFieldUpdateOperationsInput | number | null
    alignment_id?: NullableIntFieldUpdateOperationsInput | number | null
    armor_class?: NullableIntFieldUpdateOperationsInput | number | null
    hit_points?: NullableIntFieldUpdateOperationsInput | number | null
    challenge_rating?: StringFieldUpdateOperationsInput | string
    speed?: CreatureSpeedUncheckedUpdateOneWithoutCreature_relationNestedInput
    stats?: CreatureStatsUncheckedUpdateOneWithoutCreature_relationNestedInput
    skills?: CreatureSkillsUncheckedUpdateOneWithoutCreature_relationNestedInput
    senses?: CreatureSensesUncheckedUpdateOneWithoutCreature_relationNestedInput
    resistances?: DamageTypeUncheckedUpdateManyWithoutResistant_creatures_relationNestedInput
    immunities?: DamageTypeUncheckedUpdateManyWithoutImmune_creatures_relationNestedInput
    vulnerabilities?: DamageTypeUncheckedUpdateManyWithoutVulnerable_creatures_relationNestedInput
    biomes_relation?: BiomeUncheckedUpdateManyWithoutCreatures_relationNestedInput
    actions_relation?: ActionUncheckedUpdateManyWithoutCreatures_relationNestedInput
    traits_relation?: TraitUncheckedUpdateManyWithoutCreatures_relationNestedInput
  }

  export type CreatureUncheckedUpdateManyWithoutLanguages_relationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    creator_id?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableStringFieldUpdateOperationsInput | string | null
    race_id?: NullableIntFieldUpdateOperationsInput | number | null
    type_id?: NullableIntFieldUpdateOperationsInput | number | null
    source_id?: NullableIntFieldUpdateOperationsInput | number | null
    alignment_id?: NullableIntFieldUpdateOperationsInput | number | null
    armor_class?: NullableIntFieldUpdateOperationsInput | number | null
    hit_points?: NullableIntFieldUpdateOperationsInput | number | null
    challenge_rating?: StringFieldUpdateOperationsInput | string
  }

  export type CreatureUpdateWithoutBiomes_relationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    creator_id?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    armor_class?: NullableIntFieldUpdateOperationsInput | number | null
    hit_points?: NullableIntFieldUpdateOperationsInput | number | null
    speed?: CreatureSpeedUpdateOneWithoutCreature_relationNestedInput
    stats?: CreatureStatsUpdateOneWithoutCreature_relationNestedInput
    skills?: CreatureSkillsUpdateOneWithoutCreature_relationNestedInput
    senses?: CreatureSensesUpdateOneWithoutCreature_relationNestedInput
    challenge_rating_meta?: ChallengeRatingMetadataUpdateOneRequiredWithoutCreaturesNestedInput
    alignment_relation?: AlignmentUpdateOneWithoutCreaturesNestedInput
    race_relation?: CreatureRaceUpdateOneWithoutCreatures_relationNestedInput
    type_relation?: TypeUpdateOneWithoutCreaturesNestedInput
    size_relation?: SizeUpdateOneWithoutCreatureNestedInput
    source_relation?: SourceUpdateOneWithoutCreaturesNestedInput
    resistances?: DamageTypeUpdateManyWithoutResistant_creatures_relationNestedInput
    immunities?: DamageTypeUpdateManyWithoutImmune_creatures_relationNestedInput
    vulnerabilities?: DamageTypeUpdateManyWithoutVulnerable_creatures_relationNestedInput
    languages_relation?: LanguageUpdateManyWithoutCreatures_relationNestedInput
    actions_relation?: ActionUpdateManyWithoutCreatures_relationNestedInput
    traits_relation?: TraitUpdateManyWithoutCreatures_relationNestedInput
  }

  export type CreatureUncheckedUpdateWithoutBiomes_relationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    creator_id?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableStringFieldUpdateOperationsInput | string | null
    race_id?: NullableIntFieldUpdateOperationsInput | number | null
    type_id?: NullableIntFieldUpdateOperationsInput | number | null
    source_id?: NullableIntFieldUpdateOperationsInput | number | null
    alignment_id?: NullableIntFieldUpdateOperationsInput | number | null
    armor_class?: NullableIntFieldUpdateOperationsInput | number | null
    hit_points?: NullableIntFieldUpdateOperationsInput | number | null
    challenge_rating?: StringFieldUpdateOperationsInput | string
    speed?: CreatureSpeedUncheckedUpdateOneWithoutCreature_relationNestedInput
    stats?: CreatureStatsUncheckedUpdateOneWithoutCreature_relationNestedInput
    skills?: CreatureSkillsUncheckedUpdateOneWithoutCreature_relationNestedInput
    senses?: CreatureSensesUncheckedUpdateOneWithoutCreature_relationNestedInput
    resistances?: DamageTypeUncheckedUpdateManyWithoutResistant_creatures_relationNestedInput
    immunities?: DamageTypeUncheckedUpdateManyWithoutImmune_creatures_relationNestedInput
    vulnerabilities?: DamageTypeUncheckedUpdateManyWithoutVulnerable_creatures_relationNestedInput
    languages_relation?: LanguageUncheckedUpdateManyWithoutCreatures_relationNestedInput
    actions_relation?: ActionUncheckedUpdateManyWithoutCreatures_relationNestedInput
    traits_relation?: TraitUncheckedUpdateManyWithoutCreatures_relationNestedInput
  }

  export type CreatureUncheckedUpdateManyWithoutBiomes_relationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    creator_id?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableStringFieldUpdateOperationsInput | string | null
    race_id?: NullableIntFieldUpdateOperationsInput | number | null
    type_id?: NullableIntFieldUpdateOperationsInput | number | null
    source_id?: NullableIntFieldUpdateOperationsInput | number | null
    alignment_id?: NullableIntFieldUpdateOperationsInput | number | null
    armor_class?: NullableIntFieldUpdateOperationsInput | number | null
    hit_points?: NullableIntFieldUpdateOperationsInput | number | null
    challenge_rating?: StringFieldUpdateOperationsInput | string
  }

  export type CreatureCreateManyType_relationInput = {
    id?: string
    name: string
    creator_id?: string | null
    description?: string | null
    size?: string | null
    race_id?: number | null
    source_id?: number | null
    alignment_id?: number | null
    armor_class?: number | null
    hit_points?: number | null
    challenge_rating: string
  }

  export type CreatureUpdateWithoutType_relationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    creator_id?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    armor_class?: NullableIntFieldUpdateOperationsInput | number | null
    hit_points?: NullableIntFieldUpdateOperationsInput | number | null
    speed?: CreatureSpeedUpdateOneWithoutCreature_relationNestedInput
    stats?: CreatureStatsUpdateOneWithoutCreature_relationNestedInput
    skills?: CreatureSkillsUpdateOneWithoutCreature_relationNestedInput
    senses?: CreatureSensesUpdateOneWithoutCreature_relationNestedInput
    challenge_rating_meta?: ChallengeRatingMetadataUpdateOneRequiredWithoutCreaturesNestedInput
    alignment_relation?: AlignmentUpdateOneWithoutCreaturesNestedInput
    race_relation?: CreatureRaceUpdateOneWithoutCreatures_relationNestedInput
    size_relation?: SizeUpdateOneWithoutCreatureNestedInput
    source_relation?: SourceUpdateOneWithoutCreaturesNestedInput
    resistances?: DamageTypeUpdateManyWithoutResistant_creatures_relationNestedInput
    immunities?: DamageTypeUpdateManyWithoutImmune_creatures_relationNestedInput
    vulnerabilities?: DamageTypeUpdateManyWithoutVulnerable_creatures_relationNestedInput
    languages_relation?: LanguageUpdateManyWithoutCreatures_relationNestedInput
    biomes_relation?: BiomeUpdateManyWithoutCreatures_relationNestedInput
    actions_relation?: ActionUpdateManyWithoutCreatures_relationNestedInput
    traits_relation?: TraitUpdateManyWithoutCreatures_relationNestedInput
  }

  export type CreatureUncheckedUpdateWithoutType_relationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    creator_id?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableStringFieldUpdateOperationsInput | string | null
    race_id?: NullableIntFieldUpdateOperationsInput | number | null
    source_id?: NullableIntFieldUpdateOperationsInput | number | null
    alignment_id?: NullableIntFieldUpdateOperationsInput | number | null
    armor_class?: NullableIntFieldUpdateOperationsInput | number | null
    hit_points?: NullableIntFieldUpdateOperationsInput | number | null
    challenge_rating?: StringFieldUpdateOperationsInput | string
    speed?: CreatureSpeedUncheckedUpdateOneWithoutCreature_relationNestedInput
    stats?: CreatureStatsUncheckedUpdateOneWithoutCreature_relationNestedInput
    skills?: CreatureSkillsUncheckedUpdateOneWithoutCreature_relationNestedInput
    senses?: CreatureSensesUncheckedUpdateOneWithoutCreature_relationNestedInput
    resistances?: DamageTypeUncheckedUpdateManyWithoutResistant_creatures_relationNestedInput
    immunities?: DamageTypeUncheckedUpdateManyWithoutImmune_creatures_relationNestedInput
    vulnerabilities?: DamageTypeUncheckedUpdateManyWithoutVulnerable_creatures_relationNestedInput
    languages_relation?: LanguageUncheckedUpdateManyWithoutCreatures_relationNestedInput
    biomes_relation?: BiomeUncheckedUpdateManyWithoutCreatures_relationNestedInput
    actions_relation?: ActionUncheckedUpdateManyWithoutCreatures_relationNestedInput
    traits_relation?: TraitUncheckedUpdateManyWithoutCreatures_relationNestedInput
  }

  export type CreatureUncheckedUpdateManyWithoutType_relationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    creator_id?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableStringFieldUpdateOperationsInput | string | null
    race_id?: NullableIntFieldUpdateOperationsInput | number | null
    source_id?: NullableIntFieldUpdateOperationsInput | number | null
    alignment_id?: NullableIntFieldUpdateOperationsInput | number | null
    armor_class?: NullableIntFieldUpdateOperationsInput | number | null
    hit_points?: NullableIntFieldUpdateOperationsInput | number | null
    challenge_rating?: StringFieldUpdateOperationsInput | string
  }

  export type CreatureCreateManyAlignment_relationInput = {
    id?: string
    name: string
    creator_id?: string | null
    description?: string | null
    size?: string | null
    race_id?: number | null
    type_id?: number | null
    source_id?: number | null
    armor_class?: number | null
    hit_points?: number | null
    challenge_rating: string
  }

  export type CreatureUpdateWithoutAlignment_relationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    creator_id?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    armor_class?: NullableIntFieldUpdateOperationsInput | number | null
    hit_points?: NullableIntFieldUpdateOperationsInput | number | null
    speed?: CreatureSpeedUpdateOneWithoutCreature_relationNestedInput
    stats?: CreatureStatsUpdateOneWithoutCreature_relationNestedInput
    skills?: CreatureSkillsUpdateOneWithoutCreature_relationNestedInput
    senses?: CreatureSensesUpdateOneWithoutCreature_relationNestedInput
    challenge_rating_meta?: ChallengeRatingMetadataUpdateOneRequiredWithoutCreaturesNestedInput
    race_relation?: CreatureRaceUpdateOneWithoutCreatures_relationNestedInput
    type_relation?: TypeUpdateOneWithoutCreaturesNestedInput
    size_relation?: SizeUpdateOneWithoutCreatureNestedInput
    source_relation?: SourceUpdateOneWithoutCreaturesNestedInput
    resistances?: DamageTypeUpdateManyWithoutResistant_creatures_relationNestedInput
    immunities?: DamageTypeUpdateManyWithoutImmune_creatures_relationNestedInput
    vulnerabilities?: DamageTypeUpdateManyWithoutVulnerable_creatures_relationNestedInput
    languages_relation?: LanguageUpdateManyWithoutCreatures_relationNestedInput
    biomes_relation?: BiomeUpdateManyWithoutCreatures_relationNestedInput
    actions_relation?: ActionUpdateManyWithoutCreatures_relationNestedInput
    traits_relation?: TraitUpdateManyWithoutCreatures_relationNestedInput
  }

  export type CreatureUncheckedUpdateWithoutAlignment_relationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    creator_id?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableStringFieldUpdateOperationsInput | string | null
    race_id?: NullableIntFieldUpdateOperationsInput | number | null
    type_id?: NullableIntFieldUpdateOperationsInput | number | null
    source_id?: NullableIntFieldUpdateOperationsInput | number | null
    armor_class?: NullableIntFieldUpdateOperationsInput | number | null
    hit_points?: NullableIntFieldUpdateOperationsInput | number | null
    challenge_rating?: StringFieldUpdateOperationsInput | string
    speed?: CreatureSpeedUncheckedUpdateOneWithoutCreature_relationNestedInput
    stats?: CreatureStatsUncheckedUpdateOneWithoutCreature_relationNestedInput
    skills?: CreatureSkillsUncheckedUpdateOneWithoutCreature_relationNestedInput
    senses?: CreatureSensesUncheckedUpdateOneWithoutCreature_relationNestedInput
    resistances?: DamageTypeUncheckedUpdateManyWithoutResistant_creatures_relationNestedInput
    immunities?: DamageTypeUncheckedUpdateManyWithoutImmune_creatures_relationNestedInput
    vulnerabilities?: DamageTypeUncheckedUpdateManyWithoutVulnerable_creatures_relationNestedInput
    languages_relation?: LanguageUncheckedUpdateManyWithoutCreatures_relationNestedInput
    biomes_relation?: BiomeUncheckedUpdateManyWithoutCreatures_relationNestedInput
    actions_relation?: ActionUncheckedUpdateManyWithoutCreatures_relationNestedInput
    traits_relation?: TraitUncheckedUpdateManyWithoutCreatures_relationNestedInput
  }

  export type CreatureUncheckedUpdateManyWithoutAlignment_relationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    creator_id?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableStringFieldUpdateOperationsInput | string | null
    race_id?: NullableIntFieldUpdateOperationsInput | number | null
    type_id?: NullableIntFieldUpdateOperationsInput | number | null
    source_id?: NullableIntFieldUpdateOperationsInput | number | null
    armor_class?: NullableIntFieldUpdateOperationsInput | number | null
    hit_points?: NullableIntFieldUpdateOperationsInput | number | null
    challenge_rating?: StringFieldUpdateOperationsInput | string
  }

  export type CreatureStatDetailCreateManyCreature_stats_relationInput = {
    id?: string
    ability: $Enums.Ability
    value: number
    mastery: boolean
  }

  export type CreatureStatDetailUpdateWithoutCreature_stats_relationInput = {
    id?: StringFieldUpdateOperationsInput | string
    ability?: EnumAbilityFieldUpdateOperationsInput | $Enums.Ability
    value?: IntFieldUpdateOperationsInput | number
    mastery?: BoolFieldUpdateOperationsInput | boolean
  }

  export type CreatureStatDetailUncheckedUpdateWithoutCreature_stats_relationInput = {
    id?: StringFieldUpdateOperationsInput | string
    ability?: EnumAbilityFieldUpdateOperationsInput | $Enums.Ability
    value?: IntFieldUpdateOperationsInput | number
    mastery?: BoolFieldUpdateOperationsInput | boolean
  }

  export type CreatureStatDetailUncheckedUpdateManyWithoutCreature_stats_relationInput = {
    id?: StringFieldUpdateOperationsInput | string
    ability?: EnumAbilityFieldUpdateOperationsInput | $Enums.Ability
    value?: IntFieldUpdateOperationsInput | number
    mastery?: BoolFieldUpdateOperationsInput | boolean
  }

  export type CreatureSkillDetailCreateManyCreature_skills_relationInput = {
    id?: string
    skill: $Enums.Skill
    value?: number | null
    mastery: boolean
  }

  export type CreatureSkillDetailUpdateWithoutCreature_skills_relationInput = {
    id?: StringFieldUpdateOperationsInput | string
    skill?: EnumSkillFieldUpdateOperationsInput | $Enums.Skill
    value?: NullableIntFieldUpdateOperationsInput | number | null
    mastery?: BoolFieldUpdateOperationsInput | boolean
  }

  export type CreatureSkillDetailUncheckedUpdateWithoutCreature_skills_relationInput = {
    id?: StringFieldUpdateOperationsInput | string
    skill?: EnumSkillFieldUpdateOperationsInput | $Enums.Skill
    value?: NullableIntFieldUpdateOperationsInput | number | null
    mastery?: BoolFieldUpdateOperationsInput | boolean
  }

  export type CreatureSkillDetailUncheckedUpdateManyWithoutCreature_skills_relationInput = {
    id?: StringFieldUpdateOperationsInput | string
    skill?: EnumSkillFieldUpdateOperationsInput | $Enums.Skill
    value?: NullableIntFieldUpdateOperationsInput | number | null
    mastery?: BoolFieldUpdateOperationsInput | boolean
  }

  export type DamageTypeUpdateWithoutResistant_creatures_relationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    immune_creatures_relation?: CreatureUpdateManyWithoutImmunitiesNestedInput
    vulnerable_creatures_relation?: CreatureUpdateManyWithoutVulnerabilitiesNestedInput
  }

  export type DamageTypeUncheckedUpdateWithoutResistant_creatures_relationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    immune_creatures_relation?: CreatureUncheckedUpdateManyWithoutImmunitiesNestedInput
    vulnerable_creatures_relation?: CreatureUncheckedUpdateManyWithoutVulnerabilitiesNestedInput
  }

  export type DamageTypeUncheckedUpdateManyWithoutResistant_creatures_relationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type DamageTypeUpdateWithoutImmune_creatures_relationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    resistant_creatures_relation?: CreatureUpdateManyWithoutResistancesNestedInput
    vulnerable_creatures_relation?: CreatureUpdateManyWithoutVulnerabilitiesNestedInput
  }

  export type DamageTypeUncheckedUpdateWithoutImmune_creatures_relationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    resistant_creatures_relation?: CreatureUncheckedUpdateManyWithoutResistancesNestedInput
    vulnerable_creatures_relation?: CreatureUncheckedUpdateManyWithoutVulnerabilitiesNestedInput
  }

  export type DamageTypeUncheckedUpdateManyWithoutImmune_creatures_relationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type DamageTypeUpdateWithoutVulnerable_creatures_relationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    resistant_creatures_relation?: CreatureUpdateManyWithoutResistancesNestedInput
    immune_creatures_relation?: CreatureUpdateManyWithoutImmunitiesNestedInput
  }

  export type DamageTypeUncheckedUpdateWithoutVulnerable_creatures_relationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    resistant_creatures_relation?: CreatureUncheckedUpdateManyWithoutResistancesNestedInput
    immune_creatures_relation?: CreatureUncheckedUpdateManyWithoutImmunitiesNestedInput
  }

  export type DamageTypeUncheckedUpdateManyWithoutVulnerable_creatures_relationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type LanguageUpdateWithoutCreatures_relationInput = {
    name?: StringFieldUpdateOperationsInput | string
  }

  export type LanguageUncheckedUpdateWithoutCreatures_relationInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type LanguageUncheckedUpdateManyWithoutCreatures_relationInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type BiomeUpdateWithoutCreatures_relationInput = {
    short_name?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type BiomeUncheckedUpdateWithoutCreatures_relationInput = {
    id?: IntFieldUpdateOperationsInput | number
    short_name?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type BiomeUncheckedUpdateManyWithoutCreatures_relationInput = {
    id?: IntFieldUpdateOperationsInput | number
    short_name?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type ActionUpdateWithoutCreatures_relationInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    attack?: NullableStringFieldUpdateOperationsInput | string | null
    is_template?: NullableBoolFieldUpdateOperationsInput | boolean | null
    creature_races_relation?: CreatureRaceUpdateManyWithoutActions_relationNestedInput
  }

  export type ActionUncheckedUpdateWithoutCreatures_relationInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    attack?: NullableStringFieldUpdateOperationsInput | string | null
    is_template?: NullableBoolFieldUpdateOperationsInput | boolean | null
    creature_races_relation?: CreatureRaceUncheckedUpdateManyWithoutActions_relationNestedInput
  }

  export type ActionUncheckedUpdateManyWithoutCreatures_relationInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    attack?: NullableStringFieldUpdateOperationsInput | string | null
    is_template?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type TraitUpdateWithoutCreatures_relationInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    attack?: NullableStringFieldUpdateOperationsInput | string | null
    is_template?: NullableBoolFieldUpdateOperationsInput | boolean | null
    creature_races_relation?: CreatureRaceUpdateManyWithoutTraits_relationNestedInput
  }

  export type TraitUncheckedUpdateWithoutCreatures_relationInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    attack?: NullableStringFieldUpdateOperationsInput | string | null
    is_template?: NullableBoolFieldUpdateOperationsInput | boolean | null
    creature_races_relation?: CreatureRaceUncheckedUpdateManyWithoutTraits_relationNestedInput
  }

  export type TraitUncheckedUpdateManyWithoutCreatures_relationInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    attack?: NullableStringFieldUpdateOperationsInput | string | null
    is_template?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type CreatureUpdateWithoutActions_relationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    creator_id?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    armor_class?: NullableIntFieldUpdateOperationsInput | number | null
    hit_points?: NullableIntFieldUpdateOperationsInput | number | null
    speed?: CreatureSpeedUpdateOneWithoutCreature_relationNestedInput
    stats?: CreatureStatsUpdateOneWithoutCreature_relationNestedInput
    skills?: CreatureSkillsUpdateOneWithoutCreature_relationNestedInput
    senses?: CreatureSensesUpdateOneWithoutCreature_relationNestedInput
    challenge_rating_meta?: ChallengeRatingMetadataUpdateOneRequiredWithoutCreaturesNestedInput
    alignment_relation?: AlignmentUpdateOneWithoutCreaturesNestedInput
    race_relation?: CreatureRaceUpdateOneWithoutCreatures_relationNestedInput
    type_relation?: TypeUpdateOneWithoutCreaturesNestedInput
    size_relation?: SizeUpdateOneWithoutCreatureNestedInput
    source_relation?: SourceUpdateOneWithoutCreaturesNestedInput
    resistances?: DamageTypeUpdateManyWithoutResistant_creatures_relationNestedInput
    immunities?: DamageTypeUpdateManyWithoutImmune_creatures_relationNestedInput
    vulnerabilities?: DamageTypeUpdateManyWithoutVulnerable_creatures_relationNestedInput
    languages_relation?: LanguageUpdateManyWithoutCreatures_relationNestedInput
    biomes_relation?: BiomeUpdateManyWithoutCreatures_relationNestedInput
    traits_relation?: TraitUpdateManyWithoutCreatures_relationNestedInput
  }

  export type CreatureUncheckedUpdateWithoutActions_relationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    creator_id?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableStringFieldUpdateOperationsInput | string | null
    race_id?: NullableIntFieldUpdateOperationsInput | number | null
    type_id?: NullableIntFieldUpdateOperationsInput | number | null
    source_id?: NullableIntFieldUpdateOperationsInput | number | null
    alignment_id?: NullableIntFieldUpdateOperationsInput | number | null
    armor_class?: NullableIntFieldUpdateOperationsInput | number | null
    hit_points?: NullableIntFieldUpdateOperationsInput | number | null
    challenge_rating?: StringFieldUpdateOperationsInput | string
    speed?: CreatureSpeedUncheckedUpdateOneWithoutCreature_relationNestedInput
    stats?: CreatureStatsUncheckedUpdateOneWithoutCreature_relationNestedInput
    skills?: CreatureSkillsUncheckedUpdateOneWithoutCreature_relationNestedInput
    senses?: CreatureSensesUncheckedUpdateOneWithoutCreature_relationNestedInput
    resistances?: DamageTypeUncheckedUpdateManyWithoutResistant_creatures_relationNestedInput
    immunities?: DamageTypeUncheckedUpdateManyWithoutImmune_creatures_relationNestedInput
    vulnerabilities?: DamageTypeUncheckedUpdateManyWithoutVulnerable_creatures_relationNestedInput
    languages_relation?: LanguageUncheckedUpdateManyWithoutCreatures_relationNestedInput
    biomes_relation?: BiomeUncheckedUpdateManyWithoutCreatures_relationNestedInput
    traits_relation?: TraitUncheckedUpdateManyWithoutCreatures_relationNestedInput
  }

  export type CreatureUncheckedUpdateManyWithoutActions_relationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    creator_id?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableStringFieldUpdateOperationsInput | string | null
    race_id?: NullableIntFieldUpdateOperationsInput | number | null
    type_id?: NullableIntFieldUpdateOperationsInput | number | null
    source_id?: NullableIntFieldUpdateOperationsInput | number | null
    alignment_id?: NullableIntFieldUpdateOperationsInput | number | null
    armor_class?: NullableIntFieldUpdateOperationsInput | number | null
    hit_points?: NullableIntFieldUpdateOperationsInput | number | null
    challenge_rating?: StringFieldUpdateOperationsInput | string
  }

  export type CreatureRaceUpdateWithoutActions_relationInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    traits_relation?: TraitUpdateManyWithoutCreature_races_relationNestedInput
    creatures_relation?: CreatureUpdateManyWithoutRace_relationNestedInput
  }

  export type CreatureRaceUncheckedUpdateWithoutActions_relationInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    traits_relation?: TraitUncheckedUpdateManyWithoutCreature_races_relationNestedInput
    creatures_relation?: CreatureUncheckedUpdateManyWithoutRace_relationNestedInput
  }

  export type CreatureRaceUncheckedUpdateManyWithoutActions_relationInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
  }

  export type CreatureUpdateWithoutTraits_relationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    creator_id?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    armor_class?: NullableIntFieldUpdateOperationsInput | number | null
    hit_points?: NullableIntFieldUpdateOperationsInput | number | null
    speed?: CreatureSpeedUpdateOneWithoutCreature_relationNestedInput
    stats?: CreatureStatsUpdateOneWithoutCreature_relationNestedInput
    skills?: CreatureSkillsUpdateOneWithoutCreature_relationNestedInput
    senses?: CreatureSensesUpdateOneWithoutCreature_relationNestedInput
    challenge_rating_meta?: ChallengeRatingMetadataUpdateOneRequiredWithoutCreaturesNestedInput
    alignment_relation?: AlignmentUpdateOneWithoutCreaturesNestedInput
    race_relation?: CreatureRaceUpdateOneWithoutCreatures_relationNestedInput
    type_relation?: TypeUpdateOneWithoutCreaturesNestedInput
    size_relation?: SizeUpdateOneWithoutCreatureNestedInput
    source_relation?: SourceUpdateOneWithoutCreaturesNestedInput
    resistances?: DamageTypeUpdateManyWithoutResistant_creatures_relationNestedInput
    immunities?: DamageTypeUpdateManyWithoutImmune_creatures_relationNestedInput
    vulnerabilities?: DamageTypeUpdateManyWithoutVulnerable_creatures_relationNestedInput
    languages_relation?: LanguageUpdateManyWithoutCreatures_relationNestedInput
    biomes_relation?: BiomeUpdateManyWithoutCreatures_relationNestedInput
    actions_relation?: ActionUpdateManyWithoutCreatures_relationNestedInput
  }

  export type CreatureUncheckedUpdateWithoutTraits_relationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    creator_id?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableStringFieldUpdateOperationsInput | string | null
    race_id?: NullableIntFieldUpdateOperationsInput | number | null
    type_id?: NullableIntFieldUpdateOperationsInput | number | null
    source_id?: NullableIntFieldUpdateOperationsInput | number | null
    alignment_id?: NullableIntFieldUpdateOperationsInput | number | null
    armor_class?: NullableIntFieldUpdateOperationsInput | number | null
    hit_points?: NullableIntFieldUpdateOperationsInput | number | null
    challenge_rating?: StringFieldUpdateOperationsInput | string
    speed?: CreatureSpeedUncheckedUpdateOneWithoutCreature_relationNestedInput
    stats?: CreatureStatsUncheckedUpdateOneWithoutCreature_relationNestedInput
    skills?: CreatureSkillsUncheckedUpdateOneWithoutCreature_relationNestedInput
    senses?: CreatureSensesUncheckedUpdateOneWithoutCreature_relationNestedInput
    resistances?: DamageTypeUncheckedUpdateManyWithoutResistant_creatures_relationNestedInput
    immunities?: DamageTypeUncheckedUpdateManyWithoutImmune_creatures_relationNestedInput
    vulnerabilities?: DamageTypeUncheckedUpdateManyWithoutVulnerable_creatures_relationNestedInput
    languages_relation?: LanguageUncheckedUpdateManyWithoutCreatures_relationNestedInput
    biomes_relation?: BiomeUncheckedUpdateManyWithoutCreatures_relationNestedInput
    actions_relation?: ActionUncheckedUpdateManyWithoutCreatures_relationNestedInput
  }

  export type CreatureUncheckedUpdateManyWithoutTraits_relationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    creator_id?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableStringFieldUpdateOperationsInput | string | null
    race_id?: NullableIntFieldUpdateOperationsInput | number | null
    type_id?: NullableIntFieldUpdateOperationsInput | number | null
    source_id?: NullableIntFieldUpdateOperationsInput | number | null
    alignment_id?: NullableIntFieldUpdateOperationsInput | number | null
    armor_class?: NullableIntFieldUpdateOperationsInput | number | null
    hit_points?: NullableIntFieldUpdateOperationsInput | number | null
    challenge_rating?: StringFieldUpdateOperationsInput | string
  }

  export type CreatureRaceUpdateWithoutTraits_relationInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    actions_relation?: ActionUpdateManyWithoutCreature_races_relationNestedInput
    creatures_relation?: CreatureUpdateManyWithoutRace_relationNestedInput
  }

  export type CreatureRaceUncheckedUpdateWithoutTraits_relationInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    actions_relation?: ActionUncheckedUpdateManyWithoutCreature_races_relationNestedInput
    creatures_relation?: CreatureUncheckedUpdateManyWithoutRace_relationNestedInput
  }

  export type CreatureRaceUncheckedUpdateManyWithoutTraits_relationInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
  }

  export type CreatureCreateManyRace_relationInput = {
    id?: string
    name: string
    creator_id?: string | null
    description?: string | null
    size?: string | null
    type_id?: number | null
    source_id?: number | null
    alignment_id?: number | null
    armor_class?: number | null
    hit_points?: number | null
    challenge_rating: string
  }

  export type TraitUpdateWithoutCreature_races_relationInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    attack?: NullableStringFieldUpdateOperationsInput | string | null
    is_template?: NullableBoolFieldUpdateOperationsInput | boolean | null
    creatures_relation?: CreatureUpdateManyWithoutTraits_relationNestedInput
  }

  export type TraitUncheckedUpdateWithoutCreature_races_relationInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    attack?: NullableStringFieldUpdateOperationsInput | string | null
    is_template?: NullableBoolFieldUpdateOperationsInput | boolean | null
    creatures_relation?: CreatureUncheckedUpdateManyWithoutTraits_relationNestedInput
  }

  export type TraitUncheckedUpdateManyWithoutCreature_races_relationInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    attack?: NullableStringFieldUpdateOperationsInput | string | null
    is_template?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type ActionUpdateWithoutCreature_races_relationInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    attack?: NullableStringFieldUpdateOperationsInput | string | null
    is_template?: NullableBoolFieldUpdateOperationsInput | boolean | null
    creatures_relation?: CreatureUpdateManyWithoutActions_relationNestedInput
  }

  export type ActionUncheckedUpdateWithoutCreature_races_relationInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    attack?: NullableStringFieldUpdateOperationsInput | string | null
    is_template?: NullableBoolFieldUpdateOperationsInput | boolean | null
    creatures_relation?: CreatureUncheckedUpdateManyWithoutActions_relationNestedInput
  }

  export type ActionUncheckedUpdateManyWithoutCreature_races_relationInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    attack?: NullableStringFieldUpdateOperationsInput | string | null
    is_template?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type CreatureUpdateWithoutRace_relationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    creator_id?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    armor_class?: NullableIntFieldUpdateOperationsInput | number | null
    hit_points?: NullableIntFieldUpdateOperationsInput | number | null
    speed?: CreatureSpeedUpdateOneWithoutCreature_relationNestedInput
    stats?: CreatureStatsUpdateOneWithoutCreature_relationNestedInput
    skills?: CreatureSkillsUpdateOneWithoutCreature_relationNestedInput
    senses?: CreatureSensesUpdateOneWithoutCreature_relationNestedInput
    challenge_rating_meta?: ChallengeRatingMetadataUpdateOneRequiredWithoutCreaturesNestedInput
    alignment_relation?: AlignmentUpdateOneWithoutCreaturesNestedInput
    type_relation?: TypeUpdateOneWithoutCreaturesNestedInput
    size_relation?: SizeUpdateOneWithoutCreatureNestedInput
    source_relation?: SourceUpdateOneWithoutCreaturesNestedInput
    resistances?: DamageTypeUpdateManyWithoutResistant_creatures_relationNestedInput
    immunities?: DamageTypeUpdateManyWithoutImmune_creatures_relationNestedInput
    vulnerabilities?: DamageTypeUpdateManyWithoutVulnerable_creatures_relationNestedInput
    languages_relation?: LanguageUpdateManyWithoutCreatures_relationNestedInput
    biomes_relation?: BiomeUpdateManyWithoutCreatures_relationNestedInput
    actions_relation?: ActionUpdateManyWithoutCreatures_relationNestedInput
    traits_relation?: TraitUpdateManyWithoutCreatures_relationNestedInput
  }

  export type CreatureUncheckedUpdateWithoutRace_relationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    creator_id?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableStringFieldUpdateOperationsInput | string | null
    type_id?: NullableIntFieldUpdateOperationsInput | number | null
    source_id?: NullableIntFieldUpdateOperationsInput | number | null
    alignment_id?: NullableIntFieldUpdateOperationsInput | number | null
    armor_class?: NullableIntFieldUpdateOperationsInput | number | null
    hit_points?: NullableIntFieldUpdateOperationsInput | number | null
    challenge_rating?: StringFieldUpdateOperationsInput | string
    speed?: CreatureSpeedUncheckedUpdateOneWithoutCreature_relationNestedInput
    stats?: CreatureStatsUncheckedUpdateOneWithoutCreature_relationNestedInput
    skills?: CreatureSkillsUncheckedUpdateOneWithoutCreature_relationNestedInput
    senses?: CreatureSensesUncheckedUpdateOneWithoutCreature_relationNestedInput
    resistances?: DamageTypeUncheckedUpdateManyWithoutResistant_creatures_relationNestedInput
    immunities?: DamageTypeUncheckedUpdateManyWithoutImmune_creatures_relationNestedInput
    vulnerabilities?: DamageTypeUncheckedUpdateManyWithoutVulnerable_creatures_relationNestedInput
    languages_relation?: LanguageUncheckedUpdateManyWithoutCreatures_relationNestedInput
    biomes_relation?: BiomeUncheckedUpdateManyWithoutCreatures_relationNestedInput
    actions_relation?: ActionUncheckedUpdateManyWithoutCreatures_relationNestedInput
    traits_relation?: TraitUncheckedUpdateManyWithoutCreatures_relationNestedInput
  }

  export type CreatureUncheckedUpdateManyWithoutRace_relationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    creator_id?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableStringFieldUpdateOperationsInput | string | null
    type_id?: NullableIntFieldUpdateOperationsInput | number | null
    source_id?: NullableIntFieldUpdateOperationsInput | number | null
    alignment_id?: NullableIntFieldUpdateOperationsInput | number | null
    armor_class?: NullableIntFieldUpdateOperationsInput | number | null
    hit_points?: NullableIntFieldUpdateOperationsInput | number | null
    challenge_rating?: StringFieldUpdateOperationsInput | string
  }

  export type CreatureUpdateWithoutResistancesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    creator_id?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    armor_class?: NullableIntFieldUpdateOperationsInput | number | null
    hit_points?: NullableIntFieldUpdateOperationsInput | number | null
    speed?: CreatureSpeedUpdateOneWithoutCreature_relationNestedInput
    stats?: CreatureStatsUpdateOneWithoutCreature_relationNestedInput
    skills?: CreatureSkillsUpdateOneWithoutCreature_relationNestedInput
    senses?: CreatureSensesUpdateOneWithoutCreature_relationNestedInput
    challenge_rating_meta?: ChallengeRatingMetadataUpdateOneRequiredWithoutCreaturesNestedInput
    alignment_relation?: AlignmentUpdateOneWithoutCreaturesNestedInput
    race_relation?: CreatureRaceUpdateOneWithoutCreatures_relationNestedInput
    type_relation?: TypeUpdateOneWithoutCreaturesNestedInput
    size_relation?: SizeUpdateOneWithoutCreatureNestedInput
    source_relation?: SourceUpdateOneWithoutCreaturesNestedInput
    immunities?: DamageTypeUpdateManyWithoutImmune_creatures_relationNestedInput
    vulnerabilities?: DamageTypeUpdateManyWithoutVulnerable_creatures_relationNestedInput
    languages_relation?: LanguageUpdateManyWithoutCreatures_relationNestedInput
    biomes_relation?: BiomeUpdateManyWithoutCreatures_relationNestedInput
    actions_relation?: ActionUpdateManyWithoutCreatures_relationNestedInput
    traits_relation?: TraitUpdateManyWithoutCreatures_relationNestedInput
  }

  export type CreatureUncheckedUpdateWithoutResistancesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    creator_id?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableStringFieldUpdateOperationsInput | string | null
    race_id?: NullableIntFieldUpdateOperationsInput | number | null
    type_id?: NullableIntFieldUpdateOperationsInput | number | null
    source_id?: NullableIntFieldUpdateOperationsInput | number | null
    alignment_id?: NullableIntFieldUpdateOperationsInput | number | null
    armor_class?: NullableIntFieldUpdateOperationsInput | number | null
    hit_points?: NullableIntFieldUpdateOperationsInput | number | null
    challenge_rating?: StringFieldUpdateOperationsInput | string
    speed?: CreatureSpeedUncheckedUpdateOneWithoutCreature_relationNestedInput
    stats?: CreatureStatsUncheckedUpdateOneWithoutCreature_relationNestedInput
    skills?: CreatureSkillsUncheckedUpdateOneWithoutCreature_relationNestedInput
    senses?: CreatureSensesUncheckedUpdateOneWithoutCreature_relationNestedInput
    immunities?: DamageTypeUncheckedUpdateManyWithoutImmune_creatures_relationNestedInput
    vulnerabilities?: DamageTypeUncheckedUpdateManyWithoutVulnerable_creatures_relationNestedInput
    languages_relation?: LanguageUncheckedUpdateManyWithoutCreatures_relationNestedInput
    biomes_relation?: BiomeUncheckedUpdateManyWithoutCreatures_relationNestedInput
    actions_relation?: ActionUncheckedUpdateManyWithoutCreatures_relationNestedInput
    traits_relation?: TraitUncheckedUpdateManyWithoutCreatures_relationNestedInput
  }

  export type CreatureUncheckedUpdateManyWithoutResistancesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    creator_id?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableStringFieldUpdateOperationsInput | string | null
    race_id?: NullableIntFieldUpdateOperationsInput | number | null
    type_id?: NullableIntFieldUpdateOperationsInput | number | null
    source_id?: NullableIntFieldUpdateOperationsInput | number | null
    alignment_id?: NullableIntFieldUpdateOperationsInput | number | null
    armor_class?: NullableIntFieldUpdateOperationsInput | number | null
    hit_points?: NullableIntFieldUpdateOperationsInput | number | null
    challenge_rating?: StringFieldUpdateOperationsInput | string
  }

  export type CreatureUpdateWithoutImmunitiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    creator_id?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    armor_class?: NullableIntFieldUpdateOperationsInput | number | null
    hit_points?: NullableIntFieldUpdateOperationsInput | number | null
    speed?: CreatureSpeedUpdateOneWithoutCreature_relationNestedInput
    stats?: CreatureStatsUpdateOneWithoutCreature_relationNestedInput
    skills?: CreatureSkillsUpdateOneWithoutCreature_relationNestedInput
    senses?: CreatureSensesUpdateOneWithoutCreature_relationNestedInput
    challenge_rating_meta?: ChallengeRatingMetadataUpdateOneRequiredWithoutCreaturesNestedInput
    alignment_relation?: AlignmentUpdateOneWithoutCreaturesNestedInput
    race_relation?: CreatureRaceUpdateOneWithoutCreatures_relationNestedInput
    type_relation?: TypeUpdateOneWithoutCreaturesNestedInput
    size_relation?: SizeUpdateOneWithoutCreatureNestedInput
    source_relation?: SourceUpdateOneWithoutCreaturesNestedInput
    resistances?: DamageTypeUpdateManyWithoutResistant_creatures_relationNestedInput
    vulnerabilities?: DamageTypeUpdateManyWithoutVulnerable_creatures_relationNestedInput
    languages_relation?: LanguageUpdateManyWithoutCreatures_relationNestedInput
    biomes_relation?: BiomeUpdateManyWithoutCreatures_relationNestedInput
    actions_relation?: ActionUpdateManyWithoutCreatures_relationNestedInput
    traits_relation?: TraitUpdateManyWithoutCreatures_relationNestedInput
  }

  export type CreatureUncheckedUpdateWithoutImmunitiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    creator_id?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableStringFieldUpdateOperationsInput | string | null
    race_id?: NullableIntFieldUpdateOperationsInput | number | null
    type_id?: NullableIntFieldUpdateOperationsInput | number | null
    source_id?: NullableIntFieldUpdateOperationsInput | number | null
    alignment_id?: NullableIntFieldUpdateOperationsInput | number | null
    armor_class?: NullableIntFieldUpdateOperationsInput | number | null
    hit_points?: NullableIntFieldUpdateOperationsInput | number | null
    challenge_rating?: StringFieldUpdateOperationsInput | string
    speed?: CreatureSpeedUncheckedUpdateOneWithoutCreature_relationNestedInput
    stats?: CreatureStatsUncheckedUpdateOneWithoutCreature_relationNestedInput
    skills?: CreatureSkillsUncheckedUpdateOneWithoutCreature_relationNestedInput
    senses?: CreatureSensesUncheckedUpdateOneWithoutCreature_relationNestedInput
    resistances?: DamageTypeUncheckedUpdateManyWithoutResistant_creatures_relationNestedInput
    vulnerabilities?: DamageTypeUncheckedUpdateManyWithoutVulnerable_creatures_relationNestedInput
    languages_relation?: LanguageUncheckedUpdateManyWithoutCreatures_relationNestedInput
    biomes_relation?: BiomeUncheckedUpdateManyWithoutCreatures_relationNestedInput
    actions_relation?: ActionUncheckedUpdateManyWithoutCreatures_relationNestedInput
    traits_relation?: TraitUncheckedUpdateManyWithoutCreatures_relationNestedInput
  }

  export type CreatureUncheckedUpdateManyWithoutImmunitiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    creator_id?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableStringFieldUpdateOperationsInput | string | null
    race_id?: NullableIntFieldUpdateOperationsInput | number | null
    type_id?: NullableIntFieldUpdateOperationsInput | number | null
    source_id?: NullableIntFieldUpdateOperationsInput | number | null
    alignment_id?: NullableIntFieldUpdateOperationsInput | number | null
    armor_class?: NullableIntFieldUpdateOperationsInput | number | null
    hit_points?: NullableIntFieldUpdateOperationsInput | number | null
    challenge_rating?: StringFieldUpdateOperationsInput | string
  }

  export type CreatureUpdateWithoutVulnerabilitiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    creator_id?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    armor_class?: NullableIntFieldUpdateOperationsInput | number | null
    hit_points?: NullableIntFieldUpdateOperationsInput | number | null
    speed?: CreatureSpeedUpdateOneWithoutCreature_relationNestedInput
    stats?: CreatureStatsUpdateOneWithoutCreature_relationNestedInput
    skills?: CreatureSkillsUpdateOneWithoutCreature_relationNestedInput
    senses?: CreatureSensesUpdateOneWithoutCreature_relationNestedInput
    challenge_rating_meta?: ChallengeRatingMetadataUpdateOneRequiredWithoutCreaturesNestedInput
    alignment_relation?: AlignmentUpdateOneWithoutCreaturesNestedInput
    race_relation?: CreatureRaceUpdateOneWithoutCreatures_relationNestedInput
    type_relation?: TypeUpdateOneWithoutCreaturesNestedInput
    size_relation?: SizeUpdateOneWithoutCreatureNestedInput
    source_relation?: SourceUpdateOneWithoutCreaturesNestedInput
    resistances?: DamageTypeUpdateManyWithoutResistant_creatures_relationNestedInput
    immunities?: DamageTypeUpdateManyWithoutImmune_creatures_relationNestedInput
    languages_relation?: LanguageUpdateManyWithoutCreatures_relationNestedInput
    biomes_relation?: BiomeUpdateManyWithoutCreatures_relationNestedInput
    actions_relation?: ActionUpdateManyWithoutCreatures_relationNestedInput
    traits_relation?: TraitUpdateManyWithoutCreatures_relationNestedInput
  }

  export type CreatureUncheckedUpdateWithoutVulnerabilitiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    creator_id?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableStringFieldUpdateOperationsInput | string | null
    race_id?: NullableIntFieldUpdateOperationsInput | number | null
    type_id?: NullableIntFieldUpdateOperationsInput | number | null
    source_id?: NullableIntFieldUpdateOperationsInput | number | null
    alignment_id?: NullableIntFieldUpdateOperationsInput | number | null
    armor_class?: NullableIntFieldUpdateOperationsInput | number | null
    hit_points?: NullableIntFieldUpdateOperationsInput | number | null
    challenge_rating?: StringFieldUpdateOperationsInput | string
    speed?: CreatureSpeedUncheckedUpdateOneWithoutCreature_relationNestedInput
    stats?: CreatureStatsUncheckedUpdateOneWithoutCreature_relationNestedInput
    skills?: CreatureSkillsUncheckedUpdateOneWithoutCreature_relationNestedInput
    senses?: CreatureSensesUncheckedUpdateOneWithoutCreature_relationNestedInput
    resistances?: DamageTypeUncheckedUpdateManyWithoutResistant_creatures_relationNestedInput
    immunities?: DamageTypeUncheckedUpdateManyWithoutImmune_creatures_relationNestedInput
    languages_relation?: LanguageUncheckedUpdateManyWithoutCreatures_relationNestedInput
    biomes_relation?: BiomeUncheckedUpdateManyWithoutCreatures_relationNestedInput
    actions_relation?: ActionUncheckedUpdateManyWithoutCreatures_relationNestedInput
    traits_relation?: TraitUncheckedUpdateManyWithoutCreatures_relationNestedInput
  }

  export type CreatureUncheckedUpdateManyWithoutVulnerabilitiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    creator_id?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableStringFieldUpdateOperationsInput | string | null
    race_id?: NullableIntFieldUpdateOperationsInput | number | null
    type_id?: NullableIntFieldUpdateOperationsInput | number | null
    source_id?: NullableIntFieldUpdateOperationsInput | number | null
    alignment_id?: NullableIntFieldUpdateOperationsInput | number | null
    armor_class?: NullableIntFieldUpdateOperationsInput | number | null
    hit_points?: NullableIntFieldUpdateOperationsInput | number | null
    challenge_rating?: StringFieldUpdateOperationsInput | string
  }

  export type CreatureCreateManyChallenge_rating_metaInput = {
    id?: string
    name: string
    creator_id?: string | null
    description?: string | null
    size?: string | null
    race_id?: number | null
    type_id?: number | null
    source_id?: number | null
    alignment_id?: number | null
    armor_class?: number | null
    hit_points?: number | null
  }

  export type CreatureUpdateWithoutChallenge_rating_metaInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    creator_id?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    armor_class?: NullableIntFieldUpdateOperationsInput | number | null
    hit_points?: NullableIntFieldUpdateOperationsInput | number | null
    speed?: CreatureSpeedUpdateOneWithoutCreature_relationNestedInput
    stats?: CreatureStatsUpdateOneWithoutCreature_relationNestedInput
    skills?: CreatureSkillsUpdateOneWithoutCreature_relationNestedInput
    senses?: CreatureSensesUpdateOneWithoutCreature_relationNestedInput
    alignment_relation?: AlignmentUpdateOneWithoutCreaturesNestedInput
    race_relation?: CreatureRaceUpdateOneWithoutCreatures_relationNestedInput
    type_relation?: TypeUpdateOneWithoutCreaturesNestedInput
    size_relation?: SizeUpdateOneWithoutCreatureNestedInput
    source_relation?: SourceUpdateOneWithoutCreaturesNestedInput
    resistances?: DamageTypeUpdateManyWithoutResistant_creatures_relationNestedInput
    immunities?: DamageTypeUpdateManyWithoutImmune_creatures_relationNestedInput
    vulnerabilities?: DamageTypeUpdateManyWithoutVulnerable_creatures_relationNestedInput
    languages_relation?: LanguageUpdateManyWithoutCreatures_relationNestedInput
    biomes_relation?: BiomeUpdateManyWithoutCreatures_relationNestedInput
    actions_relation?: ActionUpdateManyWithoutCreatures_relationNestedInput
    traits_relation?: TraitUpdateManyWithoutCreatures_relationNestedInput
  }

  export type CreatureUncheckedUpdateWithoutChallenge_rating_metaInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    creator_id?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableStringFieldUpdateOperationsInput | string | null
    race_id?: NullableIntFieldUpdateOperationsInput | number | null
    type_id?: NullableIntFieldUpdateOperationsInput | number | null
    source_id?: NullableIntFieldUpdateOperationsInput | number | null
    alignment_id?: NullableIntFieldUpdateOperationsInput | number | null
    armor_class?: NullableIntFieldUpdateOperationsInput | number | null
    hit_points?: NullableIntFieldUpdateOperationsInput | number | null
    speed?: CreatureSpeedUncheckedUpdateOneWithoutCreature_relationNestedInput
    stats?: CreatureStatsUncheckedUpdateOneWithoutCreature_relationNestedInput
    skills?: CreatureSkillsUncheckedUpdateOneWithoutCreature_relationNestedInput
    senses?: CreatureSensesUncheckedUpdateOneWithoutCreature_relationNestedInput
    resistances?: DamageTypeUncheckedUpdateManyWithoutResistant_creatures_relationNestedInput
    immunities?: DamageTypeUncheckedUpdateManyWithoutImmune_creatures_relationNestedInput
    vulnerabilities?: DamageTypeUncheckedUpdateManyWithoutVulnerable_creatures_relationNestedInput
    languages_relation?: LanguageUncheckedUpdateManyWithoutCreatures_relationNestedInput
    biomes_relation?: BiomeUncheckedUpdateManyWithoutCreatures_relationNestedInput
    actions_relation?: ActionUncheckedUpdateManyWithoutCreatures_relationNestedInput
    traits_relation?: TraitUncheckedUpdateManyWithoutCreatures_relationNestedInput
  }

  export type CreatureUncheckedUpdateManyWithoutChallenge_rating_metaInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    creator_id?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableStringFieldUpdateOperationsInput | string | null
    race_id?: NullableIntFieldUpdateOperationsInput | number | null
    type_id?: NullableIntFieldUpdateOperationsInput | number | null
    source_id?: NullableIntFieldUpdateOperationsInput | number | null
    alignment_id?: NullableIntFieldUpdateOperationsInput | number | null
    armor_class?: NullableIntFieldUpdateOperationsInput | number | null
    hit_points?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type GPTMessageCreateManyMessage_history_relationInput = {
    number: number
    text: string
    role: string
  }

  export type GPTMessageUpdateWithoutMessage_history_relationInput = {
    number?: IntFieldUpdateOperationsInput | number
    text?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
  }

  export type GPTMessageUncheckedUpdateWithoutMessage_history_relationInput = {
    number?: IntFieldUpdateOperationsInput | number
    text?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
  }

  export type GPTMessageUncheckedUpdateManyWithoutMessage_history_relationInput = {
    number?: IntFieldUpdateOperationsInput | number
    text?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
  }

  export type KeywordUpdateWithoutAdventures_relationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    genre_relation?: GenreUpdateOneRequiredWithoutKeywords_relationNestedInput
  }

  export type KeywordUncheckedUpdateWithoutAdventures_relationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    genre_id?: StringFieldUpdateOperationsInput | string
  }

  export type KeywordUncheckedUpdateManyWithoutAdventures_relationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    genre_id?: StringFieldUpdateOperationsInput | string
  }

  export type AdventureUpdateWithoutKeywords_relationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    creator_id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    genre_relation?: GenreUpdateOneRequiredWithoutAdventures_relationNestedInput
  }

  export type AdventureUncheckedUpdateWithoutKeywords_relationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    genre_id?: StringFieldUpdateOperationsInput | string
    creator_id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdventureUncheckedUpdateManyWithoutKeywords_relationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    genre_id?: StringFieldUpdateOperationsInput | string
    creator_id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type KeywordCreateManyGenre_relationInput = {
    id?: string
    name: string
  }

  export type AdventureCreateManyGenre_relationInput = {
    id?: string
    name: string
    creator_id: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type KeywordUpdateWithoutGenre_relationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    adventures_relation?: AdventureUpdateManyWithoutKeywords_relationNestedInput
  }

  export type KeywordUncheckedUpdateWithoutGenre_relationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    adventures_relation?: AdventureUncheckedUpdateManyWithoutKeywords_relationNestedInput
  }

  export type KeywordUncheckedUpdateManyWithoutGenre_relationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type AdventureUpdateWithoutGenre_relationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    creator_id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    keywords_relation?: KeywordUpdateManyWithoutAdventures_relationNestedInput
  }

  export type AdventureUncheckedUpdateWithoutGenre_relationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    creator_id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    keywords_relation?: KeywordUncheckedUpdateManyWithoutAdventures_relationNestedInput
  }

  export type AdventureUncheckedUpdateManyWithoutGenre_relationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    creator_id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MagicItemAttunementCreateManyMagicItemInput = {
    attunementId: string
  }

  export type MagicItemAttunementUpdateWithoutMagicItemInput = {
    attunement?: AttunementConditionUpdateOneRequiredWithoutMagicItemsNestedInput
  }

  export type MagicItemAttunementUncheckedUpdateWithoutMagicItemInput = {
    attunementId?: StringFieldUpdateOperationsInput | string
  }

  export type MagicItemAttunementUncheckedUpdateManyWithoutMagicItemInput = {
    attunementId?: StringFieldUpdateOperationsInput | string
  }

  export type MagicItemCreateManyRarity_relationInput = {
    id?: string
    name: string
    description: string
    type_id: string
    source_id: number
    requires_attunement?: boolean
  }

  export type MagicItemUpdateWithoutRarity_relationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    requires_attunement?: BoolFieldUpdateOperationsInput | boolean
    type_relation?: MagicItemTypeUpdateOneRequiredWithoutMagicItemsNestedInput
    source_relation?: SourceUpdateOneRequiredWithoutMagicItemsNestedInput
    attunements_relation?: MagicItemAttunementUpdateManyWithoutMagicItemNestedInput
  }

  export type MagicItemUncheckedUpdateWithoutRarity_relationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type_id?: StringFieldUpdateOperationsInput | string
    source_id?: IntFieldUpdateOperationsInput | number
    requires_attunement?: BoolFieldUpdateOperationsInput | boolean
    attunements_relation?: MagicItemAttunementUncheckedUpdateManyWithoutMagicItemNestedInput
  }

  export type MagicItemUncheckedUpdateManyWithoutRarity_relationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type_id?: StringFieldUpdateOperationsInput | string
    source_id?: IntFieldUpdateOperationsInput | number
    requires_attunement?: BoolFieldUpdateOperationsInput | boolean
  }

  export type MagicItemCreateManyType_relationInput = {
    id?: string
    name: string
    description: string
    rarity_id: string
    source_id: number
    requires_attunement?: boolean
  }

  export type MagicItemUpdateWithoutType_relationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    requires_attunement?: BoolFieldUpdateOperationsInput | boolean
    rarity_relation?: MagicItemRarityUpdateOneRequiredWithoutMagicItemsNestedInput
    source_relation?: SourceUpdateOneRequiredWithoutMagicItemsNestedInput
    attunements_relation?: MagicItemAttunementUpdateManyWithoutMagicItemNestedInput
  }

  export type MagicItemUncheckedUpdateWithoutType_relationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    rarity_id?: StringFieldUpdateOperationsInput | string
    source_id?: IntFieldUpdateOperationsInput | number
    requires_attunement?: BoolFieldUpdateOperationsInput | boolean
    attunements_relation?: MagicItemAttunementUncheckedUpdateManyWithoutMagicItemNestedInput
  }

  export type MagicItemUncheckedUpdateManyWithoutType_relationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    rarity_id?: StringFieldUpdateOperationsInput | string
    source_id?: IntFieldUpdateOperationsInput | number
    requires_attunement?: BoolFieldUpdateOperationsInput | boolean
  }

  export type MagicItemAttunementCreateManyAttunementInput = {
    magicItemId: string
  }

  export type MagicItemAttunementUpdateWithoutAttunementInput = {
    magicItem?: MagicItemUpdateOneRequiredWithoutAttunements_relationNestedInput
  }

  export type MagicItemAttunementUncheckedUpdateWithoutAttunementInput = {
    magicItemId?: StringFieldUpdateOperationsInput | string
  }

  export type MagicItemAttunementUncheckedUpdateManyWithoutAttunementInput = {
    magicItemId?: StringFieldUpdateOperationsInput | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}