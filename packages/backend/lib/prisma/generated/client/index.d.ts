
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model Size
 * 
 */
export type Size = $Result.DefaultSelection<Prisma.$SizePayload>
/**
 * Model Source
 * 
 */
export type Source = $Result.DefaultSelection<Prisma.$SourcePayload>
/**
 * Model Language
 * 
 */
export type Language = $Result.DefaultSelection<Prisma.$LanguagePayload>
/**
 * Model Biome
 * 
 */
export type Biome = $Result.DefaultSelection<Prisma.$BiomePayload>
/**
 * Model Type
 * 
 */
export type Type = $Result.DefaultSelection<Prisma.$TypePayload>
/**
 * Model Alignment
 * 
 */
export type Alignment = $Result.DefaultSelection<Prisma.$AlignmentPayload>
/**
 * Model Speed_stat
 * 
 */
export type Speed_stat = $Result.DefaultSelection<Prisma.$Speed_statPayload>
/**
 * Model Creature_stats
 * 
 */
export type Creature_stats = $Result.DefaultSelection<Prisma.$Creature_statsPayload>
/**
 * Model Strength_stat_details
 * 
 */
export type Strength_stat_details = $Result.DefaultSelection<Prisma.$Strength_stat_detailsPayload>
/**
 * Model Dexterity_stat_details
 * 
 */
export type Dexterity_stat_details = $Result.DefaultSelection<Prisma.$Dexterity_stat_detailsPayload>
/**
 * Model Constitution_stat_details
 * 
 */
export type Constitution_stat_details = $Result.DefaultSelection<Prisma.$Constitution_stat_detailsPayload>
/**
 * Model Intelligence_stat_details
 * 
 */
export type Intelligence_stat_details = $Result.DefaultSelection<Prisma.$Intelligence_stat_detailsPayload>
/**
 * Model Wisdom_stat_details
 * 
 */
export type Wisdom_stat_details = $Result.DefaultSelection<Prisma.$Wisdom_stat_detailsPayload>
/**
 * Model Charisma_stat_details
 * 
 */
export type Charisma_stat_details = $Result.DefaultSelection<Prisma.$Charisma_stat_detailsPayload>
/**
 * Model SkillsList
 * 
 */
export type SkillsList = $Result.DefaultSelection<Prisma.$SkillsListPayload>
/**
 * Model StrengthBasedSkills
 * 
 */
export type StrengthBasedSkills = $Result.DefaultSelection<Prisma.$StrengthBasedSkillsPayload>
/**
 * Model DexterityBasedSkills
 * 
 */
export type DexterityBasedSkills = $Result.DefaultSelection<Prisma.$DexterityBasedSkillsPayload>
/**
 * Model IntellengenceBasedSkills
 * 
 */
export type IntellengenceBasedSkills = $Result.DefaultSelection<Prisma.$IntellengenceBasedSkillsPayload>
/**
 * Model WisdomBasedSkills
 * 
 */
export type WisdomBasedSkills = $Result.DefaultSelection<Prisma.$WisdomBasedSkillsPayload>
/**
 * Model CharismaBasedSkills
 * 
 */
export type CharismaBasedSkills = $Result.DefaultSelection<Prisma.$CharismaBasedSkillsPayload>
/**
 * Model AthleticsSkill
 * 
 */
export type AthleticsSkill = $Result.DefaultSelection<Prisma.$AthleticsSkillPayload>
/**
 * Model AcrobaticsSkill
 * 
 */
export type AcrobaticsSkill = $Result.DefaultSelection<Prisma.$AcrobaticsSkillPayload>
/**
 * Model SleightOfHandSkill
 * 
 */
export type SleightOfHandSkill = $Result.DefaultSelection<Prisma.$SleightOfHandSkillPayload>
/**
 * Model StealthSkill
 * 
 */
export type StealthSkill = $Result.DefaultSelection<Prisma.$StealthSkillPayload>
/**
 * Model ArcanaSkill
 * 
 */
export type ArcanaSkill = $Result.DefaultSelection<Prisma.$ArcanaSkillPayload>
/**
 * Model HistorySkill
 * 
 */
export type HistorySkill = $Result.DefaultSelection<Prisma.$HistorySkillPayload>
/**
 * Model InvestigationSkill
 * 
 */
export type InvestigationSkill = $Result.DefaultSelection<Prisma.$InvestigationSkillPayload>
/**
 * Model NatureSkill
 * 
 */
export type NatureSkill = $Result.DefaultSelection<Prisma.$NatureSkillPayload>
/**
 * Model ReligionSkill
 * 
 */
export type ReligionSkill = $Result.DefaultSelection<Prisma.$ReligionSkillPayload>
/**
 * Model AnimalHandlingSkill
 * 
 */
export type AnimalHandlingSkill = $Result.DefaultSelection<Prisma.$AnimalHandlingSkillPayload>
/**
 * Model InsightSkill
 * 
 */
export type InsightSkill = $Result.DefaultSelection<Prisma.$InsightSkillPayload>
/**
 * Model MedicineSkill
 * 
 */
export type MedicineSkill = $Result.DefaultSelection<Prisma.$MedicineSkillPayload>
/**
 * Model PerceptionSkill
 * 
 */
export type PerceptionSkill = $Result.DefaultSelection<Prisma.$PerceptionSkillPayload>
/**
 * Model SurvivalSkill
 * 
 */
export type SurvivalSkill = $Result.DefaultSelection<Prisma.$SurvivalSkillPayload>
/**
 * Model DeceptionSkill
 * 
 */
export type DeceptionSkill = $Result.DefaultSelection<Prisma.$DeceptionSkillPayload>
/**
 * Model IntimidationSkill
 * 
 */
export type IntimidationSkill = $Result.DefaultSelection<Prisma.$IntimidationSkillPayload>
/**
 * Model PerformanceSkill
 * 
 */
export type PerformanceSkill = $Result.DefaultSelection<Prisma.$PerformanceSkillPayload>
/**
 * Model PersuasionSkill
 * 
 */
export type PersuasionSkill = $Result.DefaultSelection<Prisma.$PersuasionSkillPayload>
/**
 * Model Creature
 * 
 */
export type Creature = $Result.DefaultSelection<Prisma.$CreaturePayload>
/**
 * Model Senses
 * 
 */
export type Senses = $Result.DefaultSelection<Prisma.$SensesPayload>
/**
 * Model Action
 * 
 */
export type Action = $Result.DefaultSelection<Prisma.$ActionPayload>
/**
 * Model Trait
 * 
 */
export type Trait = $Result.DefaultSelection<Prisma.$TraitPayload>
/**
 * Model CreatureRace
 * 
 */
export type CreatureRace = $Result.DefaultSelection<Prisma.$CreatureRacePayload>
/**
 * Model GenrationRequest
 * 
 */
export type GenrationRequest = $Result.DefaultSelection<Prisma.$GenrationRequestPayload>
/**
 * Model DamageType
 * 
 */
export type DamageType = $Result.DefaultSelection<Prisma.$DamageTypePayload>
/**
 * Model ChallengeRating
 * 
 */
export type ChallengeRating = $Result.DefaultSelection<Prisma.$ChallengeRatingPayload>
/**
 * Model GPTMessageHistory
 * 
 */
export type GPTMessageHistory = $Result.DefaultSelection<Prisma.$GPTMessageHistoryPayload>
/**
 * Model GPTMessage
 * 
 */
export type GPTMessage = $Result.DefaultSelection<Prisma.$GPTMessagePayload>
/**
 * Model Adventure
 * 
 */
export type Adventure = $Result.DefaultSelection<Prisma.$AdventurePayload>
/**
 * Model Genre
 * 
 */
export type Genre = $Result.DefaultSelection<Prisma.$GenrePayload>
/**
 * Model Keyword
 * 
 */
export type Keyword = $Result.DefaultSelection<Prisma.$KeywordPayload>
/**
 * Model AdventureKeyword
 * 
 */
export type AdventureKeyword = $Result.DefaultSelection<Prisma.$AdventureKeywordPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const Stat: {
  Strength: 'Strength',
  Dexterity: 'Dexterity',
  Constitution: 'Constitution',
  Intelegence: 'Intelegence',
  Wisdom: 'Wisdom',
  Charisma: 'Charisma'
};

export type Stat = (typeof Stat)[keyof typeof Stat]

}

export type Stat = $Enums.Stat

export const Stat: typeof $Enums.Stat

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Sizes
 * const sizes = await prisma.size.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Sizes
   * const sizes = await prisma.size.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb, ExtArgs, $Utils.Call<Prisma.TypeMapCb, {
    extArgs: ExtArgs
  }>, ClientOptions>

      /**
   * `prisma.size`: Exposes CRUD operations for the **Size** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Sizes
    * const sizes = await prisma.size.findMany()
    * ```
    */
  get size(): Prisma.SizeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.source`: Exposes CRUD operations for the **Source** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Sources
    * const sources = await prisma.source.findMany()
    * ```
    */
  get source(): Prisma.SourceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.language`: Exposes CRUD operations for the **Language** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Languages
    * const languages = await prisma.language.findMany()
    * ```
    */
  get language(): Prisma.LanguageDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.biome`: Exposes CRUD operations for the **Biome** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Biomes
    * const biomes = await prisma.biome.findMany()
    * ```
    */
  get biome(): Prisma.BiomeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.type`: Exposes CRUD operations for the **Type** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Types
    * const types = await prisma.type.findMany()
    * ```
    */
  get type(): Prisma.TypeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.alignment`: Exposes CRUD operations for the **Alignment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Alignments
    * const alignments = await prisma.alignment.findMany()
    * ```
    */
  get alignment(): Prisma.AlignmentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.speed_stat`: Exposes CRUD operations for the **Speed_stat** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Speed_stats
    * const speed_stats = await prisma.speed_stat.findMany()
    * ```
    */
  get speed_stat(): Prisma.Speed_statDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.creature_stats`: Exposes CRUD operations for the **Creature_stats** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Creature_stats
    * const creature_stats = await prisma.creature_stats.findMany()
    * ```
    */
  get creature_stats(): Prisma.Creature_statsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.strength_stat_details`: Exposes CRUD operations for the **Strength_stat_details** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Strength_stat_details
    * const strength_stat_details = await prisma.strength_stat_details.findMany()
    * ```
    */
  get strength_stat_details(): Prisma.Strength_stat_detailsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.dexterity_stat_details`: Exposes CRUD operations for the **Dexterity_stat_details** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Dexterity_stat_details
    * const dexterity_stat_details = await prisma.dexterity_stat_details.findMany()
    * ```
    */
  get dexterity_stat_details(): Prisma.Dexterity_stat_detailsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.constitution_stat_details`: Exposes CRUD operations for the **Constitution_stat_details** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Constitution_stat_details
    * const constitution_stat_details = await prisma.constitution_stat_details.findMany()
    * ```
    */
  get constitution_stat_details(): Prisma.Constitution_stat_detailsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.intelligence_stat_details`: Exposes CRUD operations for the **Intelligence_stat_details** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Intelligence_stat_details
    * const intelligence_stat_details = await prisma.intelligence_stat_details.findMany()
    * ```
    */
  get intelligence_stat_details(): Prisma.Intelligence_stat_detailsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.wisdom_stat_details`: Exposes CRUD operations for the **Wisdom_stat_details** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Wisdom_stat_details
    * const wisdom_stat_details = await prisma.wisdom_stat_details.findMany()
    * ```
    */
  get wisdom_stat_details(): Prisma.Wisdom_stat_detailsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.charisma_stat_details`: Exposes CRUD operations for the **Charisma_stat_details** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Charisma_stat_details
    * const charisma_stat_details = await prisma.charisma_stat_details.findMany()
    * ```
    */
  get charisma_stat_details(): Prisma.Charisma_stat_detailsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.skillsList`: Exposes CRUD operations for the **SkillsList** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SkillsLists
    * const skillsLists = await prisma.skillsList.findMany()
    * ```
    */
  get skillsList(): Prisma.SkillsListDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.strengthBasedSkills`: Exposes CRUD operations for the **StrengthBasedSkills** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more StrengthBasedSkills
    * const strengthBasedSkills = await prisma.strengthBasedSkills.findMany()
    * ```
    */
  get strengthBasedSkills(): Prisma.StrengthBasedSkillsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.dexterityBasedSkills`: Exposes CRUD operations for the **DexterityBasedSkills** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DexterityBasedSkills
    * const dexterityBasedSkills = await prisma.dexterityBasedSkills.findMany()
    * ```
    */
  get dexterityBasedSkills(): Prisma.DexterityBasedSkillsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.intellengenceBasedSkills`: Exposes CRUD operations for the **IntellengenceBasedSkills** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more IntellengenceBasedSkills
    * const intellengenceBasedSkills = await prisma.intellengenceBasedSkills.findMany()
    * ```
    */
  get intellengenceBasedSkills(): Prisma.IntellengenceBasedSkillsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.wisdomBasedSkills`: Exposes CRUD operations for the **WisdomBasedSkills** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WisdomBasedSkills
    * const wisdomBasedSkills = await prisma.wisdomBasedSkills.findMany()
    * ```
    */
  get wisdomBasedSkills(): Prisma.WisdomBasedSkillsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.charismaBasedSkills`: Exposes CRUD operations for the **CharismaBasedSkills** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CharismaBasedSkills
    * const charismaBasedSkills = await prisma.charismaBasedSkills.findMany()
    * ```
    */
  get charismaBasedSkills(): Prisma.CharismaBasedSkillsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.athleticsSkill`: Exposes CRUD operations for the **AthleticsSkill** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AthleticsSkills
    * const athleticsSkills = await prisma.athleticsSkill.findMany()
    * ```
    */
  get athleticsSkill(): Prisma.AthleticsSkillDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.acrobaticsSkill`: Exposes CRUD operations for the **AcrobaticsSkill** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AcrobaticsSkills
    * const acrobaticsSkills = await prisma.acrobaticsSkill.findMany()
    * ```
    */
  get acrobaticsSkill(): Prisma.AcrobaticsSkillDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.sleightOfHandSkill`: Exposes CRUD operations for the **SleightOfHandSkill** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SleightOfHandSkills
    * const sleightOfHandSkills = await prisma.sleightOfHandSkill.findMany()
    * ```
    */
  get sleightOfHandSkill(): Prisma.SleightOfHandSkillDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.stealthSkill`: Exposes CRUD operations for the **StealthSkill** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more StealthSkills
    * const stealthSkills = await prisma.stealthSkill.findMany()
    * ```
    */
  get stealthSkill(): Prisma.StealthSkillDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.arcanaSkill`: Exposes CRUD operations for the **ArcanaSkill** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ArcanaSkills
    * const arcanaSkills = await prisma.arcanaSkill.findMany()
    * ```
    */
  get arcanaSkill(): Prisma.ArcanaSkillDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.historySkill`: Exposes CRUD operations for the **HistorySkill** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more HistorySkills
    * const historySkills = await prisma.historySkill.findMany()
    * ```
    */
  get historySkill(): Prisma.HistorySkillDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.investigationSkill`: Exposes CRUD operations for the **InvestigationSkill** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more InvestigationSkills
    * const investigationSkills = await prisma.investigationSkill.findMany()
    * ```
    */
  get investigationSkill(): Prisma.InvestigationSkillDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.natureSkill`: Exposes CRUD operations for the **NatureSkill** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more NatureSkills
    * const natureSkills = await prisma.natureSkill.findMany()
    * ```
    */
  get natureSkill(): Prisma.NatureSkillDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.religionSkill`: Exposes CRUD operations for the **ReligionSkill** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ReligionSkills
    * const religionSkills = await prisma.religionSkill.findMany()
    * ```
    */
  get religionSkill(): Prisma.ReligionSkillDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.animalHandlingSkill`: Exposes CRUD operations for the **AnimalHandlingSkill** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AnimalHandlingSkills
    * const animalHandlingSkills = await prisma.animalHandlingSkill.findMany()
    * ```
    */
  get animalHandlingSkill(): Prisma.AnimalHandlingSkillDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.insightSkill`: Exposes CRUD operations for the **InsightSkill** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more InsightSkills
    * const insightSkills = await prisma.insightSkill.findMany()
    * ```
    */
  get insightSkill(): Prisma.InsightSkillDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.medicineSkill`: Exposes CRUD operations for the **MedicineSkill** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MedicineSkills
    * const medicineSkills = await prisma.medicineSkill.findMany()
    * ```
    */
  get medicineSkill(): Prisma.MedicineSkillDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.perceptionSkill`: Exposes CRUD operations for the **PerceptionSkill** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PerceptionSkills
    * const perceptionSkills = await prisma.perceptionSkill.findMany()
    * ```
    */
  get perceptionSkill(): Prisma.PerceptionSkillDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.survivalSkill`: Exposes CRUD operations for the **SurvivalSkill** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SurvivalSkills
    * const survivalSkills = await prisma.survivalSkill.findMany()
    * ```
    */
  get survivalSkill(): Prisma.SurvivalSkillDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.deceptionSkill`: Exposes CRUD operations for the **DeceptionSkill** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DeceptionSkills
    * const deceptionSkills = await prisma.deceptionSkill.findMany()
    * ```
    */
  get deceptionSkill(): Prisma.DeceptionSkillDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.intimidationSkill`: Exposes CRUD operations for the **IntimidationSkill** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more IntimidationSkills
    * const intimidationSkills = await prisma.intimidationSkill.findMany()
    * ```
    */
  get intimidationSkill(): Prisma.IntimidationSkillDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.performanceSkill`: Exposes CRUD operations for the **PerformanceSkill** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PerformanceSkills
    * const performanceSkills = await prisma.performanceSkill.findMany()
    * ```
    */
  get performanceSkill(): Prisma.PerformanceSkillDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.persuasionSkill`: Exposes CRUD operations for the **PersuasionSkill** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PersuasionSkills
    * const persuasionSkills = await prisma.persuasionSkill.findMany()
    * ```
    */
  get persuasionSkill(): Prisma.PersuasionSkillDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.creature`: Exposes CRUD operations for the **Creature** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Creatures
    * const creatures = await prisma.creature.findMany()
    * ```
    */
  get creature(): Prisma.CreatureDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.senses`: Exposes CRUD operations for the **Senses** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Senses
    * const senses = await prisma.senses.findMany()
    * ```
    */
  get senses(): Prisma.SensesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.action`: Exposes CRUD operations for the **Action** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Actions
    * const actions = await prisma.action.findMany()
    * ```
    */
  get action(): Prisma.ActionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.trait`: Exposes CRUD operations for the **Trait** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Traits
    * const traits = await prisma.trait.findMany()
    * ```
    */
  get trait(): Prisma.TraitDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.creatureRace`: Exposes CRUD operations for the **CreatureRace** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CreatureRaces
    * const creatureRaces = await prisma.creatureRace.findMany()
    * ```
    */
  get creatureRace(): Prisma.CreatureRaceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.genrationRequest`: Exposes CRUD operations for the **GenrationRequest** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more GenrationRequests
    * const genrationRequests = await prisma.genrationRequest.findMany()
    * ```
    */
  get genrationRequest(): Prisma.GenrationRequestDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.damageType`: Exposes CRUD operations for the **DamageType** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DamageTypes
    * const damageTypes = await prisma.damageType.findMany()
    * ```
    */
  get damageType(): Prisma.DamageTypeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.challengeRating`: Exposes CRUD operations for the **ChallengeRating** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ChallengeRatings
    * const challengeRatings = await prisma.challengeRating.findMany()
    * ```
    */
  get challengeRating(): Prisma.ChallengeRatingDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.gPTMessageHistory`: Exposes CRUD operations for the **GPTMessageHistory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more GPTMessageHistories
    * const gPTMessageHistories = await prisma.gPTMessageHistory.findMany()
    * ```
    */
  get gPTMessageHistory(): Prisma.GPTMessageHistoryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.gPTMessage`: Exposes CRUD operations for the **GPTMessage** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more GPTMessages
    * const gPTMessages = await prisma.gPTMessage.findMany()
    * ```
    */
  get gPTMessage(): Prisma.GPTMessageDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.adventure`: Exposes CRUD operations for the **Adventure** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Adventures
    * const adventures = await prisma.adventure.findMany()
    * ```
    */
  get adventure(): Prisma.AdventureDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.genre`: Exposes CRUD operations for the **Genre** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Genres
    * const genres = await prisma.genre.findMany()
    * ```
    */
  get genre(): Prisma.GenreDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.keyword`: Exposes CRUD operations for the **Keyword** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Keywords
    * const keywords = await prisma.keyword.findMany()
    * ```
    */
  get keyword(): Prisma.KeywordDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.adventureKeyword`: Exposes CRUD operations for the **AdventureKeyword** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AdventureKeywords
    * const adventureKeywords = await prisma.adventureKeyword.findMany()
    * ```
    */
  get adventureKeyword(): Prisma.AdventureKeywordDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.4.1
   * Query Engine version: 173f8d54f8d52e692c7e27e72a88314ec7aeff60
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Size: 'Size',
    Source: 'Source',
    Language: 'Language',
    Biome: 'Biome',
    Type: 'Type',
    Alignment: 'Alignment',
    Speed_stat: 'Speed_stat',
    Creature_stats: 'Creature_stats',
    Strength_stat_details: 'Strength_stat_details',
    Dexterity_stat_details: 'Dexterity_stat_details',
    Constitution_stat_details: 'Constitution_stat_details',
    Intelligence_stat_details: 'Intelligence_stat_details',
    Wisdom_stat_details: 'Wisdom_stat_details',
    Charisma_stat_details: 'Charisma_stat_details',
    SkillsList: 'SkillsList',
    StrengthBasedSkills: 'StrengthBasedSkills',
    DexterityBasedSkills: 'DexterityBasedSkills',
    IntellengenceBasedSkills: 'IntellengenceBasedSkills',
    WisdomBasedSkills: 'WisdomBasedSkills',
    CharismaBasedSkills: 'CharismaBasedSkills',
    AthleticsSkill: 'AthleticsSkill',
    AcrobaticsSkill: 'AcrobaticsSkill',
    SleightOfHandSkill: 'SleightOfHandSkill',
    StealthSkill: 'StealthSkill',
    ArcanaSkill: 'ArcanaSkill',
    HistorySkill: 'HistorySkill',
    InvestigationSkill: 'InvestigationSkill',
    NatureSkill: 'NatureSkill',
    ReligionSkill: 'ReligionSkill',
    AnimalHandlingSkill: 'AnimalHandlingSkill',
    InsightSkill: 'InsightSkill',
    MedicineSkill: 'MedicineSkill',
    PerceptionSkill: 'PerceptionSkill',
    SurvivalSkill: 'SurvivalSkill',
    DeceptionSkill: 'DeceptionSkill',
    IntimidationSkill: 'IntimidationSkill',
    PerformanceSkill: 'PerformanceSkill',
    PersuasionSkill: 'PersuasionSkill',
    Creature: 'Creature',
    Senses: 'Senses',
    Action: 'Action',
    Trait: 'Trait',
    CreatureRace: 'CreatureRace',
    GenrationRequest: 'GenrationRequest',
    DamageType: 'DamageType',
    ChallengeRating: 'ChallengeRating',
    GPTMessageHistory: 'GPTMessageHistory',
    GPTMessage: 'GPTMessage',
    Adventure: 'Adventure',
    Genre: 'Genre',
    Keyword: 'Keyword',
    AdventureKeyword: 'AdventureKeyword'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs, clientOptions: PrismaClientOptions }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], this['params']['clientOptions']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> = {
    meta: {
      modelProps: "size" | "source" | "language" | "biome" | "type" | "alignment" | "speed_stat" | "creature_stats" | "strength_stat_details" | "dexterity_stat_details" | "constitution_stat_details" | "intelligence_stat_details" | "wisdom_stat_details" | "charisma_stat_details" | "skillsList" | "strengthBasedSkills" | "dexterityBasedSkills" | "intellengenceBasedSkills" | "wisdomBasedSkills" | "charismaBasedSkills" | "athleticsSkill" | "acrobaticsSkill" | "sleightOfHandSkill" | "stealthSkill" | "arcanaSkill" | "historySkill" | "investigationSkill" | "natureSkill" | "religionSkill" | "animalHandlingSkill" | "insightSkill" | "medicineSkill" | "perceptionSkill" | "survivalSkill" | "deceptionSkill" | "intimidationSkill" | "performanceSkill" | "persuasionSkill" | "creature" | "senses" | "action" | "trait" | "creatureRace" | "genrationRequest" | "damageType" | "challengeRating" | "gPTMessageHistory" | "gPTMessage" | "adventure" | "genre" | "keyword" | "adventureKeyword"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      Size: {
        payload: Prisma.$SizePayload<ExtArgs>
        fields: Prisma.SizeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SizeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SizePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SizeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SizePayload>
          }
          findFirst: {
            args: Prisma.SizeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SizePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SizeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SizePayload>
          }
          findMany: {
            args: Prisma.SizeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SizePayload>[]
          }
          create: {
            args: Prisma.SizeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SizePayload>
          }
          createMany: {
            args: Prisma.SizeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SizeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SizePayload>[]
          }
          delete: {
            args: Prisma.SizeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SizePayload>
          }
          update: {
            args: Prisma.SizeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SizePayload>
          }
          deleteMany: {
            args: Prisma.SizeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SizeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SizeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SizePayload>[]
          }
          upsert: {
            args: Prisma.SizeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SizePayload>
          }
          aggregate: {
            args: Prisma.SizeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSize>
          }
          groupBy: {
            args: Prisma.SizeGroupByArgs<ExtArgs>
            result: $Utils.Optional<SizeGroupByOutputType>[]
          }
          count: {
            args: Prisma.SizeCountArgs<ExtArgs>
            result: $Utils.Optional<SizeCountAggregateOutputType> | number
          }
        }
      }
      Source: {
        payload: Prisma.$SourcePayload<ExtArgs>
        fields: Prisma.SourceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SourceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SourcePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SourceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SourcePayload>
          }
          findFirst: {
            args: Prisma.SourceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SourcePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SourceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SourcePayload>
          }
          findMany: {
            args: Prisma.SourceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SourcePayload>[]
          }
          create: {
            args: Prisma.SourceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SourcePayload>
          }
          createMany: {
            args: Prisma.SourceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SourceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SourcePayload>[]
          }
          delete: {
            args: Prisma.SourceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SourcePayload>
          }
          update: {
            args: Prisma.SourceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SourcePayload>
          }
          deleteMany: {
            args: Prisma.SourceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SourceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SourceUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SourcePayload>[]
          }
          upsert: {
            args: Prisma.SourceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SourcePayload>
          }
          aggregate: {
            args: Prisma.SourceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSource>
          }
          groupBy: {
            args: Prisma.SourceGroupByArgs<ExtArgs>
            result: $Utils.Optional<SourceGroupByOutputType>[]
          }
          count: {
            args: Prisma.SourceCountArgs<ExtArgs>
            result: $Utils.Optional<SourceCountAggregateOutputType> | number
          }
        }
      }
      Language: {
        payload: Prisma.$LanguagePayload<ExtArgs>
        fields: Prisma.LanguageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LanguageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LanguagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LanguageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LanguagePayload>
          }
          findFirst: {
            args: Prisma.LanguageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LanguagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LanguageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LanguagePayload>
          }
          findMany: {
            args: Prisma.LanguageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LanguagePayload>[]
          }
          create: {
            args: Prisma.LanguageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LanguagePayload>
          }
          createMany: {
            args: Prisma.LanguageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LanguageCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LanguagePayload>[]
          }
          delete: {
            args: Prisma.LanguageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LanguagePayload>
          }
          update: {
            args: Prisma.LanguageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LanguagePayload>
          }
          deleteMany: {
            args: Prisma.LanguageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LanguageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.LanguageUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LanguagePayload>[]
          }
          upsert: {
            args: Prisma.LanguageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LanguagePayload>
          }
          aggregate: {
            args: Prisma.LanguageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLanguage>
          }
          groupBy: {
            args: Prisma.LanguageGroupByArgs<ExtArgs>
            result: $Utils.Optional<LanguageGroupByOutputType>[]
          }
          count: {
            args: Prisma.LanguageCountArgs<ExtArgs>
            result: $Utils.Optional<LanguageCountAggregateOutputType> | number
          }
        }
      }
      Biome: {
        payload: Prisma.$BiomePayload<ExtArgs>
        fields: Prisma.BiomeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BiomeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BiomePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BiomeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BiomePayload>
          }
          findFirst: {
            args: Prisma.BiomeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BiomePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BiomeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BiomePayload>
          }
          findMany: {
            args: Prisma.BiomeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BiomePayload>[]
          }
          create: {
            args: Prisma.BiomeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BiomePayload>
          }
          createMany: {
            args: Prisma.BiomeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BiomeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BiomePayload>[]
          }
          delete: {
            args: Prisma.BiomeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BiomePayload>
          }
          update: {
            args: Prisma.BiomeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BiomePayload>
          }
          deleteMany: {
            args: Prisma.BiomeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BiomeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BiomeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BiomePayload>[]
          }
          upsert: {
            args: Prisma.BiomeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BiomePayload>
          }
          aggregate: {
            args: Prisma.BiomeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBiome>
          }
          groupBy: {
            args: Prisma.BiomeGroupByArgs<ExtArgs>
            result: $Utils.Optional<BiomeGroupByOutputType>[]
          }
          count: {
            args: Prisma.BiomeCountArgs<ExtArgs>
            result: $Utils.Optional<BiomeCountAggregateOutputType> | number
          }
        }
      }
      Type: {
        payload: Prisma.$TypePayload<ExtArgs>
        fields: Prisma.TypeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TypeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TypePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TypeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TypePayload>
          }
          findFirst: {
            args: Prisma.TypeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TypePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TypeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TypePayload>
          }
          findMany: {
            args: Prisma.TypeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TypePayload>[]
          }
          create: {
            args: Prisma.TypeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TypePayload>
          }
          createMany: {
            args: Prisma.TypeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TypeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TypePayload>[]
          }
          delete: {
            args: Prisma.TypeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TypePayload>
          }
          update: {
            args: Prisma.TypeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TypePayload>
          }
          deleteMany: {
            args: Prisma.TypeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TypeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TypeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TypePayload>[]
          }
          upsert: {
            args: Prisma.TypeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TypePayload>
          }
          aggregate: {
            args: Prisma.TypeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateType>
          }
          groupBy: {
            args: Prisma.TypeGroupByArgs<ExtArgs>
            result: $Utils.Optional<TypeGroupByOutputType>[]
          }
          count: {
            args: Prisma.TypeCountArgs<ExtArgs>
            result: $Utils.Optional<TypeCountAggregateOutputType> | number
          }
        }
      }
      Alignment: {
        payload: Prisma.$AlignmentPayload<ExtArgs>
        fields: Prisma.AlignmentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AlignmentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlignmentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AlignmentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlignmentPayload>
          }
          findFirst: {
            args: Prisma.AlignmentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlignmentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AlignmentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlignmentPayload>
          }
          findMany: {
            args: Prisma.AlignmentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlignmentPayload>[]
          }
          create: {
            args: Prisma.AlignmentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlignmentPayload>
          }
          createMany: {
            args: Prisma.AlignmentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AlignmentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlignmentPayload>[]
          }
          delete: {
            args: Prisma.AlignmentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlignmentPayload>
          }
          update: {
            args: Prisma.AlignmentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlignmentPayload>
          }
          deleteMany: {
            args: Prisma.AlignmentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AlignmentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AlignmentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlignmentPayload>[]
          }
          upsert: {
            args: Prisma.AlignmentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlignmentPayload>
          }
          aggregate: {
            args: Prisma.AlignmentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAlignment>
          }
          groupBy: {
            args: Prisma.AlignmentGroupByArgs<ExtArgs>
            result: $Utils.Optional<AlignmentGroupByOutputType>[]
          }
          count: {
            args: Prisma.AlignmentCountArgs<ExtArgs>
            result: $Utils.Optional<AlignmentCountAggregateOutputType> | number
          }
        }
      }
      Speed_stat: {
        payload: Prisma.$Speed_statPayload<ExtArgs>
        fields: Prisma.Speed_statFieldRefs
        operations: {
          findUnique: {
            args: Prisma.Speed_statFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Speed_statPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.Speed_statFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Speed_statPayload>
          }
          findFirst: {
            args: Prisma.Speed_statFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Speed_statPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.Speed_statFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Speed_statPayload>
          }
          findMany: {
            args: Prisma.Speed_statFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Speed_statPayload>[]
          }
          create: {
            args: Prisma.Speed_statCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Speed_statPayload>
          }
          createMany: {
            args: Prisma.Speed_statCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.Speed_statCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Speed_statPayload>[]
          }
          delete: {
            args: Prisma.Speed_statDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Speed_statPayload>
          }
          update: {
            args: Prisma.Speed_statUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Speed_statPayload>
          }
          deleteMany: {
            args: Prisma.Speed_statDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.Speed_statUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.Speed_statUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Speed_statPayload>[]
          }
          upsert: {
            args: Prisma.Speed_statUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Speed_statPayload>
          }
          aggregate: {
            args: Prisma.Speed_statAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSpeed_stat>
          }
          groupBy: {
            args: Prisma.Speed_statGroupByArgs<ExtArgs>
            result: $Utils.Optional<Speed_statGroupByOutputType>[]
          }
          count: {
            args: Prisma.Speed_statCountArgs<ExtArgs>
            result: $Utils.Optional<Speed_statCountAggregateOutputType> | number
          }
        }
      }
      Creature_stats: {
        payload: Prisma.$Creature_statsPayload<ExtArgs>
        fields: Prisma.Creature_statsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.Creature_statsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Creature_statsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.Creature_statsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Creature_statsPayload>
          }
          findFirst: {
            args: Prisma.Creature_statsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Creature_statsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.Creature_statsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Creature_statsPayload>
          }
          findMany: {
            args: Prisma.Creature_statsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Creature_statsPayload>[]
          }
          create: {
            args: Prisma.Creature_statsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Creature_statsPayload>
          }
          createMany: {
            args: Prisma.Creature_statsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.Creature_statsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Creature_statsPayload>[]
          }
          delete: {
            args: Prisma.Creature_statsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Creature_statsPayload>
          }
          update: {
            args: Prisma.Creature_statsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Creature_statsPayload>
          }
          deleteMany: {
            args: Prisma.Creature_statsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.Creature_statsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.Creature_statsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Creature_statsPayload>[]
          }
          upsert: {
            args: Prisma.Creature_statsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Creature_statsPayload>
          }
          aggregate: {
            args: Prisma.Creature_statsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCreature_stats>
          }
          groupBy: {
            args: Prisma.Creature_statsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Creature_statsGroupByOutputType>[]
          }
          count: {
            args: Prisma.Creature_statsCountArgs<ExtArgs>
            result: $Utils.Optional<Creature_statsCountAggregateOutputType> | number
          }
        }
      }
      Strength_stat_details: {
        payload: Prisma.$Strength_stat_detailsPayload<ExtArgs>
        fields: Prisma.Strength_stat_detailsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.Strength_stat_detailsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Strength_stat_detailsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.Strength_stat_detailsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Strength_stat_detailsPayload>
          }
          findFirst: {
            args: Prisma.Strength_stat_detailsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Strength_stat_detailsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.Strength_stat_detailsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Strength_stat_detailsPayload>
          }
          findMany: {
            args: Prisma.Strength_stat_detailsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Strength_stat_detailsPayload>[]
          }
          create: {
            args: Prisma.Strength_stat_detailsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Strength_stat_detailsPayload>
          }
          createMany: {
            args: Prisma.Strength_stat_detailsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.Strength_stat_detailsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Strength_stat_detailsPayload>[]
          }
          delete: {
            args: Prisma.Strength_stat_detailsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Strength_stat_detailsPayload>
          }
          update: {
            args: Prisma.Strength_stat_detailsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Strength_stat_detailsPayload>
          }
          deleteMany: {
            args: Prisma.Strength_stat_detailsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.Strength_stat_detailsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.Strength_stat_detailsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Strength_stat_detailsPayload>[]
          }
          upsert: {
            args: Prisma.Strength_stat_detailsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Strength_stat_detailsPayload>
          }
          aggregate: {
            args: Prisma.Strength_stat_detailsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStrength_stat_details>
          }
          groupBy: {
            args: Prisma.Strength_stat_detailsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Strength_stat_detailsGroupByOutputType>[]
          }
          count: {
            args: Prisma.Strength_stat_detailsCountArgs<ExtArgs>
            result: $Utils.Optional<Strength_stat_detailsCountAggregateOutputType> | number
          }
        }
      }
      Dexterity_stat_details: {
        payload: Prisma.$Dexterity_stat_detailsPayload<ExtArgs>
        fields: Prisma.Dexterity_stat_detailsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.Dexterity_stat_detailsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Dexterity_stat_detailsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.Dexterity_stat_detailsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Dexterity_stat_detailsPayload>
          }
          findFirst: {
            args: Prisma.Dexterity_stat_detailsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Dexterity_stat_detailsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.Dexterity_stat_detailsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Dexterity_stat_detailsPayload>
          }
          findMany: {
            args: Prisma.Dexterity_stat_detailsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Dexterity_stat_detailsPayload>[]
          }
          create: {
            args: Prisma.Dexterity_stat_detailsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Dexterity_stat_detailsPayload>
          }
          createMany: {
            args: Prisma.Dexterity_stat_detailsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.Dexterity_stat_detailsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Dexterity_stat_detailsPayload>[]
          }
          delete: {
            args: Prisma.Dexterity_stat_detailsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Dexterity_stat_detailsPayload>
          }
          update: {
            args: Prisma.Dexterity_stat_detailsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Dexterity_stat_detailsPayload>
          }
          deleteMany: {
            args: Prisma.Dexterity_stat_detailsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.Dexterity_stat_detailsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.Dexterity_stat_detailsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Dexterity_stat_detailsPayload>[]
          }
          upsert: {
            args: Prisma.Dexterity_stat_detailsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Dexterity_stat_detailsPayload>
          }
          aggregate: {
            args: Prisma.Dexterity_stat_detailsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDexterity_stat_details>
          }
          groupBy: {
            args: Prisma.Dexterity_stat_detailsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Dexterity_stat_detailsGroupByOutputType>[]
          }
          count: {
            args: Prisma.Dexterity_stat_detailsCountArgs<ExtArgs>
            result: $Utils.Optional<Dexterity_stat_detailsCountAggregateOutputType> | number
          }
        }
      }
      Constitution_stat_details: {
        payload: Prisma.$Constitution_stat_detailsPayload<ExtArgs>
        fields: Prisma.Constitution_stat_detailsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.Constitution_stat_detailsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Constitution_stat_detailsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.Constitution_stat_detailsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Constitution_stat_detailsPayload>
          }
          findFirst: {
            args: Prisma.Constitution_stat_detailsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Constitution_stat_detailsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.Constitution_stat_detailsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Constitution_stat_detailsPayload>
          }
          findMany: {
            args: Prisma.Constitution_stat_detailsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Constitution_stat_detailsPayload>[]
          }
          create: {
            args: Prisma.Constitution_stat_detailsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Constitution_stat_detailsPayload>
          }
          createMany: {
            args: Prisma.Constitution_stat_detailsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.Constitution_stat_detailsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Constitution_stat_detailsPayload>[]
          }
          delete: {
            args: Prisma.Constitution_stat_detailsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Constitution_stat_detailsPayload>
          }
          update: {
            args: Prisma.Constitution_stat_detailsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Constitution_stat_detailsPayload>
          }
          deleteMany: {
            args: Prisma.Constitution_stat_detailsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.Constitution_stat_detailsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.Constitution_stat_detailsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Constitution_stat_detailsPayload>[]
          }
          upsert: {
            args: Prisma.Constitution_stat_detailsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Constitution_stat_detailsPayload>
          }
          aggregate: {
            args: Prisma.Constitution_stat_detailsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateConstitution_stat_details>
          }
          groupBy: {
            args: Prisma.Constitution_stat_detailsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Constitution_stat_detailsGroupByOutputType>[]
          }
          count: {
            args: Prisma.Constitution_stat_detailsCountArgs<ExtArgs>
            result: $Utils.Optional<Constitution_stat_detailsCountAggregateOutputType> | number
          }
        }
      }
      Intelligence_stat_details: {
        payload: Prisma.$Intelligence_stat_detailsPayload<ExtArgs>
        fields: Prisma.Intelligence_stat_detailsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.Intelligence_stat_detailsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Intelligence_stat_detailsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.Intelligence_stat_detailsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Intelligence_stat_detailsPayload>
          }
          findFirst: {
            args: Prisma.Intelligence_stat_detailsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Intelligence_stat_detailsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.Intelligence_stat_detailsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Intelligence_stat_detailsPayload>
          }
          findMany: {
            args: Prisma.Intelligence_stat_detailsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Intelligence_stat_detailsPayload>[]
          }
          create: {
            args: Prisma.Intelligence_stat_detailsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Intelligence_stat_detailsPayload>
          }
          createMany: {
            args: Prisma.Intelligence_stat_detailsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.Intelligence_stat_detailsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Intelligence_stat_detailsPayload>[]
          }
          delete: {
            args: Prisma.Intelligence_stat_detailsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Intelligence_stat_detailsPayload>
          }
          update: {
            args: Prisma.Intelligence_stat_detailsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Intelligence_stat_detailsPayload>
          }
          deleteMany: {
            args: Prisma.Intelligence_stat_detailsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.Intelligence_stat_detailsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.Intelligence_stat_detailsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Intelligence_stat_detailsPayload>[]
          }
          upsert: {
            args: Prisma.Intelligence_stat_detailsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Intelligence_stat_detailsPayload>
          }
          aggregate: {
            args: Prisma.Intelligence_stat_detailsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateIntelligence_stat_details>
          }
          groupBy: {
            args: Prisma.Intelligence_stat_detailsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Intelligence_stat_detailsGroupByOutputType>[]
          }
          count: {
            args: Prisma.Intelligence_stat_detailsCountArgs<ExtArgs>
            result: $Utils.Optional<Intelligence_stat_detailsCountAggregateOutputType> | number
          }
        }
      }
      Wisdom_stat_details: {
        payload: Prisma.$Wisdom_stat_detailsPayload<ExtArgs>
        fields: Prisma.Wisdom_stat_detailsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.Wisdom_stat_detailsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Wisdom_stat_detailsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.Wisdom_stat_detailsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Wisdom_stat_detailsPayload>
          }
          findFirst: {
            args: Prisma.Wisdom_stat_detailsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Wisdom_stat_detailsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.Wisdom_stat_detailsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Wisdom_stat_detailsPayload>
          }
          findMany: {
            args: Prisma.Wisdom_stat_detailsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Wisdom_stat_detailsPayload>[]
          }
          create: {
            args: Prisma.Wisdom_stat_detailsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Wisdom_stat_detailsPayload>
          }
          createMany: {
            args: Prisma.Wisdom_stat_detailsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.Wisdom_stat_detailsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Wisdom_stat_detailsPayload>[]
          }
          delete: {
            args: Prisma.Wisdom_stat_detailsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Wisdom_stat_detailsPayload>
          }
          update: {
            args: Prisma.Wisdom_stat_detailsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Wisdom_stat_detailsPayload>
          }
          deleteMany: {
            args: Prisma.Wisdom_stat_detailsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.Wisdom_stat_detailsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.Wisdom_stat_detailsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Wisdom_stat_detailsPayload>[]
          }
          upsert: {
            args: Prisma.Wisdom_stat_detailsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Wisdom_stat_detailsPayload>
          }
          aggregate: {
            args: Prisma.Wisdom_stat_detailsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWisdom_stat_details>
          }
          groupBy: {
            args: Prisma.Wisdom_stat_detailsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Wisdom_stat_detailsGroupByOutputType>[]
          }
          count: {
            args: Prisma.Wisdom_stat_detailsCountArgs<ExtArgs>
            result: $Utils.Optional<Wisdom_stat_detailsCountAggregateOutputType> | number
          }
        }
      }
      Charisma_stat_details: {
        payload: Prisma.$Charisma_stat_detailsPayload<ExtArgs>
        fields: Prisma.Charisma_stat_detailsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.Charisma_stat_detailsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Charisma_stat_detailsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.Charisma_stat_detailsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Charisma_stat_detailsPayload>
          }
          findFirst: {
            args: Prisma.Charisma_stat_detailsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Charisma_stat_detailsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.Charisma_stat_detailsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Charisma_stat_detailsPayload>
          }
          findMany: {
            args: Prisma.Charisma_stat_detailsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Charisma_stat_detailsPayload>[]
          }
          create: {
            args: Prisma.Charisma_stat_detailsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Charisma_stat_detailsPayload>
          }
          createMany: {
            args: Prisma.Charisma_stat_detailsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.Charisma_stat_detailsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Charisma_stat_detailsPayload>[]
          }
          delete: {
            args: Prisma.Charisma_stat_detailsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Charisma_stat_detailsPayload>
          }
          update: {
            args: Prisma.Charisma_stat_detailsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Charisma_stat_detailsPayload>
          }
          deleteMany: {
            args: Prisma.Charisma_stat_detailsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.Charisma_stat_detailsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.Charisma_stat_detailsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Charisma_stat_detailsPayload>[]
          }
          upsert: {
            args: Prisma.Charisma_stat_detailsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Charisma_stat_detailsPayload>
          }
          aggregate: {
            args: Prisma.Charisma_stat_detailsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCharisma_stat_details>
          }
          groupBy: {
            args: Prisma.Charisma_stat_detailsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Charisma_stat_detailsGroupByOutputType>[]
          }
          count: {
            args: Prisma.Charisma_stat_detailsCountArgs<ExtArgs>
            result: $Utils.Optional<Charisma_stat_detailsCountAggregateOutputType> | number
          }
        }
      }
      SkillsList: {
        payload: Prisma.$SkillsListPayload<ExtArgs>
        fields: Prisma.SkillsListFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SkillsListFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkillsListPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SkillsListFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkillsListPayload>
          }
          findFirst: {
            args: Prisma.SkillsListFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkillsListPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SkillsListFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkillsListPayload>
          }
          findMany: {
            args: Prisma.SkillsListFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkillsListPayload>[]
          }
          create: {
            args: Prisma.SkillsListCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkillsListPayload>
          }
          createMany: {
            args: Prisma.SkillsListCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SkillsListCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkillsListPayload>[]
          }
          delete: {
            args: Prisma.SkillsListDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkillsListPayload>
          }
          update: {
            args: Prisma.SkillsListUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkillsListPayload>
          }
          deleteMany: {
            args: Prisma.SkillsListDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SkillsListUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SkillsListUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkillsListPayload>[]
          }
          upsert: {
            args: Prisma.SkillsListUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkillsListPayload>
          }
          aggregate: {
            args: Prisma.SkillsListAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSkillsList>
          }
          groupBy: {
            args: Prisma.SkillsListGroupByArgs<ExtArgs>
            result: $Utils.Optional<SkillsListGroupByOutputType>[]
          }
          count: {
            args: Prisma.SkillsListCountArgs<ExtArgs>
            result: $Utils.Optional<SkillsListCountAggregateOutputType> | number
          }
        }
      }
      StrengthBasedSkills: {
        payload: Prisma.$StrengthBasedSkillsPayload<ExtArgs>
        fields: Prisma.StrengthBasedSkillsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StrengthBasedSkillsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StrengthBasedSkillsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StrengthBasedSkillsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StrengthBasedSkillsPayload>
          }
          findFirst: {
            args: Prisma.StrengthBasedSkillsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StrengthBasedSkillsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StrengthBasedSkillsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StrengthBasedSkillsPayload>
          }
          findMany: {
            args: Prisma.StrengthBasedSkillsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StrengthBasedSkillsPayload>[]
          }
          create: {
            args: Prisma.StrengthBasedSkillsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StrengthBasedSkillsPayload>
          }
          createMany: {
            args: Prisma.StrengthBasedSkillsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.StrengthBasedSkillsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StrengthBasedSkillsPayload>[]
          }
          delete: {
            args: Prisma.StrengthBasedSkillsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StrengthBasedSkillsPayload>
          }
          update: {
            args: Prisma.StrengthBasedSkillsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StrengthBasedSkillsPayload>
          }
          deleteMany: {
            args: Prisma.StrengthBasedSkillsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.StrengthBasedSkillsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.StrengthBasedSkillsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StrengthBasedSkillsPayload>[]
          }
          upsert: {
            args: Prisma.StrengthBasedSkillsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StrengthBasedSkillsPayload>
          }
          aggregate: {
            args: Prisma.StrengthBasedSkillsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStrengthBasedSkills>
          }
          groupBy: {
            args: Prisma.StrengthBasedSkillsGroupByArgs<ExtArgs>
            result: $Utils.Optional<StrengthBasedSkillsGroupByOutputType>[]
          }
          count: {
            args: Prisma.StrengthBasedSkillsCountArgs<ExtArgs>
            result: $Utils.Optional<StrengthBasedSkillsCountAggregateOutputType> | number
          }
        }
      }
      DexterityBasedSkills: {
        payload: Prisma.$DexterityBasedSkillsPayload<ExtArgs>
        fields: Prisma.DexterityBasedSkillsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DexterityBasedSkillsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DexterityBasedSkillsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DexterityBasedSkillsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DexterityBasedSkillsPayload>
          }
          findFirst: {
            args: Prisma.DexterityBasedSkillsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DexterityBasedSkillsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DexterityBasedSkillsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DexterityBasedSkillsPayload>
          }
          findMany: {
            args: Prisma.DexterityBasedSkillsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DexterityBasedSkillsPayload>[]
          }
          create: {
            args: Prisma.DexterityBasedSkillsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DexterityBasedSkillsPayload>
          }
          createMany: {
            args: Prisma.DexterityBasedSkillsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DexterityBasedSkillsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DexterityBasedSkillsPayload>[]
          }
          delete: {
            args: Prisma.DexterityBasedSkillsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DexterityBasedSkillsPayload>
          }
          update: {
            args: Prisma.DexterityBasedSkillsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DexterityBasedSkillsPayload>
          }
          deleteMany: {
            args: Prisma.DexterityBasedSkillsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DexterityBasedSkillsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DexterityBasedSkillsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DexterityBasedSkillsPayload>[]
          }
          upsert: {
            args: Prisma.DexterityBasedSkillsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DexterityBasedSkillsPayload>
          }
          aggregate: {
            args: Prisma.DexterityBasedSkillsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDexterityBasedSkills>
          }
          groupBy: {
            args: Prisma.DexterityBasedSkillsGroupByArgs<ExtArgs>
            result: $Utils.Optional<DexterityBasedSkillsGroupByOutputType>[]
          }
          count: {
            args: Prisma.DexterityBasedSkillsCountArgs<ExtArgs>
            result: $Utils.Optional<DexterityBasedSkillsCountAggregateOutputType> | number
          }
        }
      }
      IntellengenceBasedSkills: {
        payload: Prisma.$IntellengenceBasedSkillsPayload<ExtArgs>
        fields: Prisma.IntellengenceBasedSkillsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.IntellengenceBasedSkillsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IntellengenceBasedSkillsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.IntellengenceBasedSkillsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IntellengenceBasedSkillsPayload>
          }
          findFirst: {
            args: Prisma.IntellengenceBasedSkillsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IntellengenceBasedSkillsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.IntellengenceBasedSkillsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IntellengenceBasedSkillsPayload>
          }
          findMany: {
            args: Prisma.IntellengenceBasedSkillsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IntellengenceBasedSkillsPayload>[]
          }
          create: {
            args: Prisma.IntellengenceBasedSkillsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IntellengenceBasedSkillsPayload>
          }
          createMany: {
            args: Prisma.IntellengenceBasedSkillsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.IntellengenceBasedSkillsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IntellengenceBasedSkillsPayload>[]
          }
          delete: {
            args: Prisma.IntellengenceBasedSkillsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IntellengenceBasedSkillsPayload>
          }
          update: {
            args: Prisma.IntellengenceBasedSkillsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IntellengenceBasedSkillsPayload>
          }
          deleteMany: {
            args: Prisma.IntellengenceBasedSkillsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.IntellengenceBasedSkillsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.IntellengenceBasedSkillsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IntellengenceBasedSkillsPayload>[]
          }
          upsert: {
            args: Prisma.IntellengenceBasedSkillsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IntellengenceBasedSkillsPayload>
          }
          aggregate: {
            args: Prisma.IntellengenceBasedSkillsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateIntellengenceBasedSkills>
          }
          groupBy: {
            args: Prisma.IntellengenceBasedSkillsGroupByArgs<ExtArgs>
            result: $Utils.Optional<IntellengenceBasedSkillsGroupByOutputType>[]
          }
          count: {
            args: Prisma.IntellengenceBasedSkillsCountArgs<ExtArgs>
            result: $Utils.Optional<IntellengenceBasedSkillsCountAggregateOutputType> | number
          }
        }
      }
      WisdomBasedSkills: {
        payload: Prisma.$WisdomBasedSkillsPayload<ExtArgs>
        fields: Prisma.WisdomBasedSkillsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WisdomBasedSkillsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WisdomBasedSkillsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WisdomBasedSkillsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WisdomBasedSkillsPayload>
          }
          findFirst: {
            args: Prisma.WisdomBasedSkillsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WisdomBasedSkillsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WisdomBasedSkillsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WisdomBasedSkillsPayload>
          }
          findMany: {
            args: Prisma.WisdomBasedSkillsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WisdomBasedSkillsPayload>[]
          }
          create: {
            args: Prisma.WisdomBasedSkillsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WisdomBasedSkillsPayload>
          }
          createMany: {
            args: Prisma.WisdomBasedSkillsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.WisdomBasedSkillsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WisdomBasedSkillsPayload>[]
          }
          delete: {
            args: Prisma.WisdomBasedSkillsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WisdomBasedSkillsPayload>
          }
          update: {
            args: Prisma.WisdomBasedSkillsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WisdomBasedSkillsPayload>
          }
          deleteMany: {
            args: Prisma.WisdomBasedSkillsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WisdomBasedSkillsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.WisdomBasedSkillsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WisdomBasedSkillsPayload>[]
          }
          upsert: {
            args: Prisma.WisdomBasedSkillsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WisdomBasedSkillsPayload>
          }
          aggregate: {
            args: Prisma.WisdomBasedSkillsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWisdomBasedSkills>
          }
          groupBy: {
            args: Prisma.WisdomBasedSkillsGroupByArgs<ExtArgs>
            result: $Utils.Optional<WisdomBasedSkillsGroupByOutputType>[]
          }
          count: {
            args: Prisma.WisdomBasedSkillsCountArgs<ExtArgs>
            result: $Utils.Optional<WisdomBasedSkillsCountAggregateOutputType> | number
          }
        }
      }
      CharismaBasedSkills: {
        payload: Prisma.$CharismaBasedSkillsPayload<ExtArgs>
        fields: Prisma.CharismaBasedSkillsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CharismaBasedSkillsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CharismaBasedSkillsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CharismaBasedSkillsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CharismaBasedSkillsPayload>
          }
          findFirst: {
            args: Prisma.CharismaBasedSkillsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CharismaBasedSkillsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CharismaBasedSkillsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CharismaBasedSkillsPayload>
          }
          findMany: {
            args: Prisma.CharismaBasedSkillsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CharismaBasedSkillsPayload>[]
          }
          create: {
            args: Prisma.CharismaBasedSkillsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CharismaBasedSkillsPayload>
          }
          createMany: {
            args: Prisma.CharismaBasedSkillsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CharismaBasedSkillsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CharismaBasedSkillsPayload>[]
          }
          delete: {
            args: Prisma.CharismaBasedSkillsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CharismaBasedSkillsPayload>
          }
          update: {
            args: Prisma.CharismaBasedSkillsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CharismaBasedSkillsPayload>
          }
          deleteMany: {
            args: Prisma.CharismaBasedSkillsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CharismaBasedSkillsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CharismaBasedSkillsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CharismaBasedSkillsPayload>[]
          }
          upsert: {
            args: Prisma.CharismaBasedSkillsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CharismaBasedSkillsPayload>
          }
          aggregate: {
            args: Prisma.CharismaBasedSkillsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCharismaBasedSkills>
          }
          groupBy: {
            args: Prisma.CharismaBasedSkillsGroupByArgs<ExtArgs>
            result: $Utils.Optional<CharismaBasedSkillsGroupByOutputType>[]
          }
          count: {
            args: Prisma.CharismaBasedSkillsCountArgs<ExtArgs>
            result: $Utils.Optional<CharismaBasedSkillsCountAggregateOutputType> | number
          }
        }
      }
      AthleticsSkill: {
        payload: Prisma.$AthleticsSkillPayload<ExtArgs>
        fields: Prisma.AthleticsSkillFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AthleticsSkillFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AthleticsSkillPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AthleticsSkillFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AthleticsSkillPayload>
          }
          findFirst: {
            args: Prisma.AthleticsSkillFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AthleticsSkillPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AthleticsSkillFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AthleticsSkillPayload>
          }
          findMany: {
            args: Prisma.AthleticsSkillFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AthleticsSkillPayload>[]
          }
          create: {
            args: Prisma.AthleticsSkillCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AthleticsSkillPayload>
          }
          createMany: {
            args: Prisma.AthleticsSkillCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AthleticsSkillCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AthleticsSkillPayload>[]
          }
          delete: {
            args: Prisma.AthleticsSkillDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AthleticsSkillPayload>
          }
          update: {
            args: Prisma.AthleticsSkillUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AthleticsSkillPayload>
          }
          deleteMany: {
            args: Prisma.AthleticsSkillDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AthleticsSkillUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AthleticsSkillUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AthleticsSkillPayload>[]
          }
          upsert: {
            args: Prisma.AthleticsSkillUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AthleticsSkillPayload>
          }
          aggregate: {
            args: Prisma.AthleticsSkillAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAthleticsSkill>
          }
          groupBy: {
            args: Prisma.AthleticsSkillGroupByArgs<ExtArgs>
            result: $Utils.Optional<AthleticsSkillGroupByOutputType>[]
          }
          count: {
            args: Prisma.AthleticsSkillCountArgs<ExtArgs>
            result: $Utils.Optional<AthleticsSkillCountAggregateOutputType> | number
          }
        }
      }
      AcrobaticsSkill: {
        payload: Prisma.$AcrobaticsSkillPayload<ExtArgs>
        fields: Prisma.AcrobaticsSkillFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AcrobaticsSkillFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AcrobaticsSkillPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AcrobaticsSkillFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AcrobaticsSkillPayload>
          }
          findFirst: {
            args: Prisma.AcrobaticsSkillFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AcrobaticsSkillPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AcrobaticsSkillFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AcrobaticsSkillPayload>
          }
          findMany: {
            args: Prisma.AcrobaticsSkillFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AcrobaticsSkillPayload>[]
          }
          create: {
            args: Prisma.AcrobaticsSkillCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AcrobaticsSkillPayload>
          }
          createMany: {
            args: Prisma.AcrobaticsSkillCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AcrobaticsSkillCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AcrobaticsSkillPayload>[]
          }
          delete: {
            args: Prisma.AcrobaticsSkillDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AcrobaticsSkillPayload>
          }
          update: {
            args: Prisma.AcrobaticsSkillUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AcrobaticsSkillPayload>
          }
          deleteMany: {
            args: Prisma.AcrobaticsSkillDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AcrobaticsSkillUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AcrobaticsSkillUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AcrobaticsSkillPayload>[]
          }
          upsert: {
            args: Prisma.AcrobaticsSkillUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AcrobaticsSkillPayload>
          }
          aggregate: {
            args: Prisma.AcrobaticsSkillAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAcrobaticsSkill>
          }
          groupBy: {
            args: Prisma.AcrobaticsSkillGroupByArgs<ExtArgs>
            result: $Utils.Optional<AcrobaticsSkillGroupByOutputType>[]
          }
          count: {
            args: Prisma.AcrobaticsSkillCountArgs<ExtArgs>
            result: $Utils.Optional<AcrobaticsSkillCountAggregateOutputType> | number
          }
        }
      }
      SleightOfHandSkill: {
        payload: Prisma.$SleightOfHandSkillPayload<ExtArgs>
        fields: Prisma.SleightOfHandSkillFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SleightOfHandSkillFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SleightOfHandSkillPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SleightOfHandSkillFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SleightOfHandSkillPayload>
          }
          findFirst: {
            args: Prisma.SleightOfHandSkillFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SleightOfHandSkillPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SleightOfHandSkillFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SleightOfHandSkillPayload>
          }
          findMany: {
            args: Prisma.SleightOfHandSkillFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SleightOfHandSkillPayload>[]
          }
          create: {
            args: Prisma.SleightOfHandSkillCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SleightOfHandSkillPayload>
          }
          createMany: {
            args: Prisma.SleightOfHandSkillCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SleightOfHandSkillCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SleightOfHandSkillPayload>[]
          }
          delete: {
            args: Prisma.SleightOfHandSkillDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SleightOfHandSkillPayload>
          }
          update: {
            args: Prisma.SleightOfHandSkillUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SleightOfHandSkillPayload>
          }
          deleteMany: {
            args: Prisma.SleightOfHandSkillDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SleightOfHandSkillUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SleightOfHandSkillUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SleightOfHandSkillPayload>[]
          }
          upsert: {
            args: Prisma.SleightOfHandSkillUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SleightOfHandSkillPayload>
          }
          aggregate: {
            args: Prisma.SleightOfHandSkillAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSleightOfHandSkill>
          }
          groupBy: {
            args: Prisma.SleightOfHandSkillGroupByArgs<ExtArgs>
            result: $Utils.Optional<SleightOfHandSkillGroupByOutputType>[]
          }
          count: {
            args: Prisma.SleightOfHandSkillCountArgs<ExtArgs>
            result: $Utils.Optional<SleightOfHandSkillCountAggregateOutputType> | number
          }
        }
      }
      StealthSkill: {
        payload: Prisma.$StealthSkillPayload<ExtArgs>
        fields: Prisma.StealthSkillFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StealthSkillFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StealthSkillPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StealthSkillFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StealthSkillPayload>
          }
          findFirst: {
            args: Prisma.StealthSkillFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StealthSkillPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StealthSkillFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StealthSkillPayload>
          }
          findMany: {
            args: Prisma.StealthSkillFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StealthSkillPayload>[]
          }
          create: {
            args: Prisma.StealthSkillCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StealthSkillPayload>
          }
          createMany: {
            args: Prisma.StealthSkillCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.StealthSkillCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StealthSkillPayload>[]
          }
          delete: {
            args: Prisma.StealthSkillDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StealthSkillPayload>
          }
          update: {
            args: Prisma.StealthSkillUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StealthSkillPayload>
          }
          deleteMany: {
            args: Prisma.StealthSkillDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.StealthSkillUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.StealthSkillUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StealthSkillPayload>[]
          }
          upsert: {
            args: Prisma.StealthSkillUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StealthSkillPayload>
          }
          aggregate: {
            args: Prisma.StealthSkillAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStealthSkill>
          }
          groupBy: {
            args: Prisma.StealthSkillGroupByArgs<ExtArgs>
            result: $Utils.Optional<StealthSkillGroupByOutputType>[]
          }
          count: {
            args: Prisma.StealthSkillCountArgs<ExtArgs>
            result: $Utils.Optional<StealthSkillCountAggregateOutputType> | number
          }
        }
      }
      ArcanaSkill: {
        payload: Prisma.$ArcanaSkillPayload<ExtArgs>
        fields: Prisma.ArcanaSkillFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ArcanaSkillFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArcanaSkillPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ArcanaSkillFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArcanaSkillPayload>
          }
          findFirst: {
            args: Prisma.ArcanaSkillFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArcanaSkillPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ArcanaSkillFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArcanaSkillPayload>
          }
          findMany: {
            args: Prisma.ArcanaSkillFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArcanaSkillPayload>[]
          }
          create: {
            args: Prisma.ArcanaSkillCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArcanaSkillPayload>
          }
          createMany: {
            args: Prisma.ArcanaSkillCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ArcanaSkillCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArcanaSkillPayload>[]
          }
          delete: {
            args: Prisma.ArcanaSkillDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArcanaSkillPayload>
          }
          update: {
            args: Prisma.ArcanaSkillUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArcanaSkillPayload>
          }
          deleteMany: {
            args: Prisma.ArcanaSkillDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ArcanaSkillUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ArcanaSkillUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArcanaSkillPayload>[]
          }
          upsert: {
            args: Prisma.ArcanaSkillUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArcanaSkillPayload>
          }
          aggregate: {
            args: Prisma.ArcanaSkillAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateArcanaSkill>
          }
          groupBy: {
            args: Prisma.ArcanaSkillGroupByArgs<ExtArgs>
            result: $Utils.Optional<ArcanaSkillGroupByOutputType>[]
          }
          count: {
            args: Prisma.ArcanaSkillCountArgs<ExtArgs>
            result: $Utils.Optional<ArcanaSkillCountAggregateOutputType> | number
          }
        }
      }
      HistorySkill: {
        payload: Prisma.$HistorySkillPayload<ExtArgs>
        fields: Prisma.HistorySkillFieldRefs
        operations: {
          findUnique: {
            args: Prisma.HistorySkillFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HistorySkillPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.HistorySkillFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HistorySkillPayload>
          }
          findFirst: {
            args: Prisma.HistorySkillFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HistorySkillPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.HistorySkillFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HistorySkillPayload>
          }
          findMany: {
            args: Prisma.HistorySkillFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HistorySkillPayload>[]
          }
          create: {
            args: Prisma.HistorySkillCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HistorySkillPayload>
          }
          createMany: {
            args: Prisma.HistorySkillCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.HistorySkillCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HistorySkillPayload>[]
          }
          delete: {
            args: Prisma.HistorySkillDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HistorySkillPayload>
          }
          update: {
            args: Prisma.HistorySkillUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HistorySkillPayload>
          }
          deleteMany: {
            args: Prisma.HistorySkillDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.HistorySkillUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.HistorySkillUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HistorySkillPayload>[]
          }
          upsert: {
            args: Prisma.HistorySkillUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HistorySkillPayload>
          }
          aggregate: {
            args: Prisma.HistorySkillAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateHistorySkill>
          }
          groupBy: {
            args: Prisma.HistorySkillGroupByArgs<ExtArgs>
            result: $Utils.Optional<HistorySkillGroupByOutputType>[]
          }
          count: {
            args: Prisma.HistorySkillCountArgs<ExtArgs>
            result: $Utils.Optional<HistorySkillCountAggregateOutputType> | number
          }
        }
      }
      InvestigationSkill: {
        payload: Prisma.$InvestigationSkillPayload<ExtArgs>
        fields: Prisma.InvestigationSkillFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InvestigationSkillFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvestigationSkillPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InvestigationSkillFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvestigationSkillPayload>
          }
          findFirst: {
            args: Prisma.InvestigationSkillFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvestigationSkillPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InvestigationSkillFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvestigationSkillPayload>
          }
          findMany: {
            args: Prisma.InvestigationSkillFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvestigationSkillPayload>[]
          }
          create: {
            args: Prisma.InvestigationSkillCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvestigationSkillPayload>
          }
          createMany: {
            args: Prisma.InvestigationSkillCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.InvestigationSkillCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvestigationSkillPayload>[]
          }
          delete: {
            args: Prisma.InvestigationSkillDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvestigationSkillPayload>
          }
          update: {
            args: Prisma.InvestigationSkillUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvestigationSkillPayload>
          }
          deleteMany: {
            args: Prisma.InvestigationSkillDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InvestigationSkillUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.InvestigationSkillUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvestigationSkillPayload>[]
          }
          upsert: {
            args: Prisma.InvestigationSkillUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvestigationSkillPayload>
          }
          aggregate: {
            args: Prisma.InvestigationSkillAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInvestigationSkill>
          }
          groupBy: {
            args: Prisma.InvestigationSkillGroupByArgs<ExtArgs>
            result: $Utils.Optional<InvestigationSkillGroupByOutputType>[]
          }
          count: {
            args: Prisma.InvestigationSkillCountArgs<ExtArgs>
            result: $Utils.Optional<InvestigationSkillCountAggregateOutputType> | number
          }
        }
      }
      NatureSkill: {
        payload: Prisma.$NatureSkillPayload<ExtArgs>
        fields: Prisma.NatureSkillFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NatureSkillFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NatureSkillPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NatureSkillFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NatureSkillPayload>
          }
          findFirst: {
            args: Prisma.NatureSkillFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NatureSkillPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NatureSkillFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NatureSkillPayload>
          }
          findMany: {
            args: Prisma.NatureSkillFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NatureSkillPayload>[]
          }
          create: {
            args: Prisma.NatureSkillCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NatureSkillPayload>
          }
          createMany: {
            args: Prisma.NatureSkillCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NatureSkillCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NatureSkillPayload>[]
          }
          delete: {
            args: Prisma.NatureSkillDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NatureSkillPayload>
          }
          update: {
            args: Prisma.NatureSkillUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NatureSkillPayload>
          }
          deleteMany: {
            args: Prisma.NatureSkillDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NatureSkillUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.NatureSkillUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NatureSkillPayload>[]
          }
          upsert: {
            args: Prisma.NatureSkillUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NatureSkillPayload>
          }
          aggregate: {
            args: Prisma.NatureSkillAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNatureSkill>
          }
          groupBy: {
            args: Prisma.NatureSkillGroupByArgs<ExtArgs>
            result: $Utils.Optional<NatureSkillGroupByOutputType>[]
          }
          count: {
            args: Prisma.NatureSkillCountArgs<ExtArgs>
            result: $Utils.Optional<NatureSkillCountAggregateOutputType> | number
          }
        }
      }
      ReligionSkill: {
        payload: Prisma.$ReligionSkillPayload<ExtArgs>
        fields: Prisma.ReligionSkillFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ReligionSkillFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReligionSkillPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ReligionSkillFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReligionSkillPayload>
          }
          findFirst: {
            args: Prisma.ReligionSkillFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReligionSkillPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ReligionSkillFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReligionSkillPayload>
          }
          findMany: {
            args: Prisma.ReligionSkillFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReligionSkillPayload>[]
          }
          create: {
            args: Prisma.ReligionSkillCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReligionSkillPayload>
          }
          createMany: {
            args: Prisma.ReligionSkillCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ReligionSkillCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReligionSkillPayload>[]
          }
          delete: {
            args: Prisma.ReligionSkillDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReligionSkillPayload>
          }
          update: {
            args: Prisma.ReligionSkillUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReligionSkillPayload>
          }
          deleteMany: {
            args: Prisma.ReligionSkillDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ReligionSkillUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ReligionSkillUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReligionSkillPayload>[]
          }
          upsert: {
            args: Prisma.ReligionSkillUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReligionSkillPayload>
          }
          aggregate: {
            args: Prisma.ReligionSkillAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateReligionSkill>
          }
          groupBy: {
            args: Prisma.ReligionSkillGroupByArgs<ExtArgs>
            result: $Utils.Optional<ReligionSkillGroupByOutputType>[]
          }
          count: {
            args: Prisma.ReligionSkillCountArgs<ExtArgs>
            result: $Utils.Optional<ReligionSkillCountAggregateOutputType> | number
          }
        }
      }
      AnimalHandlingSkill: {
        payload: Prisma.$AnimalHandlingSkillPayload<ExtArgs>
        fields: Prisma.AnimalHandlingSkillFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AnimalHandlingSkillFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnimalHandlingSkillPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AnimalHandlingSkillFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnimalHandlingSkillPayload>
          }
          findFirst: {
            args: Prisma.AnimalHandlingSkillFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnimalHandlingSkillPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AnimalHandlingSkillFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnimalHandlingSkillPayload>
          }
          findMany: {
            args: Prisma.AnimalHandlingSkillFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnimalHandlingSkillPayload>[]
          }
          create: {
            args: Prisma.AnimalHandlingSkillCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnimalHandlingSkillPayload>
          }
          createMany: {
            args: Prisma.AnimalHandlingSkillCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AnimalHandlingSkillCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnimalHandlingSkillPayload>[]
          }
          delete: {
            args: Prisma.AnimalHandlingSkillDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnimalHandlingSkillPayload>
          }
          update: {
            args: Prisma.AnimalHandlingSkillUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnimalHandlingSkillPayload>
          }
          deleteMany: {
            args: Prisma.AnimalHandlingSkillDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AnimalHandlingSkillUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AnimalHandlingSkillUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnimalHandlingSkillPayload>[]
          }
          upsert: {
            args: Prisma.AnimalHandlingSkillUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnimalHandlingSkillPayload>
          }
          aggregate: {
            args: Prisma.AnimalHandlingSkillAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAnimalHandlingSkill>
          }
          groupBy: {
            args: Prisma.AnimalHandlingSkillGroupByArgs<ExtArgs>
            result: $Utils.Optional<AnimalHandlingSkillGroupByOutputType>[]
          }
          count: {
            args: Prisma.AnimalHandlingSkillCountArgs<ExtArgs>
            result: $Utils.Optional<AnimalHandlingSkillCountAggregateOutputType> | number
          }
        }
      }
      InsightSkill: {
        payload: Prisma.$InsightSkillPayload<ExtArgs>
        fields: Prisma.InsightSkillFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InsightSkillFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InsightSkillPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InsightSkillFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InsightSkillPayload>
          }
          findFirst: {
            args: Prisma.InsightSkillFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InsightSkillPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InsightSkillFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InsightSkillPayload>
          }
          findMany: {
            args: Prisma.InsightSkillFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InsightSkillPayload>[]
          }
          create: {
            args: Prisma.InsightSkillCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InsightSkillPayload>
          }
          createMany: {
            args: Prisma.InsightSkillCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.InsightSkillCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InsightSkillPayload>[]
          }
          delete: {
            args: Prisma.InsightSkillDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InsightSkillPayload>
          }
          update: {
            args: Prisma.InsightSkillUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InsightSkillPayload>
          }
          deleteMany: {
            args: Prisma.InsightSkillDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InsightSkillUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.InsightSkillUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InsightSkillPayload>[]
          }
          upsert: {
            args: Prisma.InsightSkillUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InsightSkillPayload>
          }
          aggregate: {
            args: Prisma.InsightSkillAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInsightSkill>
          }
          groupBy: {
            args: Prisma.InsightSkillGroupByArgs<ExtArgs>
            result: $Utils.Optional<InsightSkillGroupByOutputType>[]
          }
          count: {
            args: Prisma.InsightSkillCountArgs<ExtArgs>
            result: $Utils.Optional<InsightSkillCountAggregateOutputType> | number
          }
        }
      }
      MedicineSkill: {
        payload: Prisma.$MedicineSkillPayload<ExtArgs>
        fields: Prisma.MedicineSkillFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MedicineSkillFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicineSkillPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MedicineSkillFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicineSkillPayload>
          }
          findFirst: {
            args: Prisma.MedicineSkillFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicineSkillPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MedicineSkillFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicineSkillPayload>
          }
          findMany: {
            args: Prisma.MedicineSkillFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicineSkillPayload>[]
          }
          create: {
            args: Prisma.MedicineSkillCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicineSkillPayload>
          }
          createMany: {
            args: Prisma.MedicineSkillCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MedicineSkillCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicineSkillPayload>[]
          }
          delete: {
            args: Prisma.MedicineSkillDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicineSkillPayload>
          }
          update: {
            args: Prisma.MedicineSkillUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicineSkillPayload>
          }
          deleteMany: {
            args: Prisma.MedicineSkillDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MedicineSkillUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MedicineSkillUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicineSkillPayload>[]
          }
          upsert: {
            args: Prisma.MedicineSkillUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicineSkillPayload>
          }
          aggregate: {
            args: Prisma.MedicineSkillAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMedicineSkill>
          }
          groupBy: {
            args: Prisma.MedicineSkillGroupByArgs<ExtArgs>
            result: $Utils.Optional<MedicineSkillGroupByOutputType>[]
          }
          count: {
            args: Prisma.MedicineSkillCountArgs<ExtArgs>
            result: $Utils.Optional<MedicineSkillCountAggregateOutputType> | number
          }
        }
      }
      PerceptionSkill: {
        payload: Prisma.$PerceptionSkillPayload<ExtArgs>
        fields: Prisma.PerceptionSkillFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PerceptionSkillFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PerceptionSkillPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PerceptionSkillFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PerceptionSkillPayload>
          }
          findFirst: {
            args: Prisma.PerceptionSkillFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PerceptionSkillPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PerceptionSkillFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PerceptionSkillPayload>
          }
          findMany: {
            args: Prisma.PerceptionSkillFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PerceptionSkillPayload>[]
          }
          create: {
            args: Prisma.PerceptionSkillCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PerceptionSkillPayload>
          }
          createMany: {
            args: Prisma.PerceptionSkillCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PerceptionSkillCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PerceptionSkillPayload>[]
          }
          delete: {
            args: Prisma.PerceptionSkillDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PerceptionSkillPayload>
          }
          update: {
            args: Prisma.PerceptionSkillUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PerceptionSkillPayload>
          }
          deleteMany: {
            args: Prisma.PerceptionSkillDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PerceptionSkillUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PerceptionSkillUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PerceptionSkillPayload>[]
          }
          upsert: {
            args: Prisma.PerceptionSkillUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PerceptionSkillPayload>
          }
          aggregate: {
            args: Prisma.PerceptionSkillAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePerceptionSkill>
          }
          groupBy: {
            args: Prisma.PerceptionSkillGroupByArgs<ExtArgs>
            result: $Utils.Optional<PerceptionSkillGroupByOutputType>[]
          }
          count: {
            args: Prisma.PerceptionSkillCountArgs<ExtArgs>
            result: $Utils.Optional<PerceptionSkillCountAggregateOutputType> | number
          }
        }
      }
      SurvivalSkill: {
        payload: Prisma.$SurvivalSkillPayload<ExtArgs>
        fields: Prisma.SurvivalSkillFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SurvivalSkillFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SurvivalSkillPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SurvivalSkillFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SurvivalSkillPayload>
          }
          findFirst: {
            args: Prisma.SurvivalSkillFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SurvivalSkillPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SurvivalSkillFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SurvivalSkillPayload>
          }
          findMany: {
            args: Prisma.SurvivalSkillFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SurvivalSkillPayload>[]
          }
          create: {
            args: Prisma.SurvivalSkillCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SurvivalSkillPayload>
          }
          createMany: {
            args: Prisma.SurvivalSkillCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SurvivalSkillCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SurvivalSkillPayload>[]
          }
          delete: {
            args: Prisma.SurvivalSkillDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SurvivalSkillPayload>
          }
          update: {
            args: Prisma.SurvivalSkillUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SurvivalSkillPayload>
          }
          deleteMany: {
            args: Prisma.SurvivalSkillDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SurvivalSkillUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SurvivalSkillUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SurvivalSkillPayload>[]
          }
          upsert: {
            args: Prisma.SurvivalSkillUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SurvivalSkillPayload>
          }
          aggregate: {
            args: Prisma.SurvivalSkillAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSurvivalSkill>
          }
          groupBy: {
            args: Prisma.SurvivalSkillGroupByArgs<ExtArgs>
            result: $Utils.Optional<SurvivalSkillGroupByOutputType>[]
          }
          count: {
            args: Prisma.SurvivalSkillCountArgs<ExtArgs>
            result: $Utils.Optional<SurvivalSkillCountAggregateOutputType> | number
          }
        }
      }
      DeceptionSkill: {
        payload: Prisma.$DeceptionSkillPayload<ExtArgs>
        fields: Prisma.DeceptionSkillFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DeceptionSkillFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeceptionSkillPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DeceptionSkillFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeceptionSkillPayload>
          }
          findFirst: {
            args: Prisma.DeceptionSkillFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeceptionSkillPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DeceptionSkillFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeceptionSkillPayload>
          }
          findMany: {
            args: Prisma.DeceptionSkillFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeceptionSkillPayload>[]
          }
          create: {
            args: Prisma.DeceptionSkillCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeceptionSkillPayload>
          }
          createMany: {
            args: Prisma.DeceptionSkillCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DeceptionSkillCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeceptionSkillPayload>[]
          }
          delete: {
            args: Prisma.DeceptionSkillDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeceptionSkillPayload>
          }
          update: {
            args: Prisma.DeceptionSkillUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeceptionSkillPayload>
          }
          deleteMany: {
            args: Prisma.DeceptionSkillDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DeceptionSkillUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DeceptionSkillUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeceptionSkillPayload>[]
          }
          upsert: {
            args: Prisma.DeceptionSkillUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeceptionSkillPayload>
          }
          aggregate: {
            args: Prisma.DeceptionSkillAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDeceptionSkill>
          }
          groupBy: {
            args: Prisma.DeceptionSkillGroupByArgs<ExtArgs>
            result: $Utils.Optional<DeceptionSkillGroupByOutputType>[]
          }
          count: {
            args: Prisma.DeceptionSkillCountArgs<ExtArgs>
            result: $Utils.Optional<DeceptionSkillCountAggregateOutputType> | number
          }
        }
      }
      IntimidationSkill: {
        payload: Prisma.$IntimidationSkillPayload<ExtArgs>
        fields: Prisma.IntimidationSkillFieldRefs
        operations: {
          findUnique: {
            args: Prisma.IntimidationSkillFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IntimidationSkillPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.IntimidationSkillFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IntimidationSkillPayload>
          }
          findFirst: {
            args: Prisma.IntimidationSkillFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IntimidationSkillPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.IntimidationSkillFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IntimidationSkillPayload>
          }
          findMany: {
            args: Prisma.IntimidationSkillFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IntimidationSkillPayload>[]
          }
          create: {
            args: Prisma.IntimidationSkillCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IntimidationSkillPayload>
          }
          createMany: {
            args: Prisma.IntimidationSkillCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.IntimidationSkillCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IntimidationSkillPayload>[]
          }
          delete: {
            args: Prisma.IntimidationSkillDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IntimidationSkillPayload>
          }
          update: {
            args: Prisma.IntimidationSkillUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IntimidationSkillPayload>
          }
          deleteMany: {
            args: Prisma.IntimidationSkillDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.IntimidationSkillUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.IntimidationSkillUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IntimidationSkillPayload>[]
          }
          upsert: {
            args: Prisma.IntimidationSkillUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IntimidationSkillPayload>
          }
          aggregate: {
            args: Prisma.IntimidationSkillAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateIntimidationSkill>
          }
          groupBy: {
            args: Prisma.IntimidationSkillGroupByArgs<ExtArgs>
            result: $Utils.Optional<IntimidationSkillGroupByOutputType>[]
          }
          count: {
            args: Prisma.IntimidationSkillCountArgs<ExtArgs>
            result: $Utils.Optional<IntimidationSkillCountAggregateOutputType> | number
          }
        }
      }
      PerformanceSkill: {
        payload: Prisma.$PerformanceSkillPayload<ExtArgs>
        fields: Prisma.PerformanceSkillFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PerformanceSkillFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PerformanceSkillPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PerformanceSkillFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PerformanceSkillPayload>
          }
          findFirst: {
            args: Prisma.PerformanceSkillFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PerformanceSkillPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PerformanceSkillFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PerformanceSkillPayload>
          }
          findMany: {
            args: Prisma.PerformanceSkillFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PerformanceSkillPayload>[]
          }
          create: {
            args: Prisma.PerformanceSkillCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PerformanceSkillPayload>
          }
          createMany: {
            args: Prisma.PerformanceSkillCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PerformanceSkillCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PerformanceSkillPayload>[]
          }
          delete: {
            args: Prisma.PerformanceSkillDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PerformanceSkillPayload>
          }
          update: {
            args: Prisma.PerformanceSkillUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PerformanceSkillPayload>
          }
          deleteMany: {
            args: Prisma.PerformanceSkillDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PerformanceSkillUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PerformanceSkillUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PerformanceSkillPayload>[]
          }
          upsert: {
            args: Prisma.PerformanceSkillUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PerformanceSkillPayload>
          }
          aggregate: {
            args: Prisma.PerformanceSkillAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePerformanceSkill>
          }
          groupBy: {
            args: Prisma.PerformanceSkillGroupByArgs<ExtArgs>
            result: $Utils.Optional<PerformanceSkillGroupByOutputType>[]
          }
          count: {
            args: Prisma.PerformanceSkillCountArgs<ExtArgs>
            result: $Utils.Optional<PerformanceSkillCountAggregateOutputType> | number
          }
        }
      }
      PersuasionSkill: {
        payload: Prisma.$PersuasionSkillPayload<ExtArgs>
        fields: Prisma.PersuasionSkillFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PersuasionSkillFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersuasionSkillPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PersuasionSkillFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersuasionSkillPayload>
          }
          findFirst: {
            args: Prisma.PersuasionSkillFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersuasionSkillPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PersuasionSkillFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersuasionSkillPayload>
          }
          findMany: {
            args: Prisma.PersuasionSkillFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersuasionSkillPayload>[]
          }
          create: {
            args: Prisma.PersuasionSkillCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersuasionSkillPayload>
          }
          createMany: {
            args: Prisma.PersuasionSkillCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PersuasionSkillCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersuasionSkillPayload>[]
          }
          delete: {
            args: Prisma.PersuasionSkillDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersuasionSkillPayload>
          }
          update: {
            args: Prisma.PersuasionSkillUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersuasionSkillPayload>
          }
          deleteMany: {
            args: Prisma.PersuasionSkillDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PersuasionSkillUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PersuasionSkillUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersuasionSkillPayload>[]
          }
          upsert: {
            args: Prisma.PersuasionSkillUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersuasionSkillPayload>
          }
          aggregate: {
            args: Prisma.PersuasionSkillAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePersuasionSkill>
          }
          groupBy: {
            args: Prisma.PersuasionSkillGroupByArgs<ExtArgs>
            result: $Utils.Optional<PersuasionSkillGroupByOutputType>[]
          }
          count: {
            args: Prisma.PersuasionSkillCountArgs<ExtArgs>
            result: $Utils.Optional<PersuasionSkillCountAggregateOutputType> | number
          }
        }
      }
      Creature: {
        payload: Prisma.$CreaturePayload<ExtArgs>
        fields: Prisma.CreatureFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CreatureFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreaturePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CreatureFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreaturePayload>
          }
          findFirst: {
            args: Prisma.CreatureFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreaturePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CreatureFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreaturePayload>
          }
          findMany: {
            args: Prisma.CreatureFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreaturePayload>[]
          }
          create: {
            args: Prisma.CreatureCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreaturePayload>
          }
          createMany: {
            args: Prisma.CreatureCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CreatureCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreaturePayload>[]
          }
          delete: {
            args: Prisma.CreatureDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreaturePayload>
          }
          update: {
            args: Prisma.CreatureUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreaturePayload>
          }
          deleteMany: {
            args: Prisma.CreatureDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CreatureUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CreatureUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreaturePayload>[]
          }
          upsert: {
            args: Prisma.CreatureUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreaturePayload>
          }
          aggregate: {
            args: Prisma.CreatureAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCreature>
          }
          groupBy: {
            args: Prisma.CreatureGroupByArgs<ExtArgs>
            result: $Utils.Optional<CreatureGroupByOutputType>[]
          }
          count: {
            args: Prisma.CreatureCountArgs<ExtArgs>
            result: $Utils.Optional<CreatureCountAggregateOutputType> | number
          }
        }
      }
      Senses: {
        payload: Prisma.$SensesPayload<ExtArgs>
        fields: Prisma.SensesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SensesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SensesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SensesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SensesPayload>
          }
          findFirst: {
            args: Prisma.SensesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SensesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SensesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SensesPayload>
          }
          findMany: {
            args: Prisma.SensesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SensesPayload>[]
          }
          create: {
            args: Prisma.SensesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SensesPayload>
          }
          createMany: {
            args: Prisma.SensesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SensesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SensesPayload>[]
          }
          delete: {
            args: Prisma.SensesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SensesPayload>
          }
          update: {
            args: Prisma.SensesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SensesPayload>
          }
          deleteMany: {
            args: Prisma.SensesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SensesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SensesUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SensesPayload>[]
          }
          upsert: {
            args: Prisma.SensesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SensesPayload>
          }
          aggregate: {
            args: Prisma.SensesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSenses>
          }
          groupBy: {
            args: Prisma.SensesGroupByArgs<ExtArgs>
            result: $Utils.Optional<SensesGroupByOutputType>[]
          }
          count: {
            args: Prisma.SensesCountArgs<ExtArgs>
            result: $Utils.Optional<SensesCountAggregateOutputType> | number
          }
        }
      }
      Action: {
        payload: Prisma.$ActionPayload<ExtArgs>
        fields: Prisma.ActionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ActionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ActionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActionPayload>
          }
          findFirst: {
            args: Prisma.ActionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ActionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActionPayload>
          }
          findMany: {
            args: Prisma.ActionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActionPayload>[]
          }
          create: {
            args: Prisma.ActionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActionPayload>
          }
          createMany: {
            args: Prisma.ActionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ActionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActionPayload>[]
          }
          delete: {
            args: Prisma.ActionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActionPayload>
          }
          update: {
            args: Prisma.ActionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActionPayload>
          }
          deleteMany: {
            args: Prisma.ActionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ActionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ActionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActionPayload>[]
          }
          upsert: {
            args: Prisma.ActionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActionPayload>
          }
          aggregate: {
            args: Prisma.ActionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAction>
          }
          groupBy: {
            args: Prisma.ActionGroupByArgs<ExtArgs>
            result: $Utils.Optional<ActionGroupByOutputType>[]
          }
          count: {
            args: Prisma.ActionCountArgs<ExtArgs>
            result: $Utils.Optional<ActionCountAggregateOutputType> | number
          }
        }
      }
      Trait: {
        payload: Prisma.$TraitPayload<ExtArgs>
        fields: Prisma.TraitFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TraitFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TraitPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TraitFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TraitPayload>
          }
          findFirst: {
            args: Prisma.TraitFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TraitPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TraitFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TraitPayload>
          }
          findMany: {
            args: Prisma.TraitFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TraitPayload>[]
          }
          create: {
            args: Prisma.TraitCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TraitPayload>
          }
          createMany: {
            args: Prisma.TraitCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TraitCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TraitPayload>[]
          }
          delete: {
            args: Prisma.TraitDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TraitPayload>
          }
          update: {
            args: Prisma.TraitUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TraitPayload>
          }
          deleteMany: {
            args: Prisma.TraitDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TraitUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TraitUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TraitPayload>[]
          }
          upsert: {
            args: Prisma.TraitUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TraitPayload>
          }
          aggregate: {
            args: Prisma.TraitAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTrait>
          }
          groupBy: {
            args: Prisma.TraitGroupByArgs<ExtArgs>
            result: $Utils.Optional<TraitGroupByOutputType>[]
          }
          count: {
            args: Prisma.TraitCountArgs<ExtArgs>
            result: $Utils.Optional<TraitCountAggregateOutputType> | number
          }
        }
      }
      CreatureRace: {
        payload: Prisma.$CreatureRacePayload<ExtArgs>
        fields: Prisma.CreatureRaceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CreatureRaceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreatureRacePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CreatureRaceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreatureRacePayload>
          }
          findFirst: {
            args: Prisma.CreatureRaceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreatureRacePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CreatureRaceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreatureRacePayload>
          }
          findMany: {
            args: Prisma.CreatureRaceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreatureRacePayload>[]
          }
          create: {
            args: Prisma.CreatureRaceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreatureRacePayload>
          }
          createMany: {
            args: Prisma.CreatureRaceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CreatureRaceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreatureRacePayload>[]
          }
          delete: {
            args: Prisma.CreatureRaceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreatureRacePayload>
          }
          update: {
            args: Prisma.CreatureRaceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreatureRacePayload>
          }
          deleteMany: {
            args: Prisma.CreatureRaceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CreatureRaceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CreatureRaceUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreatureRacePayload>[]
          }
          upsert: {
            args: Prisma.CreatureRaceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreatureRacePayload>
          }
          aggregate: {
            args: Prisma.CreatureRaceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCreatureRace>
          }
          groupBy: {
            args: Prisma.CreatureRaceGroupByArgs<ExtArgs>
            result: $Utils.Optional<CreatureRaceGroupByOutputType>[]
          }
          count: {
            args: Prisma.CreatureRaceCountArgs<ExtArgs>
            result: $Utils.Optional<CreatureRaceCountAggregateOutputType> | number
          }
        }
      }
      GenrationRequest: {
        payload: Prisma.$GenrationRequestPayload<ExtArgs>
        fields: Prisma.GenrationRequestFieldRefs
        operations: {
          findUnique: {
            args: Prisma.GenrationRequestFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GenrationRequestPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.GenrationRequestFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GenrationRequestPayload>
          }
          findFirst: {
            args: Prisma.GenrationRequestFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GenrationRequestPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.GenrationRequestFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GenrationRequestPayload>
          }
          findMany: {
            args: Prisma.GenrationRequestFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GenrationRequestPayload>[]
          }
          create: {
            args: Prisma.GenrationRequestCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GenrationRequestPayload>
          }
          createMany: {
            args: Prisma.GenrationRequestCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.GenrationRequestCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GenrationRequestPayload>[]
          }
          delete: {
            args: Prisma.GenrationRequestDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GenrationRequestPayload>
          }
          update: {
            args: Prisma.GenrationRequestUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GenrationRequestPayload>
          }
          deleteMany: {
            args: Prisma.GenrationRequestDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.GenrationRequestUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.GenrationRequestUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GenrationRequestPayload>[]
          }
          upsert: {
            args: Prisma.GenrationRequestUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GenrationRequestPayload>
          }
          aggregate: {
            args: Prisma.GenrationRequestAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGenrationRequest>
          }
          groupBy: {
            args: Prisma.GenrationRequestGroupByArgs<ExtArgs>
            result: $Utils.Optional<GenrationRequestGroupByOutputType>[]
          }
          count: {
            args: Prisma.GenrationRequestCountArgs<ExtArgs>
            result: $Utils.Optional<GenrationRequestCountAggregateOutputType> | number
          }
        }
      }
      DamageType: {
        payload: Prisma.$DamageTypePayload<ExtArgs>
        fields: Prisma.DamageTypeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DamageTypeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DamageTypePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DamageTypeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DamageTypePayload>
          }
          findFirst: {
            args: Prisma.DamageTypeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DamageTypePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DamageTypeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DamageTypePayload>
          }
          findMany: {
            args: Prisma.DamageTypeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DamageTypePayload>[]
          }
          create: {
            args: Prisma.DamageTypeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DamageTypePayload>
          }
          createMany: {
            args: Prisma.DamageTypeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DamageTypeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DamageTypePayload>[]
          }
          delete: {
            args: Prisma.DamageTypeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DamageTypePayload>
          }
          update: {
            args: Prisma.DamageTypeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DamageTypePayload>
          }
          deleteMany: {
            args: Prisma.DamageTypeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DamageTypeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DamageTypeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DamageTypePayload>[]
          }
          upsert: {
            args: Prisma.DamageTypeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DamageTypePayload>
          }
          aggregate: {
            args: Prisma.DamageTypeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDamageType>
          }
          groupBy: {
            args: Prisma.DamageTypeGroupByArgs<ExtArgs>
            result: $Utils.Optional<DamageTypeGroupByOutputType>[]
          }
          count: {
            args: Prisma.DamageTypeCountArgs<ExtArgs>
            result: $Utils.Optional<DamageTypeCountAggregateOutputType> | number
          }
        }
      }
      ChallengeRating: {
        payload: Prisma.$ChallengeRatingPayload<ExtArgs>
        fields: Prisma.ChallengeRatingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ChallengeRatingFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengeRatingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ChallengeRatingFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengeRatingPayload>
          }
          findFirst: {
            args: Prisma.ChallengeRatingFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengeRatingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ChallengeRatingFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengeRatingPayload>
          }
          findMany: {
            args: Prisma.ChallengeRatingFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengeRatingPayload>[]
          }
          create: {
            args: Prisma.ChallengeRatingCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengeRatingPayload>
          }
          createMany: {
            args: Prisma.ChallengeRatingCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ChallengeRatingCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengeRatingPayload>[]
          }
          delete: {
            args: Prisma.ChallengeRatingDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengeRatingPayload>
          }
          update: {
            args: Prisma.ChallengeRatingUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengeRatingPayload>
          }
          deleteMany: {
            args: Prisma.ChallengeRatingDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ChallengeRatingUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ChallengeRatingUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengeRatingPayload>[]
          }
          upsert: {
            args: Prisma.ChallengeRatingUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengeRatingPayload>
          }
          aggregate: {
            args: Prisma.ChallengeRatingAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateChallengeRating>
          }
          groupBy: {
            args: Prisma.ChallengeRatingGroupByArgs<ExtArgs>
            result: $Utils.Optional<ChallengeRatingGroupByOutputType>[]
          }
          count: {
            args: Prisma.ChallengeRatingCountArgs<ExtArgs>
            result: $Utils.Optional<ChallengeRatingCountAggregateOutputType> | number
          }
        }
      }
      GPTMessageHistory: {
        payload: Prisma.$GPTMessageHistoryPayload<ExtArgs>
        fields: Prisma.GPTMessageHistoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.GPTMessageHistoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GPTMessageHistoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.GPTMessageHistoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GPTMessageHistoryPayload>
          }
          findFirst: {
            args: Prisma.GPTMessageHistoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GPTMessageHistoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.GPTMessageHistoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GPTMessageHistoryPayload>
          }
          findMany: {
            args: Prisma.GPTMessageHistoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GPTMessageHistoryPayload>[]
          }
          create: {
            args: Prisma.GPTMessageHistoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GPTMessageHistoryPayload>
          }
          createMany: {
            args: Prisma.GPTMessageHistoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.GPTMessageHistoryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GPTMessageHistoryPayload>[]
          }
          delete: {
            args: Prisma.GPTMessageHistoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GPTMessageHistoryPayload>
          }
          update: {
            args: Prisma.GPTMessageHistoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GPTMessageHistoryPayload>
          }
          deleteMany: {
            args: Prisma.GPTMessageHistoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.GPTMessageHistoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.GPTMessageHistoryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GPTMessageHistoryPayload>[]
          }
          upsert: {
            args: Prisma.GPTMessageHistoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GPTMessageHistoryPayload>
          }
          aggregate: {
            args: Prisma.GPTMessageHistoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGPTMessageHistory>
          }
          groupBy: {
            args: Prisma.GPTMessageHistoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<GPTMessageHistoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.GPTMessageHistoryCountArgs<ExtArgs>
            result: $Utils.Optional<GPTMessageHistoryCountAggregateOutputType> | number
          }
        }
      }
      GPTMessage: {
        payload: Prisma.$GPTMessagePayload<ExtArgs>
        fields: Prisma.GPTMessageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.GPTMessageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GPTMessagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.GPTMessageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GPTMessagePayload>
          }
          findFirst: {
            args: Prisma.GPTMessageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GPTMessagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.GPTMessageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GPTMessagePayload>
          }
          findMany: {
            args: Prisma.GPTMessageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GPTMessagePayload>[]
          }
          create: {
            args: Prisma.GPTMessageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GPTMessagePayload>
          }
          createMany: {
            args: Prisma.GPTMessageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.GPTMessageCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GPTMessagePayload>[]
          }
          delete: {
            args: Prisma.GPTMessageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GPTMessagePayload>
          }
          update: {
            args: Prisma.GPTMessageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GPTMessagePayload>
          }
          deleteMany: {
            args: Prisma.GPTMessageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.GPTMessageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.GPTMessageUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GPTMessagePayload>[]
          }
          upsert: {
            args: Prisma.GPTMessageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GPTMessagePayload>
          }
          aggregate: {
            args: Prisma.GPTMessageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGPTMessage>
          }
          groupBy: {
            args: Prisma.GPTMessageGroupByArgs<ExtArgs>
            result: $Utils.Optional<GPTMessageGroupByOutputType>[]
          }
          count: {
            args: Prisma.GPTMessageCountArgs<ExtArgs>
            result: $Utils.Optional<GPTMessageCountAggregateOutputType> | number
          }
        }
      }
      Adventure: {
        payload: Prisma.$AdventurePayload<ExtArgs>
        fields: Prisma.AdventureFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AdventureFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdventurePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AdventureFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdventurePayload>
          }
          findFirst: {
            args: Prisma.AdventureFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdventurePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AdventureFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdventurePayload>
          }
          findMany: {
            args: Prisma.AdventureFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdventurePayload>[]
          }
          create: {
            args: Prisma.AdventureCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdventurePayload>
          }
          createMany: {
            args: Prisma.AdventureCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AdventureCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdventurePayload>[]
          }
          delete: {
            args: Prisma.AdventureDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdventurePayload>
          }
          update: {
            args: Prisma.AdventureUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdventurePayload>
          }
          deleteMany: {
            args: Prisma.AdventureDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AdventureUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AdventureUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdventurePayload>[]
          }
          upsert: {
            args: Prisma.AdventureUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdventurePayload>
          }
          aggregate: {
            args: Prisma.AdventureAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAdventure>
          }
          groupBy: {
            args: Prisma.AdventureGroupByArgs<ExtArgs>
            result: $Utils.Optional<AdventureGroupByOutputType>[]
          }
          count: {
            args: Prisma.AdventureCountArgs<ExtArgs>
            result: $Utils.Optional<AdventureCountAggregateOutputType> | number
          }
        }
      }
      Genre: {
        payload: Prisma.$GenrePayload<ExtArgs>
        fields: Prisma.GenreFieldRefs
        operations: {
          findUnique: {
            args: Prisma.GenreFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GenrePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.GenreFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GenrePayload>
          }
          findFirst: {
            args: Prisma.GenreFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GenrePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.GenreFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GenrePayload>
          }
          findMany: {
            args: Prisma.GenreFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GenrePayload>[]
          }
          create: {
            args: Prisma.GenreCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GenrePayload>
          }
          createMany: {
            args: Prisma.GenreCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.GenreCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GenrePayload>[]
          }
          delete: {
            args: Prisma.GenreDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GenrePayload>
          }
          update: {
            args: Prisma.GenreUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GenrePayload>
          }
          deleteMany: {
            args: Prisma.GenreDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.GenreUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.GenreUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GenrePayload>[]
          }
          upsert: {
            args: Prisma.GenreUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GenrePayload>
          }
          aggregate: {
            args: Prisma.GenreAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGenre>
          }
          groupBy: {
            args: Prisma.GenreGroupByArgs<ExtArgs>
            result: $Utils.Optional<GenreGroupByOutputType>[]
          }
          count: {
            args: Prisma.GenreCountArgs<ExtArgs>
            result: $Utils.Optional<GenreCountAggregateOutputType> | number
          }
        }
      }
      Keyword: {
        payload: Prisma.$KeywordPayload<ExtArgs>
        fields: Prisma.KeywordFieldRefs
        operations: {
          findUnique: {
            args: Prisma.KeywordFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KeywordPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.KeywordFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KeywordPayload>
          }
          findFirst: {
            args: Prisma.KeywordFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KeywordPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.KeywordFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KeywordPayload>
          }
          findMany: {
            args: Prisma.KeywordFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KeywordPayload>[]
          }
          create: {
            args: Prisma.KeywordCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KeywordPayload>
          }
          createMany: {
            args: Prisma.KeywordCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.KeywordCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KeywordPayload>[]
          }
          delete: {
            args: Prisma.KeywordDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KeywordPayload>
          }
          update: {
            args: Prisma.KeywordUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KeywordPayload>
          }
          deleteMany: {
            args: Prisma.KeywordDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.KeywordUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.KeywordUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KeywordPayload>[]
          }
          upsert: {
            args: Prisma.KeywordUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KeywordPayload>
          }
          aggregate: {
            args: Prisma.KeywordAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateKeyword>
          }
          groupBy: {
            args: Prisma.KeywordGroupByArgs<ExtArgs>
            result: $Utils.Optional<KeywordGroupByOutputType>[]
          }
          count: {
            args: Prisma.KeywordCountArgs<ExtArgs>
            result: $Utils.Optional<KeywordCountAggregateOutputType> | number
          }
        }
      }
      AdventureKeyword: {
        payload: Prisma.$AdventureKeywordPayload<ExtArgs>
        fields: Prisma.AdventureKeywordFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AdventureKeywordFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdventureKeywordPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AdventureKeywordFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdventureKeywordPayload>
          }
          findFirst: {
            args: Prisma.AdventureKeywordFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdventureKeywordPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AdventureKeywordFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdventureKeywordPayload>
          }
          findMany: {
            args: Prisma.AdventureKeywordFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdventureKeywordPayload>[]
          }
          create: {
            args: Prisma.AdventureKeywordCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdventureKeywordPayload>
          }
          createMany: {
            args: Prisma.AdventureKeywordCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AdventureKeywordCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdventureKeywordPayload>[]
          }
          delete: {
            args: Prisma.AdventureKeywordDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdventureKeywordPayload>
          }
          update: {
            args: Prisma.AdventureKeywordUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdventureKeywordPayload>
          }
          deleteMany: {
            args: Prisma.AdventureKeywordDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AdventureKeywordUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AdventureKeywordUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdventureKeywordPayload>[]
          }
          upsert: {
            args: Prisma.AdventureKeywordUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdventureKeywordPayload>
          }
          aggregate: {
            args: Prisma.AdventureKeywordAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAdventureKeyword>
          }
          groupBy: {
            args: Prisma.AdventureKeywordGroupByArgs<ExtArgs>
            result: $Utils.Optional<AdventureKeywordGroupByOutputType>[]
          }
          count: {
            args: Prisma.AdventureKeywordCountArgs<ExtArgs>
            result: $Utils.Optional<AdventureKeywordCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    size?: SizeOmit
    source?: SourceOmit
    language?: LanguageOmit
    biome?: BiomeOmit
    type?: TypeOmit
    alignment?: AlignmentOmit
    speed_stat?: Speed_statOmit
    creature_stats?: Creature_statsOmit
    strength_stat_details?: Strength_stat_detailsOmit
    dexterity_stat_details?: Dexterity_stat_detailsOmit
    constitution_stat_details?: Constitution_stat_detailsOmit
    intelligence_stat_details?: Intelligence_stat_detailsOmit
    wisdom_stat_details?: Wisdom_stat_detailsOmit
    charisma_stat_details?: Charisma_stat_detailsOmit
    skillsList?: SkillsListOmit
    strengthBasedSkills?: StrengthBasedSkillsOmit
    dexterityBasedSkills?: DexterityBasedSkillsOmit
    intellengenceBasedSkills?: IntellengenceBasedSkillsOmit
    wisdomBasedSkills?: WisdomBasedSkillsOmit
    charismaBasedSkills?: CharismaBasedSkillsOmit
    athleticsSkill?: AthleticsSkillOmit
    acrobaticsSkill?: AcrobaticsSkillOmit
    sleightOfHandSkill?: SleightOfHandSkillOmit
    stealthSkill?: StealthSkillOmit
    arcanaSkill?: ArcanaSkillOmit
    historySkill?: HistorySkillOmit
    investigationSkill?: InvestigationSkillOmit
    natureSkill?: NatureSkillOmit
    religionSkill?: ReligionSkillOmit
    animalHandlingSkill?: AnimalHandlingSkillOmit
    insightSkill?: InsightSkillOmit
    medicineSkill?: MedicineSkillOmit
    perceptionSkill?: PerceptionSkillOmit
    survivalSkill?: SurvivalSkillOmit
    deceptionSkill?: DeceptionSkillOmit
    intimidationSkill?: IntimidationSkillOmit
    performanceSkill?: PerformanceSkillOmit
    persuasionSkill?: PersuasionSkillOmit
    creature?: CreatureOmit
    senses?: SensesOmit
    action?: ActionOmit
    trait?: TraitOmit
    creatureRace?: CreatureRaceOmit
    genrationRequest?: GenrationRequestOmit
    damageType?: DamageTypeOmit
    challengeRating?: ChallengeRatingOmit
    gPTMessageHistory?: GPTMessageHistoryOmit
    gPTMessage?: GPTMessageOmit
    adventure?: AdventureOmit
    genre?: GenreOmit
    keyword?: KeywordOmit
    adventureKeyword?: AdventureKeywordOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type SizeCountOutputType
   */

  export type SizeCountOutputType = {
    creature: number
  }

  export type SizeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creature?: boolean | SizeCountOutputTypeCountCreatureArgs
  }

  // Custom InputTypes
  /**
   * SizeCountOutputType without action
   */
  export type SizeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SizeCountOutputType
     */
    select?: SizeCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SizeCountOutputType without action
   */
  export type SizeCountOutputTypeCountCreatureArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CreatureWhereInput
  }


  /**
   * Count Type SourceCountOutputType
   */

  export type SourceCountOutputType = {
    creatures: number
  }

  export type SourceCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creatures?: boolean | SourceCountOutputTypeCountCreaturesArgs
  }

  // Custom InputTypes
  /**
   * SourceCountOutputType without action
   */
  export type SourceCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SourceCountOutputType
     */
    select?: SourceCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SourceCountOutputType without action
   */
  export type SourceCountOutputTypeCountCreaturesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CreatureWhereInput
  }


  /**
   * Count Type LanguageCountOutputType
   */

  export type LanguageCountOutputType = {
    creatures: number
  }

  export type LanguageCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creatures?: boolean | LanguageCountOutputTypeCountCreaturesArgs
  }

  // Custom InputTypes
  /**
   * LanguageCountOutputType without action
   */
  export type LanguageCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LanguageCountOutputType
     */
    select?: LanguageCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * LanguageCountOutputType without action
   */
  export type LanguageCountOutputTypeCountCreaturesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CreatureWhereInput
  }


  /**
   * Count Type BiomeCountOutputType
   */

  export type BiomeCountOutputType = {
    creatures: number
  }

  export type BiomeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creatures?: boolean | BiomeCountOutputTypeCountCreaturesArgs
  }

  // Custom InputTypes
  /**
   * BiomeCountOutputType without action
   */
  export type BiomeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BiomeCountOutputType
     */
    select?: BiomeCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * BiomeCountOutputType without action
   */
  export type BiomeCountOutputTypeCountCreaturesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CreatureWhereInput
  }


  /**
   * Count Type TypeCountOutputType
   */

  export type TypeCountOutputType = {
    creatures: number
  }

  export type TypeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creatures?: boolean | TypeCountOutputTypeCountCreaturesArgs
  }

  // Custom InputTypes
  /**
   * TypeCountOutputType without action
   */
  export type TypeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TypeCountOutputType
     */
    select?: TypeCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TypeCountOutputType without action
   */
  export type TypeCountOutputTypeCountCreaturesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CreatureWhereInput
  }


  /**
   * Count Type AlignmentCountOutputType
   */

  export type AlignmentCountOutputType = {
    creatures: number
  }

  export type AlignmentCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creatures?: boolean | AlignmentCountOutputTypeCountCreaturesArgs
  }

  // Custom InputTypes
  /**
   * AlignmentCountOutputType without action
   */
  export type AlignmentCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AlignmentCountOutputType
     */
    select?: AlignmentCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AlignmentCountOutputType without action
   */
  export type AlignmentCountOutputTypeCountCreaturesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CreatureWhereInput
  }


  /**
   * Count Type CreatureCountOutputType
   */

  export type CreatureCountOutputType = {
    resistances: number
    immunities: number
    vulnerabilities: number
    languages: number
    actions: number
    traits: number
    biome_relation: number
  }

  export type CreatureCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    resistances?: boolean | CreatureCountOutputTypeCountResistancesArgs
    immunities?: boolean | CreatureCountOutputTypeCountImmunitiesArgs
    vulnerabilities?: boolean | CreatureCountOutputTypeCountVulnerabilitiesArgs
    languages?: boolean | CreatureCountOutputTypeCountLanguagesArgs
    actions?: boolean | CreatureCountOutputTypeCountActionsArgs
    traits?: boolean | CreatureCountOutputTypeCountTraitsArgs
    biome_relation?: boolean | CreatureCountOutputTypeCountBiome_relationArgs
  }

  // Custom InputTypes
  /**
   * CreatureCountOutputType without action
   */
  export type CreatureCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreatureCountOutputType
     */
    select?: CreatureCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CreatureCountOutputType without action
   */
  export type CreatureCountOutputTypeCountResistancesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DamageTypeWhereInput
  }

  /**
   * CreatureCountOutputType without action
   */
  export type CreatureCountOutputTypeCountImmunitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DamageTypeWhereInput
  }

  /**
   * CreatureCountOutputType without action
   */
  export type CreatureCountOutputTypeCountVulnerabilitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DamageTypeWhereInput
  }

  /**
   * CreatureCountOutputType without action
   */
  export type CreatureCountOutputTypeCountLanguagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LanguageWhereInput
  }

  /**
   * CreatureCountOutputType without action
   */
  export type CreatureCountOutputTypeCountActionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ActionWhereInput
  }

  /**
   * CreatureCountOutputType without action
   */
  export type CreatureCountOutputTypeCountTraitsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TraitWhereInput
  }

  /**
   * CreatureCountOutputType without action
   */
  export type CreatureCountOutputTypeCountBiome_relationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BiomeWhereInput
  }


  /**
   * Count Type ActionCountOutputType
   */

  export type ActionCountOutputType = {
    creatures: number
    creatureTypes: number
  }

  export type ActionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creatures?: boolean | ActionCountOutputTypeCountCreaturesArgs
    creatureTypes?: boolean | ActionCountOutputTypeCountCreatureTypesArgs
  }

  // Custom InputTypes
  /**
   * ActionCountOutputType without action
   */
  export type ActionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActionCountOutputType
     */
    select?: ActionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ActionCountOutputType without action
   */
  export type ActionCountOutputTypeCountCreaturesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CreatureWhereInput
  }

  /**
   * ActionCountOutputType without action
   */
  export type ActionCountOutputTypeCountCreatureTypesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CreatureRaceWhereInput
  }


  /**
   * Count Type TraitCountOutputType
   */

  export type TraitCountOutputType = {
    cretures: number
    creatureTypes: number
  }

  export type TraitCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cretures?: boolean | TraitCountOutputTypeCountCreturesArgs
    creatureTypes?: boolean | TraitCountOutputTypeCountCreatureTypesArgs
  }

  // Custom InputTypes
  /**
   * TraitCountOutputType without action
   */
  export type TraitCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TraitCountOutputType
     */
    select?: TraitCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TraitCountOutputType without action
   */
  export type TraitCountOutputTypeCountCreturesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CreatureWhereInput
  }

  /**
   * TraitCountOutputType without action
   */
  export type TraitCountOutputTypeCountCreatureTypesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CreatureRaceWhereInput
  }


  /**
   * Count Type CreatureRaceCountOutputType
   */

  export type CreatureRaceCountOutputType = {
    traits: number
    actions: number
    creatures: number
  }

  export type CreatureRaceCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    traits?: boolean | CreatureRaceCountOutputTypeCountTraitsArgs
    actions?: boolean | CreatureRaceCountOutputTypeCountActionsArgs
    creatures?: boolean | CreatureRaceCountOutputTypeCountCreaturesArgs
  }

  // Custom InputTypes
  /**
   * CreatureRaceCountOutputType without action
   */
  export type CreatureRaceCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreatureRaceCountOutputType
     */
    select?: CreatureRaceCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CreatureRaceCountOutputType without action
   */
  export type CreatureRaceCountOutputTypeCountTraitsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TraitWhereInput
  }

  /**
   * CreatureRaceCountOutputType without action
   */
  export type CreatureRaceCountOutputTypeCountActionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ActionWhereInput
  }

  /**
   * CreatureRaceCountOutputType without action
   */
  export type CreatureRaceCountOutputTypeCountCreaturesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CreatureWhereInput
  }


  /**
   * Count Type DamageTypeCountOutputType
   */

  export type DamageTypeCountOutputType = {
    resistant_creatures: number
    immune_creatures: number
    vunlerable_creatures: number
  }

  export type DamageTypeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    resistant_creatures?: boolean | DamageTypeCountOutputTypeCountResistant_creaturesArgs
    immune_creatures?: boolean | DamageTypeCountOutputTypeCountImmune_creaturesArgs
    vunlerable_creatures?: boolean | DamageTypeCountOutputTypeCountVunlerable_creaturesArgs
  }

  // Custom InputTypes
  /**
   * DamageTypeCountOutputType without action
   */
  export type DamageTypeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DamageTypeCountOutputType
     */
    select?: DamageTypeCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * DamageTypeCountOutputType without action
   */
  export type DamageTypeCountOutputTypeCountResistant_creaturesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CreatureWhereInput
  }

  /**
   * DamageTypeCountOutputType without action
   */
  export type DamageTypeCountOutputTypeCountImmune_creaturesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CreatureWhereInput
  }

  /**
   * DamageTypeCountOutputType without action
   */
  export type DamageTypeCountOutputTypeCountVunlerable_creaturesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CreatureWhereInput
  }


  /**
   * Count Type GPTMessageHistoryCountOutputType
   */

  export type GPTMessageHistoryCountOutputType = {
    messages: number
  }

  export type GPTMessageHistoryCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    messages?: boolean | GPTMessageHistoryCountOutputTypeCountMessagesArgs
  }

  // Custom InputTypes
  /**
   * GPTMessageHistoryCountOutputType without action
   */
  export type GPTMessageHistoryCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GPTMessageHistoryCountOutputType
     */
    select?: GPTMessageHistoryCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * GPTMessageHistoryCountOutputType without action
   */
  export type GPTMessageHistoryCountOutputTypeCountMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GPTMessageWhereInput
  }


  /**
   * Count Type AdventureCountOutputType
   */

  export type AdventureCountOutputType = {
    keywords: number
  }

  export type AdventureCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    keywords?: boolean | AdventureCountOutputTypeCountKeywordsArgs
  }

  // Custom InputTypes
  /**
   * AdventureCountOutputType without action
   */
  export type AdventureCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdventureCountOutputType
     */
    select?: AdventureCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AdventureCountOutputType without action
   */
  export type AdventureCountOutputTypeCountKeywordsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdventureKeywordWhereInput
  }


  /**
   * Count Type GenreCountOutputType
   */

  export type GenreCountOutputType = {
    keywords: number
    adventures: number
  }

  export type GenreCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    keywords?: boolean | GenreCountOutputTypeCountKeywordsArgs
    adventures?: boolean | GenreCountOutputTypeCountAdventuresArgs
  }

  // Custom InputTypes
  /**
   * GenreCountOutputType without action
   */
  export type GenreCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GenreCountOutputType
     */
    select?: GenreCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * GenreCountOutputType without action
   */
  export type GenreCountOutputTypeCountKeywordsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: KeywordWhereInput
  }

  /**
   * GenreCountOutputType without action
   */
  export type GenreCountOutputTypeCountAdventuresArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdventureWhereInput
  }


  /**
   * Count Type KeywordCountOutputType
   */

  export type KeywordCountOutputType = {
    adventures: number
  }

  export type KeywordCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    adventures?: boolean | KeywordCountOutputTypeCountAdventuresArgs
  }

  // Custom InputTypes
  /**
   * KeywordCountOutputType without action
   */
  export type KeywordCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KeywordCountOutputType
     */
    select?: KeywordCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * KeywordCountOutputType without action
   */
  export type KeywordCountOutputTypeCountAdventuresArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdventureKeywordWhereInput
  }


  /**
   * Models
   */

  /**
   * Model Size
   */

  export type AggregateSize = {
    _count: SizeCountAggregateOutputType | null
    _min: SizeMinAggregateOutputType | null
    _max: SizeMaxAggregateOutputType | null
  }

  export type SizeMinAggregateOutputType = {
    id: string | null
    name: string | null
  }

  export type SizeMaxAggregateOutputType = {
    id: string | null
    name: string | null
  }

  export type SizeCountAggregateOutputType = {
    id: number
    name: number
    _all: number
  }


  export type SizeMinAggregateInputType = {
    id?: true
    name?: true
  }

  export type SizeMaxAggregateInputType = {
    id?: true
    name?: true
  }

  export type SizeCountAggregateInputType = {
    id?: true
    name?: true
    _all?: true
  }

  export type SizeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Size to aggregate.
     */
    where?: SizeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sizes to fetch.
     */
    orderBy?: SizeOrderByWithRelationInput | SizeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SizeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sizes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sizes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Sizes
    **/
    _count?: true | SizeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SizeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SizeMaxAggregateInputType
  }

  export type GetSizeAggregateType<T extends SizeAggregateArgs> = {
        [P in keyof T & keyof AggregateSize]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSize[P]>
      : GetScalarType<T[P], AggregateSize[P]>
  }




  export type SizeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SizeWhereInput
    orderBy?: SizeOrderByWithAggregationInput | SizeOrderByWithAggregationInput[]
    by: SizeScalarFieldEnum[] | SizeScalarFieldEnum
    having?: SizeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SizeCountAggregateInputType | true
    _min?: SizeMinAggregateInputType
    _max?: SizeMaxAggregateInputType
  }

  export type SizeGroupByOutputType = {
    id: string
    name: string
    _count: SizeCountAggregateOutputType | null
    _min: SizeMinAggregateOutputType | null
    _max: SizeMaxAggregateOutputType | null
  }

  type GetSizeGroupByPayload<T extends SizeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SizeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SizeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SizeGroupByOutputType[P]>
            : GetScalarType<T[P], SizeGroupByOutputType[P]>
        }
      >
    >


  export type SizeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    creature?: boolean | Size$creatureArgs<ExtArgs>
    _count?: boolean | SizeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["size"]>

  export type SizeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
  }, ExtArgs["result"]["size"]>

  export type SizeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
  }, ExtArgs["result"]["size"]>

  export type SizeSelectScalar = {
    id?: boolean
    name?: boolean
  }

  export type SizeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name", ExtArgs["result"]["size"]>
  export type SizeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creature?: boolean | Size$creatureArgs<ExtArgs>
    _count?: boolean | SizeCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type SizeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type SizeIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $SizePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Size"
    objects: {
      creature: Prisma.$CreaturePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
    }, ExtArgs["result"]["size"]>
    composites: {}
  }

  type SizeGetPayload<S extends boolean | null | undefined | SizeDefaultArgs> = $Result.GetResult<Prisma.$SizePayload, S>

  type SizeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SizeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SizeCountAggregateInputType | true
    }

  export interface SizeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Size'], meta: { name: 'Size' } }
    /**
     * Find zero or one Size that matches the filter.
     * @param {SizeFindUniqueArgs} args - Arguments to find a Size
     * @example
     * // Get one Size
     * const size = await prisma.size.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SizeFindUniqueArgs>(args: SelectSubset<T, SizeFindUniqueArgs<ExtArgs>>): Prisma__SizeClient<$Result.GetResult<Prisma.$SizePayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Size that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SizeFindUniqueOrThrowArgs} args - Arguments to find a Size
     * @example
     * // Get one Size
     * const size = await prisma.size.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SizeFindUniqueOrThrowArgs>(args: SelectSubset<T, SizeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SizeClient<$Result.GetResult<Prisma.$SizePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Size that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SizeFindFirstArgs} args - Arguments to find a Size
     * @example
     * // Get one Size
     * const size = await prisma.size.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SizeFindFirstArgs>(args?: SelectSubset<T, SizeFindFirstArgs<ExtArgs>>): Prisma__SizeClient<$Result.GetResult<Prisma.$SizePayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Size that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SizeFindFirstOrThrowArgs} args - Arguments to find a Size
     * @example
     * // Get one Size
     * const size = await prisma.size.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SizeFindFirstOrThrowArgs>(args?: SelectSubset<T, SizeFindFirstOrThrowArgs<ExtArgs>>): Prisma__SizeClient<$Result.GetResult<Prisma.$SizePayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Sizes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SizeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Sizes
     * const sizes = await prisma.size.findMany()
     * 
     * // Get first 10 Sizes
     * const sizes = await prisma.size.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sizeWithIdOnly = await prisma.size.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SizeFindManyArgs>(args?: SelectSubset<T, SizeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SizePayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Size.
     * @param {SizeCreateArgs} args - Arguments to create a Size.
     * @example
     * // Create one Size
     * const Size = await prisma.size.create({
     *   data: {
     *     // ... data to create a Size
     *   }
     * })
     * 
     */
    create<T extends SizeCreateArgs>(args: SelectSubset<T, SizeCreateArgs<ExtArgs>>): Prisma__SizeClient<$Result.GetResult<Prisma.$SizePayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Sizes.
     * @param {SizeCreateManyArgs} args - Arguments to create many Sizes.
     * @example
     * // Create many Sizes
     * const size = await prisma.size.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SizeCreateManyArgs>(args?: SelectSubset<T, SizeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Sizes and returns the data saved in the database.
     * @param {SizeCreateManyAndReturnArgs} args - Arguments to create many Sizes.
     * @example
     * // Create many Sizes
     * const size = await prisma.size.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Sizes and only return the `id`
     * const sizeWithIdOnly = await prisma.size.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SizeCreateManyAndReturnArgs>(args?: SelectSubset<T, SizeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SizePayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Size.
     * @param {SizeDeleteArgs} args - Arguments to delete one Size.
     * @example
     * // Delete one Size
     * const Size = await prisma.size.delete({
     *   where: {
     *     // ... filter to delete one Size
     *   }
     * })
     * 
     */
    delete<T extends SizeDeleteArgs>(args: SelectSubset<T, SizeDeleteArgs<ExtArgs>>): Prisma__SizeClient<$Result.GetResult<Prisma.$SizePayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Size.
     * @param {SizeUpdateArgs} args - Arguments to update one Size.
     * @example
     * // Update one Size
     * const size = await prisma.size.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SizeUpdateArgs>(args: SelectSubset<T, SizeUpdateArgs<ExtArgs>>): Prisma__SizeClient<$Result.GetResult<Prisma.$SizePayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Sizes.
     * @param {SizeDeleteManyArgs} args - Arguments to filter Sizes to delete.
     * @example
     * // Delete a few Sizes
     * const { count } = await prisma.size.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SizeDeleteManyArgs>(args?: SelectSubset<T, SizeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sizes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SizeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Sizes
     * const size = await prisma.size.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SizeUpdateManyArgs>(args: SelectSubset<T, SizeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sizes and returns the data updated in the database.
     * @param {SizeUpdateManyAndReturnArgs} args - Arguments to update many Sizes.
     * @example
     * // Update many Sizes
     * const size = await prisma.size.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Sizes and only return the `id`
     * const sizeWithIdOnly = await prisma.size.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SizeUpdateManyAndReturnArgs>(args: SelectSubset<T, SizeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SizePayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Size.
     * @param {SizeUpsertArgs} args - Arguments to update or create a Size.
     * @example
     * // Update or create a Size
     * const size = await prisma.size.upsert({
     *   create: {
     *     // ... data to create a Size
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Size we want to update
     *   }
     * })
     */
    upsert<T extends SizeUpsertArgs>(args: SelectSubset<T, SizeUpsertArgs<ExtArgs>>): Prisma__SizeClient<$Result.GetResult<Prisma.$SizePayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Sizes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SizeCountArgs} args - Arguments to filter Sizes to count.
     * @example
     * // Count the number of Sizes
     * const count = await prisma.size.count({
     *   where: {
     *     // ... the filter for the Sizes we want to count
     *   }
     * })
    **/
    count<T extends SizeCountArgs>(
      args?: Subset<T, SizeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SizeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Size.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SizeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SizeAggregateArgs>(args: Subset<T, SizeAggregateArgs>): Prisma.PrismaPromise<GetSizeAggregateType<T>>

    /**
     * Group by Size.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SizeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SizeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SizeGroupByArgs['orderBy'] }
        : { orderBy?: SizeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SizeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSizeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Size model
   */
  readonly fields: SizeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Size.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SizeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    creature<T extends Size$creatureArgs<ExtArgs> = {}>(args?: Subset<T, Size$creatureArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CreaturePayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Size model
   */ 
  interface SizeFieldRefs {
    readonly id: FieldRef<"Size", 'String'>
    readonly name: FieldRef<"Size", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Size findUnique
   */
  export type SizeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Size
     */
    select?: SizeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Size
     */
    omit?: SizeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SizeInclude<ExtArgs> | null
    /**
     * Filter, which Size to fetch.
     */
    where: SizeWhereUniqueInput
  }

  /**
   * Size findUniqueOrThrow
   */
  export type SizeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Size
     */
    select?: SizeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Size
     */
    omit?: SizeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SizeInclude<ExtArgs> | null
    /**
     * Filter, which Size to fetch.
     */
    where: SizeWhereUniqueInput
  }

  /**
   * Size findFirst
   */
  export type SizeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Size
     */
    select?: SizeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Size
     */
    omit?: SizeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SizeInclude<ExtArgs> | null
    /**
     * Filter, which Size to fetch.
     */
    where?: SizeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sizes to fetch.
     */
    orderBy?: SizeOrderByWithRelationInput | SizeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sizes.
     */
    cursor?: SizeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sizes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sizes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sizes.
     */
    distinct?: SizeScalarFieldEnum | SizeScalarFieldEnum[]
  }

  /**
   * Size findFirstOrThrow
   */
  export type SizeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Size
     */
    select?: SizeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Size
     */
    omit?: SizeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SizeInclude<ExtArgs> | null
    /**
     * Filter, which Size to fetch.
     */
    where?: SizeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sizes to fetch.
     */
    orderBy?: SizeOrderByWithRelationInput | SizeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sizes.
     */
    cursor?: SizeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sizes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sizes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sizes.
     */
    distinct?: SizeScalarFieldEnum | SizeScalarFieldEnum[]
  }

  /**
   * Size findMany
   */
  export type SizeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Size
     */
    select?: SizeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Size
     */
    omit?: SizeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SizeInclude<ExtArgs> | null
    /**
     * Filter, which Sizes to fetch.
     */
    where?: SizeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sizes to fetch.
     */
    orderBy?: SizeOrderByWithRelationInput | SizeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Sizes.
     */
    cursor?: SizeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sizes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sizes.
     */
    skip?: number
    distinct?: SizeScalarFieldEnum | SizeScalarFieldEnum[]
  }

  /**
   * Size create
   */
  export type SizeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Size
     */
    select?: SizeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Size
     */
    omit?: SizeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SizeInclude<ExtArgs> | null
    /**
     * The data needed to create a Size.
     */
    data: XOR<SizeCreateInput, SizeUncheckedCreateInput>
  }

  /**
   * Size createMany
   */
  export type SizeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Sizes.
     */
    data: SizeCreateManyInput | SizeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Size createManyAndReturn
   */
  export type SizeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Size
     */
    select?: SizeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Size
     */
    omit?: SizeOmit<ExtArgs> | null
    /**
     * The data used to create many Sizes.
     */
    data: SizeCreateManyInput | SizeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Size update
   */
  export type SizeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Size
     */
    select?: SizeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Size
     */
    omit?: SizeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SizeInclude<ExtArgs> | null
    /**
     * The data needed to update a Size.
     */
    data: XOR<SizeUpdateInput, SizeUncheckedUpdateInput>
    /**
     * Choose, which Size to update.
     */
    where: SizeWhereUniqueInput
  }

  /**
   * Size updateMany
   */
  export type SizeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Sizes.
     */
    data: XOR<SizeUpdateManyMutationInput, SizeUncheckedUpdateManyInput>
    /**
     * Filter which Sizes to update
     */
    where?: SizeWhereInput
    /**
     * Limit how many Sizes to update.
     */
    limit?: number
  }

  /**
   * Size updateManyAndReturn
   */
  export type SizeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Size
     */
    select?: SizeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Size
     */
    omit?: SizeOmit<ExtArgs> | null
    /**
     * The data used to update Sizes.
     */
    data: XOR<SizeUpdateManyMutationInput, SizeUncheckedUpdateManyInput>
    /**
     * Filter which Sizes to update
     */
    where?: SizeWhereInput
    /**
     * Limit how many Sizes to update.
     */
    limit?: number
  }

  /**
   * Size upsert
   */
  export type SizeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Size
     */
    select?: SizeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Size
     */
    omit?: SizeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SizeInclude<ExtArgs> | null
    /**
     * The filter to search for the Size to update in case it exists.
     */
    where: SizeWhereUniqueInput
    /**
     * In case the Size found by the `where` argument doesn't exist, create a new Size with this data.
     */
    create: XOR<SizeCreateInput, SizeUncheckedCreateInput>
    /**
     * In case the Size was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SizeUpdateInput, SizeUncheckedUpdateInput>
  }

  /**
   * Size delete
   */
  export type SizeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Size
     */
    select?: SizeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Size
     */
    omit?: SizeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SizeInclude<ExtArgs> | null
    /**
     * Filter which Size to delete.
     */
    where: SizeWhereUniqueInput
  }

  /**
   * Size deleteMany
   */
  export type SizeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Sizes to delete
     */
    where?: SizeWhereInput
    /**
     * Limit how many Sizes to delete.
     */
    limit?: number
  }

  /**
   * Size.creature
   */
  export type Size$creatureArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Creature
     */
    select?: CreatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Creature
     */
    omit?: CreatureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreatureInclude<ExtArgs> | null
    where?: CreatureWhereInput
    orderBy?: CreatureOrderByWithRelationInput | CreatureOrderByWithRelationInput[]
    cursor?: CreatureWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CreatureScalarFieldEnum | CreatureScalarFieldEnum[]
  }

  /**
   * Size without action
   */
  export type SizeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Size
     */
    select?: SizeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Size
     */
    omit?: SizeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SizeInclude<ExtArgs> | null
  }


  /**
   * Model Source
   */

  export type AggregateSource = {
    _count: SourceCountAggregateOutputType | null
    _avg: SourceAvgAggregateOutputType | null
    _sum: SourceSumAggregateOutputType | null
    _min: SourceMinAggregateOutputType | null
    _max: SourceMaxAggregateOutputType | null
  }

  export type SourceAvgAggregateOutputType = {
    id: number | null
  }

  export type SourceSumAggregateOutputType = {
    id: number | null
  }

  export type SourceMinAggregateOutputType = {
    id: number | null
    shortName: string | null
    name: string | null
  }

  export type SourceMaxAggregateOutputType = {
    id: number | null
    shortName: string | null
    name: string | null
  }

  export type SourceCountAggregateOutputType = {
    id: number
    shortName: number
    name: number
    _all: number
  }


  export type SourceAvgAggregateInputType = {
    id?: true
  }

  export type SourceSumAggregateInputType = {
    id?: true
  }

  export type SourceMinAggregateInputType = {
    id?: true
    shortName?: true
    name?: true
  }

  export type SourceMaxAggregateInputType = {
    id?: true
    shortName?: true
    name?: true
  }

  export type SourceCountAggregateInputType = {
    id?: true
    shortName?: true
    name?: true
    _all?: true
  }

  export type SourceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Source to aggregate.
     */
    where?: SourceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sources to fetch.
     */
    orderBy?: SourceOrderByWithRelationInput | SourceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SourceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sources from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sources.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Sources
    **/
    _count?: true | SourceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SourceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SourceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SourceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SourceMaxAggregateInputType
  }

  export type GetSourceAggregateType<T extends SourceAggregateArgs> = {
        [P in keyof T & keyof AggregateSource]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSource[P]>
      : GetScalarType<T[P], AggregateSource[P]>
  }




  export type SourceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SourceWhereInput
    orderBy?: SourceOrderByWithAggregationInput | SourceOrderByWithAggregationInput[]
    by: SourceScalarFieldEnum[] | SourceScalarFieldEnum
    having?: SourceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SourceCountAggregateInputType | true
    _avg?: SourceAvgAggregateInputType
    _sum?: SourceSumAggregateInputType
    _min?: SourceMinAggregateInputType
    _max?: SourceMaxAggregateInputType
  }

  export type SourceGroupByOutputType = {
    id: number
    shortName: string
    name: string
    _count: SourceCountAggregateOutputType | null
    _avg: SourceAvgAggregateOutputType | null
    _sum: SourceSumAggregateOutputType | null
    _min: SourceMinAggregateOutputType | null
    _max: SourceMaxAggregateOutputType | null
  }

  type GetSourceGroupByPayload<T extends SourceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SourceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SourceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SourceGroupByOutputType[P]>
            : GetScalarType<T[P], SourceGroupByOutputType[P]>
        }
      >
    >


  export type SourceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    shortName?: boolean
    name?: boolean
    creatures?: boolean | Source$creaturesArgs<ExtArgs>
    _count?: boolean | SourceCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["source"]>

  export type SourceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    shortName?: boolean
    name?: boolean
  }, ExtArgs["result"]["source"]>

  export type SourceSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    shortName?: boolean
    name?: boolean
  }, ExtArgs["result"]["source"]>

  export type SourceSelectScalar = {
    id?: boolean
    shortName?: boolean
    name?: boolean
  }

  export type SourceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "shortName" | "name", ExtArgs["result"]["source"]>
  export type SourceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creatures?: boolean | Source$creaturesArgs<ExtArgs>
    _count?: boolean | SourceCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type SourceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type SourceIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $SourcePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Source"
    objects: {
      creatures: Prisma.$CreaturePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      shortName: string
      name: string
    }, ExtArgs["result"]["source"]>
    composites: {}
  }

  type SourceGetPayload<S extends boolean | null | undefined | SourceDefaultArgs> = $Result.GetResult<Prisma.$SourcePayload, S>

  type SourceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SourceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SourceCountAggregateInputType | true
    }

  export interface SourceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Source'], meta: { name: 'Source' } }
    /**
     * Find zero or one Source that matches the filter.
     * @param {SourceFindUniqueArgs} args - Arguments to find a Source
     * @example
     * // Get one Source
     * const source = await prisma.source.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SourceFindUniqueArgs>(args: SelectSubset<T, SourceFindUniqueArgs<ExtArgs>>): Prisma__SourceClient<$Result.GetResult<Prisma.$SourcePayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Source that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SourceFindUniqueOrThrowArgs} args - Arguments to find a Source
     * @example
     * // Get one Source
     * const source = await prisma.source.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SourceFindUniqueOrThrowArgs>(args: SelectSubset<T, SourceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SourceClient<$Result.GetResult<Prisma.$SourcePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Source that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SourceFindFirstArgs} args - Arguments to find a Source
     * @example
     * // Get one Source
     * const source = await prisma.source.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SourceFindFirstArgs>(args?: SelectSubset<T, SourceFindFirstArgs<ExtArgs>>): Prisma__SourceClient<$Result.GetResult<Prisma.$SourcePayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Source that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SourceFindFirstOrThrowArgs} args - Arguments to find a Source
     * @example
     * // Get one Source
     * const source = await prisma.source.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SourceFindFirstOrThrowArgs>(args?: SelectSubset<T, SourceFindFirstOrThrowArgs<ExtArgs>>): Prisma__SourceClient<$Result.GetResult<Prisma.$SourcePayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Sources that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SourceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Sources
     * const sources = await prisma.source.findMany()
     * 
     * // Get first 10 Sources
     * const sources = await prisma.source.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sourceWithIdOnly = await prisma.source.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SourceFindManyArgs>(args?: SelectSubset<T, SourceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SourcePayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Source.
     * @param {SourceCreateArgs} args - Arguments to create a Source.
     * @example
     * // Create one Source
     * const Source = await prisma.source.create({
     *   data: {
     *     // ... data to create a Source
     *   }
     * })
     * 
     */
    create<T extends SourceCreateArgs>(args: SelectSubset<T, SourceCreateArgs<ExtArgs>>): Prisma__SourceClient<$Result.GetResult<Prisma.$SourcePayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Sources.
     * @param {SourceCreateManyArgs} args - Arguments to create many Sources.
     * @example
     * // Create many Sources
     * const source = await prisma.source.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SourceCreateManyArgs>(args?: SelectSubset<T, SourceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Sources and returns the data saved in the database.
     * @param {SourceCreateManyAndReturnArgs} args - Arguments to create many Sources.
     * @example
     * // Create many Sources
     * const source = await prisma.source.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Sources and only return the `id`
     * const sourceWithIdOnly = await prisma.source.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SourceCreateManyAndReturnArgs>(args?: SelectSubset<T, SourceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SourcePayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Source.
     * @param {SourceDeleteArgs} args - Arguments to delete one Source.
     * @example
     * // Delete one Source
     * const Source = await prisma.source.delete({
     *   where: {
     *     // ... filter to delete one Source
     *   }
     * })
     * 
     */
    delete<T extends SourceDeleteArgs>(args: SelectSubset<T, SourceDeleteArgs<ExtArgs>>): Prisma__SourceClient<$Result.GetResult<Prisma.$SourcePayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Source.
     * @param {SourceUpdateArgs} args - Arguments to update one Source.
     * @example
     * // Update one Source
     * const source = await prisma.source.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SourceUpdateArgs>(args: SelectSubset<T, SourceUpdateArgs<ExtArgs>>): Prisma__SourceClient<$Result.GetResult<Prisma.$SourcePayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Sources.
     * @param {SourceDeleteManyArgs} args - Arguments to filter Sources to delete.
     * @example
     * // Delete a few Sources
     * const { count } = await prisma.source.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SourceDeleteManyArgs>(args?: SelectSubset<T, SourceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sources.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SourceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Sources
     * const source = await prisma.source.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SourceUpdateManyArgs>(args: SelectSubset<T, SourceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sources and returns the data updated in the database.
     * @param {SourceUpdateManyAndReturnArgs} args - Arguments to update many Sources.
     * @example
     * // Update many Sources
     * const source = await prisma.source.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Sources and only return the `id`
     * const sourceWithIdOnly = await prisma.source.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SourceUpdateManyAndReturnArgs>(args: SelectSubset<T, SourceUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SourcePayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Source.
     * @param {SourceUpsertArgs} args - Arguments to update or create a Source.
     * @example
     * // Update or create a Source
     * const source = await prisma.source.upsert({
     *   create: {
     *     // ... data to create a Source
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Source we want to update
     *   }
     * })
     */
    upsert<T extends SourceUpsertArgs>(args: SelectSubset<T, SourceUpsertArgs<ExtArgs>>): Prisma__SourceClient<$Result.GetResult<Prisma.$SourcePayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Sources.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SourceCountArgs} args - Arguments to filter Sources to count.
     * @example
     * // Count the number of Sources
     * const count = await prisma.source.count({
     *   where: {
     *     // ... the filter for the Sources we want to count
     *   }
     * })
    **/
    count<T extends SourceCountArgs>(
      args?: Subset<T, SourceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SourceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Source.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SourceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SourceAggregateArgs>(args: Subset<T, SourceAggregateArgs>): Prisma.PrismaPromise<GetSourceAggregateType<T>>

    /**
     * Group by Source.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SourceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SourceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SourceGroupByArgs['orderBy'] }
        : { orderBy?: SourceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SourceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSourceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Source model
   */
  readonly fields: SourceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Source.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SourceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    creatures<T extends Source$creaturesArgs<ExtArgs> = {}>(args?: Subset<T, Source$creaturesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CreaturePayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Source model
   */ 
  interface SourceFieldRefs {
    readonly id: FieldRef<"Source", 'Int'>
    readonly shortName: FieldRef<"Source", 'String'>
    readonly name: FieldRef<"Source", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Source findUnique
   */
  export type SourceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Source
     */
    select?: SourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Source
     */
    omit?: SourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SourceInclude<ExtArgs> | null
    /**
     * Filter, which Source to fetch.
     */
    where: SourceWhereUniqueInput
  }

  /**
   * Source findUniqueOrThrow
   */
  export type SourceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Source
     */
    select?: SourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Source
     */
    omit?: SourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SourceInclude<ExtArgs> | null
    /**
     * Filter, which Source to fetch.
     */
    where: SourceWhereUniqueInput
  }

  /**
   * Source findFirst
   */
  export type SourceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Source
     */
    select?: SourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Source
     */
    omit?: SourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SourceInclude<ExtArgs> | null
    /**
     * Filter, which Source to fetch.
     */
    where?: SourceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sources to fetch.
     */
    orderBy?: SourceOrderByWithRelationInput | SourceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sources.
     */
    cursor?: SourceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sources from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sources.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sources.
     */
    distinct?: SourceScalarFieldEnum | SourceScalarFieldEnum[]
  }

  /**
   * Source findFirstOrThrow
   */
  export type SourceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Source
     */
    select?: SourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Source
     */
    omit?: SourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SourceInclude<ExtArgs> | null
    /**
     * Filter, which Source to fetch.
     */
    where?: SourceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sources to fetch.
     */
    orderBy?: SourceOrderByWithRelationInput | SourceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sources.
     */
    cursor?: SourceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sources from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sources.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sources.
     */
    distinct?: SourceScalarFieldEnum | SourceScalarFieldEnum[]
  }

  /**
   * Source findMany
   */
  export type SourceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Source
     */
    select?: SourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Source
     */
    omit?: SourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SourceInclude<ExtArgs> | null
    /**
     * Filter, which Sources to fetch.
     */
    where?: SourceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sources to fetch.
     */
    orderBy?: SourceOrderByWithRelationInput | SourceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Sources.
     */
    cursor?: SourceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sources from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sources.
     */
    skip?: number
    distinct?: SourceScalarFieldEnum | SourceScalarFieldEnum[]
  }

  /**
   * Source create
   */
  export type SourceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Source
     */
    select?: SourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Source
     */
    omit?: SourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SourceInclude<ExtArgs> | null
    /**
     * The data needed to create a Source.
     */
    data: XOR<SourceCreateInput, SourceUncheckedCreateInput>
  }

  /**
   * Source createMany
   */
  export type SourceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Sources.
     */
    data: SourceCreateManyInput | SourceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Source createManyAndReturn
   */
  export type SourceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Source
     */
    select?: SourceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Source
     */
    omit?: SourceOmit<ExtArgs> | null
    /**
     * The data used to create many Sources.
     */
    data: SourceCreateManyInput | SourceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Source update
   */
  export type SourceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Source
     */
    select?: SourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Source
     */
    omit?: SourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SourceInclude<ExtArgs> | null
    /**
     * The data needed to update a Source.
     */
    data: XOR<SourceUpdateInput, SourceUncheckedUpdateInput>
    /**
     * Choose, which Source to update.
     */
    where: SourceWhereUniqueInput
  }

  /**
   * Source updateMany
   */
  export type SourceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Sources.
     */
    data: XOR<SourceUpdateManyMutationInput, SourceUncheckedUpdateManyInput>
    /**
     * Filter which Sources to update
     */
    where?: SourceWhereInput
    /**
     * Limit how many Sources to update.
     */
    limit?: number
  }

  /**
   * Source updateManyAndReturn
   */
  export type SourceUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Source
     */
    select?: SourceSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Source
     */
    omit?: SourceOmit<ExtArgs> | null
    /**
     * The data used to update Sources.
     */
    data: XOR<SourceUpdateManyMutationInput, SourceUncheckedUpdateManyInput>
    /**
     * Filter which Sources to update
     */
    where?: SourceWhereInput
    /**
     * Limit how many Sources to update.
     */
    limit?: number
  }

  /**
   * Source upsert
   */
  export type SourceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Source
     */
    select?: SourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Source
     */
    omit?: SourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SourceInclude<ExtArgs> | null
    /**
     * The filter to search for the Source to update in case it exists.
     */
    where: SourceWhereUniqueInput
    /**
     * In case the Source found by the `where` argument doesn't exist, create a new Source with this data.
     */
    create: XOR<SourceCreateInput, SourceUncheckedCreateInput>
    /**
     * In case the Source was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SourceUpdateInput, SourceUncheckedUpdateInput>
  }

  /**
   * Source delete
   */
  export type SourceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Source
     */
    select?: SourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Source
     */
    omit?: SourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SourceInclude<ExtArgs> | null
    /**
     * Filter which Source to delete.
     */
    where: SourceWhereUniqueInput
  }

  /**
   * Source deleteMany
   */
  export type SourceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Sources to delete
     */
    where?: SourceWhereInput
    /**
     * Limit how many Sources to delete.
     */
    limit?: number
  }

  /**
   * Source.creatures
   */
  export type Source$creaturesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Creature
     */
    select?: CreatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Creature
     */
    omit?: CreatureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreatureInclude<ExtArgs> | null
    where?: CreatureWhereInput
    orderBy?: CreatureOrderByWithRelationInput | CreatureOrderByWithRelationInput[]
    cursor?: CreatureWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CreatureScalarFieldEnum | CreatureScalarFieldEnum[]
  }

  /**
   * Source without action
   */
  export type SourceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Source
     */
    select?: SourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Source
     */
    omit?: SourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SourceInclude<ExtArgs> | null
  }


  /**
   * Model Language
   */

  export type AggregateLanguage = {
    _count: LanguageCountAggregateOutputType | null
    _avg: LanguageAvgAggregateOutputType | null
    _sum: LanguageSumAggregateOutputType | null
    _min: LanguageMinAggregateOutputType | null
    _max: LanguageMaxAggregateOutputType | null
  }

  export type LanguageAvgAggregateOutputType = {
    id: number | null
  }

  export type LanguageSumAggregateOutputType = {
    id: number | null
  }

  export type LanguageMinAggregateOutputType = {
    id: number | null
    name: string | null
  }

  export type LanguageMaxAggregateOutputType = {
    id: number | null
    name: string | null
  }

  export type LanguageCountAggregateOutputType = {
    id: number
    name: number
    _all: number
  }


  export type LanguageAvgAggregateInputType = {
    id?: true
  }

  export type LanguageSumAggregateInputType = {
    id?: true
  }

  export type LanguageMinAggregateInputType = {
    id?: true
    name?: true
  }

  export type LanguageMaxAggregateInputType = {
    id?: true
    name?: true
  }

  export type LanguageCountAggregateInputType = {
    id?: true
    name?: true
    _all?: true
  }

  export type LanguageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Language to aggregate.
     */
    where?: LanguageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Languages to fetch.
     */
    orderBy?: LanguageOrderByWithRelationInput | LanguageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LanguageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Languages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Languages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Languages
    **/
    _count?: true | LanguageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LanguageAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LanguageSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LanguageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LanguageMaxAggregateInputType
  }

  export type GetLanguageAggregateType<T extends LanguageAggregateArgs> = {
        [P in keyof T & keyof AggregateLanguage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLanguage[P]>
      : GetScalarType<T[P], AggregateLanguage[P]>
  }




  export type LanguageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LanguageWhereInput
    orderBy?: LanguageOrderByWithAggregationInput | LanguageOrderByWithAggregationInput[]
    by: LanguageScalarFieldEnum[] | LanguageScalarFieldEnum
    having?: LanguageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LanguageCountAggregateInputType | true
    _avg?: LanguageAvgAggregateInputType
    _sum?: LanguageSumAggregateInputType
    _min?: LanguageMinAggregateInputType
    _max?: LanguageMaxAggregateInputType
  }

  export type LanguageGroupByOutputType = {
    id: number
    name: string
    _count: LanguageCountAggregateOutputType | null
    _avg: LanguageAvgAggregateOutputType | null
    _sum: LanguageSumAggregateOutputType | null
    _min: LanguageMinAggregateOutputType | null
    _max: LanguageMaxAggregateOutputType | null
  }

  type GetLanguageGroupByPayload<T extends LanguageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LanguageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LanguageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LanguageGroupByOutputType[P]>
            : GetScalarType<T[P], LanguageGroupByOutputType[P]>
        }
      >
    >


  export type LanguageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    creatures?: boolean | Language$creaturesArgs<ExtArgs>
    _count?: boolean | LanguageCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["language"]>

  export type LanguageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
  }, ExtArgs["result"]["language"]>

  export type LanguageSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
  }, ExtArgs["result"]["language"]>

  export type LanguageSelectScalar = {
    id?: boolean
    name?: boolean
  }

  export type LanguageOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name", ExtArgs["result"]["language"]>
  export type LanguageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creatures?: boolean | Language$creaturesArgs<ExtArgs>
    _count?: boolean | LanguageCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type LanguageIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type LanguageIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $LanguagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Language"
    objects: {
      creatures: Prisma.$CreaturePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
    }, ExtArgs["result"]["language"]>
    composites: {}
  }

  type LanguageGetPayload<S extends boolean | null | undefined | LanguageDefaultArgs> = $Result.GetResult<Prisma.$LanguagePayload, S>

  type LanguageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LanguageFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LanguageCountAggregateInputType | true
    }

  export interface LanguageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Language'], meta: { name: 'Language' } }
    /**
     * Find zero or one Language that matches the filter.
     * @param {LanguageFindUniqueArgs} args - Arguments to find a Language
     * @example
     * // Get one Language
     * const language = await prisma.language.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LanguageFindUniqueArgs>(args: SelectSubset<T, LanguageFindUniqueArgs<ExtArgs>>): Prisma__LanguageClient<$Result.GetResult<Prisma.$LanguagePayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Language that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LanguageFindUniqueOrThrowArgs} args - Arguments to find a Language
     * @example
     * // Get one Language
     * const language = await prisma.language.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LanguageFindUniqueOrThrowArgs>(args: SelectSubset<T, LanguageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LanguageClient<$Result.GetResult<Prisma.$LanguagePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Language that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LanguageFindFirstArgs} args - Arguments to find a Language
     * @example
     * // Get one Language
     * const language = await prisma.language.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LanguageFindFirstArgs>(args?: SelectSubset<T, LanguageFindFirstArgs<ExtArgs>>): Prisma__LanguageClient<$Result.GetResult<Prisma.$LanguagePayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Language that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LanguageFindFirstOrThrowArgs} args - Arguments to find a Language
     * @example
     * // Get one Language
     * const language = await prisma.language.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LanguageFindFirstOrThrowArgs>(args?: SelectSubset<T, LanguageFindFirstOrThrowArgs<ExtArgs>>): Prisma__LanguageClient<$Result.GetResult<Prisma.$LanguagePayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Languages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LanguageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Languages
     * const languages = await prisma.language.findMany()
     * 
     * // Get first 10 Languages
     * const languages = await prisma.language.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const languageWithIdOnly = await prisma.language.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LanguageFindManyArgs>(args?: SelectSubset<T, LanguageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LanguagePayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Language.
     * @param {LanguageCreateArgs} args - Arguments to create a Language.
     * @example
     * // Create one Language
     * const Language = await prisma.language.create({
     *   data: {
     *     // ... data to create a Language
     *   }
     * })
     * 
     */
    create<T extends LanguageCreateArgs>(args: SelectSubset<T, LanguageCreateArgs<ExtArgs>>): Prisma__LanguageClient<$Result.GetResult<Prisma.$LanguagePayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Languages.
     * @param {LanguageCreateManyArgs} args - Arguments to create many Languages.
     * @example
     * // Create many Languages
     * const language = await prisma.language.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LanguageCreateManyArgs>(args?: SelectSubset<T, LanguageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Languages and returns the data saved in the database.
     * @param {LanguageCreateManyAndReturnArgs} args - Arguments to create many Languages.
     * @example
     * // Create many Languages
     * const language = await prisma.language.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Languages and only return the `id`
     * const languageWithIdOnly = await prisma.language.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LanguageCreateManyAndReturnArgs>(args?: SelectSubset<T, LanguageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LanguagePayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Language.
     * @param {LanguageDeleteArgs} args - Arguments to delete one Language.
     * @example
     * // Delete one Language
     * const Language = await prisma.language.delete({
     *   where: {
     *     // ... filter to delete one Language
     *   }
     * })
     * 
     */
    delete<T extends LanguageDeleteArgs>(args: SelectSubset<T, LanguageDeleteArgs<ExtArgs>>): Prisma__LanguageClient<$Result.GetResult<Prisma.$LanguagePayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Language.
     * @param {LanguageUpdateArgs} args - Arguments to update one Language.
     * @example
     * // Update one Language
     * const language = await prisma.language.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LanguageUpdateArgs>(args: SelectSubset<T, LanguageUpdateArgs<ExtArgs>>): Prisma__LanguageClient<$Result.GetResult<Prisma.$LanguagePayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Languages.
     * @param {LanguageDeleteManyArgs} args - Arguments to filter Languages to delete.
     * @example
     * // Delete a few Languages
     * const { count } = await prisma.language.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LanguageDeleteManyArgs>(args?: SelectSubset<T, LanguageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Languages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LanguageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Languages
     * const language = await prisma.language.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LanguageUpdateManyArgs>(args: SelectSubset<T, LanguageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Languages and returns the data updated in the database.
     * @param {LanguageUpdateManyAndReturnArgs} args - Arguments to update many Languages.
     * @example
     * // Update many Languages
     * const language = await prisma.language.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Languages and only return the `id`
     * const languageWithIdOnly = await prisma.language.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends LanguageUpdateManyAndReturnArgs>(args: SelectSubset<T, LanguageUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LanguagePayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Language.
     * @param {LanguageUpsertArgs} args - Arguments to update or create a Language.
     * @example
     * // Update or create a Language
     * const language = await prisma.language.upsert({
     *   create: {
     *     // ... data to create a Language
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Language we want to update
     *   }
     * })
     */
    upsert<T extends LanguageUpsertArgs>(args: SelectSubset<T, LanguageUpsertArgs<ExtArgs>>): Prisma__LanguageClient<$Result.GetResult<Prisma.$LanguagePayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Languages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LanguageCountArgs} args - Arguments to filter Languages to count.
     * @example
     * // Count the number of Languages
     * const count = await prisma.language.count({
     *   where: {
     *     // ... the filter for the Languages we want to count
     *   }
     * })
    **/
    count<T extends LanguageCountArgs>(
      args?: Subset<T, LanguageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LanguageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Language.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LanguageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LanguageAggregateArgs>(args: Subset<T, LanguageAggregateArgs>): Prisma.PrismaPromise<GetLanguageAggregateType<T>>

    /**
     * Group by Language.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LanguageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LanguageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LanguageGroupByArgs['orderBy'] }
        : { orderBy?: LanguageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LanguageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLanguageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Language model
   */
  readonly fields: LanguageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Language.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LanguageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    creatures<T extends Language$creaturesArgs<ExtArgs> = {}>(args?: Subset<T, Language$creaturesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CreaturePayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Language model
   */ 
  interface LanguageFieldRefs {
    readonly id: FieldRef<"Language", 'Int'>
    readonly name: FieldRef<"Language", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Language findUnique
   */
  export type LanguageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Language
     */
    select?: LanguageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Language
     */
    omit?: LanguageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LanguageInclude<ExtArgs> | null
    /**
     * Filter, which Language to fetch.
     */
    where: LanguageWhereUniqueInput
  }

  /**
   * Language findUniqueOrThrow
   */
  export type LanguageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Language
     */
    select?: LanguageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Language
     */
    omit?: LanguageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LanguageInclude<ExtArgs> | null
    /**
     * Filter, which Language to fetch.
     */
    where: LanguageWhereUniqueInput
  }

  /**
   * Language findFirst
   */
  export type LanguageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Language
     */
    select?: LanguageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Language
     */
    omit?: LanguageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LanguageInclude<ExtArgs> | null
    /**
     * Filter, which Language to fetch.
     */
    where?: LanguageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Languages to fetch.
     */
    orderBy?: LanguageOrderByWithRelationInput | LanguageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Languages.
     */
    cursor?: LanguageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Languages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Languages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Languages.
     */
    distinct?: LanguageScalarFieldEnum | LanguageScalarFieldEnum[]
  }

  /**
   * Language findFirstOrThrow
   */
  export type LanguageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Language
     */
    select?: LanguageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Language
     */
    omit?: LanguageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LanguageInclude<ExtArgs> | null
    /**
     * Filter, which Language to fetch.
     */
    where?: LanguageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Languages to fetch.
     */
    orderBy?: LanguageOrderByWithRelationInput | LanguageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Languages.
     */
    cursor?: LanguageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Languages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Languages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Languages.
     */
    distinct?: LanguageScalarFieldEnum | LanguageScalarFieldEnum[]
  }

  /**
   * Language findMany
   */
  export type LanguageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Language
     */
    select?: LanguageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Language
     */
    omit?: LanguageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LanguageInclude<ExtArgs> | null
    /**
     * Filter, which Languages to fetch.
     */
    where?: LanguageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Languages to fetch.
     */
    orderBy?: LanguageOrderByWithRelationInput | LanguageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Languages.
     */
    cursor?: LanguageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Languages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Languages.
     */
    skip?: number
    distinct?: LanguageScalarFieldEnum | LanguageScalarFieldEnum[]
  }

  /**
   * Language create
   */
  export type LanguageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Language
     */
    select?: LanguageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Language
     */
    omit?: LanguageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LanguageInclude<ExtArgs> | null
    /**
     * The data needed to create a Language.
     */
    data: XOR<LanguageCreateInput, LanguageUncheckedCreateInput>
  }

  /**
   * Language createMany
   */
  export type LanguageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Languages.
     */
    data: LanguageCreateManyInput | LanguageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Language createManyAndReturn
   */
  export type LanguageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Language
     */
    select?: LanguageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Language
     */
    omit?: LanguageOmit<ExtArgs> | null
    /**
     * The data used to create many Languages.
     */
    data: LanguageCreateManyInput | LanguageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Language update
   */
  export type LanguageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Language
     */
    select?: LanguageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Language
     */
    omit?: LanguageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LanguageInclude<ExtArgs> | null
    /**
     * The data needed to update a Language.
     */
    data: XOR<LanguageUpdateInput, LanguageUncheckedUpdateInput>
    /**
     * Choose, which Language to update.
     */
    where: LanguageWhereUniqueInput
  }

  /**
   * Language updateMany
   */
  export type LanguageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Languages.
     */
    data: XOR<LanguageUpdateManyMutationInput, LanguageUncheckedUpdateManyInput>
    /**
     * Filter which Languages to update
     */
    where?: LanguageWhereInput
    /**
     * Limit how many Languages to update.
     */
    limit?: number
  }

  /**
   * Language updateManyAndReturn
   */
  export type LanguageUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Language
     */
    select?: LanguageSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Language
     */
    omit?: LanguageOmit<ExtArgs> | null
    /**
     * The data used to update Languages.
     */
    data: XOR<LanguageUpdateManyMutationInput, LanguageUncheckedUpdateManyInput>
    /**
     * Filter which Languages to update
     */
    where?: LanguageWhereInput
    /**
     * Limit how many Languages to update.
     */
    limit?: number
  }

  /**
   * Language upsert
   */
  export type LanguageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Language
     */
    select?: LanguageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Language
     */
    omit?: LanguageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LanguageInclude<ExtArgs> | null
    /**
     * The filter to search for the Language to update in case it exists.
     */
    where: LanguageWhereUniqueInput
    /**
     * In case the Language found by the `where` argument doesn't exist, create a new Language with this data.
     */
    create: XOR<LanguageCreateInput, LanguageUncheckedCreateInput>
    /**
     * In case the Language was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LanguageUpdateInput, LanguageUncheckedUpdateInput>
  }

  /**
   * Language delete
   */
  export type LanguageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Language
     */
    select?: LanguageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Language
     */
    omit?: LanguageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LanguageInclude<ExtArgs> | null
    /**
     * Filter which Language to delete.
     */
    where: LanguageWhereUniqueInput
  }

  /**
   * Language deleteMany
   */
  export type LanguageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Languages to delete
     */
    where?: LanguageWhereInput
    /**
     * Limit how many Languages to delete.
     */
    limit?: number
  }

  /**
   * Language.creatures
   */
  export type Language$creaturesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Creature
     */
    select?: CreatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Creature
     */
    omit?: CreatureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreatureInclude<ExtArgs> | null
    where?: CreatureWhereInput
    orderBy?: CreatureOrderByWithRelationInput | CreatureOrderByWithRelationInput[]
    cursor?: CreatureWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CreatureScalarFieldEnum | CreatureScalarFieldEnum[]
  }

  /**
   * Language without action
   */
  export type LanguageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Language
     */
    select?: LanguageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Language
     */
    omit?: LanguageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LanguageInclude<ExtArgs> | null
  }


  /**
   * Model Biome
   */

  export type AggregateBiome = {
    _count: BiomeCountAggregateOutputType | null
    _avg: BiomeAvgAggregateOutputType | null
    _sum: BiomeSumAggregateOutputType | null
    _min: BiomeMinAggregateOutputType | null
    _max: BiomeMaxAggregateOutputType | null
  }

  export type BiomeAvgAggregateOutputType = {
    id: number | null
  }

  export type BiomeSumAggregateOutputType = {
    id: number | null
  }

  export type BiomeMinAggregateOutputType = {
    id: number | null
    key: string | null
    name: string | null
  }

  export type BiomeMaxAggregateOutputType = {
    id: number | null
    key: string | null
    name: string | null
  }

  export type BiomeCountAggregateOutputType = {
    id: number
    key: number
    name: number
    _all: number
  }


  export type BiomeAvgAggregateInputType = {
    id?: true
  }

  export type BiomeSumAggregateInputType = {
    id?: true
  }

  export type BiomeMinAggregateInputType = {
    id?: true
    key?: true
    name?: true
  }

  export type BiomeMaxAggregateInputType = {
    id?: true
    key?: true
    name?: true
  }

  export type BiomeCountAggregateInputType = {
    id?: true
    key?: true
    name?: true
    _all?: true
  }

  export type BiomeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Biome to aggregate.
     */
    where?: BiomeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Biomes to fetch.
     */
    orderBy?: BiomeOrderByWithRelationInput | BiomeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BiomeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Biomes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Biomes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Biomes
    **/
    _count?: true | BiomeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BiomeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BiomeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BiomeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BiomeMaxAggregateInputType
  }

  export type GetBiomeAggregateType<T extends BiomeAggregateArgs> = {
        [P in keyof T & keyof AggregateBiome]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBiome[P]>
      : GetScalarType<T[P], AggregateBiome[P]>
  }




  export type BiomeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BiomeWhereInput
    orderBy?: BiomeOrderByWithAggregationInput | BiomeOrderByWithAggregationInput[]
    by: BiomeScalarFieldEnum[] | BiomeScalarFieldEnum
    having?: BiomeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BiomeCountAggregateInputType | true
    _avg?: BiomeAvgAggregateInputType
    _sum?: BiomeSumAggregateInputType
    _min?: BiomeMinAggregateInputType
    _max?: BiomeMaxAggregateInputType
  }

  export type BiomeGroupByOutputType = {
    id: number
    key: string
    name: string
    _count: BiomeCountAggregateOutputType | null
    _avg: BiomeAvgAggregateOutputType | null
    _sum: BiomeSumAggregateOutputType | null
    _min: BiomeMinAggregateOutputType | null
    _max: BiomeMaxAggregateOutputType | null
  }

  type GetBiomeGroupByPayload<T extends BiomeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BiomeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BiomeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BiomeGroupByOutputType[P]>
            : GetScalarType<T[P], BiomeGroupByOutputType[P]>
        }
      >
    >


  export type BiomeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    key?: boolean
    name?: boolean
    creatures?: boolean | Biome$creaturesArgs<ExtArgs>
    _count?: boolean | BiomeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["biome"]>

  export type BiomeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    key?: boolean
    name?: boolean
  }, ExtArgs["result"]["biome"]>

  export type BiomeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    key?: boolean
    name?: boolean
  }, ExtArgs["result"]["biome"]>

  export type BiomeSelectScalar = {
    id?: boolean
    key?: boolean
    name?: boolean
  }

  export type BiomeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "key" | "name", ExtArgs["result"]["biome"]>
  export type BiomeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creatures?: boolean | Biome$creaturesArgs<ExtArgs>
    _count?: boolean | BiomeCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type BiomeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type BiomeIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $BiomePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Biome"
    objects: {
      creatures: Prisma.$CreaturePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      key: string
      name: string
    }, ExtArgs["result"]["biome"]>
    composites: {}
  }

  type BiomeGetPayload<S extends boolean | null | undefined | BiomeDefaultArgs> = $Result.GetResult<Prisma.$BiomePayload, S>

  type BiomeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BiomeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BiomeCountAggregateInputType | true
    }

  export interface BiomeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Biome'], meta: { name: 'Biome' } }
    /**
     * Find zero or one Biome that matches the filter.
     * @param {BiomeFindUniqueArgs} args - Arguments to find a Biome
     * @example
     * // Get one Biome
     * const biome = await prisma.biome.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BiomeFindUniqueArgs>(args: SelectSubset<T, BiomeFindUniqueArgs<ExtArgs>>): Prisma__BiomeClient<$Result.GetResult<Prisma.$BiomePayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Biome that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BiomeFindUniqueOrThrowArgs} args - Arguments to find a Biome
     * @example
     * // Get one Biome
     * const biome = await prisma.biome.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BiomeFindUniqueOrThrowArgs>(args: SelectSubset<T, BiomeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BiomeClient<$Result.GetResult<Prisma.$BiomePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Biome that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BiomeFindFirstArgs} args - Arguments to find a Biome
     * @example
     * // Get one Biome
     * const biome = await prisma.biome.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BiomeFindFirstArgs>(args?: SelectSubset<T, BiomeFindFirstArgs<ExtArgs>>): Prisma__BiomeClient<$Result.GetResult<Prisma.$BiomePayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Biome that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BiomeFindFirstOrThrowArgs} args - Arguments to find a Biome
     * @example
     * // Get one Biome
     * const biome = await prisma.biome.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BiomeFindFirstOrThrowArgs>(args?: SelectSubset<T, BiomeFindFirstOrThrowArgs<ExtArgs>>): Prisma__BiomeClient<$Result.GetResult<Prisma.$BiomePayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Biomes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BiomeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Biomes
     * const biomes = await prisma.biome.findMany()
     * 
     * // Get first 10 Biomes
     * const biomes = await prisma.biome.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const biomeWithIdOnly = await prisma.biome.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BiomeFindManyArgs>(args?: SelectSubset<T, BiomeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BiomePayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Biome.
     * @param {BiomeCreateArgs} args - Arguments to create a Biome.
     * @example
     * // Create one Biome
     * const Biome = await prisma.biome.create({
     *   data: {
     *     // ... data to create a Biome
     *   }
     * })
     * 
     */
    create<T extends BiomeCreateArgs>(args: SelectSubset<T, BiomeCreateArgs<ExtArgs>>): Prisma__BiomeClient<$Result.GetResult<Prisma.$BiomePayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Biomes.
     * @param {BiomeCreateManyArgs} args - Arguments to create many Biomes.
     * @example
     * // Create many Biomes
     * const biome = await prisma.biome.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BiomeCreateManyArgs>(args?: SelectSubset<T, BiomeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Biomes and returns the data saved in the database.
     * @param {BiomeCreateManyAndReturnArgs} args - Arguments to create many Biomes.
     * @example
     * // Create many Biomes
     * const biome = await prisma.biome.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Biomes and only return the `id`
     * const biomeWithIdOnly = await prisma.biome.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BiomeCreateManyAndReturnArgs>(args?: SelectSubset<T, BiomeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BiomePayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Biome.
     * @param {BiomeDeleteArgs} args - Arguments to delete one Biome.
     * @example
     * // Delete one Biome
     * const Biome = await prisma.biome.delete({
     *   where: {
     *     // ... filter to delete one Biome
     *   }
     * })
     * 
     */
    delete<T extends BiomeDeleteArgs>(args: SelectSubset<T, BiomeDeleteArgs<ExtArgs>>): Prisma__BiomeClient<$Result.GetResult<Prisma.$BiomePayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Biome.
     * @param {BiomeUpdateArgs} args - Arguments to update one Biome.
     * @example
     * // Update one Biome
     * const biome = await prisma.biome.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BiomeUpdateArgs>(args: SelectSubset<T, BiomeUpdateArgs<ExtArgs>>): Prisma__BiomeClient<$Result.GetResult<Prisma.$BiomePayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Biomes.
     * @param {BiomeDeleteManyArgs} args - Arguments to filter Biomes to delete.
     * @example
     * // Delete a few Biomes
     * const { count } = await prisma.biome.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BiomeDeleteManyArgs>(args?: SelectSubset<T, BiomeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Biomes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BiomeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Biomes
     * const biome = await prisma.biome.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BiomeUpdateManyArgs>(args: SelectSubset<T, BiomeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Biomes and returns the data updated in the database.
     * @param {BiomeUpdateManyAndReturnArgs} args - Arguments to update many Biomes.
     * @example
     * // Update many Biomes
     * const biome = await prisma.biome.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Biomes and only return the `id`
     * const biomeWithIdOnly = await prisma.biome.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BiomeUpdateManyAndReturnArgs>(args: SelectSubset<T, BiomeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BiomePayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Biome.
     * @param {BiomeUpsertArgs} args - Arguments to update or create a Biome.
     * @example
     * // Update or create a Biome
     * const biome = await prisma.biome.upsert({
     *   create: {
     *     // ... data to create a Biome
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Biome we want to update
     *   }
     * })
     */
    upsert<T extends BiomeUpsertArgs>(args: SelectSubset<T, BiomeUpsertArgs<ExtArgs>>): Prisma__BiomeClient<$Result.GetResult<Prisma.$BiomePayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Biomes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BiomeCountArgs} args - Arguments to filter Biomes to count.
     * @example
     * // Count the number of Biomes
     * const count = await prisma.biome.count({
     *   where: {
     *     // ... the filter for the Biomes we want to count
     *   }
     * })
    **/
    count<T extends BiomeCountArgs>(
      args?: Subset<T, BiomeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BiomeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Biome.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BiomeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BiomeAggregateArgs>(args: Subset<T, BiomeAggregateArgs>): Prisma.PrismaPromise<GetBiomeAggregateType<T>>

    /**
     * Group by Biome.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BiomeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BiomeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BiomeGroupByArgs['orderBy'] }
        : { orderBy?: BiomeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BiomeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBiomeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Biome model
   */
  readonly fields: BiomeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Biome.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BiomeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    creatures<T extends Biome$creaturesArgs<ExtArgs> = {}>(args?: Subset<T, Biome$creaturesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CreaturePayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Biome model
   */ 
  interface BiomeFieldRefs {
    readonly id: FieldRef<"Biome", 'Int'>
    readonly key: FieldRef<"Biome", 'String'>
    readonly name: FieldRef<"Biome", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Biome findUnique
   */
  export type BiomeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Biome
     */
    select?: BiomeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Biome
     */
    omit?: BiomeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BiomeInclude<ExtArgs> | null
    /**
     * Filter, which Biome to fetch.
     */
    where: BiomeWhereUniqueInput
  }

  /**
   * Biome findUniqueOrThrow
   */
  export type BiomeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Biome
     */
    select?: BiomeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Biome
     */
    omit?: BiomeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BiomeInclude<ExtArgs> | null
    /**
     * Filter, which Biome to fetch.
     */
    where: BiomeWhereUniqueInput
  }

  /**
   * Biome findFirst
   */
  export type BiomeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Biome
     */
    select?: BiomeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Biome
     */
    omit?: BiomeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BiomeInclude<ExtArgs> | null
    /**
     * Filter, which Biome to fetch.
     */
    where?: BiomeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Biomes to fetch.
     */
    orderBy?: BiomeOrderByWithRelationInput | BiomeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Biomes.
     */
    cursor?: BiomeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Biomes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Biomes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Biomes.
     */
    distinct?: BiomeScalarFieldEnum | BiomeScalarFieldEnum[]
  }

  /**
   * Biome findFirstOrThrow
   */
  export type BiomeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Biome
     */
    select?: BiomeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Biome
     */
    omit?: BiomeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BiomeInclude<ExtArgs> | null
    /**
     * Filter, which Biome to fetch.
     */
    where?: BiomeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Biomes to fetch.
     */
    orderBy?: BiomeOrderByWithRelationInput | BiomeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Biomes.
     */
    cursor?: BiomeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Biomes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Biomes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Biomes.
     */
    distinct?: BiomeScalarFieldEnum | BiomeScalarFieldEnum[]
  }

  /**
   * Biome findMany
   */
  export type BiomeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Biome
     */
    select?: BiomeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Biome
     */
    omit?: BiomeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BiomeInclude<ExtArgs> | null
    /**
     * Filter, which Biomes to fetch.
     */
    where?: BiomeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Biomes to fetch.
     */
    orderBy?: BiomeOrderByWithRelationInput | BiomeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Biomes.
     */
    cursor?: BiomeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Biomes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Biomes.
     */
    skip?: number
    distinct?: BiomeScalarFieldEnum | BiomeScalarFieldEnum[]
  }

  /**
   * Biome create
   */
  export type BiomeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Biome
     */
    select?: BiomeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Biome
     */
    omit?: BiomeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BiomeInclude<ExtArgs> | null
    /**
     * The data needed to create a Biome.
     */
    data: XOR<BiomeCreateInput, BiomeUncheckedCreateInput>
  }

  /**
   * Biome createMany
   */
  export type BiomeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Biomes.
     */
    data: BiomeCreateManyInput | BiomeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Biome createManyAndReturn
   */
  export type BiomeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Biome
     */
    select?: BiomeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Biome
     */
    omit?: BiomeOmit<ExtArgs> | null
    /**
     * The data used to create many Biomes.
     */
    data: BiomeCreateManyInput | BiomeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Biome update
   */
  export type BiomeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Biome
     */
    select?: BiomeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Biome
     */
    omit?: BiomeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BiomeInclude<ExtArgs> | null
    /**
     * The data needed to update a Biome.
     */
    data: XOR<BiomeUpdateInput, BiomeUncheckedUpdateInput>
    /**
     * Choose, which Biome to update.
     */
    where: BiomeWhereUniqueInput
  }

  /**
   * Biome updateMany
   */
  export type BiomeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Biomes.
     */
    data: XOR<BiomeUpdateManyMutationInput, BiomeUncheckedUpdateManyInput>
    /**
     * Filter which Biomes to update
     */
    where?: BiomeWhereInput
    /**
     * Limit how many Biomes to update.
     */
    limit?: number
  }

  /**
   * Biome updateManyAndReturn
   */
  export type BiomeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Biome
     */
    select?: BiomeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Biome
     */
    omit?: BiomeOmit<ExtArgs> | null
    /**
     * The data used to update Biomes.
     */
    data: XOR<BiomeUpdateManyMutationInput, BiomeUncheckedUpdateManyInput>
    /**
     * Filter which Biomes to update
     */
    where?: BiomeWhereInput
    /**
     * Limit how many Biomes to update.
     */
    limit?: number
  }

  /**
   * Biome upsert
   */
  export type BiomeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Biome
     */
    select?: BiomeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Biome
     */
    omit?: BiomeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BiomeInclude<ExtArgs> | null
    /**
     * The filter to search for the Biome to update in case it exists.
     */
    where: BiomeWhereUniqueInput
    /**
     * In case the Biome found by the `where` argument doesn't exist, create a new Biome with this data.
     */
    create: XOR<BiomeCreateInput, BiomeUncheckedCreateInput>
    /**
     * In case the Biome was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BiomeUpdateInput, BiomeUncheckedUpdateInput>
  }

  /**
   * Biome delete
   */
  export type BiomeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Biome
     */
    select?: BiomeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Biome
     */
    omit?: BiomeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BiomeInclude<ExtArgs> | null
    /**
     * Filter which Biome to delete.
     */
    where: BiomeWhereUniqueInput
  }

  /**
   * Biome deleteMany
   */
  export type BiomeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Biomes to delete
     */
    where?: BiomeWhereInput
    /**
     * Limit how many Biomes to delete.
     */
    limit?: number
  }

  /**
   * Biome.creatures
   */
  export type Biome$creaturesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Creature
     */
    select?: CreatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Creature
     */
    omit?: CreatureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreatureInclude<ExtArgs> | null
    where?: CreatureWhereInput
    orderBy?: CreatureOrderByWithRelationInput | CreatureOrderByWithRelationInput[]
    cursor?: CreatureWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CreatureScalarFieldEnum | CreatureScalarFieldEnum[]
  }

  /**
   * Biome without action
   */
  export type BiomeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Biome
     */
    select?: BiomeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Biome
     */
    omit?: BiomeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BiomeInclude<ExtArgs> | null
  }


  /**
   * Model Type
   */

  export type AggregateType = {
    _count: TypeCountAggregateOutputType | null
    _avg: TypeAvgAggregateOutputType | null
    _sum: TypeSumAggregateOutputType | null
    _min: TypeMinAggregateOutputType | null
    _max: TypeMaxAggregateOutputType | null
  }

  export type TypeAvgAggregateOutputType = {
    id: number | null
  }

  export type TypeSumAggregateOutputType = {
    id: number | null
  }

  export type TypeMinAggregateOutputType = {
    id: number | null
    name: string | null
  }

  export type TypeMaxAggregateOutputType = {
    id: number | null
    name: string | null
  }

  export type TypeCountAggregateOutputType = {
    id: number
    name: number
    _all: number
  }


  export type TypeAvgAggregateInputType = {
    id?: true
  }

  export type TypeSumAggregateInputType = {
    id?: true
  }

  export type TypeMinAggregateInputType = {
    id?: true
    name?: true
  }

  export type TypeMaxAggregateInputType = {
    id?: true
    name?: true
  }

  export type TypeCountAggregateInputType = {
    id?: true
    name?: true
    _all?: true
  }

  export type TypeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Type to aggregate.
     */
    where?: TypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Types to fetch.
     */
    orderBy?: TypeOrderByWithRelationInput | TypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Types from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Types.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Types
    **/
    _count?: true | TypeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TypeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TypeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TypeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TypeMaxAggregateInputType
  }

  export type GetTypeAggregateType<T extends TypeAggregateArgs> = {
        [P in keyof T & keyof AggregateType]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateType[P]>
      : GetScalarType<T[P], AggregateType[P]>
  }




  export type TypeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TypeWhereInput
    orderBy?: TypeOrderByWithAggregationInput | TypeOrderByWithAggregationInput[]
    by: TypeScalarFieldEnum[] | TypeScalarFieldEnum
    having?: TypeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TypeCountAggregateInputType | true
    _avg?: TypeAvgAggregateInputType
    _sum?: TypeSumAggregateInputType
    _min?: TypeMinAggregateInputType
    _max?: TypeMaxAggregateInputType
  }

  export type TypeGroupByOutputType = {
    id: number
    name: string
    _count: TypeCountAggregateOutputType | null
    _avg: TypeAvgAggregateOutputType | null
    _sum: TypeSumAggregateOutputType | null
    _min: TypeMinAggregateOutputType | null
    _max: TypeMaxAggregateOutputType | null
  }

  type GetTypeGroupByPayload<T extends TypeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TypeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TypeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TypeGroupByOutputType[P]>
            : GetScalarType<T[P], TypeGroupByOutputType[P]>
        }
      >
    >


  export type TypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    creatures?: boolean | Type$creaturesArgs<ExtArgs>
    _count?: boolean | TypeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["type"]>

  export type TypeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
  }, ExtArgs["result"]["type"]>

  export type TypeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
  }, ExtArgs["result"]["type"]>

  export type TypeSelectScalar = {
    id?: boolean
    name?: boolean
  }

  export type TypeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name", ExtArgs["result"]["type"]>
  export type TypeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creatures?: boolean | Type$creaturesArgs<ExtArgs>
    _count?: boolean | TypeCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TypeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type TypeIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $TypePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Type"
    objects: {
      creatures: Prisma.$CreaturePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
    }, ExtArgs["result"]["type"]>
    composites: {}
  }

  type TypeGetPayload<S extends boolean | null | undefined | TypeDefaultArgs> = $Result.GetResult<Prisma.$TypePayload, S>

  type TypeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TypeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TypeCountAggregateInputType | true
    }

  export interface TypeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Type'], meta: { name: 'Type' } }
    /**
     * Find zero or one Type that matches the filter.
     * @param {TypeFindUniqueArgs} args - Arguments to find a Type
     * @example
     * // Get one Type
     * const type = await prisma.type.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TypeFindUniqueArgs>(args: SelectSubset<T, TypeFindUniqueArgs<ExtArgs>>): Prisma__TypeClient<$Result.GetResult<Prisma.$TypePayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Type that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TypeFindUniqueOrThrowArgs} args - Arguments to find a Type
     * @example
     * // Get one Type
     * const type = await prisma.type.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TypeFindUniqueOrThrowArgs>(args: SelectSubset<T, TypeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TypeClient<$Result.GetResult<Prisma.$TypePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Type that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TypeFindFirstArgs} args - Arguments to find a Type
     * @example
     * // Get one Type
     * const type = await prisma.type.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TypeFindFirstArgs>(args?: SelectSubset<T, TypeFindFirstArgs<ExtArgs>>): Prisma__TypeClient<$Result.GetResult<Prisma.$TypePayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Type that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TypeFindFirstOrThrowArgs} args - Arguments to find a Type
     * @example
     * // Get one Type
     * const type = await prisma.type.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TypeFindFirstOrThrowArgs>(args?: SelectSubset<T, TypeFindFirstOrThrowArgs<ExtArgs>>): Prisma__TypeClient<$Result.GetResult<Prisma.$TypePayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Types that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TypeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Types
     * const types = await prisma.type.findMany()
     * 
     * // Get first 10 Types
     * const types = await prisma.type.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const typeWithIdOnly = await prisma.type.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TypeFindManyArgs>(args?: SelectSubset<T, TypeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TypePayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Type.
     * @param {TypeCreateArgs} args - Arguments to create a Type.
     * @example
     * // Create one Type
     * const Type = await prisma.type.create({
     *   data: {
     *     // ... data to create a Type
     *   }
     * })
     * 
     */
    create<T extends TypeCreateArgs>(args: SelectSubset<T, TypeCreateArgs<ExtArgs>>): Prisma__TypeClient<$Result.GetResult<Prisma.$TypePayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Types.
     * @param {TypeCreateManyArgs} args - Arguments to create many Types.
     * @example
     * // Create many Types
     * const type = await prisma.type.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TypeCreateManyArgs>(args?: SelectSubset<T, TypeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Types and returns the data saved in the database.
     * @param {TypeCreateManyAndReturnArgs} args - Arguments to create many Types.
     * @example
     * // Create many Types
     * const type = await prisma.type.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Types and only return the `id`
     * const typeWithIdOnly = await prisma.type.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TypeCreateManyAndReturnArgs>(args?: SelectSubset<T, TypeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TypePayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Type.
     * @param {TypeDeleteArgs} args - Arguments to delete one Type.
     * @example
     * // Delete one Type
     * const Type = await prisma.type.delete({
     *   where: {
     *     // ... filter to delete one Type
     *   }
     * })
     * 
     */
    delete<T extends TypeDeleteArgs>(args: SelectSubset<T, TypeDeleteArgs<ExtArgs>>): Prisma__TypeClient<$Result.GetResult<Prisma.$TypePayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Type.
     * @param {TypeUpdateArgs} args - Arguments to update one Type.
     * @example
     * // Update one Type
     * const type = await prisma.type.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TypeUpdateArgs>(args: SelectSubset<T, TypeUpdateArgs<ExtArgs>>): Prisma__TypeClient<$Result.GetResult<Prisma.$TypePayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Types.
     * @param {TypeDeleteManyArgs} args - Arguments to filter Types to delete.
     * @example
     * // Delete a few Types
     * const { count } = await prisma.type.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TypeDeleteManyArgs>(args?: SelectSubset<T, TypeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Types.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TypeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Types
     * const type = await prisma.type.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TypeUpdateManyArgs>(args: SelectSubset<T, TypeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Types and returns the data updated in the database.
     * @param {TypeUpdateManyAndReturnArgs} args - Arguments to update many Types.
     * @example
     * // Update many Types
     * const type = await prisma.type.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Types and only return the `id`
     * const typeWithIdOnly = await prisma.type.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TypeUpdateManyAndReturnArgs>(args: SelectSubset<T, TypeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TypePayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Type.
     * @param {TypeUpsertArgs} args - Arguments to update or create a Type.
     * @example
     * // Update or create a Type
     * const type = await prisma.type.upsert({
     *   create: {
     *     // ... data to create a Type
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Type we want to update
     *   }
     * })
     */
    upsert<T extends TypeUpsertArgs>(args: SelectSubset<T, TypeUpsertArgs<ExtArgs>>): Prisma__TypeClient<$Result.GetResult<Prisma.$TypePayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Types.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TypeCountArgs} args - Arguments to filter Types to count.
     * @example
     * // Count the number of Types
     * const count = await prisma.type.count({
     *   where: {
     *     // ... the filter for the Types we want to count
     *   }
     * })
    **/
    count<T extends TypeCountArgs>(
      args?: Subset<T, TypeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TypeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Type.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TypeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TypeAggregateArgs>(args: Subset<T, TypeAggregateArgs>): Prisma.PrismaPromise<GetTypeAggregateType<T>>

    /**
     * Group by Type.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TypeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TypeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TypeGroupByArgs['orderBy'] }
        : { orderBy?: TypeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TypeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTypeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Type model
   */
  readonly fields: TypeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Type.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TypeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    creatures<T extends Type$creaturesArgs<ExtArgs> = {}>(args?: Subset<T, Type$creaturesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CreaturePayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Type model
   */ 
  interface TypeFieldRefs {
    readonly id: FieldRef<"Type", 'Int'>
    readonly name: FieldRef<"Type", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Type findUnique
   */
  export type TypeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Type
     */
    select?: TypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Type
     */
    omit?: TypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TypeInclude<ExtArgs> | null
    /**
     * Filter, which Type to fetch.
     */
    where: TypeWhereUniqueInput
  }

  /**
   * Type findUniqueOrThrow
   */
  export type TypeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Type
     */
    select?: TypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Type
     */
    omit?: TypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TypeInclude<ExtArgs> | null
    /**
     * Filter, which Type to fetch.
     */
    where: TypeWhereUniqueInput
  }

  /**
   * Type findFirst
   */
  export type TypeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Type
     */
    select?: TypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Type
     */
    omit?: TypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TypeInclude<ExtArgs> | null
    /**
     * Filter, which Type to fetch.
     */
    where?: TypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Types to fetch.
     */
    orderBy?: TypeOrderByWithRelationInput | TypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Types.
     */
    cursor?: TypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Types from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Types.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Types.
     */
    distinct?: TypeScalarFieldEnum | TypeScalarFieldEnum[]
  }

  /**
   * Type findFirstOrThrow
   */
  export type TypeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Type
     */
    select?: TypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Type
     */
    omit?: TypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TypeInclude<ExtArgs> | null
    /**
     * Filter, which Type to fetch.
     */
    where?: TypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Types to fetch.
     */
    orderBy?: TypeOrderByWithRelationInput | TypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Types.
     */
    cursor?: TypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Types from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Types.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Types.
     */
    distinct?: TypeScalarFieldEnum | TypeScalarFieldEnum[]
  }

  /**
   * Type findMany
   */
  export type TypeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Type
     */
    select?: TypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Type
     */
    omit?: TypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TypeInclude<ExtArgs> | null
    /**
     * Filter, which Types to fetch.
     */
    where?: TypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Types to fetch.
     */
    orderBy?: TypeOrderByWithRelationInput | TypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Types.
     */
    cursor?: TypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Types from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Types.
     */
    skip?: number
    distinct?: TypeScalarFieldEnum | TypeScalarFieldEnum[]
  }

  /**
   * Type create
   */
  export type TypeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Type
     */
    select?: TypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Type
     */
    omit?: TypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TypeInclude<ExtArgs> | null
    /**
     * The data needed to create a Type.
     */
    data: XOR<TypeCreateInput, TypeUncheckedCreateInput>
  }

  /**
   * Type createMany
   */
  export type TypeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Types.
     */
    data: TypeCreateManyInput | TypeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Type createManyAndReturn
   */
  export type TypeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Type
     */
    select?: TypeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Type
     */
    omit?: TypeOmit<ExtArgs> | null
    /**
     * The data used to create many Types.
     */
    data: TypeCreateManyInput | TypeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Type update
   */
  export type TypeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Type
     */
    select?: TypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Type
     */
    omit?: TypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TypeInclude<ExtArgs> | null
    /**
     * The data needed to update a Type.
     */
    data: XOR<TypeUpdateInput, TypeUncheckedUpdateInput>
    /**
     * Choose, which Type to update.
     */
    where: TypeWhereUniqueInput
  }

  /**
   * Type updateMany
   */
  export type TypeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Types.
     */
    data: XOR<TypeUpdateManyMutationInput, TypeUncheckedUpdateManyInput>
    /**
     * Filter which Types to update
     */
    where?: TypeWhereInput
    /**
     * Limit how many Types to update.
     */
    limit?: number
  }

  /**
   * Type updateManyAndReturn
   */
  export type TypeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Type
     */
    select?: TypeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Type
     */
    omit?: TypeOmit<ExtArgs> | null
    /**
     * The data used to update Types.
     */
    data: XOR<TypeUpdateManyMutationInput, TypeUncheckedUpdateManyInput>
    /**
     * Filter which Types to update
     */
    where?: TypeWhereInput
    /**
     * Limit how many Types to update.
     */
    limit?: number
  }

  /**
   * Type upsert
   */
  export type TypeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Type
     */
    select?: TypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Type
     */
    omit?: TypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TypeInclude<ExtArgs> | null
    /**
     * The filter to search for the Type to update in case it exists.
     */
    where: TypeWhereUniqueInput
    /**
     * In case the Type found by the `where` argument doesn't exist, create a new Type with this data.
     */
    create: XOR<TypeCreateInput, TypeUncheckedCreateInput>
    /**
     * In case the Type was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TypeUpdateInput, TypeUncheckedUpdateInput>
  }

  /**
   * Type delete
   */
  export type TypeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Type
     */
    select?: TypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Type
     */
    omit?: TypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TypeInclude<ExtArgs> | null
    /**
     * Filter which Type to delete.
     */
    where: TypeWhereUniqueInput
  }

  /**
   * Type deleteMany
   */
  export type TypeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Types to delete
     */
    where?: TypeWhereInput
    /**
     * Limit how many Types to delete.
     */
    limit?: number
  }

  /**
   * Type.creatures
   */
  export type Type$creaturesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Creature
     */
    select?: CreatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Creature
     */
    omit?: CreatureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreatureInclude<ExtArgs> | null
    where?: CreatureWhereInput
    orderBy?: CreatureOrderByWithRelationInput | CreatureOrderByWithRelationInput[]
    cursor?: CreatureWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CreatureScalarFieldEnum | CreatureScalarFieldEnum[]
  }

  /**
   * Type without action
   */
  export type TypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Type
     */
    select?: TypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Type
     */
    omit?: TypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TypeInclude<ExtArgs> | null
  }


  /**
   * Model Alignment
   */

  export type AggregateAlignment = {
    _count: AlignmentCountAggregateOutputType | null
    _avg: AlignmentAvgAggregateOutputType | null
    _sum: AlignmentSumAggregateOutputType | null
    _min: AlignmentMinAggregateOutputType | null
    _max: AlignmentMaxAggregateOutputType | null
  }

  export type AlignmentAvgAggregateOutputType = {
    id: number | null
  }

  export type AlignmentSumAggregateOutputType = {
    id: number | null
  }

  export type AlignmentMinAggregateOutputType = {
    id: number | null
    name: string | null
  }

  export type AlignmentMaxAggregateOutputType = {
    id: number | null
    name: string | null
  }

  export type AlignmentCountAggregateOutputType = {
    id: number
    name: number
    _all: number
  }


  export type AlignmentAvgAggregateInputType = {
    id?: true
  }

  export type AlignmentSumAggregateInputType = {
    id?: true
  }

  export type AlignmentMinAggregateInputType = {
    id?: true
    name?: true
  }

  export type AlignmentMaxAggregateInputType = {
    id?: true
    name?: true
  }

  export type AlignmentCountAggregateInputType = {
    id?: true
    name?: true
    _all?: true
  }

  export type AlignmentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Alignment to aggregate.
     */
    where?: AlignmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Alignments to fetch.
     */
    orderBy?: AlignmentOrderByWithRelationInput | AlignmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AlignmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Alignments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Alignments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Alignments
    **/
    _count?: true | AlignmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AlignmentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AlignmentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AlignmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AlignmentMaxAggregateInputType
  }

  export type GetAlignmentAggregateType<T extends AlignmentAggregateArgs> = {
        [P in keyof T & keyof AggregateAlignment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAlignment[P]>
      : GetScalarType<T[P], AggregateAlignment[P]>
  }




  export type AlignmentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AlignmentWhereInput
    orderBy?: AlignmentOrderByWithAggregationInput | AlignmentOrderByWithAggregationInput[]
    by: AlignmentScalarFieldEnum[] | AlignmentScalarFieldEnum
    having?: AlignmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AlignmentCountAggregateInputType | true
    _avg?: AlignmentAvgAggregateInputType
    _sum?: AlignmentSumAggregateInputType
    _min?: AlignmentMinAggregateInputType
    _max?: AlignmentMaxAggregateInputType
  }

  export type AlignmentGroupByOutputType = {
    id: number
    name: string
    _count: AlignmentCountAggregateOutputType | null
    _avg: AlignmentAvgAggregateOutputType | null
    _sum: AlignmentSumAggregateOutputType | null
    _min: AlignmentMinAggregateOutputType | null
    _max: AlignmentMaxAggregateOutputType | null
  }

  type GetAlignmentGroupByPayload<T extends AlignmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AlignmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AlignmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AlignmentGroupByOutputType[P]>
            : GetScalarType<T[P], AlignmentGroupByOutputType[P]>
        }
      >
    >


  export type AlignmentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    creatures?: boolean | Alignment$creaturesArgs<ExtArgs>
    _count?: boolean | AlignmentCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["alignment"]>

  export type AlignmentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
  }, ExtArgs["result"]["alignment"]>

  export type AlignmentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
  }, ExtArgs["result"]["alignment"]>

  export type AlignmentSelectScalar = {
    id?: boolean
    name?: boolean
  }

  export type AlignmentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name", ExtArgs["result"]["alignment"]>
  export type AlignmentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creatures?: boolean | Alignment$creaturesArgs<ExtArgs>
    _count?: boolean | AlignmentCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type AlignmentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type AlignmentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $AlignmentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Alignment"
    objects: {
      creatures: Prisma.$CreaturePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
    }, ExtArgs["result"]["alignment"]>
    composites: {}
  }

  type AlignmentGetPayload<S extends boolean | null | undefined | AlignmentDefaultArgs> = $Result.GetResult<Prisma.$AlignmentPayload, S>

  type AlignmentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AlignmentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AlignmentCountAggregateInputType | true
    }

  export interface AlignmentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Alignment'], meta: { name: 'Alignment' } }
    /**
     * Find zero or one Alignment that matches the filter.
     * @param {AlignmentFindUniqueArgs} args - Arguments to find a Alignment
     * @example
     * // Get one Alignment
     * const alignment = await prisma.alignment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AlignmentFindUniqueArgs>(args: SelectSubset<T, AlignmentFindUniqueArgs<ExtArgs>>): Prisma__AlignmentClient<$Result.GetResult<Prisma.$AlignmentPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Alignment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AlignmentFindUniqueOrThrowArgs} args - Arguments to find a Alignment
     * @example
     * // Get one Alignment
     * const alignment = await prisma.alignment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AlignmentFindUniqueOrThrowArgs>(args: SelectSubset<T, AlignmentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AlignmentClient<$Result.GetResult<Prisma.$AlignmentPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Alignment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlignmentFindFirstArgs} args - Arguments to find a Alignment
     * @example
     * // Get one Alignment
     * const alignment = await prisma.alignment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AlignmentFindFirstArgs>(args?: SelectSubset<T, AlignmentFindFirstArgs<ExtArgs>>): Prisma__AlignmentClient<$Result.GetResult<Prisma.$AlignmentPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Alignment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlignmentFindFirstOrThrowArgs} args - Arguments to find a Alignment
     * @example
     * // Get one Alignment
     * const alignment = await prisma.alignment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AlignmentFindFirstOrThrowArgs>(args?: SelectSubset<T, AlignmentFindFirstOrThrowArgs<ExtArgs>>): Prisma__AlignmentClient<$Result.GetResult<Prisma.$AlignmentPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Alignments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlignmentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Alignments
     * const alignments = await prisma.alignment.findMany()
     * 
     * // Get first 10 Alignments
     * const alignments = await prisma.alignment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const alignmentWithIdOnly = await prisma.alignment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AlignmentFindManyArgs>(args?: SelectSubset<T, AlignmentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AlignmentPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Alignment.
     * @param {AlignmentCreateArgs} args - Arguments to create a Alignment.
     * @example
     * // Create one Alignment
     * const Alignment = await prisma.alignment.create({
     *   data: {
     *     // ... data to create a Alignment
     *   }
     * })
     * 
     */
    create<T extends AlignmentCreateArgs>(args: SelectSubset<T, AlignmentCreateArgs<ExtArgs>>): Prisma__AlignmentClient<$Result.GetResult<Prisma.$AlignmentPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Alignments.
     * @param {AlignmentCreateManyArgs} args - Arguments to create many Alignments.
     * @example
     * // Create many Alignments
     * const alignment = await prisma.alignment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AlignmentCreateManyArgs>(args?: SelectSubset<T, AlignmentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Alignments and returns the data saved in the database.
     * @param {AlignmentCreateManyAndReturnArgs} args - Arguments to create many Alignments.
     * @example
     * // Create many Alignments
     * const alignment = await prisma.alignment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Alignments and only return the `id`
     * const alignmentWithIdOnly = await prisma.alignment.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AlignmentCreateManyAndReturnArgs>(args?: SelectSubset<T, AlignmentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AlignmentPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Alignment.
     * @param {AlignmentDeleteArgs} args - Arguments to delete one Alignment.
     * @example
     * // Delete one Alignment
     * const Alignment = await prisma.alignment.delete({
     *   where: {
     *     // ... filter to delete one Alignment
     *   }
     * })
     * 
     */
    delete<T extends AlignmentDeleteArgs>(args: SelectSubset<T, AlignmentDeleteArgs<ExtArgs>>): Prisma__AlignmentClient<$Result.GetResult<Prisma.$AlignmentPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Alignment.
     * @param {AlignmentUpdateArgs} args - Arguments to update one Alignment.
     * @example
     * // Update one Alignment
     * const alignment = await prisma.alignment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AlignmentUpdateArgs>(args: SelectSubset<T, AlignmentUpdateArgs<ExtArgs>>): Prisma__AlignmentClient<$Result.GetResult<Prisma.$AlignmentPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Alignments.
     * @param {AlignmentDeleteManyArgs} args - Arguments to filter Alignments to delete.
     * @example
     * // Delete a few Alignments
     * const { count } = await prisma.alignment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AlignmentDeleteManyArgs>(args?: SelectSubset<T, AlignmentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Alignments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlignmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Alignments
     * const alignment = await prisma.alignment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AlignmentUpdateManyArgs>(args: SelectSubset<T, AlignmentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Alignments and returns the data updated in the database.
     * @param {AlignmentUpdateManyAndReturnArgs} args - Arguments to update many Alignments.
     * @example
     * // Update many Alignments
     * const alignment = await prisma.alignment.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Alignments and only return the `id`
     * const alignmentWithIdOnly = await prisma.alignment.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AlignmentUpdateManyAndReturnArgs>(args: SelectSubset<T, AlignmentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AlignmentPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Alignment.
     * @param {AlignmentUpsertArgs} args - Arguments to update or create a Alignment.
     * @example
     * // Update or create a Alignment
     * const alignment = await prisma.alignment.upsert({
     *   create: {
     *     // ... data to create a Alignment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Alignment we want to update
     *   }
     * })
     */
    upsert<T extends AlignmentUpsertArgs>(args: SelectSubset<T, AlignmentUpsertArgs<ExtArgs>>): Prisma__AlignmentClient<$Result.GetResult<Prisma.$AlignmentPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Alignments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlignmentCountArgs} args - Arguments to filter Alignments to count.
     * @example
     * // Count the number of Alignments
     * const count = await prisma.alignment.count({
     *   where: {
     *     // ... the filter for the Alignments we want to count
     *   }
     * })
    **/
    count<T extends AlignmentCountArgs>(
      args?: Subset<T, AlignmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AlignmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Alignment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlignmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AlignmentAggregateArgs>(args: Subset<T, AlignmentAggregateArgs>): Prisma.PrismaPromise<GetAlignmentAggregateType<T>>

    /**
     * Group by Alignment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlignmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AlignmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AlignmentGroupByArgs['orderBy'] }
        : { orderBy?: AlignmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AlignmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAlignmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Alignment model
   */
  readonly fields: AlignmentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Alignment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AlignmentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    creatures<T extends Alignment$creaturesArgs<ExtArgs> = {}>(args?: Subset<T, Alignment$creaturesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CreaturePayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Alignment model
   */ 
  interface AlignmentFieldRefs {
    readonly id: FieldRef<"Alignment", 'Int'>
    readonly name: FieldRef<"Alignment", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Alignment findUnique
   */
  export type AlignmentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alignment
     */
    select?: AlignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Alignment
     */
    omit?: AlignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlignmentInclude<ExtArgs> | null
    /**
     * Filter, which Alignment to fetch.
     */
    where: AlignmentWhereUniqueInput
  }

  /**
   * Alignment findUniqueOrThrow
   */
  export type AlignmentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alignment
     */
    select?: AlignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Alignment
     */
    omit?: AlignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlignmentInclude<ExtArgs> | null
    /**
     * Filter, which Alignment to fetch.
     */
    where: AlignmentWhereUniqueInput
  }

  /**
   * Alignment findFirst
   */
  export type AlignmentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alignment
     */
    select?: AlignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Alignment
     */
    omit?: AlignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlignmentInclude<ExtArgs> | null
    /**
     * Filter, which Alignment to fetch.
     */
    where?: AlignmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Alignments to fetch.
     */
    orderBy?: AlignmentOrderByWithRelationInput | AlignmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Alignments.
     */
    cursor?: AlignmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Alignments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Alignments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Alignments.
     */
    distinct?: AlignmentScalarFieldEnum | AlignmentScalarFieldEnum[]
  }

  /**
   * Alignment findFirstOrThrow
   */
  export type AlignmentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alignment
     */
    select?: AlignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Alignment
     */
    omit?: AlignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlignmentInclude<ExtArgs> | null
    /**
     * Filter, which Alignment to fetch.
     */
    where?: AlignmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Alignments to fetch.
     */
    orderBy?: AlignmentOrderByWithRelationInput | AlignmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Alignments.
     */
    cursor?: AlignmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Alignments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Alignments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Alignments.
     */
    distinct?: AlignmentScalarFieldEnum | AlignmentScalarFieldEnum[]
  }

  /**
   * Alignment findMany
   */
  export type AlignmentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alignment
     */
    select?: AlignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Alignment
     */
    omit?: AlignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlignmentInclude<ExtArgs> | null
    /**
     * Filter, which Alignments to fetch.
     */
    where?: AlignmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Alignments to fetch.
     */
    orderBy?: AlignmentOrderByWithRelationInput | AlignmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Alignments.
     */
    cursor?: AlignmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Alignments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Alignments.
     */
    skip?: number
    distinct?: AlignmentScalarFieldEnum | AlignmentScalarFieldEnum[]
  }

  /**
   * Alignment create
   */
  export type AlignmentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alignment
     */
    select?: AlignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Alignment
     */
    omit?: AlignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlignmentInclude<ExtArgs> | null
    /**
     * The data needed to create a Alignment.
     */
    data: XOR<AlignmentCreateInput, AlignmentUncheckedCreateInput>
  }

  /**
   * Alignment createMany
   */
  export type AlignmentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Alignments.
     */
    data: AlignmentCreateManyInput | AlignmentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Alignment createManyAndReturn
   */
  export type AlignmentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alignment
     */
    select?: AlignmentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Alignment
     */
    omit?: AlignmentOmit<ExtArgs> | null
    /**
     * The data used to create many Alignments.
     */
    data: AlignmentCreateManyInput | AlignmentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Alignment update
   */
  export type AlignmentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alignment
     */
    select?: AlignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Alignment
     */
    omit?: AlignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlignmentInclude<ExtArgs> | null
    /**
     * The data needed to update a Alignment.
     */
    data: XOR<AlignmentUpdateInput, AlignmentUncheckedUpdateInput>
    /**
     * Choose, which Alignment to update.
     */
    where: AlignmentWhereUniqueInput
  }

  /**
   * Alignment updateMany
   */
  export type AlignmentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Alignments.
     */
    data: XOR<AlignmentUpdateManyMutationInput, AlignmentUncheckedUpdateManyInput>
    /**
     * Filter which Alignments to update
     */
    where?: AlignmentWhereInput
    /**
     * Limit how many Alignments to update.
     */
    limit?: number
  }

  /**
   * Alignment updateManyAndReturn
   */
  export type AlignmentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alignment
     */
    select?: AlignmentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Alignment
     */
    omit?: AlignmentOmit<ExtArgs> | null
    /**
     * The data used to update Alignments.
     */
    data: XOR<AlignmentUpdateManyMutationInput, AlignmentUncheckedUpdateManyInput>
    /**
     * Filter which Alignments to update
     */
    where?: AlignmentWhereInput
    /**
     * Limit how many Alignments to update.
     */
    limit?: number
  }

  /**
   * Alignment upsert
   */
  export type AlignmentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alignment
     */
    select?: AlignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Alignment
     */
    omit?: AlignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlignmentInclude<ExtArgs> | null
    /**
     * The filter to search for the Alignment to update in case it exists.
     */
    where: AlignmentWhereUniqueInput
    /**
     * In case the Alignment found by the `where` argument doesn't exist, create a new Alignment with this data.
     */
    create: XOR<AlignmentCreateInput, AlignmentUncheckedCreateInput>
    /**
     * In case the Alignment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AlignmentUpdateInput, AlignmentUncheckedUpdateInput>
  }

  /**
   * Alignment delete
   */
  export type AlignmentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alignment
     */
    select?: AlignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Alignment
     */
    omit?: AlignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlignmentInclude<ExtArgs> | null
    /**
     * Filter which Alignment to delete.
     */
    where: AlignmentWhereUniqueInput
  }

  /**
   * Alignment deleteMany
   */
  export type AlignmentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Alignments to delete
     */
    where?: AlignmentWhereInput
    /**
     * Limit how many Alignments to delete.
     */
    limit?: number
  }

  /**
   * Alignment.creatures
   */
  export type Alignment$creaturesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Creature
     */
    select?: CreatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Creature
     */
    omit?: CreatureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreatureInclude<ExtArgs> | null
    where?: CreatureWhereInput
    orderBy?: CreatureOrderByWithRelationInput | CreatureOrderByWithRelationInput[]
    cursor?: CreatureWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CreatureScalarFieldEnum | CreatureScalarFieldEnum[]
  }

  /**
   * Alignment without action
   */
  export type AlignmentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alignment
     */
    select?: AlignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Alignment
     */
    omit?: AlignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlignmentInclude<ExtArgs> | null
  }


  /**
   * Model Speed_stat
   */

  export type AggregateSpeed_stat = {
    _count: Speed_statCountAggregateOutputType | null
    _avg: Speed_statAvgAggregateOutputType | null
    _sum: Speed_statSumAggregateOutputType | null
    _min: Speed_statMinAggregateOutputType | null
    _max: Speed_statMaxAggregateOutputType | null
  }

  export type Speed_statAvgAggregateOutputType = {
    walk: number | null
    fly: number | null
    swim: number | null
    burrow: number | null
    climb: number | null
  }

  export type Speed_statSumAggregateOutputType = {
    walk: number | null
    fly: number | null
    swim: number | null
    burrow: number | null
    climb: number | null
  }

  export type Speed_statMinAggregateOutputType = {
    id: string | null
    walk: number | null
    fly: number | null
    swim: number | null
    burrow: number | null
    climb: number | null
  }

  export type Speed_statMaxAggregateOutputType = {
    id: string | null
    walk: number | null
    fly: number | null
    swim: number | null
    burrow: number | null
    climb: number | null
  }

  export type Speed_statCountAggregateOutputType = {
    id: number
    walk: number
    fly: number
    swim: number
    burrow: number
    climb: number
    _all: number
  }


  export type Speed_statAvgAggregateInputType = {
    walk?: true
    fly?: true
    swim?: true
    burrow?: true
    climb?: true
  }

  export type Speed_statSumAggregateInputType = {
    walk?: true
    fly?: true
    swim?: true
    burrow?: true
    climb?: true
  }

  export type Speed_statMinAggregateInputType = {
    id?: true
    walk?: true
    fly?: true
    swim?: true
    burrow?: true
    climb?: true
  }

  export type Speed_statMaxAggregateInputType = {
    id?: true
    walk?: true
    fly?: true
    swim?: true
    burrow?: true
    climb?: true
  }

  export type Speed_statCountAggregateInputType = {
    id?: true
    walk?: true
    fly?: true
    swim?: true
    burrow?: true
    climb?: true
    _all?: true
  }

  export type Speed_statAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Speed_stat to aggregate.
     */
    where?: Speed_statWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Speed_stats to fetch.
     */
    orderBy?: Speed_statOrderByWithRelationInput | Speed_statOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: Speed_statWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Speed_stats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Speed_stats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Speed_stats
    **/
    _count?: true | Speed_statCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Speed_statAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Speed_statSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Speed_statMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Speed_statMaxAggregateInputType
  }

  export type GetSpeed_statAggregateType<T extends Speed_statAggregateArgs> = {
        [P in keyof T & keyof AggregateSpeed_stat]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSpeed_stat[P]>
      : GetScalarType<T[P], AggregateSpeed_stat[P]>
  }




  export type Speed_statGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: Speed_statWhereInput
    orderBy?: Speed_statOrderByWithAggregationInput | Speed_statOrderByWithAggregationInput[]
    by: Speed_statScalarFieldEnum[] | Speed_statScalarFieldEnum
    having?: Speed_statScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Speed_statCountAggregateInputType | true
    _avg?: Speed_statAvgAggregateInputType
    _sum?: Speed_statSumAggregateInputType
    _min?: Speed_statMinAggregateInputType
    _max?: Speed_statMaxAggregateInputType
  }

  export type Speed_statGroupByOutputType = {
    id: string
    walk: number | null
    fly: number | null
    swim: number | null
    burrow: number | null
    climb: number | null
    _count: Speed_statCountAggregateOutputType | null
    _avg: Speed_statAvgAggregateOutputType | null
    _sum: Speed_statSumAggregateOutputType | null
    _min: Speed_statMinAggregateOutputType | null
    _max: Speed_statMaxAggregateOutputType | null
  }

  type GetSpeed_statGroupByPayload<T extends Speed_statGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Speed_statGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Speed_statGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Speed_statGroupByOutputType[P]>
            : GetScalarType<T[P], Speed_statGroupByOutputType[P]>
        }
      >
    >


  export type Speed_statSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    walk?: boolean
    fly?: boolean
    swim?: boolean
    burrow?: boolean
    climb?: boolean
    id_relation?: boolean | CreatureDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["speed_stat"]>

  export type Speed_statSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    walk?: boolean
    fly?: boolean
    swim?: boolean
    burrow?: boolean
    climb?: boolean
    id_relation?: boolean | CreatureDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["speed_stat"]>

  export type Speed_statSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    walk?: boolean
    fly?: boolean
    swim?: boolean
    burrow?: boolean
    climb?: boolean
    id_relation?: boolean | CreatureDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["speed_stat"]>

  export type Speed_statSelectScalar = {
    id?: boolean
    walk?: boolean
    fly?: boolean
    swim?: boolean
    burrow?: boolean
    climb?: boolean
  }

  export type Speed_statOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "walk" | "fly" | "swim" | "burrow" | "climb", ExtArgs["result"]["speed_stat"]>
  export type Speed_statInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    id_relation?: boolean | CreatureDefaultArgs<ExtArgs>
  }
  export type Speed_statIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    id_relation?: boolean | CreatureDefaultArgs<ExtArgs>
  }
  export type Speed_statIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    id_relation?: boolean | CreatureDefaultArgs<ExtArgs>
  }

  export type $Speed_statPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Speed_stat"
    objects: {
      id_relation: Prisma.$CreaturePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      walk: number | null
      fly: number | null
      swim: number | null
      burrow: number | null
      climb: number | null
    }, ExtArgs["result"]["speed_stat"]>
    composites: {}
  }

  type Speed_statGetPayload<S extends boolean | null | undefined | Speed_statDefaultArgs> = $Result.GetResult<Prisma.$Speed_statPayload, S>

  type Speed_statCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<Speed_statFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Speed_statCountAggregateInputType | true
    }

  export interface Speed_statDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Speed_stat'], meta: { name: 'Speed_stat' } }
    /**
     * Find zero or one Speed_stat that matches the filter.
     * @param {Speed_statFindUniqueArgs} args - Arguments to find a Speed_stat
     * @example
     * // Get one Speed_stat
     * const speed_stat = await prisma.speed_stat.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends Speed_statFindUniqueArgs>(args: SelectSubset<T, Speed_statFindUniqueArgs<ExtArgs>>): Prisma__Speed_statClient<$Result.GetResult<Prisma.$Speed_statPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Speed_stat that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {Speed_statFindUniqueOrThrowArgs} args - Arguments to find a Speed_stat
     * @example
     * // Get one Speed_stat
     * const speed_stat = await prisma.speed_stat.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends Speed_statFindUniqueOrThrowArgs>(args: SelectSubset<T, Speed_statFindUniqueOrThrowArgs<ExtArgs>>): Prisma__Speed_statClient<$Result.GetResult<Prisma.$Speed_statPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Speed_stat that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Speed_statFindFirstArgs} args - Arguments to find a Speed_stat
     * @example
     * // Get one Speed_stat
     * const speed_stat = await prisma.speed_stat.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends Speed_statFindFirstArgs>(args?: SelectSubset<T, Speed_statFindFirstArgs<ExtArgs>>): Prisma__Speed_statClient<$Result.GetResult<Prisma.$Speed_statPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Speed_stat that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Speed_statFindFirstOrThrowArgs} args - Arguments to find a Speed_stat
     * @example
     * // Get one Speed_stat
     * const speed_stat = await prisma.speed_stat.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends Speed_statFindFirstOrThrowArgs>(args?: SelectSubset<T, Speed_statFindFirstOrThrowArgs<ExtArgs>>): Prisma__Speed_statClient<$Result.GetResult<Prisma.$Speed_statPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Speed_stats that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Speed_statFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Speed_stats
     * const speed_stats = await prisma.speed_stat.findMany()
     * 
     * // Get first 10 Speed_stats
     * const speed_stats = await prisma.speed_stat.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const speed_statWithIdOnly = await prisma.speed_stat.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends Speed_statFindManyArgs>(args?: SelectSubset<T, Speed_statFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Speed_statPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Speed_stat.
     * @param {Speed_statCreateArgs} args - Arguments to create a Speed_stat.
     * @example
     * // Create one Speed_stat
     * const Speed_stat = await prisma.speed_stat.create({
     *   data: {
     *     // ... data to create a Speed_stat
     *   }
     * })
     * 
     */
    create<T extends Speed_statCreateArgs>(args: SelectSubset<T, Speed_statCreateArgs<ExtArgs>>): Prisma__Speed_statClient<$Result.GetResult<Prisma.$Speed_statPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Speed_stats.
     * @param {Speed_statCreateManyArgs} args - Arguments to create many Speed_stats.
     * @example
     * // Create many Speed_stats
     * const speed_stat = await prisma.speed_stat.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends Speed_statCreateManyArgs>(args?: SelectSubset<T, Speed_statCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Speed_stats and returns the data saved in the database.
     * @param {Speed_statCreateManyAndReturnArgs} args - Arguments to create many Speed_stats.
     * @example
     * // Create many Speed_stats
     * const speed_stat = await prisma.speed_stat.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Speed_stats and only return the `id`
     * const speed_statWithIdOnly = await prisma.speed_stat.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends Speed_statCreateManyAndReturnArgs>(args?: SelectSubset<T, Speed_statCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Speed_statPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Speed_stat.
     * @param {Speed_statDeleteArgs} args - Arguments to delete one Speed_stat.
     * @example
     * // Delete one Speed_stat
     * const Speed_stat = await prisma.speed_stat.delete({
     *   where: {
     *     // ... filter to delete one Speed_stat
     *   }
     * })
     * 
     */
    delete<T extends Speed_statDeleteArgs>(args: SelectSubset<T, Speed_statDeleteArgs<ExtArgs>>): Prisma__Speed_statClient<$Result.GetResult<Prisma.$Speed_statPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Speed_stat.
     * @param {Speed_statUpdateArgs} args - Arguments to update one Speed_stat.
     * @example
     * // Update one Speed_stat
     * const speed_stat = await prisma.speed_stat.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends Speed_statUpdateArgs>(args: SelectSubset<T, Speed_statUpdateArgs<ExtArgs>>): Prisma__Speed_statClient<$Result.GetResult<Prisma.$Speed_statPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Speed_stats.
     * @param {Speed_statDeleteManyArgs} args - Arguments to filter Speed_stats to delete.
     * @example
     * // Delete a few Speed_stats
     * const { count } = await prisma.speed_stat.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends Speed_statDeleteManyArgs>(args?: SelectSubset<T, Speed_statDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Speed_stats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Speed_statUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Speed_stats
     * const speed_stat = await prisma.speed_stat.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends Speed_statUpdateManyArgs>(args: SelectSubset<T, Speed_statUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Speed_stats and returns the data updated in the database.
     * @param {Speed_statUpdateManyAndReturnArgs} args - Arguments to update many Speed_stats.
     * @example
     * // Update many Speed_stats
     * const speed_stat = await prisma.speed_stat.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Speed_stats and only return the `id`
     * const speed_statWithIdOnly = await prisma.speed_stat.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends Speed_statUpdateManyAndReturnArgs>(args: SelectSubset<T, Speed_statUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Speed_statPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Speed_stat.
     * @param {Speed_statUpsertArgs} args - Arguments to update or create a Speed_stat.
     * @example
     * // Update or create a Speed_stat
     * const speed_stat = await prisma.speed_stat.upsert({
     *   create: {
     *     // ... data to create a Speed_stat
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Speed_stat we want to update
     *   }
     * })
     */
    upsert<T extends Speed_statUpsertArgs>(args: SelectSubset<T, Speed_statUpsertArgs<ExtArgs>>): Prisma__Speed_statClient<$Result.GetResult<Prisma.$Speed_statPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Speed_stats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Speed_statCountArgs} args - Arguments to filter Speed_stats to count.
     * @example
     * // Count the number of Speed_stats
     * const count = await prisma.speed_stat.count({
     *   where: {
     *     // ... the filter for the Speed_stats we want to count
     *   }
     * })
    **/
    count<T extends Speed_statCountArgs>(
      args?: Subset<T, Speed_statCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Speed_statCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Speed_stat.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Speed_statAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Speed_statAggregateArgs>(args: Subset<T, Speed_statAggregateArgs>): Prisma.PrismaPromise<GetSpeed_statAggregateType<T>>

    /**
     * Group by Speed_stat.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Speed_statGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Speed_statGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Speed_statGroupByArgs['orderBy'] }
        : { orderBy?: Speed_statGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Speed_statGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSpeed_statGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Speed_stat model
   */
  readonly fields: Speed_statFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Speed_stat.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__Speed_statClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    id_relation<T extends CreatureDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CreatureDefaultArgs<ExtArgs>>): Prisma__CreatureClient<$Result.GetResult<Prisma.$CreaturePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Speed_stat model
   */ 
  interface Speed_statFieldRefs {
    readonly id: FieldRef<"Speed_stat", 'String'>
    readonly walk: FieldRef<"Speed_stat", 'Int'>
    readonly fly: FieldRef<"Speed_stat", 'Int'>
    readonly swim: FieldRef<"Speed_stat", 'Int'>
    readonly burrow: FieldRef<"Speed_stat", 'Int'>
    readonly climb: FieldRef<"Speed_stat", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Speed_stat findUnique
   */
  export type Speed_statFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Speed_stat
     */
    select?: Speed_statSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Speed_stat
     */
    omit?: Speed_statOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Speed_statInclude<ExtArgs> | null
    /**
     * Filter, which Speed_stat to fetch.
     */
    where: Speed_statWhereUniqueInput
  }

  /**
   * Speed_stat findUniqueOrThrow
   */
  export type Speed_statFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Speed_stat
     */
    select?: Speed_statSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Speed_stat
     */
    omit?: Speed_statOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Speed_statInclude<ExtArgs> | null
    /**
     * Filter, which Speed_stat to fetch.
     */
    where: Speed_statWhereUniqueInput
  }

  /**
   * Speed_stat findFirst
   */
  export type Speed_statFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Speed_stat
     */
    select?: Speed_statSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Speed_stat
     */
    omit?: Speed_statOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Speed_statInclude<ExtArgs> | null
    /**
     * Filter, which Speed_stat to fetch.
     */
    where?: Speed_statWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Speed_stats to fetch.
     */
    orderBy?: Speed_statOrderByWithRelationInput | Speed_statOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Speed_stats.
     */
    cursor?: Speed_statWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Speed_stats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Speed_stats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Speed_stats.
     */
    distinct?: Speed_statScalarFieldEnum | Speed_statScalarFieldEnum[]
  }

  /**
   * Speed_stat findFirstOrThrow
   */
  export type Speed_statFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Speed_stat
     */
    select?: Speed_statSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Speed_stat
     */
    omit?: Speed_statOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Speed_statInclude<ExtArgs> | null
    /**
     * Filter, which Speed_stat to fetch.
     */
    where?: Speed_statWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Speed_stats to fetch.
     */
    orderBy?: Speed_statOrderByWithRelationInput | Speed_statOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Speed_stats.
     */
    cursor?: Speed_statWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Speed_stats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Speed_stats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Speed_stats.
     */
    distinct?: Speed_statScalarFieldEnum | Speed_statScalarFieldEnum[]
  }

  /**
   * Speed_stat findMany
   */
  export type Speed_statFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Speed_stat
     */
    select?: Speed_statSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Speed_stat
     */
    omit?: Speed_statOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Speed_statInclude<ExtArgs> | null
    /**
     * Filter, which Speed_stats to fetch.
     */
    where?: Speed_statWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Speed_stats to fetch.
     */
    orderBy?: Speed_statOrderByWithRelationInput | Speed_statOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Speed_stats.
     */
    cursor?: Speed_statWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Speed_stats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Speed_stats.
     */
    skip?: number
    distinct?: Speed_statScalarFieldEnum | Speed_statScalarFieldEnum[]
  }

  /**
   * Speed_stat create
   */
  export type Speed_statCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Speed_stat
     */
    select?: Speed_statSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Speed_stat
     */
    omit?: Speed_statOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Speed_statInclude<ExtArgs> | null
    /**
     * The data needed to create a Speed_stat.
     */
    data: XOR<Speed_statCreateInput, Speed_statUncheckedCreateInput>
  }

  /**
   * Speed_stat createMany
   */
  export type Speed_statCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Speed_stats.
     */
    data: Speed_statCreateManyInput | Speed_statCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Speed_stat createManyAndReturn
   */
  export type Speed_statCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Speed_stat
     */
    select?: Speed_statSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Speed_stat
     */
    omit?: Speed_statOmit<ExtArgs> | null
    /**
     * The data used to create many Speed_stats.
     */
    data: Speed_statCreateManyInput | Speed_statCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Speed_statIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Speed_stat update
   */
  export type Speed_statUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Speed_stat
     */
    select?: Speed_statSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Speed_stat
     */
    omit?: Speed_statOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Speed_statInclude<ExtArgs> | null
    /**
     * The data needed to update a Speed_stat.
     */
    data: XOR<Speed_statUpdateInput, Speed_statUncheckedUpdateInput>
    /**
     * Choose, which Speed_stat to update.
     */
    where: Speed_statWhereUniqueInput
  }

  /**
   * Speed_stat updateMany
   */
  export type Speed_statUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Speed_stats.
     */
    data: XOR<Speed_statUpdateManyMutationInput, Speed_statUncheckedUpdateManyInput>
    /**
     * Filter which Speed_stats to update
     */
    where?: Speed_statWhereInput
    /**
     * Limit how many Speed_stats to update.
     */
    limit?: number
  }

  /**
   * Speed_stat updateManyAndReturn
   */
  export type Speed_statUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Speed_stat
     */
    select?: Speed_statSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Speed_stat
     */
    omit?: Speed_statOmit<ExtArgs> | null
    /**
     * The data used to update Speed_stats.
     */
    data: XOR<Speed_statUpdateManyMutationInput, Speed_statUncheckedUpdateManyInput>
    /**
     * Filter which Speed_stats to update
     */
    where?: Speed_statWhereInput
    /**
     * Limit how many Speed_stats to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Speed_statIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Speed_stat upsert
   */
  export type Speed_statUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Speed_stat
     */
    select?: Speed_statSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Speed_stat
     */
    omit?: Speed_statOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Speed_statInclude<ExtArgs> | null
    /**
     * The filter to search for the Speed_stat to update in case it exists.
     */
    where: Speed_statWhereUniqueInput
    /**
     * In case the Speed_stat found by the `where` argument doesn't exist, create a new Speed_stat with this data.
     */
    create: XOR<Speed_statCreateInput, Speed_statUncheckedCreateInput>
    /**
     * In case the Speed_stat was found with the provided `where` argument, update it with this data.
     */
    update: XOR<Speed_statUpdateInput, Speed_statUncheckedUpdateInput>
  }

  /**
   * Speed_stat delete
   */
  export type Speed_statDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Speed_stat
     */
    select?: Speed_statSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Speed_stat
     */
    omit?: Speed_statOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Speed_statInclude<ExtArgs> | null
    /**
     * Filter which Speed_stat to delete.
     */
    where: Speed_statWhereUniqueInput
  }

  /**
   * Speed_stat deleteMany
   */
  export type Speed_statDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Speed_stats to delete
     */
    where?: Speed_statWhereInput
    /**
     * Limit how many Speed_stats to delete.
     */
    limit?: number
  }

  /**
   * Speed_stat without action
   */
  export type Speed_statDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Speed_stat
     */
    select?: Speed_statSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Speed_stat
     */
    omit?: Speed_statOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Speed_statInclude<ExtArgs> | null
  }


  /**
   * Model Creature_stats
   */

  export type AggregateCreature_stats = {
    _count: Creature_statsCountAggregateOutputType | null
    _min: Creature_statsMinAggregateOutputType | null
    _max: Creature_statsMaxAggregateOutputType | null
  }

  export type Creature_statsMinAggregateOutputType = {
    id: string | null
  }

  export type Creature_statsMaxAggregateOutputType = {
    id: string | null
  }

  export type Creature_statsCountAggregateOutputType = {
    id: number
    _all: number
  }


  export type Creature_statsMinAggregateInputType = {
    id?: true
  }

  export type Creature_statsMaxAggregateInputType = {
    id?: true
  }

  export type Creature_statsCountAggregateInputType = {
    id?: true
    _all?: true
  }

  export type Creature_statsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Creature_stats to aggregate.
     */
    where?: Creature_statsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Creature_stats to fetch.
     */
    orderBy?: Creature_statsOrderByWithRelationInput | Creature_statsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: Creature_statsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Creature_stats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Creature_stats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Creature_stats
    **/
    _count?: true | Creature_statsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Creature_statsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Creature_statsMaxAggregateInputType
  }

  export type GetCreature_statsAggregateType<T extends Creature_statsAggregateArgs> = {
        [P in keyof T & keyof AggregateCreature_stats]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCreature_stats[P]>
      : GetScalarType<T[P], AggregateCreature_stats[P]>
  }




  export type Creature_statsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: Creature_statsWhereInput
    orderBy?: Creature_statsOrderByWithAggregationInput | Creature_statsOrderByWithAggregationInput[]
    by: Creature_statsScalarFieldEnum[] | Creature_statsScalarFieldEnum
    having?: Creature_statsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Creature_statsCountAggregateInputType | true
    _min?: Creature_statsMinAggregateInputType
    _max?: Creature_statsMaxAggregateInputType
  }

  export type Creature_statsGroupByOutputType = {
    id: string
    _count: Creature_statsCountAggregateOutputType | null
    _min: Creature_statsMinAggregateOutputType | null
    _max: Creature_statsMaxAggregateOutputType | null
  }

  type GetCreature_statsGroupByPayload<T extends Creature_statsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Creature_statsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Creature_statsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Creature_statsGroupByOutputType[P]>
            : GetScalarType<T[P], Creature_statsGroupByOutputType[P]>
        }
      >
    >


  export type Creature_statsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    strength?: boolean | Creature_stats$strengthArgs<ExtArgs>
    dexterity?: boolean | Creature_stats$dexterityArgs<ExtArgs>
    constitution?: boolean | Creature_stats$constitutionArgs<ExtArgs>
    intelligence?: boolean | Creature_stats$intelligenceArgs<ExtArgs>
    wisdom?: boolean | Creature_stats$wisdomArgs<ExtArgs>
    charisma?: boolean | Creature_stats$charismaArgs<ExtArgs>
    id_relation?: boolean | CreatureDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["creature_stats"]>

  export type Creature_statsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    id_relation?: boolean | CreatureDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["creature_stats"]>

  export type Creature_statsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    id_relation?: boolean | CreatureDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["creature_stats"]>

  export type Creature_statsSelectScalar = {
    id?: boolean
  }

  export type Creature_statsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id", ExtArgs["result"]["creature_stats"]>
  export type Creature_statsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    strength?: boolean | Creature_stats$strengthArgs<ExtArgs>
    dexterity?: boolean | Creature_stats$dexterityArgs<ExtArgs>
    constitution?: boolean | Creature_stats$constitutionArgs<ExtArgs>
    intelligence?: boolean | Creature_stats$intelligenceArgs<ExtArgs>
    wisdom?: boolean | Creature_stats$wisdomArgs<ExtArgs>
    charisma?: boolean | Creature_stats$charismaArgs<ExtArgs>
    id_relation?: boolean | CreatureDefaultArgs<ExtArgs>
  }
  export type Creature_statsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    id_relation?: boolean | CreatureDefaultArgs<ExtArgs>
  }
  export type Creature_statsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    id_relation?: boolean | CreatureDefaultArgs<ExtArgs>
  }

  export type $Creature_statsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Creature_stats"
    objects: {
      strength: Prisma.$Strength_stat_detailsPayload<ExtArgs> | null
      dexterity: Prisma.$Dexterity_stat_detailsPayload<ExtArgs> | null
      constitution: Prisma.$Constitution_stat_detailsPayload<ExtArgs> | null
      intelligence: Prisma.$Intelligence_stat_detailsPayload<ExtArgs> | null
      wisdom: Prisma.$Wisdom_stat_detailsPayload<ExtArgs> | null
      charisma: Prisma.$Charisma_stat_detailsPayload<ExtArgs> | null
      id_relation: Prisma.$CreaturePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
    }, ExtArgs["result"]["creature_stats"]>
    composites: {}
  }

  type Creature_statsGetPayload<S extends boolean | null | undefined | Creature_statsDefaultArgs> = $Result.GetResult<Prisma.$Creature_statsPayload, S>

  type Creature_statsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<Creature_statsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Creature_statsCountAggregateInputType | true
    }

  export interface Creature_statsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Creature_stats'], meta: { name: 'Creature_stats' } }
    /**
     * Find zero or one Creature_stats that matches the filter.
     * @param {Creature_statsFindUniqueArgs} args - Arguments to find a Creature_stats
     * @example
     * // Get one Creature_stats
     * const creature_stats = await prisma.creature_stats.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends Creature_statsFindUniqueArgs>(args: SelectSubset<T, Creature_statsFindUniqueArgs<ExtArgs>>): Prisma__Creature_statsClient<$Result.GetResult<Prisma.$Creature_statsPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Creature_stats that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {Creature_statsFindUniqueOrThrowArgs} args - Arguments to find a Creature_stats
     * @example
     * // Get one Creature_stats
     * const creature_stats = await prisma.creature_stats.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends Creature_statsFindUniqueOrThrowArgs>(args: SelectSubset<T, Creature_statsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__Creature_statsClient<$Result.GetResult<Prisma.$Creature_statsPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Creature_stats that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Creature_statsFindFirstArgs} args - Arguments to find a Creature_stats
     * @example
     * // Get one Creature_stats
     * const creature_stats = await prisma.creature_stats.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends Creature_statsFindFirstArgs>(args?: SelectSubset<T, Creature_statsFindFirstArgs<ExtArgs>>): Prisma__Creature_statsClient<$Result.GetResult<Prisma.$Creature_statsPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Creature_stats that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Creature_statsFindFirstOrThrowArgs} args - Arguments to find a Creature_stats
     * @example
     * // Get one Creature_stats
     * const creature_stats = await prisma.creature_stats.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends Creature_statsFindFirstOrThrowArgs>(args?: SelectSubset<T, Creature_statsFindFirstOrThrowArgs<ExtArgs>>): Prisma__Creature_statsClient<$Result.GetResult<Prisma.$Creature_statsPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Creature_stats that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Creature_statsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Creature_stats
     * const creature_stats = await prisma.creature_stats.findMany()
     * 
     * // Get first 10 Creature_stats
     * const creature_stats = await prisma.creature_stats.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const creature_statsWithIdOnly = await prisma.creature_stats.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends Creature_statsFindManyArgs>(args?: SelectSubset<T, Creature_statsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Creature_statsPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Creature_stats.
     * @param {Creature_statsCreateArgs} args - Arguments to create a Creature_stats.
     * @example
     * // Create one Creature_stats
     * const Creature_stats = await prisma.creature_stats.create({
     *   data: {
     *     // ... data to create a Creature_stats
     *   }
     * })
     * 
     */
    create<T extends Creature_statsCreateArgs>(args: SelectSubset<T, Creature_statsCreateArgs<ExtArgs>>): Prisma__Creature_statsClient<$Result.GetResult<Prisma.$Creature_statsPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Creature_stats.
     * @param {Creature_statsCreateManyArgs} args - Arguments to create many Creature_stats.
     * @example
     * // Create many Creature_stats
     * const creature_stats = await prisma.creature_stats.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends Creature_statsCreateManyArgs>(args?: SelectSubset<T, Creature_statsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Creature_stats and returns the data saved in the database.
     * @param {Creature_statsCreateManyAndReturnArgs} args - Arguments to create many Creature_stats.
     * @example
     * // Create many Creature_stats
     * const creature_stats = await prisma.creature_stats.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Creature_stats and only return the `id`
     * const creature_statsWithIdOnly = await prisma.creature_stats.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends Creature_statsCreateManyAndReturnArgs>(args?: SelectSubset<T, Creature_statsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Creature_statsPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Creature_stats.
     * @param {Creature_statsDeleteArgs} args - Arguments to delete one Creature_stats.
     * @example
     * // Delete one Creature_stats
     * const Creature_stats = await prisma.creature_stats.delete({
     *   where: {
     *     // ... filter to delete one Creature_stats
     *   }
     * })
     * 
     */
    delete<T extends Creature_statsDeleteArgs>(args: SelectSubset<T, Creature_statsDeleteArgs<ExtArgs>>): Prisma__Creature_statsClient<$Result.GetResult<Prisma.$Creature_statsPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Creature_stats.
     * @param {Creature_statsUpdateArgs} args - Arguments to update one Creature_stats.
     * @example
     * // Update one Creature_stats
     * const creature_stats = await prisma.creature_stats.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends Creature_statsUpdateArgs>(args: SelectSubset<T, Creature_statsUpdateArgs<ExtArgs>>): Prisma__Creature_statsClient<$Result.GetResult<Prisma.$Creature_statsPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Creature_stats.
     * @param {Creature_statsDeleteManyArgs} args - Arguments to filter Creature_stats to delete.
     * @example
     * // Delete a few Creature_stats
     * const { count } = await prisma.creature_stats.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends Creature_statsDeleteManyArgs>(args?: SelectSubset<T, Creature_statsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Creature_stats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Creature_statsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Creature_stats
     * const creature_stats = await prisma.creature_stats.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends Creature_statsUpdateManyArgs>(args: SelectSubset<T, Creature_statsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Creature_stats and returns the data updated in the database.
     * @param {Creature_statsUpdateManyAndReturnArgs} args - Arguments to update many Creature_stats.
     * @example
     * // Update many Creature_stats
     * const creature_stats = await prisma.creature_stats.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Creature_stats and only return the `id`
     * const creature_statsWithIdOnly = await prisma.creature_stats.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends Creature_statsUpdateManyAndReturnArgs>(args: SelectSubset<T, Creature_statsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Creature_statsPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Creature_stats.
     * @param {Creature_statsUpsertArgs} args - Arguments to update or create a Creature_stats.
     * @example
     * // Update or create a Creature_stats
     * const creature_stats = await prisma.creature_stats.upsert({
     *   create: {
     *     // ... data to create a Creature_stats
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Creature_stats we want to update
     *   }
     * })
     */
    upsert<T extends Creature_statsUpsertArgs>(args: SelectSubset<T, Creature_statsUpsertArgs<ExtArgs>>): Prisma__Creature_statsClient<$Result.GetResult<Prisma.$Creature_statsPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Creature_stats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Creature_statsCountArgs} args - Arguments to filter Creature_stats to count.
     * @example
     * // Count the number of Creature_stats
     * const count = await prisma.creature_stats.count({
     *   where: {
     *     // ... the filter for the Creature_stats we want to count
     *   }
     * })
    **/
    count<T extends Creature_statsCountArgs>(
      args?: Subset<T, Creature_statsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Creature_statsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Creature_stats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Creature_statsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Creature_statsAggregateArgs>(args: Subset<T, Creature_statsAggregateArgs>): Prisma.PrismaPromise<GetCreature_statsAggregateType<T>>

    /**
     * Group by Creature_stats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Creature_statsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Creature_statsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Creature_statsGroupByArgs['orderBy'] }
        : { orderBy?: Creature_statsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Creature_statsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCreature_statsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Creature_stats model
   */
  readonly fields: Creature_statsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Creature_stats.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__Creature_statsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    strength<T extends Creature_stats$strengthArgs<ExtArgs> = {}>(args?: Subset<T, Creature_stats$strengthArgs<ExtArgs>>): Prisma__Strength_stat_detailsClient<$Result.GetResult<Prisma.$Strength_stat_detailsPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | null, null, ExtArgs, ClientOptions>
    dexterity<T extends Creature_stats$dexterityArgs<ExtArgs> = {}>(args?: Subset<T, Creature_stats$dexterityArgs<ExtArgs>>): Prisma__Dexterity_stat_detailsClient<$Result.GetResult<Prisma.$Dexterity_stat_detailsPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | null, null, ExtArgs, ClientOptions>
    constitution<T extends Creature_stats$constitutionArgs<ExtArgs> = {}>(args?: Subset<T, Creature_stats$constitutionArgs<ExtArgs>>): Prisma__Constitution_stat_detailsClient<$Result.GetResult<Prisma.$Constitution_stat_detailsPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | null, null, ExtArgs, ClientOptions>
    intelligence<T extends Creature_stats$intelligenceArgs<ExtArgs> = {}>(args?: Subset<T, Creature_stats$intelligenceArgs<ExtArgs>>): Prisma__Intelligence_stat_detailsClient<$Result.GetResult<Prisma.$Intelligence_stat_detailsPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | null, null, ExtArgs, ClientOptions>
    wisdom<T extends Creature_stats$wisdomArgs<ExtArgs> = {}>(args?: Subset<T, Creature_stats$wisdomArgs<ExtArgs>>): Prisma__Wisdom_stat_detailsClient<$Result.GetResult<Prisma.$Wisdom_stat_detailsPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | null, null, ExtArgs, ClientOptions>
    charisma<T extends Creature_stats$charismaArgs<ExtArgs> = {}>(args?: Subset<T, Creature_stats$charismaArgs<ExtArgs>>): Prisma__Charisma_stat_detailsClient<$Result.GetResult<Prisma.$Charisma_stat_detailsPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | null, null, ExtArgs, ClientOptions>
    id_relation<T extends CreatureDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CreatureDefaultArgs<ExtArgs>>): Prisma__CreatureClient<$Result.GetResult<Prisma.$CreaturePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Creature_stats model
   */ 
  interface Creature_statsFieldRefs {
    readonly id: FieldRef<"Creature_stats", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Creature_stats findUnique
   */
  export type Creature_statsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Creature_stats
     */
    select?: Creature_statsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Creature_stats
     */
    omit?: Creature_statsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Creature_statsInclude<ExtArgs> | null
    /**
     * Filter, which Creature_stats to fetch.
     */
    where: Creature_statsWhereUniqueInput
  }

  /**
   * Creature_stats findUniqueOrThrow
   */
  export type Creature_statsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Creature_stats
     */
    select?: Creature_statsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Creature_stats
     */
    omit?: Creature_statsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Creature_statsInclude<ExtArgs> | null
    /**
     * Filter, which Creature_stats to fetch.
     */
    where: Creature_statsWhereUniqueInput
  }

  /**
   * Creature_stats findFirst
   */
  export type Creature_statsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Creature_stats
     */
    select?: Creature_statsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Creature_stats
     */
    omit?: Creature_statsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Creature_statsInclude<ExtArgs> | null
    /**
     * Filter, which Creature_stats to fetch.
     */
    where?: Creature_statsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Creature_stats to fetch.
     */
    orderBy?: Creature_statsOrderByWithRelationInput | Creature_statsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Creature_stats.
     */
    cursor?: Creature_statsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Creature_stats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Creature_stats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Creature_stats.
     */
    distinct?: Creature_statsScalarFieldEnum | Creature_statsScalarFieldEnum[]
  }

  /**
   * Creature_stats findFirstOrThrow
   */
  export type Creature_statsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Creature_stats
     */
    select?: Creature_statsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Creature_stats
     */
    omit?: Creature_statsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Creature_statsInclude<ExtArgs> | null
    /**
     * Filter, which Creature_stats to fetch.
     */
    where?: Creature_statsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Creature_stats to fetch.
     */
    orderBy?: Creature_statsOrderByWithRelationInput | Creature_statsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Creature_stats.
     */
    cursor?: Creature_statsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Creature_stats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Creature_stats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Creature_stats.
     */
    distinct?: Creature_statsScalarFieldEnum | Creature_statsScalarFieldEnum[]
  }

  /**
   * Creature_stats findMany
   */
  export type Creature_statsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Creature_stats
     */
    select?: Creature_statsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Creature_stats
     */
    omit?: Creature_statsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Creature_statsInclude<ExtArgs> | null
    /**
     * Filter, which Creature_stats to fetch.
     */
    where?: Creature_statsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Creature_stats to fetch.
     */
    orderBy?: Creature_statsOrderByWithRelationInput | Creature_statsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Creature_stats.
     */
    cursor?: Creature_statsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Creature_stats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Creature_stats.
     */
    skip?: number
    distinct?: Creature_statsScalarFieldEnum | Creature_statsScalarFieldEnum[]
  }

  /**
   * Creature_stats create
   */
  export type Creature_statsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Creature_stats
     */
    select?: Creature_statsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Creature_stats
     */
    omit?: Creature_statsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Creature_statsInclude<ExtArgs> | null
    /**
     * The data needed to create a Creature_stats.
     */
    data: XOR<Creature_statsCreateInput, Creature_statsUncheckedCreateInput>
  }

  /**
   * Creature_stats createMany
   */
  export type Creature_statsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Creature_stats.
     */
    data: Creature_statsCreateManyInput | Creature_statsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Creature_stats createManyAndReturn
   */
  export type Creature_statsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Creature_stats
     */
    select?: Creature_statsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Creature_stats
     */
    omit?: Creature_statsOmit<ExtArgs> | null
    /**
     * The data used to create many Creature_stats.
     */
    data: Creature_statsCreateManyInput | Creature_statsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Creature_statsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Creature_stats update
   */
  export type Creature_statsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Creature_stats
     */
    select?: Creature_statsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Creature_stats
     */
    omit?: Creature_statsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Creature_statsInclude<ExtArgs> | null
    /**
     * The data needed to update a Creature_stats.
     */
    data: XOR<Creature_statsUpdateInput, Creature_statsUncheckedUpdateInput>
    /**
     * Choose, which Creature_stats to update.
     */
    where: Creature_statsWhereUniqueInput
  }

  /**
   * Creature_stats updateMany
   */
  export type Creature_statsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Creature_stats.
     */
    data: XOR<Creature_statsUpdateManyMutationInput, Creature_statsUncheckedUpdateManyInput>
    /**
     * Filter which Creature_stats to update
     */
    where?: Creature_statsWhereInput
    /**
     * Limit how many Creature_stats to update.
     */
    limit?: number
  }

  /**
   * Creature_stats updateManyAndReturn
   */
  export type Creature_statsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Creature_stats
     */
    select?: Creature_statsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Creature_stats
     */
    omit?: Creature_statsOmit<ExtArgs> | null
    /**
     * The data used to update Creature_stats.
     */
    data: XOR<Creature_statsUpdateManyMutationInput, Creature_statsUncheckedUpdateManyInput>
    /**
     * Filter which Creature_stats to update
     */
    where?: Creature_statsWhereInput
    /**
     * Limit how many Creature_stats to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Creature_statsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Creature_stats upsert
   */
  export type Creature_statsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Creature_stats
     */
    select?: Creature_statsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Creature_stats
     */
    omit?: Creature_statsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Creature_statsInclude<ExtArgs> | null
    /**
     * The filter to search for the Creature_stats to update in case it exists.
     */
    where: Creature_statsWhereUniqueInput
    /**
     * In case the Creature_stats found by the `where` argument doesn't exist, create a new Creature_stats with this data.
     */
    create: XOR<Creature_statsCreateInput, Creature_statsUncheckedCreateInput>
    /**
     * In case the Creature_stats was found with the provided `where` argument, update it with this data.
     */
    update: XOR<Creature_statsUpdateInput, Creature_statsUncheckedUpdateInput>
  }

  /**
   * Creature_stats delete
   */
  export type Creature_statsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Creature_stats
     */
    select?: Creature_statsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Creature_stats
     */
    omit?: Creature_statsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Creature_statsInclude<ExtArgs> | null
    /**
     * Filter which Creature_stats to delete.
     */
    where: Creature_statsWhereUniqueInput
  }

  /**
   * Creature_stats deleteMany
   */
  export type Creature_statsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Creature_stats to delete
     */
    where?: Creature_statsWhereInput
    /**
     * Limit how many Creature_stats to delete.
     */
    limit?: number
  }

  /**
   * Creature_stats.strength
   */
  export type Creature_stats$strengthArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Strength_stat_details
     */
    select?: Strength_stat_detailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Strength_stat_details
     */
    omit?: Strength_stat_detailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Strength_stat_detailsInclude<ExtArgs> | null
    where?: Strength_stat_detailsWhereInput
  }

  /**
   * Creature_stats.dexterity
   */
  export type Creature_stats$dexterityArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dexterity_stat_details
     */
    select?: Dexterity_stat_detailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Dexterity_stat_details
     */
    omit?: Dexterity_stat_detailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Dexterity_stat_detailsInclude<ExtArgs> | null
    where?: Dexterity_stat_detailsWhereInput
  }

  /**
   * Creature_stats.constitution
   */
  export type Creature_stats$constitutionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Constitution_stat_details
     */
    select?: Constitution_stat_detailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Constitution_stat_details
     */
    omit?: Constitution_stat_detailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Constitution_stat_detailsInclude<ExtArgs> | null
    where?: Constitution_stat_detailsWhereInput
  }

  /**
   * Creature_stats.intelligence
   */
  export type Creature_stats$intelligenceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Intelligence_stat_details
     */
    select?: Intelligence_stat_detailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Intelligence_stat_details
     */
    omit?: Intelligence_stat_detailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Intelligence_stat_detailsInclude<ExtArgs> | null
    where?: Intelligence_stat_detailsWhereInput
  }

  /**
   * Creature_stats.wisdom
   */
  export type Creature_stats$wisdomArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Wisdom_stat_details
     */
    select?: Wisdom_stat_detailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Wisdom_stat_details
     */
    omit?: Wisdom_stat_detailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Wisdom_stat_detailsInclude<ExtArgs> | null
    where?: Wisdom_stat_detailsWhereInput
  }

  /**
   * Creature_stats.charisma
   */
  export type Creature_stats$charismaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Charisma_stat_details
     */
    select?: Charisma_stat_detailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Charisma_stat_details
     */
    omit?: Charisma_stat_detailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Charisma_stat_detailsInclude<ExtArgs> | null
    where?: Charisma_stat_detailsWhereInput
  }

  /**
   * Creature_stats without action
   */
  export type Creature_statsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Creature_stats
     */
    select?: Creature_statsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Creature_stats
     */
    omit?: Creature_statsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Creature_statsInclude<ExtArgs> | null
  }


  /**
   * Model Strength_stat_details
   */

  export type AggregateStrength_stat_details = {
    _count: Strength_stat_detailsCountAggregateOutputType | null
    _avg: Strength_stat_detailsAvgAggregateOutputType | null
    _sum: Strength_stat_detailsSumAggregateOutputType | null
    _min: Strength_stat_detailsMinAggregateOutputType | null
    _max: Strength_stat_detailsMaxAggregateOutputType | null
  }

  export type Strength_stat_detailsAvgAggregateOutputType = {
    value: number | null
  }

  export type Strength_stat_detailsSumAggregateOutputType = {
    value: number | null
  }

  export type Strength_stat_detailsMinAggregateOutputType = {
    statblock_id: string | null
    value: number | null
    mastery: boolean | null
  }

  export type Strength_stat_detailsMaxAggregateOutputType = {
    statblock_id: string | null
    value: number | null
    mastery: boolean | null
  }

  export type Strength_stat_detailsCountAggregateOutputType = {
    statblock_id: number
    value: number
    mastery: number
    _all: number
  }


  export type Strength_stat_detailsAvgAggregateInputType = {
    value?: true
  }

  export type Strength_stat_detailsSumAggregateInputType = {
    value?: true
  }

  export type Strength_stat_detailsMinAggregateInputType = {
    statblock_id?: true
    value?: true
    mastery?: true
  }

  export type Strength_stat_detailsMaxAggregateInputType = {
    statblock_id?: true
    value?: true
    mastery?: true
  }

  export type Strength_stat_detailsCountAggregateInputType = {
    statblock_id?: true
    value?: true
    mastery?: true
    _all?: true
  }

  export type Strength_stat_detailsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Strength_stat_details to aggregate.
     */
    where?: Strength_stat_detailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Strength_stat_details to fetch.
     */
    orderBy?: Strength_stat_detailsOrderByWithRelationInput | Strength_stat_detailsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: Strength_stat_detailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Strength_stat_details from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Strength_stat_details.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Strength_stat_details
    **/
    _count?: true | Strength_stat_detailsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Strength_stat_detailsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Strength_stat_detailsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Strength_stat_detailsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Strength_stat_detailsMaxAggregateInputType
  }

  export type GetStrength_stat_detailsAggregateType<T extends Strength_stat_detailsAggregateArgs> = {
        [P in keyof T & keyof AggregateStrength_stat_details]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStrength_stat_details[P]>
      : GetScalarType<T[P], AggregateStrength_stat_details[P]>
  }




  export type Strength_stat_detailsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: Strength_stat_detailsWhereInput
    orderBy?: Strength_stat_detailsOrderByWithAggregationInput | Strength_stat_detailsOrderByWithAggregationInput[]
    by: Strength_stat_detailsScalarFieldEnum[] | Strength_stat_detailsScalarFieldEnum
    having?: Strength_stat_detailsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Strength_stat_detailsCountAggregateInputType | true
    _avg?: Strength_stat_detailsAvgAggregateInputType
    _sum?: Strength_stat_detailsSumAggregateInputType
    _min?: Strength_stat_detailsMinAggregateInputType
    _max?: Strength_stat_detailsMaxAggregateInputType
  }

  export type Strength_stat_detailsGroupByOutputType = {
    statblock_id: string
    value: number
    mastery: boolean
    _count: Strength_stat_detailsCountAggregateOutputType | null
    _avg: Strength_stat_detailsAvgAggregateOutputType | null
    _sum: Strength_stat_detailsSumAggregateOutputType | null
    _min: Strength_stat_detailsMinAggregateOutputType | null
    _max: Strength_stat_detailsMaxAggregateOutputType | null
  }

  type GetStrength_stat_detailsGroupByPayload<T extends Strength_stat_detailsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Strength_stat_detailsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Strength_stat_detailsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Strength_stat_detailsGroupByOutputType[P]>
            : GetScalarType<T[P], Strength_stat_detailsGroupByOutputType[P]>
        }
      >
    >


  export type Strength_stat_detailsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    statblock_id?: boolean
    value?: boolean
    mastery?: boolean
    creature_stat?: boolean | Creature_statsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["strength_stat_details"]>

  export type Strength_stat_detailsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    statblock_id?: boolean
    value?: boolean
    mastery?: boolean
    creature_stat?: boolean | Creature_statsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["strength_stat_details"]>

  export type Strength_stat_detailsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    statblock_id?: boolean
    value?: boolean
    mastery?: boolean
    creature_stat?: boolean | Creature_statsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["strength_stat_details"]>

  export type Strength_stat_detailsSelectScalar = {
    statblock_id?: boolean
    value?: boolean
    mastery?: boolean
  }

  export type Strength_stat_detailsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"statblock_id" | "value" | "mastery", ExtArgs["result"]["strength_stat_details"]>
  export type Strength_stat_detailsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creature_stat?: boolean | Creature_statsDefaultArgs<ExtArgs>
  }
  export type Strength_stat_detailsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creature_stat?: boolean | Creature_statsDefaultArgs<ExtArgs>
  }
  export type Strength_stat_detailsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creature_stat?: boolean | Creature_statsDefaultArgs<ExtArgs>
  }

  export type $Strength_stat_detailsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Strength_stat_details"
    objects: {
      creature_stat: Prisma.$Creature_statsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      statblock_id: string
      value: number
      mastery: boolean
    }, ExtArgs["result"]["strength_stat_details"]>
    composites: {}
  }

  type Strength_stat_detailsGetPayload<S extends boolean | null | undefined | Strength_stat_detailsDefaultArgs> = $Result.GetResult<Prisma.$Strength_stat_detailsPayload, S>

  type Strength_stat_detailsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<Strength_stat_detailsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Strength_stat_detailsCountAggregateInputType | true
    }

  export interface Strength_stat_detailsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Strength_stat_details'], meta: { name: 'Strength_stat_details' } }
    /**
     * Find zero or one Strength_stat_details that matches the filter.
     * @param {Strength_stat_detailsFindUniqueArgs} args - Arguments to find a Strength_stat_details
     * @example
     * // Get one Strength_stat_details
     * const strength_stat_details = await prisma.strength_stat_details.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends Strength_stat_detailsFindUniqueArgs>(args: SelectSubset<T, Strength_stat_detailsFindUniqueArgs<ExtArgs>>): Prisma__Strength_stat_detailsClient<$Result.GetResult<Prisma.$Strength_stat_detailsPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Strength_stat_details that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {Strength_stat_detailsFindUniqueOrThrowArgs} args - Arguments to find a Strength_stat_details
     * @example
     * // Get one Strength_stat_details
     * const strength_stat_details = await prisma.strength_stat_details.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends Strength_stat_detailsFindUniqueOrThrowArgs>(args: SelectSubset<T, Strength_stat_detailsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__Strength_stat_detailsClient<$Result.GetResult<Prisma.$Strength_stat_detailsPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Strength_stat_details that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Strength_stat_detailsFindFirstArgs} args - Arguments to find a Strength_stat_details
     * @example
     * // Get one Strength_stat_details
     * const strength_stat_details = await prisma.strength_stat_details.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends Strength_stat_detailsFindFirstArgs>(args?: SelectSubset<T, Strength_stat_detailsFindFirstArgs<ExtArgs>>): Prisma__Strength_stat_detailsClient<$Result.GetResult<Prisma.$Strength_stat_detailsPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Strength_stat_details that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Strength_stat_detailsFindFirstOrThrowArgs} args - Arguments to find a Strength_stat_details
     * @example
     * // Get one Strength_stat_details
     * const strength_stat_details = await prisma.strength_stat_details.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends Strength_stat_detailsFindFirstOrThrowArgs>(args?: SelectSubset<T, Strength_stat_detailsFindFirstOrThrowArgs<ExtArgs>>): Prisma__Strength_stat_detailsClient<$Result.GetResult<Prisma.$Strength_stat_detailsPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Strength_stat_details that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Strength_stat_detailsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Strength_stat_details
     * const strength_stat_details = await prisma.strength_stat_details.findMany()
     * 
     * // Get first 10 Strength_stat_details
     * const strength_stat_details = await prisma.strength_stat_details.findMany({ take: 10 })
     * 
     * // Only select the `statblock_id`
     * const strength_stat_detailsWithStatblock_idOnly = await prisma.strength_stat_details.findMany({ select: { statblock_id: true } })
     * 
     */
    findMany<T extends Strength_stat_detailsFindManyArgs>(args?: SelectSubset<T, Strength_stat_detailsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Strength_stat_detailsPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Strength_stat_details.
     * @param {Strength_stat_detailsCreateArgs} args - Arguments to create a Strength_stat_details.
     * @example
     * // Create one Strength_stat_details
     * const Strength_stat_details = await prisma.strength_stat_details.create({
     *   data: {
     *     // ... data to create a Strength_stat_details
     *   }
     * })
     * 
     */
    create<T extends Strength_stat_detailsCreateArgs>(args: SelectSubset<T, Strength_stat_detailsCreateArgs<ExtArgs>>): Prisma__Strength_stat_detailsClient<$Result.GetResult<Prisma.$Strength_stat_detailsPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Strength_stat_details.
     * @param {Strength_stat_detailsCreateManyArgs} args - Arguments to create many Strength_stat_details.
     * @example
     * // Create many Strength_stat_details
     * const strength_stat_details = await prisma.strength_stat_details.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends Strength_stat_detailsCreateManyArgs>(args?: SelectSubset<T, Strength_stat_detailsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Strength_stat_details and returns the data saved in the database.
     * @param {Strength_stat_detailsCreateManyAndReturnArgs} args - Arguments to create many Strength_stat_details.
     * @example
     * // Create many Strength_stat_details
     * const strength_stat_details = await prisma.strength_stat_details.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Strength_stat_details and only return the `statblock_id`
     * const strength_stat_detailsWithStatblock_idOnly = await prisma.strength_stat_details.createManyAndReturn({
     *   select: { statblock_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends Strength_stat_detailsCreateManyAndReturnArgs>(args?: SelectSubset<T, Strength_stat_detailsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Strength_stat_detailsPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Strength_stat_details.
     * @param {Strength_stat_detailsDeleteArgs} args - Arguments to delete one Strength_stat_details.
     * @example
     * // Delete one Strength_stat_details
     * const Strength_stat_details = await prisma.strength_stat_details.delete({
     *   where: {
     *     // ... filter to delete one Strength_stat_details
     *   }
     * })
     * 
     */
    delete<T extends Strength_stat_detailsDeleteArgs>(args: SelectSubset<T, Strength_stat_detailsDeleteArgs<ExtArgs>>): Prisma__Strength_stat_detailsClient<$Result.GetResult<Prisma.$Strength_stat_detailsPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Strength_stat_details.
     * @param {Strength_stat_detailsUpdateArgs} args - Arguments to update one Strength_stat_details.
     * @example
     * // Update one Strength_stat_details
     * const strength_stat_details = await prisma.strength_stat_details.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends Strength_stat_detailsUpdateArgs>(args: SelectSubset<T, Strength_stat_detailsUpdateArgs<ExtArgs>>): Prisma__Strength_stat_detailsClient<$Result.GetResult<Prisma.$Strength_stat_detailsPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Strength_stat_details.
     * @param {Strength_stat_detailsDeleteManyArgs} args - Arguments to filter Strength_stat_details to delete.
     * @example
     * // Delete a few Strength_stat_details
     * const { count } = await prisma.strength_stat_details.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends Strength_stat_detailsDeleteManyArgs>(args?: SelectSubset<T, Strength_stat_detailsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Strength_stat_details.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Strength_stat_detailsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Strength_stat_details
     * const strength_stat_details = await prisma.strength_stat_details.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends Strength_stat_detailsUpdateManyArgs>(args: SelectSubset<T, Strength_stat_detailsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Strength_stat_details and returns the data updated in the database.
     * @param {Strength_stat_detailsUpdateManyAndReturnArgs} args - Arguments to update many Strength_stat_details.
     * @example
     * // Update many Strength_stat_details
     * const strength_stat_details = await prisma.strength_stat_details.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Strength_stat_details and only return the `statblock_id`
     * const strength_stat_detailsWithStatblock_idOnly = await prisma.strength_stat_details.updateManyAndReturn({
     *   select: { statblock_id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends Strength_stat_detailsUpdateManyAndReturnArgs>(args: SelectSubset<T, Strength_stat_detailsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Strength_stat_detailsPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Strength_stat_details.
     * @param {Strength_stat_detailsUpsertArgs} args - Arguments to update or create a Strength_stat_details.
     * @example
     * // Update or create a Strength_stat_details
     * const strength_stat_details = await prisma.strength_stat_details.upsert({
     *   create: {
     *     // ... data to create a Strength_stat_details
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Strength_stat_details we want to update
     *   }
     * })
     */
    upsert<T extends Strength_stat_detailsUpsertArgs>(args: SelectSubset<T, Strength_stat_detailsUpsertArgs<ExtArgs>>): Prisma__Strength_stat_detailsClient<$Result.GetResult<Prisma.$Strength_stat_detailsPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Strength_stat_details.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Strength_stat_detailsCountArgs} args - Arguments to filter Strength_stat_details to count.
     * @example
     * // Count the number of Strength_stat_details
     * const count = await prisma.strength_stat_details.count({
     *   where: {
     *     // ... the filter for the Strength_stat_details we want to count
     *   }
     * })
    **/
    count<T extends Strength_stat_detailsCountArgs>(
      args?: Subset<T, Strength_stat_detailsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Strength_stat_detailsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Strength_stat_details.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Strength_stat_detailsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Strength_stat_detailsAggregateArgs>(args: Subset<T, Strength_stat_detailsAggregateArgs>): Prisma.PrismaPromise<GetStrength_stat_detailsAggregateType<T>>

    /**
     * Group by Strength_stat_details.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Strength_stat_detailsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Strength_stat_detailsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Strength_stat_detailsGroupByArgs['orderBy'] }
        : { orderBy?: Strength_stat_detailsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Strength_stat_detailsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStrength_stat_detailsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Strength_stat_details model
   */
  readonly fields: Strength_stat_detailsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Strength_stat_details.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__Strength_stat_detailsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    creature_stat<T extends Creature_statsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, Creature_statsDefaultArgs<ExtArgs>>): Prisma__Creature_statsClient<$Result.GetResult<Prisma.$Creature_statsPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Strength_stat_details model
   */ 
  interface Strength_stat_detailsFieldRefs {
    readonly statblock_id: FieldRef<"Strength_stat_details", 'String'>
    readonly value: FieldRef<"Strength_stat_details", 'Int'>
    readonly mastery: FieldRef<"Strength_stat_details", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * Strength_stat_details findUnique
   */
  export type Strength_stat_detailsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Strength_stat_details
     */
    select?: Strength_stat_detailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Strength_stat_details
     */
    omit?: Strength_stat_detailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Strength_stat_detailsInclude<ExtArgs> | null
    /**
     * Filter, which Strength_stat_details to fetch.
     */
    where: Strength_stat_detailsWhereUniqueInput
  }

  /**
   * Strength_stat_details findUniqueOrThrow
   */
  export type Strength_stat_detailsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Strength_stat_details
     */
    select?: Strength_stat_detailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Strength_stat_details
     */
    omit?: Strength_stat_detailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Strength_stat_detailsInclude<ExtArgs> | null
    /**
     * Filter, which Strength_stat_details to fetch.
     */
    where: Strength_stat_detailsWhereUniqueInput
  }

  /**
   * Strength_stat_details findFirst
   */
  export type Strength_stat_detailsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Strength_stat_details
     */
    select?: Strength_stat_detailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Strength_stat_details
     */
    omit?: Strength_stat_detailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Strength_stat_detailsInclude<ExtArgs> | null
    /**
     * Filter, which Strength_stat_details to fetch.
     */
    where?: Strength_stat_detailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Strength_stat_details to fetch.
     */
    orderBy?: Strength_stat_detailsOrderByWithRelationInput | Strength_stat_detailsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Strength_stat_details.
     */
    cursor?: Strength_stat_detailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Strength_stat_details from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Strength_stat_details.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Strength_stat_details.
     */
    distinct?: Strength_stat_detailsScalarFieldEnum | Strength_stat_detailsScalarFieldEnum[]
  }

  /**
   * Strength_stat_details findFirstOrThrow
   */
  export type Strength_stat_detailsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Strength_stat_details
     */
    select?: Strength_stat_detailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Strength_stat_details
     */
    omit?: Strength_stat_detailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Strength_stat_detailsInclude<ExtArgs> | null
    /**
     * Filter, which Strength_stat_details to fetch.
     */
    where?: Strength_stat_detailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Strength_stat_details to fetch.
     */
    orderBy?: Strength_stat_detailsOrderByWithRelationInput | Strength_stat_detailsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Strength_stat_details.
     */
    cursor?: Strength_stat_detailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Strength_stat_details from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Strength_stat_details.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Strength_stat_details.
     */
    distinct?: Strength_stat_detailsScalarFieldEnum | Strength_stat_detailsScalarFieldEnum[]
  }

  /**
   * Strength_stat_details findMany
   */
  export type Strength_stat_detailsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Strength_stat_details
     */
    select?: Strength_stat_detailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Strength_stat_details
     */
    omit?: Strength_stat_detailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Strength_stat_detailsInclude<ExtArgs> | null
    /**
     * Filter, which Strength_stat_details to fetch.
     */
    where?: Strength_stat_detailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Strength_stat_details to fetch.
     */
    orderBy?: Strength_stat_detailsOrderByWithRelationInput | Strength_stat_detailsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Strength_stat_details.
     */
    cursor?: Strength_stat_detailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Strength_stat_details from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Strength_stat_details.
     */
    skip?: number
    distinct?: Strength_stat_detailsScalarFieldEnum | Strength_stat_detailsScalarFieldEnum[]
  }

  /**
   * Strength_stat_details create
   */
  export type Strength_stat_detailsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Strength_stat_details
     */
    select?: Strength_stat_detailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Strength_stat_details
     */
    omit?: Strength_stat_detailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Strength_stat_detailsInclude<ExtArgs> | null
    /**
     * The data needed to create a Strength_stat_details.
     */
    data: XOR<Strength_stat_detailsCreateInput, Strength_stat_detailsUncheckedCreateInput>
  }

  /**
   * Strength_stat_details createMany
   */
  export type Strength_stat_detailsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Strength_stat_details.
     */
    data: Strength_stat_detailsCreateManyInput | Strength_stat_detailsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Strength_stat_details createManyAndReturn
   */
  export type Strength_stat_detailsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Strength_stat_details
     */
    select?: Strength_stat_detailsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Strength_stat_details
     */
    omit?: Strength_stat_detailsOmit<ExtArgs> | null
    /**
     * The data used to create many Strength_stat_details.
     */
    data: Strength_stat_detailsCreateManyInput | Strength_stat_detailsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Strength_stat_detailsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Strength_stat_details update
   */
  export type Strength_stat_detailsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Strength_stat_details
     */
    select?: Strength_stat_detailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Strength_stat_details
     */
    omit?: Strength_stat_detailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Strength_stat_detailsInclude<ExtArgs> | null
    /**
     * The data needed to update a Strength_stat_details.
     */
    data: XOR<Strength_stat_detailsUpdateInput, Strength_stat_detailsUncheckedUpdateInput>
    /**
     * Choose, which Strength_stat_details to update.
     */
    where: Strength_stat_detailsWhereUniqueInput
  }

  /**
   * Strength_stat_details updateMany
   */
  export type Strength_stat_detailsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Strength_stat_details.
     */
    data: XOR<Strength_stat_detailsUpdateManyMutationInput, Strength_stat_detailsUncheckedUpdateManyInput>
    /**
     * Filter which Strength_stat_details to update
     */
    where?: Strength_stat_detailsWhereInput
    /**
     * Limit how many Strength_stat_details to update.
     */
    limit?: number
  }

  /**
   * Strength_stat_details updateManyAndReturn
   */
  export type Strength_stat_detailsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Strength_stat_details
     */
    select?: Strength_stat_detailsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Strength_stat_details
     */
    omit?: Strength_stat_detailsOmit<ExtArgs> | null
    /**
     * The data used to update Strength_stat_details.
     */
    data: XOR<Strength_stat_detailsUpdateManyMutationInput, Strength_stat_detailsUncheckedUpdateManyInput>
    /**
     * Filter which Strength_stat_details to update
     */
    where?: Strength_stat_detailsWhereInput
    /**
     * Limit how many Strength_stat_details to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Strength_stat_detailsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Strength_stat_details upsert
   */
  export type Strength_stat_detailsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Strength_stat_details
     */
    select?: Strength_stat_detailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Strength_stat_details
     */
    omit?: Strength_stat_detailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Strength_stat_detailsInclude<ExtArgs> | null
    /**
     * The filter to search for the Strength_stat_details to update in case it exists.
     */
    where: Strength_stat_detailsWhereUniqueInput
    /**
     * In case the Strength_stat_details found by the `where` argument doesn't exist, create a new Strength_stat_details with this data.
     */
    create: XOR<Strength_stat_detailsCreateInput, Strength_stat_detailsUncheckedCreateInput>
    /**
     * In case the Strength_stat_details was found with the provided `where` argument, update it with this data.
     */
    update: XOR<Strength_stat_detailsUpdateInput, Strength_stat_detailsUncheckedUpdateInput>
  }

  /**
   * Strength_stat_details delete
   */
  export type Strength_stat_detailsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Strength_stat_details
     */
    select?: Strength_stat_detailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Strength_stat_details
     */
    omit?: Strength_stat_detailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Strength_stat_detailsInclude<ExtArgs> | null
    /**
     * Filter which Strength_stat_details to delete.
     */
    where: Strength_stat_detailsWhereUniqueInput
  }

  /**
   * Strength_stat_details deleteMany
   */
  export type Strength_stat_detailsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Strength_stat_details to delete
     */
    where?: Strength_stat_detailsWhereInput
    /**
     * Limit how many Strength_stat_details to delete.
     */
    limit?: number
  }

  /**
   * Strength_stat_details without action
   */
  export type Strength_stat_detailsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Strength_stat_details
     */
    select?: Strength_stat_detailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Strength_stat_details
     */
    omit?: Strength_stat_detailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Strength_stat_detailsInclude<ExtArgs> | null
  }


  /**
   * Model Dexterity_stat_details
   */

  export type AggregateDexterity_stat_details = {
    _count: Dexterity_stat_detailsCountAggregateOutputType | null
    _avg: Dexterity_stat_detailsAvgAggregateOutputType | null
    _sum: Dexterity_stat_detailsSumAggregateOutputType | null
    _min: Dexterity_stat_detailsMinAggregateOutputType | null
    _max: Dexterity_stat_detailsMaxAggregateOutputType | null
  }

  export type Dexterity_stat_detailsAvgAggregateOutputType = {
    value: number | null
  }

  export type Dexterity_stat_detailsSumAggregateOutputType = {
    value: number | null
  }

  export type Dexterity_stat_detailsMinAggregateOutputType = {
    statblock_id: string | null
    value: number | null
    mastery: boolean | null
  }

  export type Dexterity_stat_detailsMaxAggregateOutputType = {
    statblock_id: string | null
    value: number | null
    mastery: boolean | null
  }

  export type Dexterity_stat_detailsCountAggregateOutputType = {
    statblock_id: number
    value: number
    mastery: number
    _all: number
  }


  export type Dexterity_stat_detailsAvgAggregateInputType = {
    value?: true
  }

  export type Dexterity_stat_detailsSumAggregateInputType = {
    value?: true
  }

  export type Dexterity_stat_detailsMinAggregateInputType = {
    statblock_id?: true
    value?: true
    mastery?: true
  }

  export type Dexterity_stat_detailsMaxAggregateInputType = {
    statblock_id?: true
    value?: true
    mastery?: true
  }

  export type Dexterity_stat_detailsCountAggregateInputType = {
    statblock_id?: true
    value?: true
    mastery?: true
    _all?: true
  }

  export type Dexterity_stat_detailsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Dexterity_stat_details to aggregate.
     */
    where?: Dexterity_stat_detailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Dexterity_stat_details to fetch.
     */
    orderBy?: Dexterity_stat_detailsOrderByWithRelationInput | Dexterity_stat_detailsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: Dexterity_stat_detailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Dexterity_stat_details from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Dexterity_stat_details.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Dexterity_stat_details
    **/
    _count?: true | Dexterity_stat_detailsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Dexterity_stat_detailsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Dexterity_stat_detailsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Dexterity_stat_detailsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Dexterity_stat_detailsMaxAggregateInputType
  }

  export type GetDexterity_stat_detailsAggregateType<T extends Dexterity_stat_detailsAggregateArgs> = {
        [P in keyof T & keyof AggregateDexterity_stat_details]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDexterity_stat_details[P]>
      : GetScalarType<T[P], AggregateDexterity_stat_details[P]>
  }




  export type Dexterity_stat_detailsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: Dexterity_stat_detailsWhereInput
    orderBy?: Dexterity_stat_detailsOrderByWithAggregationInput | Dexterity_stat_detailsOrderByWithAggregationInput[]
    by: Dexterity_stat_detailsScalarFieldEnum[] | Dexterity_stat_detailsScalarFieldEnum
    having?: Dexterity_stat_detailsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Dexterity_stat_detailsCountAggregateInputType | true
    _avg?: Dexterity_stat_detailsAvgAggregateInputType
    _sum?: Dexterity_stat_detailsSumAggregateInputType
    _min?: Dexterity_stat_detailsMinAggregateInputType
    _max?: Dexterity_stat_detailsMaxAggregateInputType
  }

  export type Dexterity_stat_detailsGroupByOutputType = {
    statblock_id: string
    value: number
    mastery: boolean
    _count: Dexterity_stat_detailsCountAggregateOutputType | null
    _avg: Dexterity_stat_detailsAvgAggregateOutputType | null
    _sum: Dexterity_stat_detailsSumAggregateOutputType | null
    _min: Dexterity_stat_detailsMinAggregateOutputType | null
    _max: Dexterity_stat_detailsMaxAggregateOutputType | null
  }

  type GetDexterity_stat_detailsGroupByPayload<T extends Dexterity_stat_detailsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Dexterity_stat_detailsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Dexterity_stat_detailsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Dexterity_stat_detailsGroupByOutputType[P]>
            : GetScalarType<T[P], Dexterity_stat_detailsGroupByOutputType[P]>
        }
      >
    >


  export type Dexterity_stat_detailsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    statblock_id?: boolean
    value?: boolean
    mastery?: boolean
    creature_stat?: boolean | Creature_statsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["dexterity_stat_details"]>

  export type Dexterity_stat_detailsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    statblock_id?: boolean
    value?: boolean
    mastery?: boolean
    creature_stat?: boolean | Creature_statsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["dexterity_stat_details"]>

  export type Dexterity_stat_detailsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    statblock_id?: boolean
    value?: boolean
    mastery?: boolean
    creature_stat?: boolean | Creature_statsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["dexterity_stat_details"]>

  export type Dexterity_stat_detailsSelectScalar = {
    statblock_id?: boolean
    value?: boolean
    mastery?: boolean
  }

  export type Dexterity_stat_detailsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"statblock_id" | "value" | "mastery", ExtArgs["result"]["dexterity_stat_details"]>
  export type Dexterity_stat_detailsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creature_stat?: boolean | Creature_statsDefaultArgs<ExtArgs>
  }
  export type Dexterity_stat_detailsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creature_stat?: boolean | Creature_statsDefaultArgs<ExtArgs>
  }
  export type Dexterity_stat_detailsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creature_stat?: boolean | Creature_statsDefaultArgs<ExtArgs>
  }

  export type $Dexterity_stat_detailsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Dexterity_stat_details"
    objects: {
      creature_stat: Prisma.$Creature_statsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      statblock_id: string
      value: number
      mastery: boolean
    }, ExtArgs["result"]["dexterity_stat_details"]>
    composites: {}
  }

  type Dexterity_stat_detailsGetPayload<S extends boolean | null | undefined | Dexterity_stat_detailsDefaultArgs> = $Result.GetResult<Prisma.$Dexterity_stat_detailsPayload, S>

  type Dexterity_stat_detailsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<Dexterity_stat_detailsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Dexterity_stat_detailsCountAggregateInputType | true
    }

  export interface Dexterity_stat_detailsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Dexterity_stat_details'], meta: { name: 'Dexterity_stat_details' } }
    /**
     * Find zero or one Dexterity_stat_details that matches the filter.
     * @param {Dexterity_stat_detailsFindUniqueArgs} args - Arguments to find a Dexterity_stat_details
     * @example
     * // Get one Dexterity_stat_details
     * const dexterity_stat_details = await prisma.dexterity_stat_details.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends Dexterity_stat_detailsFindUniqueArgs>(args: SelectSubset<T, Dexterity_stat_detailsFindUniqueArgs<ExtArgs>>): Prisma__Dexterity_stat_detailsClient<$Result.GetResult<Prisma.$Dexterity_stat_detailsPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Dexterity_stat_details that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {Dexterity_stat_detailsFindUniqueOrThrowArgs} args - Arguments to find a Dexterity_stat_details
     * @example
     * // Get one Dexterity_stat_details
     * const dexterity_stat_details = await prisma.dexterity_stat_details.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends Dexterity_stat_detailsFindUniqueOrThrowArgs>(args: SelectSubset<T, Dexterity_stat_detailsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__Dexterity_stat_detailsClient<$Result.GetResult<Prisma.$Dexterity_stat_detailsPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Dexterity_stat_details that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Dexterity_stat_detailsFindFirstArgs} args - Arguments to find a Dexterity_stat_details
     * @example
     * // Get one Dexterity_stat_details
     * const dexterity_stat_details = await prisma.dexterity_stat_details.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends Dexterity_stat_detailsFindFirstArgs>(args?: SelectSubset<T, Dexterity_stat_detailsFindFirstArgs<ExtArgs>>): Prisma__Dexterity_stat_detailsClient<$Result.GetResult<Prisma.$Dexterity_stat_detailsPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Dexterity_stat_details that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Dexterity_stat_detailsFindFirstOrThrowArgs} args - Arguments to find a Dexterity_stat_details
     * @example
     * // Get one Dexterity_stat_details
     * const dexterity_stat_details = await prisma.dexterity_stat_details.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends Dexterity_stat_detailsFindFirstOrThrowArgs>(args?: SelectSubset<T, Dexterity_stat_detailsFindFirstOrThrowArgs<ExtArgs>>): Prisma__Dexterity_stat_detailsClient<$Result.GetResult<Prisma.$Dexterity_stat_detailsPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Dexterity_stat_details that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Dexterity_stat_detailsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Dexterity_stat_details
     * const dexterity_stat_details = await prisma.dexterity_stat_details.findMany()
     * 
     * // Get first 10 Dexterity_stat_details
     * const dexterity_stat_details = await prisma.dexterity_stat_details.findMany({ take: 10 })
     * 
     * // Only select the `statblock_id`
     * const dexterity_stat_detailsWithStatblock_idOnly = await prisma.dexterity_stat_details.findMany({ select: { statblock_id: true } })
     * 
     */
    findMany<T extends Dexterity_stat_detailsFindManyArgs>(args?: SelectSubset<T, Dexterity_stat_detailsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Dexterity_stat_detailsPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Dexterity_stat_details.
     * @param {Dexterity_stat_detailsCreateArgs} args - Arguments to create a Dexterity_stat_details.
     * @example
     * // Create one Dexterity_stat_details
     * const Dexterity_stat_details = await prisma.dexterity_stat_details.create({
     *   data: {
     *     // ... data to create a Dexterity_stat_details
     *   }
     * })
     * 
     */
    create<T extends Dexterity_stat_detailsCreateArgs>(args: SelectSubset<T, Dexterity_stat_detailsCreateArgs<ExtArgs>>): Prisma__Dexterity_stat_detailsClient<$Result.GetResult<Prisma.$Dexterity_stat_detailsPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Dexterity_stat_details.
     * @param {Dexterity_stat_detailsCreateManyArgs} args - Arguments to create many Dexterity_stat_details.
     * @example
     * // Create many Dexterity_stat_details
     * const dexterity_stat_details = await prisma.dexterity_stat_details.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends Dexterity_stat_detailsCreateManyArgs>(args?: SelectSubset<T, Dexterity_stat_detailsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Dexterity_stat_details and returns the data saved in the database.
     * @param {Dexterity_stat_detailsCreateManyAndReturnArgs} args - Arguments to create many Dexterity_stat_details.
     * @example
     * // Create many Dexterity_stat_details
     * const dexterity_stat_details = await prisma.dexterity_stat_details.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Dexterity_stat_details and only return the `statblock_id`
     * const dexterity_stat_detailsWithStatblock_idOnly = await prisma.dexterity_stat_details.createManyAndReturn({
     *   select: { statblock_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends Dexterity_stat_detailsCreateManyAndReturnArgs>(args?: SelectSubset<T, Dexterity_stat_detailsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Dexterity_stat_detailsPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Dexterity_stat_details.
     * @param {Dexterity_stat_detailsDeleteArgs} args - Arguments to delete one Dexterity_stat_details.
     * @example
     * // Delete one Dexterity_stat_details
     * const Dexterity_stat_details = await prisma.dexterity_stat_details.delete({
     *   where: {
     *     // ... filter to delete one Dexterity_stat_details
     *   }
     * })
     * 
     */
    delete<T extends Dexterity_stat_detailsDeleteArgs>(args: SelectSubset<T, Dexterity_stat_detailsDeleteArgs<ExtArgs>>): Prisma__Dexterity_stat_detailsClient<$Result.GetResult<Prisma.$Dexterity_stat_detailsPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Dexterity_stat_details.
     * @param {Dexterity_stat_detailsUpdateArgs} args - Arguments to update one Dexterity_stat_details.
     * @example
     * // Update one Dexterity_stat_details
     * const dexterity_stat_details = await prisma.dexterity_stat_details.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends Dexterity_stat_detailsUpdateArgs>(args: SelectSubset<T, Dexterity_stat_detailsUpdateArgs<ExtArgs>>): Prisma__Dexterity_stat_detailsClient<$Result.GetResult<Prisma.$Dexterity_stat_detailsPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Dexterity_stat_details.
     * @param {Dexterity_stat_detailsDeleteManyArgs} args - Arguments to filter Dexterity_stat_details to delete.
     * @example
     * // Delete a few Dexterity_stat_details
     * const { count } = await prisma.dexterity_stat_details.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends Dexterity_stat_detailsDeleteManyArgs>(args?: SelectSubset<T, Dexterity_stat_detailsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Dexterity_stat_details.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Dexterity_stat_detailsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Dexterity_stat_details
     * const dexterity_stat_details = await prisma.dexterity_stat_details.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends Dexterity_stat_detailsUpdateManyArgs>(args: SelectSubset<T, Dexterity_stat_detailsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Dexterity_stat_details and returns the data updated in the database.
     * @param {Dexterity_stat_detailsUpdateManyAndReturnArgs} args - Arguments to update many Dexterity_stat_details.
     * @example
     * // Update many Dexterity_stat_details
     * const dexterity_stat_details = await prisma.dexterity_stat_details.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Dexterity_stat_details and only return the `statblock_id`
     * const dexterity_stat_detailsWithStatblock_idOnly = await prisma.dexterity_stat_details.updateManyAndReturn({
     *   select: { statblock_id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends Dexterity_stat_detailsUpdateManyAndReturnArgs>(args: SelectSubset<T, Dexterity_stat_detailsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Dexterity_stat_detailsPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Dexterity_stat_details.
     * @param {Dexterity_stat_detailsUpsertArgs} args - Arguments to update or create a Dexterity_stat_details.
     * @example
     * // Update or create a Dexterity_stat_details
     * const dexterity_stat_details = await prisma.dexterity_stat_details.upsert({
     *   create: {
     *     // ... data to create a Dexterity_stat_details
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Dexterity_stat_details we want to update
     *   }
     * })
     */
    upsert<T extends Dexterity_stat_detailsUpsertArgs>(args: SelectSubset<T, Dexterity_stat_detailsUpsertArgs<ExtArgs>>): Prisma__Dexterity_stat_detailsClient<$Result.GetResult<Prisma.$Dexterity_stat_detailsPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Dexterity_stat_details.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Dexterity_stat_detailsCountArgs} args - Arguments to filter Dexterity_stat_details to count.
     * @example
     * // Count the number of Dexterity_stat_details
     * const count = await prisma.dexterity_stat_details.count({
     *   where: {
     *     // ... the filter for the Dexterity_stat_details we want to count
     *   }
     * })
    **/
    count<T extends Dexterity_stat_detailsCountArgs>(
      args?: Subset<T, Dexterity_stat_detailsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Dexterity_stat_detailsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Dexterity_stat_details.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Dexterity_stat_detailsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Dexterity_stat_detailsAggregateArgs>(args: Subset<T, Dexterity_stat_detailsAggregateArgs>): Prisma.PrismaPromise<GetDexterity_stat_detailsAggregateType<T>>

    /**
     * Group by Dexterity_stat_details.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Dexterity_stat_detailsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Dexterity_stat_detailsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Dexterity_stat_detailsGroupByArgs['orderBy'] }
        : { orderBy?: Dexterity_stat_detailsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Dexterity_stat_detailsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDexterity_stat_detailsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Dexterity_stat_details model
   */
  readonly fields: Dexterity_stat_detailsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Dexterity_stat_details.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__Dexterity_stat_detailsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    creature_stat<T extends Creature_statsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, Creature_statsDefaultArgs<ExtArgs>>): Prisma__Creature_statsClient<$Result.GetResult<Prisma.$Creature_statsPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Dexterity_stat_details model
   */ 
  interface Dexterity_stat_detailsFieldRefs {
    readonly statblock_id: FieldRef<"Dexterity_stat_details", 'String'>
    readonly value: FieldRef<"Dexterity_stat_details", 'Int'>
    readonly mastery: FieldRef<"Dexterity_stat_details", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * Dexterity_stat_details findUnique
   */
  export type Dexterity_stat_detailsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dexterity_stat_details
     */
    select?: Dexterity_stat_detailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Dexterity_stat_details
     */
    omit?: Dexterity_stat_detailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Dexterity_stat_detailsInclude<ExtArgs> | null
    /**
     * Filter, which Dexterity_stat_details to fetch.
     */
    where: Dexterity_stat_detailsWhereUniqueInput
  }

  /**
   * Dexterity_stat_details findUniqueOrThrow
   */
  export type Dexterity_stat_detailsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dexterity_stat_details
     */
    select?: Dexterity_stat_detailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Dexterity_stat_details
     */
    omit?: Dexterity_stat_detailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Dexterity_stat_detailsInclude<ExtArgs> | null
    /**
     * Filter, which Dexterity_stat_details to fetch.
     */
    where: Dexterity_stat_detailsWhereUniqueInput
  }

  /**
   * Dexterity_stat_details findFirst
   */
  export type Dexterity_stat_detailsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dexterity_stat_details
     */
    select?: Dexterity_stat_detailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Dexterity_stat_details
     */
    omit?: Dexterity_stat_detailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Dexterity_stat_detailsInclude<ExtArgs> | null
    /**
     * Filter, which Dexterity_stat_details to fetch.
     */
    where?: Dexterity_stat_detailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Dexterity_stat_details to fetch.
     */
    orderBy?: Dexterity_stat_detailsOrderByWithRelationInput | Dexterity_stat_detailsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Dexterity_stat_details.
     */
    cursor?: Dexterity_stat_detailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Dexterity_stat_details from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Dexterity_stat_details.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Dexterity_stat_details.
     */
    distinct?: Dexterity_stat_detailsScalarFieldEnum | Dexterity_stat_detailsScalarFieldEnum[]
  }

  /**
   * Dexterity_stat_details findFirstOrThrow
   */
  export type Dexterity_stat_detailsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dexterity_stat_details
     */
    select?: Dexterity_stat_detailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Dexterity_stat_details
     */
    omit?: Dexterity_stat_detailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Dexterity_stat_detailsInclude<ExtArgs> | null
    /**
     * Filter, which Dexterity_stat_details to fetch.
     */
    where?: Dexterity_stat_detailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Dexterity_stat_details to fetch.
     */
    orderBy?: Dexterity_stat_detailsOrderByWithRelationInput | Dexterity_stat_detailsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Dexterity_stat_details.
     */
    cursor?: Dexterity_stat_detailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Dexterity_stat_details from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Dexterity_stat_details.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Dexterity_stat_details.
     */
    distinct?: Dexterity_stat_detailsScalarFieldEnum | Dexterity_stat_detailsScalarFieldEnum[]
  }

  /**
   * Dexterity_stat_details findMany
   */
  export type Dexterity_stat_detailsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dexterity_stat_details
     */
    select?: Dexterity_stat_detailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Dexterity_stat_details
     */
    omit?: Dexterity_stat_detailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Dexterity_stat_detailsInclude<ExtArgs> | null
    /**
     * Filter, which Dexterity_stat_details to fetch.
     */
    where?: Dexterity_stat_detailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Dexterity_stat_details to fetch.
     */
    orderBy?: Dexterity_stat_detailsOrderByWithRelationInput | Dexterity_stat_detailsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Dexterity_stat_details.
     */
    cursor?: Dexterity_stat_detailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Dexterity_stat_details from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Dexterity_stat_details.
     */
    skip?: number
    distinct?: Dexterity_stat_detailsScalarFieldEnum | Dexterity_stat_detailsScalarFieldEnum[]
  }

  /**
   * Dexterity_stat_details create
   */
  export type Dexterity_stat_detailsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dexterity_stat_details
     */
    select?: Dexterity_stat_detailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Dexterity_stat_details
     */
    omit?: Dexterity_stat_detailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Dexterity_stat_detailsInclude<ExtArgs> | null
    /**
     * The data needed to create a Dexterity_stat_details.
     */
    data: XOR<Dexterity_stat_detailsCreateInput, Dexterity_stat_detailsUncheckedCreateInput>
  }

  /**
   * Dexterity_stat_details createMany
   */
  export type Dexterity_stat_detailsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Dexterity_stat_details.
     */
    data: Dexterity_stat_detailsCreateManyInput | Dexterity_stat_detailsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Dexterity_stat_details createManyAndReturn
   */
  export type Dexterity_stat_detailsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dexterity_stat_details
     */
    select?: Dexterity_stat_detailsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Dexterity_stat_details
     */
    omit?: Dexterity_stat_detailsOmit<ExtArgs> | null
    /**
     * The data used to create many Dexterity_stat_details.
     */
    data: Dexterity_stat_detailsCreateManyInput | Dexterity_stat_detailsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Dexterity_stat_detailsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Dexterity_stat_details update
   */
  export type Dexterity_stat_detailsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dexterity_stat_details
     */
    select?: Dexterity_stat_detailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Dexterity_stat_details
     */
    omit?: Dexterity_stat_detailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Dexterity_stat_detailsInclude<ExtArgs> | null
    /**
     * The data needed to update a Dexterity_stat_details.
     */
    data: XOR<Dexterity_stat_detailsUpdateInput, Dexterity_stat_detailsUncheckedUpdateInput>
    /**
     * Choose, which Dexterity_stat_details to update.
     */
    where: Dexterity_stat_detailsWhereUniqueInput
  }

  /**
   * Dexterity_stat_details updateMany
   */
  export type Dexterity_stat_detailsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Dexterity_stat_details.
     */
    data: XOR<Dexterity_stat_detailsUpdateManyMutationInput, Dexterity_stat_detailsUncheckedUpdateManyInput>
    /**
     * Filter which Dexterity_stat_details to update
     */
    where?: Dexterity_stat_detailsWhereInput
    /**
     * Limit how many Dexterity_stat_details to update.
     */
    limit?: number
  }

  /**
   * Dexterity_stat_details updateManyAndReturn
   */
  export type Dexterity_stat_detailsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dexterity_stat_details
     */
    select?: Dexterity_stat_detailsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Dexterity_stat_details
     */
    omit?: Dexterity_stat_detailsOmit<ExtArgs> | null
    /**
     * The data used to update Dexterity_stat_details.
     */
    data: XOR<Dexterity_stat_detailsUpdateManyMutationInput, Dexterity_stat_detailsUncheckedUpdateManyInput>
    /**
     * Filter which Dexterity_stat_details to update
     */
    where?: Dexterity_stat_detailsWhereInput
    /**
     * Limit how many Dexterity_stat_details to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Dexterity_stat_detailsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Dexterity_stat_details upsert
   */
  export type Dexterity_stat_detailsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dexterity_stat_details
     */
    select?: Dexterity_stat_detailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Dexterity_stat_details
     */
    omit?: Dexterity_stat_detailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Dexterity_stat_detailsInclude<ExtArgs> | null
    /**
     * The filter to search for the Dexterity_stat_details to update in case it exists.
     */
    where: Dexterity_stat_detailsWhereUniqueInput
    /**
     * In case the Dexterity_stat_details found by the `where` argument doesn't exist, create a new Dexterity_stat_details with this data.
     */
    create: XOR<Dexterity_stat_detailsCreateInput, Dexterity_stat_detailsUncheckedCreateInput>
    /**
     * In case the Dexterity_stat_details was found with the provided `where` argument, update it with this data.
     */
    update: XOR<Dexterity_stat_detailsUpdateInput, Dexterity_stat_detailsUncheckedUpdateInput>
  }

  /**
   * Dexterity_stat_details delete
   */
  export type Dexterity_stat_detailsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dexterity_stat_details
     */
    select?: Dexterity_stat_detailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Dexterity_stat_details
     */
    omit?: Dexterity_stat_detailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Dexterity_stat_detailsInclude<ExtArgs> | null
    /**
     * Filter which Dexterity_stat_details to delete.
     */
    where: Dexterity_stat_detailsWhereUniqueInput
  }

  /**
   * Dexterity_stat_details deleteMany
   */
  export type Dexterity_stat_detailsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Dexterity_stat_details to delete
     */
    where?: Dexterity_stat_detailsWhereInput
    /**
     * Limit how many Dexterity_stat_details to delete.
     */
    limit?: number
  }

  /**
   * Dexterity_stat_details without action
   */
  export type Dexterity_stat_detailsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dexterity_stat_details
     */
    select?: Dexterity_stat_detailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Dexterity_stat_details
     */
    omit?: Dexterity_stat_detailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Dexterity_stat_detailsInclude<ExtArgs> | null
  }


  /**
   * Model Constitution_stat_details
   */

  export type AggregateConstitution_stat_details = {
    _count: Constitution_stat_detailsCountAggregateOutputType | null
    _avg: Constitution_stat_detailsAvgAggregateOutputType | null
    _sum: Constitution_stat_detailsSumAggregateOutputType | null
    _min: Constitution_stat_detailsMinAggregateOutputType | null
    _max: Constitution_stat_detailsMaxAggregateOutputType | null
  }

  export type Constitution_stat_detailsAvgAggregateOutputType = {
    value: number | null
  }

  export type Constitution_stat_detailsSumAggregateOutputType = {
    value: number | null
  }

  export type Constitution_stat_detailsMinAggregateOutputType = {
    statblock_id: string | null
    value: number | null
    mastery: boolean | null
  }

  export type Constitution_stat_detailsMaxAggregateOutputType = {
    statblock_id: string | null
    value: number | null
    mastery: boolean | null
  }

  export type Constitution_stat_detailsCountAggregateOutputType = {
    statblock_id: number
    value: number
    mastery: number
    _all: number
  }


  export type Constitution_stat_detailsAvgAggregateInputType = {
    value?: true
  }

  export type Constitution_stat_detailsSumAggregateInputType = {
    value?: true
  }

  export type Constitution_stat_detailsMinAggregateInputType = {
    statblock_id?: true
    value?: true
    mastery?: true
  }

  export type Constitution_stat_detailsMaxAggregateInputType = {
    statblock_id?: true
    value?: true
    mastery?: true
  }

  export type Constitution_stat_detailsCountAggregateInputType = {
    statblock_id?: true
    value?: true
    mastery?: true
    _all?: true
  }

  export type Constitution_stat_detailsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Constitution_stat_details to aggregate.
     */
    where?: Constitution_stat_detailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Constitution_stat_details to fetch.
     */
    orderBy?: Constitution_stat_detailsOrderByWithRelationInput | Constitution_stat_detailsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: Constitution_stat_detailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Constitution_stat_details from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Constitution_stat_details.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Constitution_stat_details
    **/
    _count?: true | Constitution_stat_detailsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Constitution_stat_detailsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Constitution_stat_detailsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Constitution_stat_detailsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Constitution_stat_detailsMaxAggregateInputType
  }

  export type GetConstitution_stat_detailsAggregateType<T extends Constitution_stat_detailsAggregateArgs> = {
        [P in keyof T & keyof AggregateConstitution_stat_details]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateConstitution_stat_details[P]>
      : GetScalarType<T[P], AggregateConstitution_stat_details[P]>
  }




  export type Constitution_stat_detailsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: Constitution_stat_detailsWhereInput
    orderBy?: Constitution_stat_detailsOrderByWithAggregationInput | Constitution_stat_detailsOrderByWithAggregationInput[]
    by: Constitution_stat_detailsScalarFieldEnum[] | Constitution_stat_detailsScalarFieldEnum
    having?: Constitution_stat_detailsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Constitution_stat_detailsCountAggregateInputType | true
    _avg?: Constitution_stat_detailsAvgAggregateInputType
    _sum?: Constitution_stat_detailsSumAggregateInputType
    _min?: Constitution_stat_detailsMinAggregateInputType
    _max?: Constitution_stat_detailsMaxAggregateInputType
  }

  export type Constitution_stat_detailsGroupByOutputType = {
    statblock_id: string
    value: number
    mastery: boolean
    _count: Constitution_stat_detailsCountAggregateOutputType | null
    _avg: Constitution_stat_detailsAvgAggregateOutputType | null
    _sum: Constitution_stat_detailsSumAggregateOutputType | null
    _min: Constitution_stat_detailsMinAggregateOutputType | null
    _max: Constitution_stat_detailsMaxAggregateOutputType | null
  }

  type GetConstitution_stat_detailsGroupByPayload<T extends Constitution_stat_detailsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Constitution_stat_detailsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Constitution_stat_detailsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Constitution_stat_detailsGroupByOutputType[P]>
            : GetScalarType<T[P], Constitution_stat_detailsGroupByOutputType[P]>
        }
      >
    >


  export type Constitution_stat_detailsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    statblock_id?: boolean
    value?: boolean
    mastery?: boolean
    creature_stat?: boolean | Creature_statsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["constitution_stat_details"]>

  export type Constitution_stat_detailsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    statblock_id?: boolean
    value?: boolean
    mastery?: boolean
    creature_stat?: boolean | Creature_statsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["constitution_stat_details"]>

  export type Constitution_stat_detailsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    statblock_id?: boolean
    value?: boolean
    mastery?: boolean
    creature_stat?: boolean | Creature_statsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["constitution_stat_details"]>

  export type Constitution_stat_detailsSelectScalar = {
    statblock_id?: boolean
    value?: boolean
    mastery?: boolean
  }

  export type Constitution_stat_detailsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"statblock_id" | "value" | "mastery", ExtArgs["result"]["constitution_stat_details"]>
  export type Constitution_stat_detailsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creature_stat?: boolean | Creature_statsDefaultArgs<ExtArgs>
  }
  export type Constitution_stat_detailsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creature_stat?: boolean | Creature_statsDefaultArgs<ExtArgs>
  }
  export type Constitution_stat_detailsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creature_stat?: boolean | Creature_statsDefaultArgs<ExtArgs>
  }

  export type $Constitution_stat_detailsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Constitution_stat_details"
    objects: {
      creature_stat: Prisma.$Creature_statsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      statblock_id: string
      value: number
      mastery: boolean
    }, ExtArgs["result"]["constitution_stat_details"]>
    composites: {}
  }

  type Constitution_stat_detailsGetPayload<S extends boolean | null | undefined | Constitution_stat_detailsDefaultArgs> = $Result.GetResult<Prisma.$Constitution_stat_detailsPayload, S>

  type Constitution_stat_detailsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<Constitution_stat_detailsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Constitution_stat_detailsCountAggregateInputType | true
    }

  export interface Constitution_stat_detailsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Constitution_stat_details'], meta: { name: 'Constitution_stat_details' } }
    /**
     * Find zero or one Constitution_stat_details that matches the filter.
     * @param {Constitution_stat_detailsFindUniqueArgs} args - Arguments to find a Constitution_stat_details
     * @example
     * // Get one Constitution_stat_details
     * const constitution_stat_details = await prisma.constitution_stat_details.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends Constitution_stat_detailsFindUniqueArgs>(args: SelectSubset<T, Constitution_stat_detailsFindUniqueArgs<ExtArgs>>): Prisma__Constitution_stat_detailsClient<$Result.GetResult<Prisma.$Constitution_stat_detailsPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Constitution_stat_details that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {Constitution_stat_detailsFindUniqueOrThrowArgs} args - Arguments to find a Constitution_stat_details
     * @example
     * // Get one Constitution_stat_details
     * const constitution_stat_details = await prisma.constitution_stat_details.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends Constitution_stat_detailsFindUniqueOrThrowArgs>(args: SelectSubset<T, Constitution_stat_detailsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__Constitution_stat_detailsClient<$Result.GetResult<Prisma.$Constitution_stat_detailsPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Constitution_stat_details that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Constitution_stat_detailsFindFirstArgs} args - Arguments to find a Constitution_stat_details
     * @example
     * // Get one Constitution_stat_details
     * const constitution_stat_details = await prisma.constitution_stat_details.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends Constitution_stat_detailsFindFirstArgs>(args?: SelectSubset<T, Constitution_stat_detailsFindFirstArgs<ExtArgs>>): Prisma__Constitution_stat_detailsClient<$Result.GetResult<Prisma.$Constitution_stat_detailsPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Constitution_stat_details that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Constitution_stat_detailsFindFirstOrThrowArgs} args - Arguments to find a Constitution_stat_details
     * @example
     * // Get one Constitution_stat_details
     * const constitution_stat_details = await prisma.constitution_stat_details.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends Constitution_stat_detailsFindFirstOrThrowArgs>(args?: SelectSubset<T, Constitution_stat_detailsFindFirstOrThrowArgs<ExtArgs>>): Prisma__Constitution_stat_detailsClient<$Result.GetResult<Prisma.$Constitution_stat_detailsPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Constitution_stat_details that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Constitution_stat_detailsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Constitution_stat_details
     * const constitution_stat_details = await prisma.constitution_stat_details.findMany()
     * 
     * // Get first 10 Constitution_stat_details
     * const constitution_stat_details = await prisma.constitution_stat_details.findMany({ take: 10 })
     * 
     * // Only select the `statblock_id`
     * const constitution_stat_detailsWithStatblock_idOnly = await prisma.constitution_stat_details.findMany({ select: { statblock_id: true } })
     * 
     */
    findMany<T extends Constitution_stat_detailsFindManyArgs>(args?: SelectSubset<T, Constitution_stat_detailsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Constitution_stat_detailsPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Constitution_stat_details.
     * @param {Constitution_stat_detailsCreateArgs} args - Arguments to create a Constitution_stat_details.
     * @example
     * // Create one Constitution_stat_details
     * const Constitution_stat_details = await prisma.constitution_stat_details.create({
     *   data: {
     *     // ... data to create a Constitution_stat_details
     *   }
     * })
     * 
     */
    create<T extends Constitution_stat_detailsCreateArgs>(args: SelectSubset<T, Constitution_stat_detailsCreateArgs<ExtArgs>>): Prisma__Constitution_stat_detailsClient<$Result.GetResult<Prisma.$Constitution_stat_detailsPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Constitution_stat_details.
     * @param {Constitution_stat_detailsCreateManyArgs} args - Arguments to create many Constitution_stat_details.
     * @example
     * // Create many Constitution_stat_details
     * const constitution_stat_details = await prisma.constitution_stat_details.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends Constitution_stat_detailsCreateManyArgs>(args?: SelectSubset<T, Constitution_stat_detailsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Constitution_stat_details and returns the data saved in the database.
     * @param {Constitution_stat_detailsCreateManyAndReturnArgs} args - Arguments to create many Constitution_stat_details.
     * @example
     * // Create many Constitution_stat_details
     * const constitution_stat_details = await prisma.constitution_stat_details.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Constitution_stat_details and only return the `statblock_id`
     * const constitution_stat_detailsWithStatblock_idOnly = await prisma.constitution_stat_details.createManyAndReturn({
     *   select: { statblock_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends Constitution_stat_detailsCreateManyAndReturnArgs>(args?: SelectSubset<T, Constitution_stat_detailsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Constitution_stat_detailsPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Constitution_stat_details.
     * @param {Constitution_stat_detailsDeleteArgs} args - Arguments to delete one Constitution_stat_details.
     * @example
     * // Delete one Constitution_stat_details
     * const Constitution_stat_details = await prisma.constitution_stat_details.delete({
     *   where: {
     *     // ... filter to delete one Constitution_stat_details
     *   }
     * })
     * 
     */
    delete<T extends Constitution_stat_detailsDeleteArgs>(args: SelectSubset<T, Constitution_stat_detailsDeleteArgs<ExtArgs>>): Prisma__Constitution_stat_detailsClient<$Result.GetResult<Prisma.$Constitution_stat_detailsPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Constitution_stat_details.
     * @param {Constitution_stat_detailsUpdateArgs} args - Arguments to update one Constitution_stat_details.
     * @example
     * // Update one Constitution_stat_details
     * const constitution_stat_details = await prisma.constitution_stat_details.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends Constitution_stat_detailsUpdateArgs>(args: SelectSubset<T, Constitution_stat_detailsUpdateArgs<ExtArgs>>): Prisma__Constitution_stat_detailsClient<$Result.GetResult<Prisma.$Constitution_stat_detailsPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Constitution_stat_details.
     * @param {Constitution_stat_detailsDeleteManyArgs} args - Arguments to filter Constitution_stat_details to delete.
     * @example
     * // Delete a few Constitution_stat_details
     * const { count } = await prisma.constitution_stat_details.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends Constitution_stat_detailsDeleteManyArgs>(args?: SelectSubset<T, Constitution_stat_detailsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Constitution_stat_details.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Constitution_stat_detailsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Constitution_stat_details
     * const constitution_stat_details = await prisma.constitution_stat_details.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends Constitution_stat_detailsUpdateManyArgs>(args: SelectSubset<T, Constitution_stat_detailsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Constitution_stat_details and returns the data updated in the database.
     * @param {Constitution_stat_detailsUpdateManyAndReturnArgs} args - Arguments to update many Constitution_stat_details.
     * @example
     * // Update many Constitution_stat_details
     * const constitution_stat_details = await prisma.constitution_stat_details.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Constitution_stat_details and only return the `statblock_id`
     * const constitution_stat_detailsWithStatblock_idOnly = await prisma.constitution_stat_details.updateManyAndReturn({
     *   select: { statblock_id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends Constitution_stat_detailsUpdateManyAndReturnArgs>(args: SelectSubset<T, Constitution_stat_detailsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Constitution_stat_detailsPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Constitution_stat_details.
     * @param {Constitution_stat_detailsUpsertArgs} args - Arguments to update or create a Constitution_stat_details.
     * @example
     * // Update or create a Constitution_stat_details
     * const constitution_stat_details = await prisma.constitution_stat_details.upsert({
     *   create: {
     *     // ... data to create a Constitution_stat_details
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Constitution_stat_details we want to update
     *   }
     * })
     */
    upsert<T extends Constitution_stat_detailsUpsertArgs>(args: SelectSubset<T, Constitution_stat_detailsUpsertArgs<ExtArgs>>): Prisma__Constitution_stat_detailsClient<$Result.GetResult<Prisma.$Constitution_stat_detailsPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Constitution_stat_details.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Constitution_stat_detailsCountArgs} args - Arguments to filter Constitution_stat_details to count.
     * @example
     * // Count the number of Constitution_stat_details
     * const count = await prisma.constitution_stat_details.count({
     *   where: {
     *     // ... the filter for the Constitution_stat_details we want to count
     *   }
     * })
    **/
    count<T extends Constitution_stat_detailsCountArgs>(
      args?: Subset<T, Constitution_stat_detailsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Constitution_stat_detailsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Constitution_stat_details.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Constitution_stat_detailsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Constitution_stat_detailsAggregateArgs>(args: Subset<T, Constitution_stat_detailsAggregateArgs>): Prisma.PrismaPromise<GetConstitution_stat_detailsAggregateType<T>>

    /**
     * Group by Constitution_stat_details.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Constitution_stat_detailsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Constitution_stat_detailsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Constitution_stat_detailsGroupByArgs['orderBy'] }
        : { orderBy?: Constitution_stat_detailsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Constitution_stat_detailsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetConstitution_stat_detailsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Constitution_stat_details model
   */
  readonly fields: Constitution_stat_detailsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Constitution_stat_details.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__Constitution_stat_detailsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    creature_stat<T extends Creature_statsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, Creature_statsDefaultArgs<ExtArgs>>): Prisma__Creature_statsClient<$Result.GetResult<Prisma.$Creature_statsPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Constitution_stat_details model
   */ 
  interface Constitution_stat_detailsFieldRefs {
    readonly statblock_id: FieldRef<"Constitution_stat_details", 'String'>
    readonly value: FieldRef<"Constitution_stat_details", 'Int'>
    readonly mastery: FieldRef<"Constitution_stat_details", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * Constitution_stat_details findUnique
   */
  export type Constitution_stat_detailsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Constitution_stat_details
     */
    select?: Constitution_stat_detailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Constitution_stat_details
     */
    omit?: Constitution_stat_detailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Constitution_stat_detailsInclude<ExtArgs> | null
    /**
     * Filter, which Constitution_stat_details to fetch.
     */
    where: Constitution_stat_detailsWhereUniqueInput
  }

  /**
   * Constitution_stat_details findUniqueOrThrow
   */
  export type Constitution_stat_detailsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Constitution_stat_details
     */
    select?: Constitution_stat_detailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Constitution_stat_details
     */
    omit?: Constitution_stat_detailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Constitution_stat_detailsInclude<ExtArgs> | null
    /**
     * Filter, which Constitution_stat_details to fetch.
     */
    where: Constitution_stat_detailsWhereUniqueInput
  }

  /**
   * Constitution_stat_details findFirst
   */
  export type Constitution_stat_detailsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Constitution_stat_details
     */
    select?: Constitution_stat_detailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Constitution_stat_details
     */
    omit?: Constitution_stat_detailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Constitution_stat_detailsInclude<ExtArgs> | null
    /**
     * Filter, which Constitution_stat_details to fetch.
     */
    where?: Constitution_stat_detailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Constitution_stat_details to fetch.
     */
    orderBy?: Constitution_stat_detailsOrderByWithRelationInput | Constitution_stat_detailsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Constitution_stat_details.
     */
    cursor?: Constitution_stat_detailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Constitution_stat_details from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Constitution_stat_details.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Constitution_stat_details.
     */
    distinct?: Constitution_stat_detailsScalarFieldEnum | Constitution_stat_detailsScalarFieldEnum[]
  }

  /**
   * Constitution_stat_details findFirstOrThrow
   */
  export type Constitution_stat_detailsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Constitution_stat_details
     */
    select?: Constitution_stat_detailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Constitution_stat_details
     */
    omit?: Constitution_stat_detailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Constitution_stat_detailsInclude<ExtArgs> | null
    /**
     * Filter, which Constitution_stat_details to fetch.
     */
    where?: Constitution_stat_detailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Constitution_stat_details to fetch.
     */
    orderBy?: Constitution_stat_detailsOrderByWithRelationInput | Constitution_stat_detailsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Constitution_stat_details.
     */
    cursor?: Constitution_stat_detailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Constitution_stat_details from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Constitution_stat_details.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Constitution_stat_details.
     */
    distinct?: Constitution_stat_detailsScalarFieldEnum | Constitution_stat_detailsScalarFieldEnum[]
  }

  /**
   * Constitution_stat_details findMany
   */
  export type Constitution_stat_detailsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Constitution_stat_details
     */
    select?: Constitution_stat_detailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Constitution_stat_details
     */
    omit?: Constitution_stat_detailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Constitution_stat_detailsInclude<ExtArgs> | null
    /**
     * Filter, which Constitution_stat_details to fetch.
     */
    where?: Constitution_stat_detailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Constitution_stat_details to fetch.
     */
    orderBy?: Constitution_stat_detailsOrderByWithRelationInput | Constitution_stat_detailsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Constitution_stat_details.
     */
    cursor?: Constitution_stat_detailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Constitution_stat_details from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Constitution_stat_details.
     */
    skip?: number
    distinct?: Constitution_stat_detailsScalarFieldEnum | Constitution_stat_detailsScalarFieldEnum[]
  }

  /**
   * Constitution_stat_details create
   */
  export type Constitution_stat_detailsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Constitution_stat_details
     */
    select?: Constitution_stat_detailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Constitution_stat_details
     */
    omit?: Constitution_stat_detailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Constitution_stat_detailsInclude<ExtArgs> | null
    /**
     * The data needed to create a Constitution_stat_details.
     */
    data: XOR<Constitution_stat_detailsCreateInput, Constitution_stat_detailsUncheckedCreateInput>
  }

  /**
   * Constitution_stat_details createMany
   */
  export type Constitution_stat_detailsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Constitution_stat_details.
     */
    data: Constitution_stat_detailsCreateManyInput | Constitution_stat_detailsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Constitution_stat_details createManyAndReturn
   */
  export type Constitution_stat_detailsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Constitution_stat_details
     */
    select?: Constitution_stat_detailsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Constitution_stat_details
     */
    omit?: Constitution_stat_detailsOmit<ExtArgs> | null
    /**
     * The data used to create many Constitution_stat_details.
     */
    data: Constitution_stat_detailsCreateManyInput | Constitution_stat_detailsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Constitution_stat_detailsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Constitution_stat_details update
   */
  export type Constitution_stat_detailsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Constitution_stat_details
     */
    select?: Constitution_stat_detailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Constitution_stat_details
     */
    omit?: Constitution_stat_detailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Constitution_stat_detailsInclude<ExtArgs> | null
    /**
     * The data needed to update a Constitution_stat_details.
     */
    data: XOR<Constitution_stat_detailsUpdateInput, Constitution_stat_detailsUncheckedUpdateInput>
    /**
     * Choose, which Constitution_stat_details to update.
     */
    where: Constitution_stat_detailsWhereUniqueInput
  }

  /**
   * Constitution_stat_details updateMany
   */
  export type Constitution_stat_detailsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Constitution_stat_details.
     */
    data: XOR<Constitution_stat_detailsUpdateManyMutationInput, Constitution_stat_detailsUncheckedUpdateManyInput>
    /**
     * Filter which Constitution_stat_details to update
     */
    where?: Constitution_stat_detailsWhereInput
    /**
     * Limit how many Constitution_stat_details to update.
     */
    limit?: number
  }

  /**
   * Constitution_stat_details updateManyAndReturn
   */
  export type Constitution_stat_detailsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Constitution_stat_details
     */
    select?: Constitution_stat_detailsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Constitution_stat_details
     */
    omit?: Constitution_stat_detailsOmit<ExtArgs> | null
    /**
     * The data used to update Constitution_stat_details.
     */
    data: XOR<Constitution_stat_detailsUpdateManyMutationInput, Constitution_stat_detailsUncheckedUpdateManyInput>
    /**
     * Filter which Constitution_stat_details to update
     */
    where?: Constitution_stat_detailsWhereInput
    /**
     * Limit how many Constitution_stat_details to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Constitution_stat_detailsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Constitution_stat_details upsert
   */
  export type Constitution_stat_detailsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Constitution_stat_details
     */
    select?: Constitution_stat_detailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Constitution_stat_details
     */
    omit?: Constitution_stat_detailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Constitution_stat_detailsInclude<ExtArgs> | null
    /**
     * The filter to search for the Constitution_stat_details to update in case it exists.
     */
    where: Constitution_stat_detailsWhereUniqueInput
    /**
     * In case the Constitution_stat_details found by the `where` argument doesn't exist, create a new Constitution_stat_details with this data.
     */
    create: XOR<Constitution_stat_detailsCreateInput, Constitution_stat_detailsUncheckedCreateInput>
    /**
     * In case the Constitution_stat_details was found with the provided `where` argument, update it with this data.
     */
    update: XOR<Constitution_stat_detailsUpdateInput, Constitution_stat_detailsUncheckedUpdateInput>
  }

  /**
   * Constitution_stat_details delete
   */
  export type Constitution_stat_detailsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Constitution_stat_details
     */
    select?: Constitution_stat_detailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Constitution_stat_details
     */
    omit?: Constitution_stat_detailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Constitution_stat_detailsInclude<ExtArgs> | null
    /**
     * Filter which Constitution_stat_details to delete.
     */
    where: Constitution_stat_detailsWhereUniqueInput
  }

  /**
   * Constitution_stat_details deleteMany
   */
  export type Constitution_stat_detailsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Constitution_stat_details to delete
     */
    where?: Constitution_stat_detailsWhereInput
    /**
     * Limit how many Constitution_stat_details to delete.
     */
    limit?: number
  }

  /**
   * Constitution_stat_details without action
   */
  export type Constitution_stat_detailsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Constitution_stat_details
     */
    select?: Constitution_stat_detailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Constitution_stat_details
     */
    omit?: Constitution_stat_detailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Constitution_stat_detailsInclude<ExtArgs> | null
  }


  /**
   * Model Intelligence_stat_details
   */

  export type AggregateIntelligence_stat_details = {
    _count: Intelligence_stat_detailsCountAggregateOutputType | null
    _avg: Intelligence_stat_detailsAvgAggregateOutputType | null
    _sum: Intelligence_stat_detailsSumAggregateOutputType | null
    _min: Intelligence_stat_detailsMinAggregateOutputType | null
    _max: Intelligence_stat_detailsMaxAggregateOutputType | null
  }

  export type Intelligence_stat_detailsAvgAggregateOutputType = {
    value: number | null
  }

  export type Intelligence_stat_detailsSumAggregateOutputType = {
    value: number | null
  }

  export type Intelligence_stat_detailsMinAggregateOutputType = {
    statblock_id: string | null
    value: number | null
    mastery: boolean | null
  }

  export type Intelligence_stat_detailsMaxAggregateOutputType = {
    statblock_id: string | null
    value: number | null
    mastery: boolean | null
  }

  export type Intelligence_stat_detailsCountAggregateOutputType = {
    statblock_id: number
    value: number
    mastery: number
    _all: number
  }


  export type Intelligence_stat_detailsAvgAggregateInputType = {
    value?: true
  }

  export type Intelligence_stat_detailsSumAggregateInputType = {
    value?: true
  }

  export type Intelligence_stat_detailsMinAggregateInputType = {
    statblock_id?: true
    value?: true
    mastery?: true
  }

  export type Intelligence_stat_detailsMaxAggregateInputType = {
    statblock_id?: true
    value?: true
    mastery?: true
  }

  export type Intelligence_stat_detailsCountAggregateInputType = {
    statblock_id?: true
    value?: true
    mastery?: true
    _all?: true
  }

  export type Intelligence_stat_detailsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Intelligence_stat_details to aggregate.
     */
    where?: Intelligence_stat_detailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Intelligence_stat_details to fetch.
     */
    orderBy?: Intelligence_stat_detailsOrderByWithRelationInput | Intelligence_stat_detailsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: Intelligence_stat_detailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Intelligence_stat_details from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Intelligence_stat_details.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Intelligence_stat_details
    **/
    _count?: true | Intelligence_stat_detailsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Intelligence_stat_detailsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Intelligence_stat_detailsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Intelligence_stat_detailsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Intelligence_stat_detailsMaxAggregateInputType
  }

  export type GetIntelligence_stat_detailsAggregateType<T extends Intelligence_stat_detailsAggregateArgs> = {
        [P in keyof T & keyof AggregateIntelligence_stat_details]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateIntelligence_stat_details[P]>
      : GetScalarType<T[P], AggregateIntelligence_stat_details[P]>
  }




  export type Intelligence_stat_detailsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: Intelligence_stat_detailsWhereInput
    orderBy?: Intelligence_stat_detailsOrderByWithAggregationInput | Intelligence_stat_detailsOrderByWithAggregationInput[]
    by: Intelligence_stat_detailsScalarFieldEnum[] | Intelligence_stat_detailsScalarFieldEnum
    having?: Intelligence_stat_detailsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Intelligence_stat_detailsCountAggregateInputType | true
    _avg?: Intelligence_stat_detailsAvgAggregateInputType
    _sum?: Intelligence_stat_detailsSumAggregateInputType
    _min?: Intelligence_stat_detailsMinAggregateInputType
    _max?: Intelligence_stat_detailsMaxAggregateInputType
  }

  export type Intelligence_stat_detailsGroupByOutputType = {
    statblock_id: string
    value: number
    mastery: boolean
    _count: Intelligence_stat_detailsCountAggregateOutputType | null
    _avg: Intelligence_stat_detailsAvgAggregateOutputType | null
    _sum: Intelligence_stat_detailsSumAggregateOutputType | null
    _min: Intelligence_stat_detailsMinAggregateOutputType | null
    _max: Intelligence_stat_detailsMaxAggregateOutputType | null
  }

  type GetIntelligence_stat_detailsGroupByPayload<T extends Intelligence_stat_detailsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Intelligence_stat_detailsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Intelligence_stat_detailsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Intelligence_stat_detailsGroupByOutputType[P]>
            : GetScalarType<T[P], Intelligence_stat_detailsGroupByOutputType[P]>
        }
      >
    >


  export type Intelligence_stat_detailsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    statblock_id?: boolean
    value?: boolean
    mastery?: boolean
    creature_stat?: boolean | Creature_statsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["intelligence_stat_details"]>

  export type Intelligence_stat_detailsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    statblock_id?: boolean
    value?: boolean
    mastery?: boolean
    creature_stat?: boolean | Creature_statsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["intelligence_stat_details"]>

  export type Intelligence_stat_detailsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    statblock_id?: boolean
    value?: boolean
    mastery?: boolean
    creature_stat?: boolean | Creature_statsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["intelligence_stat_details"]>

  export type Intelligence_stat_detailsSelectScalar = {
    statblock_id?: boolean
    value?: boolean
    mastery?: boolean
  }

  export type Intelligence_stat_detailsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"statblock_id" | "value" | "mastery", ExtArgs["result"]["intelligence_stat_details"]>
  export type Intelligence_stat_detailsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creature_stat?: boolean | Creature_statsDefaultArgs<ExtArgs>
  }
  export type Intelligence_stat_detailsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creature_stat?: boolean | Creature_statsDefaultArgs<ExtArgs>
  }
  export type Intelligence_stat_detailsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creature_stat?: boolean | Creature_statsDefaultArgs<ExtArgs>
  }

  export type $Intelligence_stat_detailsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Intelligence_stat_details"
    objects: {
      creature_stat: Prisma.$Creature_statsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      statblock_id: string
      value: number
      mastery: boolean
    }, ExtArgs["result"]["intelligence_stat_details"]>
    composites: {}
  }

  type Intelligence_stat_detailsGetPayload<S extends boolean | null | undefined | Intelligence_stat_detailsDefaultArgs> = $Result.GetResult<Prisma.$Intelligence_stat_detailsPayload, S>

  type Intelligence_stat_detailsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<Intelligence_stat_detailsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Intelligence_stat_detailsCountAggregateInputType | true
    }

  export interface Intelligence_stat_detailsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Intelligence_stat_details'], meta: { name: 'Intelligence_stat_details' } }
    /**
     * Find zero or one Intelligence_stat_details that matches the filter.
     * @param {Intelligence_stat_detailsFindUniqueArgs} args - Arguments to find a Intelligence_stat_details
     * @example
     * // Get one Intelligence_stat_details
     * const intelligence_stat_details = await prisma.intelligence_stat_details.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends Intelligence_stat_detailsFindUniqueArgs>(args: SelectSubset<T, Intelligence_stat_detailsFindUniqueArgs<ExtArgs>>): Prisma__Intelligence_stat_detailsClient<$Result.GetResult<Prisma.$Intelligence_stat_detailsPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Intelligence_stat_details that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {Intelligence_stat_detailsFindUniqueOrThrowArgs} args - Arguments to find a Intelligence_stat_details
     * @example
     * // Get one Intelligence_stat_details
     * const intelligence_stat_details = await prisma.intelligence_stat_details.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends Intelligence_stat_detailsFindUniqueOrThrowArgs>(args: SelectSubset<T, Intelligence_stat_detailsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__Intelligence_stat_detailsClient<$Result.GetResult<Prisma.$Intelligence_stat_detailsPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Intelligence_stat_details that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Intelligence_stat_detailsFindFirstArgs} args - Arguments to find a Intelligence_stat_details
     * @example
     * // Get one Intelligence_stat_details
     * const intelligence_stat_details = await prisma.intelligence_stat_details.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends Intelligence_stat_detailsFindFirstArgs>(args?: SelectSubset<T, Intelligence_stat_detailsFindFirstArgs<ExtArgs>>): Prisma__Intelligence_stat_detailsClient<$Result.GetResult<Prisma.$Intelligence_stat_detailsPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Intelligence_stat_details that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Intelligence_stat_detailsFindFirstOrThrowArgs} args - Arguments to find a Intelligence_stat_details
     * @example
     * // Get one Intelligence_stat_details
     * const intelligence_stat_details = await prisma.intelligence_stat_details.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends Intelligence_stat_detailsFindFirstOrThrowArgs>(args?: SelectSubset<T, Intelligence_stat_detailsFindFirstOrThrowArgs<ExtArgs>>): Prisma__Intelligence_stat_detailsClient<$Result.GetResult<Prisma.$Intelligence_stat_detailsPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Intelligence_stat_details that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Intelligence_stat_detailsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Intelligence_stat_details
     * const intelligence_stat_details = await prisma.intelligence_stat_details.findMany()
     * 
     * // Get first 10 Intelligence_stat_details
     * const intelligence_stat_details = await prisma.intelligence_stat_details.findMany({ take: 10 })
     * 
     * // Only select the `statblock_id`
     * const intelligence_stat_detailsWithStatblock_idOnly = await prisma.intelligence_stat_details.findMany({ select: { statblock_id: true } })
     * 
     */
    findMany<T extends Intelligence_stat_detailsFindManyArgs>(args?: SelectSubset<T, Intelligence_stat_detailsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Intelligence_stat_detailsPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Intelligence_stat_details.
     * @param {Intelligence_stat_detailsCreateArgs} args - Arguments to create a Intelligence_stat_details.
     * @example
     * // Create one Intelligence_stat_details
     * const Intelligence_stat_details = await prisma.intelligence_stat_details.create({
     *   data: {
     *     // ... data to create a Intelligence_stat_details
     *   }
     * })
     * 
     */
    create<T extends Intelligence_stat_detailsCreateArgs>(args: SelectSubset<T, Intelligence_stat_detailsCreateArgs<ExtArgs>>): Prisma__Intelligence_stat_detailsClient<$Result.GetResult<Prisma.$Intelligence_stat_detailsPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Intelligence_stat_details.
     * @param {Intelligence_stat_detailsCreateManyArgs} args - Arguments to create many Intelligence_stat_details.
     * @example
     * // Create many Intelligence_stat_details
     * const intelligence_stat_details = await prisma.intelligence_stat_details.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends Intelligence_stat_detailsCreateManyArgs>(args?: SelectSubset<T, Intelligence_stat_detailsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Intelligence_stat_details and returns the data saved in the database.
     * @param {Intelligence_stat_detailsCreateManyAndReturnArgs} args - Arguments to create many Intelligence_stat_details.
     * @example
     * // Create many Intelligence_stat_details
     * const intelligence_stat_details = await prisma.intelligence_stat_details.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Intelligence_stat_details and only return the `statblock_id`
     * const intelligence_stat_detailsWithStatblock_idOnly = await prisma.intelligence_stat_details.createManyAndReturn({
     *   select: { statblock_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends Intelligence_stat_detailsCreateManyAndReturnArgs>(args?: SelectSubset<T, Intelligence_stat_detailsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Intelligence_stat_detailsPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Intelligence_stat_details.
     * @param {Intelligence_stat_detailsDeleteArgs} args - Arguments to delete one Intelligence_stat_details.
     * @example
     * // Delete one Intelligence_stat_details
     * const Intelligence_stat_details = await prisma.intelligence_stat_details.delete({
     *   where: {
     *     // ... filter to delete one Intelligence_stat_details
     *   }
     * })
     * 
     */
    delete<T extends Intelligence_stat_detailsDeleteArgs>(args: SelectSubset<T, Intelligence_stat_detailsDeleteArgs<ExtArgs>>): Prisma__Intelligence_stat_detailsClient<$Result.GetResult<Prisma.$Intelligence_stat_detailsPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Intelligence_stat_details.
     * @param {Intelligence_stat_detailsUpdateArgs} args - Arguments to update one Intelligence_stat_details.
     * @example
     * // Update one Intelligence_stat_details
     * const intelligence_stat_details = await prisma.intelligence_stat_details.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends Intelligence_stat_detailsUpdateArgs>(args: SelectSubset<T, Intelligence_stat_detailsUpdateArgs<ExtArgs>>): Prisma__Intelligence_stat_detailsClient<$Result.GetResult<Prisma.$Intelligence_stat_detailsPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Intelligence_stat_details.
     * @param {Intelligence_stat_detailsDeleteManyArgs} args - Arguments to filter Intelligence_stat_details to delete.
     * @example
     * // Delete a few Intelligence_stat_details
     * const { count } = await prisma.intelligence_stat_details.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends Intelligence_stat_detailsDeleteManyArgs>(args?: SelectSubset<T, Intelligence_stat_detailsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Intelligence_stat_details.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Intelligence_stat_detailsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Intelligence_stat_details
     * const intelligence_stat_details = await prisma.intelligence_stat_details.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends Intelligence_stat_detailsUpdateManyArgs>(args: SelectSubset<T, Intelligence_stat_detailsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Intelligence_stat_details and returns the data updated in the database.
     * @param {Intelligence_stat_detailsUpdateManyAndReturnArgs} args - Arguments to update many Intelligence_stat_details.
     * @example
     * // Update many Intelligence_stat_details
     * const intelligence_stat_details = await prisma.intelligence_stat_details.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Intelligence_stat_details and only return the `statblock_id`
     * const intelligence_stat_detailsWithStatblock_idOnly = await prisma.intelligence_stat_details.updateManyAndReturn({
     *   select: { statblock_id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends Intelligence_stat_detailsUpdateManyAndReturnArgs>(args: SelectSubset<T, Intelligence_stat_detailsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Intelligence_stat_detailsPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Intelligence_stat_details.
     * @param {Intelligence_stat_detailsUpsertArgs} args - Arguments to update or create a Intelligence_stat_details.
     * @example
     * // Update or create a Intelligence_stat_details
     * const intelligence_stat_details = await prisma.intelligence_stat_details.upsert({
     *   create: {
     *     // ... data to create a Intelligence_stat_details
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Intelligence_stat_details we want to update
     *   }
     * })
     */
    upsert<T extends Intelligence_stat_detailsUpsertArgs>(args: SelectSubset<T, Intelligence_stat_detailsUpsertArgs<ExtArgs>>): Prisma__Intelligence_stat_detailsClient<$Result.GetResult<Prisma.$Intelligence_stat_detailsPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Intelligence_stat_details.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Intelligence_stat_detailsCountArgs} args - Arguments to filter Intelligence_stat_details to count.
     * @example
     * // Count the number of Intelligence_stat_details
     * const count = await prisma.intelligence_stat_details.count({
     *   where: {
     *     // ... the filter for the Intelligence_stat_details we want to count
     *   }
     * })
    **/
    count<T extends Intelligence_stat_detailsCountArgs>(
      args?: Subset<T, Intelligence_stat_detailsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Intelligence_stat_detailsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Intelligence_stat_details.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Intelligence_stat_detailsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Intelligence_stat_detailsAggregateArgs>(args: Subset<T, Intelligence_stat_detailsAggregateArgs>): Prisma.PrismaPromise<GetIntelligence_stat_detailsAggregateType<T>>

    /**
     * Group by Intelligence_stat_details.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Intelligence_stat_detailsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Intelligence_stat_detailsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Intelligence_stat_detailsGroupByArgs['orderBy'] }
        : { orderBy?: Intelligence_stat_detailsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Intelligence_stat_detailsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetIntelligence_stat_detailsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Intelligence_stat_details model
   */
  readonly fields: Intelligence_stat_detailsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Intelligence_stat_details.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__Intelligence_stat_detailsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    creature_stat<T extends Creature_statsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, Creature_statsDefaultArgs<ExtArgs>>): Prisma__Creature_statsClient<$Result.GetResult<Prisma.$Creature_statsPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Intelligence_stat_details model
   */ 
  interface Intelligence_stat_detailsFieldRefs {
    readonly statblock_id: FieldRef<"Intelligence_stat_details", 'String'>
    readonly value: FieldRef<"Intelligence_stat_details", 'Int'>
    readonly mastery: FieldRef<"Intelligence_stat_details", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * Intelligence_stat_details findUnique
   */
  export type Intelligence_stat_detailsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Intelligence_stat_details
     */
    select?: Intelligence_stat_detailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Intelligence_stat_details
     */
    omit?: Intelligence_stat_detailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Intelligence_stat_detailsInclude<ExtArgs> | null
    /**
     * Filter, which Intelligence_stat_details to fetch.
     */
    where: Intelligence_stat_detailsWhereUniqueInput
  }

  /**
   * Intelligence_stat_details findUniqueOrThrow
   */
  export type Intelligence_stat_detailsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Intelligence_stat_details
     */
    select?: Intelligence_stat_detailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Intelligence_stat_details
     */
    omit?: Intelligence_stat_detailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Intelligence_stat_detailsInclude<ExtArgs> | null
    /**
     * Filter, which Intelligence_stat_details to fetch.
     */
    where: Intelligence_stat_detailsWhereUniqueInput
  }

  /**
   * Intelligence_stat_details findFirst
   */
  export type Intelligence_stat_detailsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Intelligence_stat_details
     */
    select?: Intelligence_stat_detailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Intelligence_stat_details
     */
    omit?: Intelligence_stat_detailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Intelligence_stat_detailsInclude<ExtArgs> | null
    /**
     * Filter, which Intelligence_stat_details to fetch.
     */
    where?: Intelligence_stat_detailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Intelligence_stat_details to fetch.
     */
    orderBy?: Intelligence_stat_detailsOrderByWithRelationInput | Intelligence_stat_detailsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Intelligence_stat_details.
     */
    cursor?: Intelligence_stat_detailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Intelligence_stat_details from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Intelligence_stat_details.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Intelligence_stat_details.
     */
    distinct?: Intelligence_stat_detailsScalarFieldEnum | Intelligence_stat_detailsScalarFieldEnum[]
  }

  /**
   * Intelligence_stat_details findFirstOrThrow
   */
  export type Intelligence_stat_detailsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Intelligence_stat_details
     */
    select?: Intelligence_stat_detailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Intelligence_stat_details
     */
    omit?: Intelligence_stat_detailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Intelligence_stat_detailsInclude<ExtArgs> | null
    /**
     * Filter, which Intelligence_stat_details to fetch.
     */
    where?: Intelligence_stat_detailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Intelligence_stat_details to fetch.
     */
    orderBy?: Intelligence_stat_detailsOrderByWithRelationInput | Intelligence_stat_detailsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Intelligence_stat_details.
     */
    cursor?: Intelligence_stat_detailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Intelligence_stat_details from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Intelligence_stat_details.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Intelligence_stat_details.
     */
    distinct?: Intelligence_stat_detailsScalarFieldEnum | Intelligence_stat_detailsScalarFieldEnum[]
  }

  /**
   * Intelligence_stat_details findMany
   */
  export type Intelligence_stat_detailsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Intelligence_stat_details
     */
    select?: Intelligence_stat_detailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Intelligence_stat_details
     */
    omit?: Intelligence_stat_detailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Intelligence_stat_detailsInclude<ExtArgs> | null
    /**
     * Filter, which Intelligence_stat_details to fetch.
     */
    where?: Intelligence_stat_detailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Intelligence_stat_details to fetch.
     */
    orderBy?: Intelligence_stat_detailsOrderByWithRelationInput | Intelligence_stat_detailsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Intelligence_stat_details.
     */
    cursor?: Intelligence_stat_detailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Intelligence_stat_details from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Intelligence_stat_details.
     */
    skip?: number
    distinct?: Intelligence_stat_detailsScalarFieldEnum | Intelligence_stat_detailsScalarFieldEnum[]
  }

  /**
   * Intelligence_stat_details create
   */
  export type Intelligence_stat_detailsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Intelligence_stat_details
     */
    select?: Intelligence_stat_detailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Intelligence_stat_details
     */
    omit?: Intelligence_stat_detailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Intelligence_stat_detailsInclude<ExtArgs> | null
    /**
     * The data needed to create a Intelligence_stat_details.
     */
    data: XOR<Intelligence_stat_detailsCreateInput, Intelligence_stat_detailsUncheckedCreateInput>
  }

  /**
   * Intelligence_stat_details createMany
   */
  export type Intelligence_stat_detailsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Intelligence_stat_details.
     */
    data: Intelligence_stat_detailsCreateManyInput | Intelligence_stat_detailsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Intelligence_stat_details createManyAndReturn
   */
  export type Intelligence_stat_detailsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Intelligence_stat_details
     */
    select?: Intelligence_stat_detailsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Intelligence_stat_details
     */
    omit?: Intelligence_stat_detailsOmit<ExtArgs> | null
    /**
     * The data used to create many Intelligence_stat_details.
     */
    data: Intelligence_stat_detailsCreateManyInput | Intelligence_stat_detailsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Intelligence_stat_detailsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Intelligence_stat_details update
   */
  export type Intelligence_stat_detailsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Intelligence_stat_details
     */
    select?: Intelligence_stat_detailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Intelligence_stat_details
     */
    omit?: Intelligence_stat_detailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Intelligence_stat_detailsInclude<ExtArgs> | null
    /**
     * The data needed to update a Intelligence_stat_details.
     */
    data: XOR<Intelligence_stat_detailsUpdateInput, Intelligence_stat_detailsUncheckedUpdateInput>
    /**
     * Choose, which Intelligence_stat_details to update.
     */
    where: Intelligence_stat_detailsWhereUniqueInput
  }

  /**
   * Intelligence_stat_details updateMany
   */
  export type Intelligence_stat_detailsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Intelligence_stat_details.
     */
    data: XOR<Intelligence_stat_detailsUpdateManyMutationInput, Intelligence_stat_detailsUncheckedUpdateManyInput>
    /**
     * Filter which Intelligence_stat_details to update
     */
    where?: Intelligence_stat_detailsWhereInput
    /**
     * Limit how many Intelligence_stat_details to update.
     */
    limit?: number
  }

  /**
   * Intelligence_stat_details updateManyAndReturn
   */
  export type Intelligence_stat_detailsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Intelligence_stat_details
     */
    select?: Intelligence_stat_detailsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Intelligence_stat_details
     */
    omit?: Intelligence_stat_detailsOmit<ExtArgs> | null
    /**
     * The data used to update Intelligence_stat_details.
     */
    data: XOR<Intelligence_stat_detailsUpdateManyMutationInput, Intelligence_stat_detailsUncheckedUpdateManyInput>
    /**
     * Filter which Intelligence_stat_details to update
     */
    where?: Intelligence_stat_detailsWhereInput
    /**
     * Limit how many Intelligence_stat_details to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Intelligence_stat_detailsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Intelligence_stat_details upsert
   */
  export type Intelligence_stat_detailsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Intelligence_stat_details
     */
    select?: Intelligence_stat_detailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Intelligence_stat_details
     */
    omit?: Intelligence_stat_detailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Intelligence_stat_detailsInclude<ExtArgs> | null
    /**
     * The filter to search for the Intelligence_stat_details to update in case it exists.
     */
    where: Intelligence_stat_detailsWhereUniqueInput
    /**
     * In case the Intelligence_stat_details found by the `where` argument doesn't exist, create a new Intelligence_stat_details with this data.
     */
    create: XOR<Intelligence_stat_detailsCreateInput, Intelligence_stat_detailsUncheckedCreateInput>
    /**
     * In case the Intelligence_stat_details was found with the provided `where` argument, update it with this data.
     */
    update: XOR<Intelligence_stat_detailsUpdateInput, Intelligence_stat_detailsUncheckedUpdateInput>
  }

  /**
   * Intelligence_stat_details delete
   */
  export type Intelligence_stat_detailsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Intelligence_stat_details
     */
    select?: Intelligence_stat_detailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Intelligence_stat_details
     */
    omit?: Intelligence_stat_detailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Intelligence_stat_detailsInclude<ExtArgs> | null
    /**
     * Filter which Intelligence_stat_details to delete.
     */
    where: Intelligence_stat_detailsWhereUniqueInput
  }

  /**
   * Intelligence_stat_details deleteMany
   */
  export type Intelligence_stat_detailsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Intelligence_stat_details to delete
     */
    where?: Intelligence_stat_detailsWhereInput
    /**
     * Limit how many Intelligence_stat_details to delete.
     */
    limit?: number
  }

  /**
   * Intelligence_stat_details without action
   */
  export type Intelligence_stat_detailsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Intelligence_stat_details
     */
    select?: Intelligence_stat_detailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Intelligence_stat_details
     */
    omit?: Intelligence_stat_detailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Intelligence_stat_detailsInclude<ExtArgs> | null
  }


  /**
   * Model Wisdom_stat_details
   */

  export type AggregateWisdom_stat_details = {
    _count: Wisdom_stat_detailsCountAggregateOutputType | null
    _avg: Wisdom_stat_detailsAvgAggregateOutputType | null
    _sum: Wisdom_stat_detailsSumAggregateOutputType | null
    _min: Wisdom_stat_detailsMinAggregateOutputType | null
    _max: Wisdom_stat_detailsMaxAggregateOutputType | null
  }

  export type Wisdom_stat_detailsAvgAggregateOutputType = {
    value: number | null
  }

  export type Wisdom_stat_detailsSumAggregateOutputType = {
    value: number | null
  }

  export type Wisdom_stat_detailsMinAggregateOutputType = {
    statblock_id: string | null
    value: number | null
    mastery: boolean | null
  }

  export type Wisdom_stat_detailsMaxAggregateOutputType = {
    statblock_id: string | null
    value: number | null
    mastery: boolean | null
  }

  export type Wisdom_stat_detailsCountAggregateOutputType = {
    statblock_id: number
    value: number
    mastery: number
    _all: number
  }


  export type Wisdom_stat_detailsAvgAggregateInputType = {
    value?: true
  }

  export type Wisdom_stat_detailsSumAggregateInputType = {
    value?: true
  }

  export type Wisdom_stat_detailsMinAggregateInputType = {
    statblock_id?: true
    value?: true
    mastery?: true
  }

  export type Wisdom_stat_detailsMaxAggregateInputType = {
    statblock_id?: true
    value?: true
    mastery?: true
  }

  export type Wisdom_stat_detailsCountAggregateInputType = {
    statblock_id?: true
    value?: true
    mastery?: true
    _all?: true
  }

  export type Wisdom_stat_detailsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Wisdom_stat_details to aggregate.
     */
    where?: Wisdom_stat_detailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Wisdom_stat_details to fetch.
     */
    orderBy?: Wisdom_stat_detailsOrderByWithRelationInput | Wisdom_stat_detailsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: Wisdom_stat_detailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Wisdom_stat_details from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Wisdom_stat_details.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Wisdom_stat_details
    **/
    _count?: true | Wisdom_stat_detailsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Wisdom_stat_detailsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Wisdom_stat_detailsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Wisdom_stat_detailsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Wisdom_stat_detailsMaxAggregateInputType
  }

  export type GetWisdom_stat_detailsAggregateType<T extends Wisdom_stat_detailsAggregateArgs> = {
        [P in keyof T & keyof AggregateWisdom_stat_details]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWisdom_stat_details[P]>
      : GetScalarType<T[P], AggregateWisdom_stat_details[P]>
  }




  export type Wisdom_stat_detailsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: Wisdom_stat_detailsWhereInput
    orderBy?: Wisdom_stat_detailsOrderByWithAggregationInput | Wisdom_stat_detailsOrderByWithAggregationInput[]
    by: Wisdom_stat_detailsScalarFieldEnum[] | Wisdom_stat_detailsScalarFieldEnum
    having?: Wisdom_stat_detailsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Wisdom_stat_detailsCountAggregateInputType | true
    _avg?: Wisdom_stat_detailsAvgAggregateInputType
    _sum?: Wisdom_stat_detailsSumAggregateInputType
    _min?: Wisdom_stat_detailsMinAggregateInputType
    _max?: Wisdom_stat_detailsMaxAggregateInputType
  }

  export type Wisdom_stat_detailsGroupByOutputType = {
    statblock_id: string
    value: number
    mastery: boolean
    _count: Wisdom_stat_detailsCountAggregateOutputType | null
    _avg: Wisdom_stat_detailsAvgAggregateOutputType | null
    _sum: Wisdom_stat_detailsSumAggregateOutputType | null
    _min: Wisdom_stat_detailsMinAggregateOutputType | null
    _max: Wisdom_stat_detailsMaxAggregateOutputType | null
  }

  type GetWisdom_stat_detailsGroupByPayload<T extends Wisdom_stat_detailsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Wisdom_stat_detailsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Wisdom_stat_detailsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Wisdom_stat_detailsGroupByOutputType[P]>
            : GetScalarType<T[P], Wisdom_stat_detailsGroupByOutputType[P]>
        }
      >
    >


  export type Wisdom_stat_detailsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    statblock_id?: boolean
    value?: boolean
    mastery?: boolean
    creature_stat?: boolean | Creature_statsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["wisdom_stat_details"]>

  export type Wisdom_stat_detailsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    statblock_id?: boolean
    value?: boolean
    mastery?: boolean
    creature_stat?: boolean | Creature_statsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["wisdom_stat_details"]>

  export type Wisdom_stat_detailsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    statblock_id?: boolean
    value?: boolean
    mastery?: boolean
    creature_stat?: boolean | Creature_statsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["wisdom_stat_details"]>

  export type Wisdom_stat_detailsSelectScalar = {
    statblock_id?: boolean
    value?: boolean
    mastery?: boolean
  }

  export type Wisdom_stat_detailsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"statblock_id" | "value" | "mastery", ExtArgs["result"]["wisdom_stat_details"]>
  export type Wisdom_stat_detailsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creature_stat?: boolean | Creature_statsDefaultArgs<ExtArgs>
  }
  export type Wisdom_stat_detailsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creature_stat?: boolean | Creature_statsDefaultArgs<ExtArgs>
  }
  export type Wisdom_stat_detailsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creature_stat?: boolean | Creature_statsDefaultArgs<ExtArgs>
  }

  export type $Wisdom_stat_detailsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Wisdom_stat_details"
    objects: {
      creature_stat: Prisma.$Creature_statsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      statblock_id: string
      value: number
      mastery: boolean
    }, ExtArgs["result"]["wisdom_stat_details"]>
    composites: {}
  }

  type Wisdom_stat_detailsGetPayload<S extends boolean | null | undefined | Wisdom_stat_detailsDefaultArgs> = $Result.GetResult<Prisma.$Wisdom_stat_detailsPayload, S>

  type Wisdom_stat_detailsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<Wisdom_stat_detailsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Wisdom_stat_detailsCountAggregateInputType | true
    }

  export interface Wisdom_stat_detailsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Wisdom_stat_details'], meta: { name: 'Wisdom_stat_details' } }
    /**
     * Find zero or one Wisdom_stat_details that matches the filter.
     * @param {Wisdom_stat_detailsFindUniqueArgs} args - Arguments to find a Wisdom_stat_details
     * @example
     * // Get one Wisdom_stat_details
     * const wisdom_stat_details = await prisma.wisdom_stat_details.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends Wisdom_stat_detailsFindUniqueArgs>(args: SelectSubset<T, Wisdom_stat_detailsFindUniqueArgs<ExtArgs>>): Prisma__Wisdom_stat_detailsClient<$Result.GetResult<Prisma.$Wisdom_stat_detailsPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Wisdom_stat_details that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {Wisdom_stat_detailsFindUniqueOrThrowArgs} args - Arguments to find a Wisdom_stat_details
     * @example
     * // Get one Wisdom_stat_details
     * const wisdom_stat_details = await prisma.wisdom_stat_details.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends Wisdom_stat_detailsFindUniqueOrThrowArgs>(args: SelectSubset<T, Wisdom_stat_detailsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__Wisdom_stat_detailsClient<$Result.GetResult<Prisma.$Wisdom_stat_detailsPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Wisdom_stat_details that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Wisdom_stat_detailsFindFirstArgs} args - Arguments to find a Wisdom_stat_details
     * @example
     * // Get one Wisdom_stat_details
     * const wisdom_stat_details = await prisma.wisdom_stat_details.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends Wisdom_stat_detailsFindFirstArgs>(args?: SelectSubset<T, Wisdom_stat_detailsFindFirstArgs<ExtArgs>>): Prisma__Wisdom_stat_detailsClient<$Result.GetResult<Prisma.$Wisdom_stat_detailsPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Wisdom_stat_details that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Wisdom_stat_detailsFindFirstOrThrowArgs} args - Arguments to find a Wisdom_stat_details
     * @example
     * // Get one Wisdom_stat_details
     * const wisdom_stat_details = await prisma.wisdom_stat_details.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends Wisdom_stat_detailsFindFirstOrThrowArgs>(args?: SelectSubset<T, Wisdom_stat_detailsFindFirstOrThrowArgs<ExtArgs>>): Prisma__Wisdom_stat_detailsClient<$Result.GetResult<Prisma.$Wisdom_stat_detailsPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Wisdom_stat_details that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Wisdom_stat_detailsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Wisdom_stat_details
     * const wisdom_stat_details = await prisma.wisdom_stat_details.findMany()
     * 
     * // Get first 10 Wisdom_stat_details
     * const wisdom_stat_details = await prisma.wisdom_stat_details.findMany({ take: 10 })
     * 
     * // Only select the `statblock_id`
     * const wisdom_stat_detailsWithStatblock_idOnly = await prisma.wisdom_stat_details.findMany({ select: { statblock_id: true } })
     * 
     */
    findMany<T extends Wisdom_stat_detailsFindManyArgs>(args?: SelectSubset<T, Wisdom_stat_detailsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Wisdom_stat_detailsPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Wisdom_stat_details.
     * @param {Wisdom_stat_detailsCreateArgs} args - Arguments to create a Wisdom_stat_details.
     * @example
     * // Create one Wisdom_stat_details
     * const Wisdom_stat_details = await prisma.wisdom_stat_details.create({
     *   data: {
     *     // ... data to create a Wisdom_stat_details
     *   }
     * })
     * 
     */
    create<T extends Wisdom_stat_detailsCreateArgs>(args: SelectSubset<T, Wisdom_stat_detailsCreateArgs<ExtArgs>>): Prisma__Wisdom_stat_detailsClient<$Result.GetResult<Prisma.$Wisdom_stat_detailsPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Wisdom_stat_details.
     * @param {Wisdom_stat_detailsCreateManyArgs} args - Arguments to create many Wisdom_stat_details.
     * @example
     * // Create many Wisdom_stat_details
     * const wisdom_stat_details = await prisma.wisdom_stat_details.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends Wisdom_stat_detailsCreateManyArgs>(args?: SelectSubset<T, Wisdom_stat_detailsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Wisdom_stat_details and returns the data saved in the database.
     * @param {Wisdom_stat_detailsCreateManyAndReturnArgs} args - Arguments to create many Wisdom_stat_details.
     * @example
     * // Create many Wisdom_stat_details
     * const wisdom_stat_details = await prisma.wisdom_stat_details.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Wisdom_stat_details and only return the `statblock_id`
     * const wisdom_stat_detailsWithStatblock_idOnly = await prisma.wisdom_stat_details.createManyAndReturn({
     *   select: { statblock_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends Wisdom_stat_detailsCreateManyAndReturnArgs>(args?: SelectSubset<T, Wisdom_stat_detailsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Wisdom_stat_detailsPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Wisdom_stat_details.
     * @param {Wisdom_stat_detailsDeleteArgs} args - Arguments to delete one Wisdom_stat_details.
     * @example
     * // Delete one Wisdom_stat_details
     * const Wisdom_stat_details = await prisma.wisdom_stat_details.delete({
     *   where: {
     *     // ... filter to delete one Wisdom_stat_details
     *   }
     * })
     * 
     */
    delete<T extends Wisdom_stat_detailsDeleteArgs>(args: SelectSubset<T, Wisdom_stat_detailsDeleteArgs<ExtArgs>>): Prisma__Wisdom_stat_detailsClient<$Result.GetResult<Prisma.$Wisdom_stat_detailsPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Wisdom_stat_details.
     * @param {Wisdom_stat_detailsUpdateArgs} args - Arguments to update one Wisdom_stat_details.
     * @example
     * // Update one Wisdom_stat_details
     * const wisdom_stat_details = await prisma.wisdom_stat_details.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends Wisdom_stat_detailsUpdateArgs>(args: SelectSubset<T, Wisdom_stat_detailsUpdateArgs<ExtArgs>>): Prisma__Wisdom_stat_detailsClient<$Result.GetResult<Prisma.$Wisdom_stat_detailsPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Wisdom_stat_details.
     * @param {Wisdom_stat_detailsDeleteManyArgs} args - Arguments to filter Wisdom_stat_details to delete.
     * @example
     * // Delete a few Wisdom_stat_details
     * const { count } = await prisma.wisdom_stat_details.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends Wisdom_stat_detailsDeleteManyArgs>(args?: SelectSubset<T, Wisdom_stat_detailsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Wisdom_stat_details.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Wisdom_stat_detailsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Wisdom_stat_details
     * const wisdom_stat_details = await prisma.wisdom_stat_details.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends Wisdom_stat_detailsUpdateManyArgs>(args: SelectSubset<T, Wisdom_stat_detailsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Wisdom_stat_details and returns the data updated in the database.
     * @param {Wisdom_stat_detailsUpdateManyAndReturnArgs} args - Arguments to update many Wisdom_stat_details.
     * @example
     * // Update many Wisdom_stat_details
     * const wisdom_stat_details = await prisma.wisdom_stat_details.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Wisdom_stat_details and only return the `statblock_id`
     * const wisdom_stat_detailsWithStatblock_idOnly = await prisma.wisdom_stat_details.updateManyAndReturn({
     *   select: { statblock_id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends Wisdom_stat_detailsUpdateManyAndReturnArgs>(args: SelectSubset<T, Wisdom_stat_detailsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Wisdom_stat_detailsPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Wisdom_stat_details.
     * @param {Wisdom_stat_detailsUpsertArgs} args - Arguments to update or create a Wisdom_stat_details.
     * @example
     * // Update or create a Wisdom_stat_details
     * const wisdom_stat_details = await prisma.wisdom_stat_details.upsert({
     *   create: {
     *     // ... data to create a Wisdom_stat_details
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Wisdom_stat_details we want to update
     *   }
     * })
     */
    upsert<T extends Wisdom_stat_detailsUpsertArgs>(args: SelectSubset<T, Wisdom_stat_detailsUpsertArgs<ExtArgs>>): Prisma__Wisdom_stat_detailsClient<$Result.GetResult<Prisma.$Wisdom_stat_detailsPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Wisdom_stat_details.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Wisdom_stat_detailsCountArgs} args - Arguments to filter Wisdom_stat_details to count.
     * @example
     * // Count the number of Wisdom_stat_details
     * const count = await prisma.wisdom_stat_details.count({
     *   where: {
     *     // ... the filter for the Wisdom_stat_details we want to count
     *   }
     * })
    **/
    count<T extends Wisdom_stat_detailsCountArgs>(
      args?: Subset<T, Wisdom_stat_detailsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Wisdom_stat_detailsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Wisdom_stat_details.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Wisdom_stat_detailsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Wisdom_stat_detailsAggregateArgs>(args: Subset<T, Wisdom_stat_detailsAggregateArgs>): Prisma.PrismaPromise<GetWisdom_stat_detailsAggregateType<T>>

    /**
     * Group by Wisdom_stat_details.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Wisdom_stat_detailsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Wisdom_stat_detailsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Wisdom_stat_detailsGroupByArgs['orderBy'] }
        : { orderBy?: Wisdom_stat_detailsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Wisdom_stat_detailsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWisdom_stat_detailsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Wisdom_stat_details model
   */
  readonly fields: Wisdom_stat_detailsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Wisdom_stat_details.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__Wisdom_stat_detailsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    creature_stat<T extends Creature_statsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, Creature_statsDefaultArgs<ExtArgs>>): Prisma__Creature_statsClient<$Result.GetResult<Prisma.$Creature_statsPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Wisdom_stat_details model
   */ 
  interface Wisdom_stat_detailsFieldRefs {
    readonly statblock_id: FieldRef<"Wisdom_stat_details", 'String'>
    readonly value: FieldRef<"Wisdom_stat_details", 'Int'>
    readonly mastery: FieldRef<"Wisdom_stat_details", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * Wisdom_stat_details findUnique
   */
  export type Wisdom_stat_detailsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Wisdom_stat_details
     */
    select?: Wisdom_stat_detailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Wisdom_stat_details
     */
    omit?: Wisdom_stat_detailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Wisdom_stat_detailsInclude<ExtArgs> | null
    /**
     * Filter, which Wisdom_stat_details to fetch.
     */
    where: Wisdom_stat_detailsWhereUniqueInput
  }

  /**
   * Wisdom_stat_details findUniqueOrThrow
   */
  export type Wisdom_stat_detailsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Wisdom_stat_details
     */
    select?: Wisdom_stat_detailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Wisdom_stat_details
     */
    omit?: Wisdom_stat_detailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Wisdom_stat_detailsInclude<ExtArgs> | null
    /**
     * Filter, which Wisdom_stat_details to fetch.
     */
    where: Wisdom_stat_detailsWhereUniqueInput
  }

  /**
   * Wisdom_stat_details findFirst
   */
  export type Wisdom_stat_detailsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Wisdom_stat_details
     */
    select?: Wisdom_stat_detailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Wisdom_stat_details
     */
    omit?: Wisdom_stat_detailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Wisdom_stat_detailsInclude<ExtArgs> | null
    /**
     * Filter, which Wisdom_stat_details to fetch.
     */
    where?: Wisdom_stat_detailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Wisdom_stat_details to fetch.
     */
    orderBy?: Wisdom_stat_detailsOrderByWithRelationInput | Wisdom_stat_detailsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Wisdom_stat_details.
     */
    cursor?: Wisdom_stat_detailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Wisdom_stat_details from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Wisdom_stat_details.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Wisdom_stat_details.
     */
    distinct?: Wisdom_stat_detailsScalarFieldEnum | Wisdom_stat_detailsScalarFieldEnum[]
  }

  /**
   * Wisdom_stat_details findFirstOrThrow
   */
  export type Wisdom_stat_detailsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Wisdom_stat_details
     */
    select?: Wisdom_stat_detailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Wisdom_stat_details
     */
    omit?: Wisdom_stat_detailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Wisdom_stat_detailsInclude<ExtArgs> | null
    /**
     * Filter, which Wisdom_stat_details to fetch.
     */
    where?: Wisdom_stat_detailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Wisdom_stat_details to fetch.
     */
    orderBy?: Wisdom_stat_detailsOrderByWithRelationInput | Wisdom_stat_detailsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Wisdom_stat_details.
     */
    cursor?: Wisdom_stat_detailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Wisdom_stat_details from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Wisdom_stat_details.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Wisdom_stat_details.
     */
    distinct?: Wisdom_stat_detailsScalarFieldEnum | Wisdom_stat_detailsScalarFieldEnum[]
  }

  /**
   * Wisdom_stat_details findMany
   */
  export type Wisdom_stat_detailsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Wisdom_stat_details
     */
    select?: Wisdom_stat_detailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Wisdom_stat_details
     */
    omit?: Wisdom_stat_detailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Wisdom_stat_detailsInclude<ExtArgs> | null
    /**
     * Filter, which Wisdom_stat_details to fetch.
     */
    where?: Wisdom_stat_detailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Wisdom_stat_details to fetch.
     */
    orderBy?: Wisdom_stat_detailsOrderByWithRelationInput | Wisdom_stat_detailsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Wisdom_stat_details.
     */
    cursor?: Wisdom_stat_detailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Wisdom_stat_details from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Wisdom_stat_details.
     */
    skip?: number
    distinct?: Wisdom_stat_detailsScalarFieldEnum | Wisdom_stat_detailsScalarFieldEnum[]
  }

  /**
   * Wisdom_stat_details create
   */
  export type Wisdom_stat_detailsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Wisdom_stat_details
     */
    select?: Wisdom_stat_detailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Wisdom_stat_details
     */
    omit?: Wisdom_stat_detailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Wisdom_stat_detailsInclude<ExtArgs> | null
    /**
     * The data needed to create a Wisdom_stat_details.
     */
    data: XOR<Wisdom_stat_detailsCreateInput, Wisdom_stat_detailsUncheckedCreateInput>
  }

  /**
   * Wisdom_stat_details createMany
   */
  export type Wisdom_stat_detailsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Wisdom_stat_details.
     */
    data: Wisdom_stat_detailsCreateManyInput | Wisdom_stat_detailsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Wisdom_stat_details createManyAndReturn
   */
  export type Wisdom_stat_detailsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Wisdom_stat_details
     */
    select?: Wisdom_stat_detailsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Wisdom_stat_details
     */
    omit?: Wisdom_stat_detailsOmit<ExtArgs> | null
    /**
     * The data used to create many Wisdom_stat_details.
     */
    data: Wisdom_stat_detailsCreateManyInput | Wisdom_stat_detailsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Wisdom_stat_detailsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Wisdom_stat_details update
   */
  export type Wisdom_stat_detailsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Wisdom_stat_details
     */
    select?: Wisdom_stat_detailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Wisdom_stat_details
     */
    omit?: Wisdom_stat_detailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Wisdom_stat_detailsInclude<ExtArgs> | null
    /**
     * The data needed to update a Wisdom_stat_details.
     */
    data: XOR<Wisdom_stat_detailsUpdateInput, Wisdom_stat_detailsUncheckedUpdateInput>
    /**
     * Choose, which Wisdom_stat_details to update.
     */
    where: Wisdom_stat_detailsWhereUniqueInput
  }

  /**
   * Wisdom_stat_details updateMany
   */
  export type Wisdom_stat_detailsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Wisdom_stat_details.
     */
    data: XOR<Wisdom_stat_detailsUpdateManyMutationInput, Wisdom_stat_detailsUncheckedUpdateManyInput>
    /**
     * Filter which Wisdom_stat_details to update
     */
    where?: Wisdom_stat_detailsWhereInput
    /**
     * Limit how many Wisdom_stat_details to update.
     */
    limit?: number
  }

  /**
   * Wisdom_stat_details updateManyAndReturn
   */
  export type Wisdom_stat_detailsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Wisdom_stat_details
     */
    select?: Wisdom_stat_detailsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Wisdom_stat_details
     */
    omit?: Wisdom_stat_detailsOmit<ExtArgs> | null
    /**
     * The data used to update Wisdom_stat_details.
     */
    data: XOR<Wisdom_stat_detailsUpdateManyMutationInput, Wisdom_stat_detailsUncheckedUpdateManyInput>
    /**
     * Filter which Wisdom_stat_details to update
     */
    where?: Wisdom_stat_detailsWhereInput
    /**
     * Limit how many Wisdom_stat_details to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Wisdom_stat_detailsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Wisdom_stat_details upsert
   */
  export type Wisdom_stat_detailsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Wisdom_stat_details
     */
    select?: Wisdom_stat_detailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Wisdom_stat_details
     */
    omit?: Wisdom_stat_detailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Wisdom_stat_detailsInclude<ExtArgs> | null
    /**
     * The filter to search for the Wisdom_stat_details to update in case it exists.
     */
    where: Wisdom_stat_detailsWhereUniqueInput
    /**
     * In case the Wisdom_stat_details found by the `where` argument doesn't exist, create a new Wisdom_stat_details with this data.
     */
    create: XOR<Wisdom_stat_detailsCreateInput, Wisdom_stat_detailsUncheckedCreateInput>
    /**
     * In case the Wisdom_stat_details was found with the provided `where` argument, update it with this data.
     */
    update: XOR<Wisdom_stat_detailsUpdateInput, Wisdom_stat_detailsUncheckedUpdateInput>
  }

  /**
   * Wisdom_stat_details delete
   */
  export type Wisdom_stat_detailsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Wisdom_stat_details
     */
    select?: Wisdom_stat_detailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Wisdom_stat_details
     */
    omit?: Wisdom_stat_detailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Wisdom_stat_detailsInclude<ExtArgs> | null
    /**
     * Filter which Wisdom_stat_details to delete.
     */
    where: Wisdom_stat_detailsWhereUniqueInput
  }

  /**
   * Wisdom_stat_details deleteMany
   */
  export type Wisdom_stat_detailsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Wisdom_stat_details to delete
     */
    where?: Wisdom_stat_detailsWhereInput
    /**
     * Limit how many Wisdom_stat_details to delete.
     */
    limit?: number
  }

  /**
   * Wisdom_stat_details without action
   */
  export type Wisdom_stat_detailsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Wisdom_stat_details
     */
    select?: Wisdom_stat_detailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Wisdom_stat_details
     */
    omit?: Wisdom_stat_detailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Wisdom_stat_detailsInclude<ExtArgs> | null
  }


  /**
   * Model Charisma_stat_details
   */

  export type AggregateCharisma_stat_details = {
    _count: Charisma_stat_detailsCountAggregateOutputType | null
    _avg: Charisma_stat_detailsAvgAggregateOutputType | null
    _sum: Charisma_stat_detailsSumAggregateOutputType | null
    _min: Charisma_stat_detailsMinAggregateOutputType | null
    _max: Charisma_stat_detailsMaxAggregateOutputType | null
  }

  export type Charisma_stat_detailsAvgAggregateOutputType = {
    value: number | null
  }

  export type Charisma_stat_detailsSumAggregateOutputType = {
    value: number | null
  }

  export type Charisma_stat_detailsMinAggregateOutputType = {
    statblock_id: string | null
    value: number | null
    mastery: boolean | null
  }

  export type Charisma_stat_detailsMaxAggregateOutputType = {
    statblock_id: string | null
    value: number | null
    mastery: boolean | null
  }

  export type Charisma_stat_detailsCountAggregateOutputType = {
    statblock_id: number
    value: number
    mastery: number
    _all: number
  }


  export type Charisma_stat_detailsAvgAggregateInputType = {
    value?: true
  }

  export type Charisma_stat_detailsSumAggregateInputType = {
    value?: true
  }

  export type Charisma_stat_detailsMinAggregateInputType = {
    statblock_id?: true
    value?: true
    mastery?: true
  }

  export type Charisma_stat_detailsMaxAggregateInputType = {
    statblock_id?: true
    value?: true
    mastery?: true
  }

  export type Charisma_stat_detailsCountAggregateInputType = {
    statblock_id?: true
    value?: true
    mastery?: true
    _all?: true
  }

  export type Charisma_stat_detailsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Charisma_stat_details to aggregate.
     */
    where?: Charisma_stat_detailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Charisma_stat_details to fetch.
     */
    orderBy?: Charisma_stat_detailsOrderByWithRelationInput | Charisma_stat_detailsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: Charisma_stat_detailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Charisma_stat_details from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Charisma_stat_details.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Charisma_stat_details
    **/
    _count?: true | Charisma_stat_detailsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Charisma_stat_detailsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Charisma_stat_detailsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Charisma_stat_detailsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Charisma_stat_detailsMaxAggregateInputType
  }

  export type GetCharisma_stat_detailsAggregateType<T extends Charisma_stat_detailsAggregateArgs> = {
        [P in keyof T & keyof AggregateCharisma_stat_details]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCharisma_stat_details[P]>
      : GetScalarType<T[P], AggregateCharisma_stat_details[P]>
  }




  export type Charisma_stat_detailsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: Charisma_stat_detailsWhereInput
    orderBy?: Charisma_stat_detailsOrderByWithAggregationInput | Charisma_stat_detailsOrderByWithAggregationInput[]
    by: Charisma_stat_detailsScalarFieldEnum[] | Charisma_stat_detailsScalarFieldEnum
    having?: Charisma_stat_detailsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Charisma_stat_detailsCountAggregateInputType | true
    _avg?: Charisma_stat_detailsAvgAggregateInputType
    _sum?: Charisma_stat_detailsSumAggregateInputType
    _min?: Charisma_stat_detailsMinAggregateInputType
    _max?: Charisma_stat_detailsMaxAggregateInputType
  }

  export type Charisma_stat_detailsGroupByOutputType = {
    statblock_id: string
    value: number
    mastery: boolean
    _count: Charisma_stat_detailsCountAggregateOutputType | null
    _avg: Charisma_stat_detailsAvgAggregateOutputType | null
    _sum: Charisma_stat_detailsSumAggregateOutputType | null
    _min: Charisma_stat_detailsMinAggregateOutputType | null
    _max: Charisma_stat_detailsMaxAggregateOutputType | null
  }

  type GetCharisma_stat_detailsGroupByPayload<T extends Charisma_stat_detailsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Charisma_stat_detailsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Charisma_stat_detailsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Charisma_stat_detailsGroupByOutputType[P]>
            : GetScalarType<T[P], Charisma_stat_detailsGroupByOutputType[P]>
        }
      >
    >


  export type Charisma_stat_detailsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    statblock_id?: boolean
    value?: boolean
    mastery?: boolean
    creature_stat?: boolean | Creature_statsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["charisma_stat_details"]>

  export type Charisma_stat_detailsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    statblock_id?: boolean
    value?: boolean
    mastery?: boolean
    creature_stat?: boolean | Creature_statsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["charisma_stat_details"]>

  export type Charisma_stat_detailsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    statblock_id?: boolean
    value?: boolean
    mastery?: boolean
    creature_stat?: boolean | Creature_statsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["charisma_stat_details"]>

  export type Charisma_stat_detailsSelectScalar = {
    statblock_id?: boolean
    value?: boolean
    mastery?: boolean
  }

  export type Charisma_stat_detailsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"statblock_id" | "value" | "mastery", ExtArgs["result"]["charisma_stat_details"]>
  export type Charisma_stat_detailsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creature_stat?: boolean | Creature_statsDefaultArgs<ExtArgs>
  }
  export type Charisma_stat_detailsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creature_stat?: boolean | Creature_statsDefaultArgs<ExtArgs>
  }
  export type Charisma_stat_detailsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creature_stat?: boolean | Creature_statsDefaultArgs<ExtArgs>
  }

  export type $Charisma_stat_detailsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Charisma_stat_details"
    objects: {
      creature_stat: Prisma.$Creature_statsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      statblock_id: string
      value: number
      mastery: boolean
    }, ExtArgs["result"]["charisma_stat_details"]>
    composites: {}
  }

  type Charisma_stat_detailsGetPayload<S extends boolean | null | undefined | Charisma_stat_detailsDefaultArgs> = $Result.GetResult<Prisma.$Charisma_stat_detailsPayload, S>

  type Charisma_stat_detailsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<Charisma_stat_detailsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Charisma_stat_detailsCountAggregateInputType | true
    }

  export interface Charisma_stat_detailsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Charisma_stat_details'], meta: { name: 'Charisma_stat_details' } }
    /**
     * Find zero or one Charisma_stat_details that matches the filter.
     * @param {Charisma_stat_detailsFindUniqueArgs} args - Arguments to find a Charisma_stat_details
     * @example
     * // Get one Charisma_stat_details
     * const charisma_stat_details = await prisma.charisma_stat_details.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends Charisma_stat_detailsFindUniqueArgs>(args: SelectSubset<T, Charisma_stat_detailsFindUniqueArgs<ExtArgs>>): Prisma__Charisma_stat_detailsClient<$Result.GetResult<Prisma.$Charisma_stat_detailsPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Charisma_stat_details that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {Charisma_stat_detailsFindUniqueOrThrowArgs} args - Arguments to find a Charisma_stat_details
     * @example
     * // Get one Charisma_stat_details
     * const charisma_stat_details = await prisma.charisma_stat_details.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends Charisma_stat_detailsFindUniqueOrThrowArgs>(args: SelectSubset<T, Charisma_stat_detailsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__Charisma_stat_detailsClient<$Result.GetResult<Prisma.$Charisma_stat_detailsPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Charisma_stat_details that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Charisma_stat_detailsFindFirstArgs} args - Arguments to find a Charisma_stat_details
     * @example
     * // Get one Charisma_stat_details
     * const charisma_stat_details = await prisma.charisma_stat_details.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends Charisma_stat_detailsFindFirstArgs>(args?: SelectSubset<T, Charisma_stat_detailsFindFirstArgs<ExtArgs>>): Prisma__Charisma_stat_detailsClient<$Result.GetResult<Prisma.$Charisma_stat_detailsPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Charisma_stat_details that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Charisma_stat_detailsFindFirstOrThrowArgs} args - Arguments to find a Charisma_stat_details
     * @example
     * // Get one Charisma_stat_details
     * const charisma_stat_details = await prisma.charisma_stat_details.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends Charisma_stat_detailsFindFirstOrThrowArgs>(args?: SelectSubset<T, Charisma_stat_detailsFindFirstOrThrowArgs<ExtArgs>>): Prisma__Charisma_stat_detailsClient<$Result.GetResult<Prisma.$Charisma_stat_detailsPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Charisma_stat_details that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Charisma_stat_detailsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Charisma_stat_details
     * const charisma_stat_details = await prisma.charisma_stat_details.findMany()
     * 
     * // Get first 10 Charisma_stat_details
     * const charisma_stat_details = await prisma.charisma_stat_details.findMany({ take: 10 })
     * 
     * // Only select the `statblock_id`
     * const charisma_stat_detailsWithStatblock_idOnly = await prisma.charisma_stat_details.findMany({ select: { statblock_id: true } })
     * 
     */
    findMany<T extends Charisma_stat_detailsFindManyArgs>(args?: SelectSubset<T, Charisma_stat_detailsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Charisma_stat_detailsPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Charisma_stat_details.
     * @param {Charisma_stat_detailsCreateArgs} args - Arguments to create a Charisma_stat_details.
     * @example
     * // Create one Charisma_stat_details
     * const Charisma_stat_details = await prisma.charisma_stat_details.create({
     *   data: {
     *     // ... data to create a Charisma_stat_details
     *   }
     * })
     * 
     */
    create<T extends Charisma_stat_detailsCreateArgs>(args: SelectSubset<T, Charisma_stat_detailsCreateArgs<ExtArgs>>): Prisma__Charisma_stat_detailsClient<$Result.GetResult<Prisma.$Charisma_stat_detailsPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Charisma_stat_details.
     * @param {Charisma_stat_detailsCreateManyArgs} args - Arguments to create many Charisma_stat_details.
     * @example
     * // Create many Charisma_stat_details
     * const charisma_stat_details = await prisma.charisma_stat_details.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends Charisma_stat_detailsCreateManyArgs>(args?: SelectSubset<T, Charisma_stat_detailsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Charisma_stat_details and returns the data saved in the database.
     * @param {Charisma_stat_detailsCreateManyAndReturnArgs} args - Arguments to create many Charisma_stat_details.
     * @example
     * // Create many Charisma_stat_details
     * const charisma_stat_details = await prisma.charisma_stat_details.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Charisma_stat_details and only return the `statblock_id`
     * const charisma_stat_detailsWithStatblock_idOnly = await prisma.charisma_stat_details.createManyAndReturn({
     *   select: { statblock_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends Charisma_stat_detailsCreateManyAndReturnArgs>(args?: SelectSubset<T, Charisma_stat_detailsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Charisma_stat_detailsPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Charisma_stat_details.
     * @param {Charisma_stat_detailsDeleteArgs} args - Arguments to delete one Charisma_stat_details.
     * @example
     * // Delete one Charisma_stat_details
     * const Charisma_stat_details = await prisma.charisma_stat_details.delete({
     *   where: {
     *     // ... filter to delete one Charisma_stat_details
     *   }
     * })
     * 
     */
    delete<T extends Charisma_stat_detailsDeleteArgs>(args: SelectSubset<T, Charisma_stat_detailsDeleteArgs<ExtArgs>>): Prisma__Charisma_stat_detailsClient<$Result.GetResult<Prisma.$Charisma_stat_detailsPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Charisma_stat_details.
     * @param {Charisma_stat_detailsUpdateArgs} args - Arguments to update one Charisma_stat_details.
     * @example
     * // Update one Charisma_stat_details
     * const charisma_stat_details = await prisma.charisma_stat_details.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends Charisma_stat_detailsUpdateArgs>(args: SelectSubset<T, Charisma_stat_detailsUpdateArgs<ExtArgs>>): Prisma__Charisma_stat_detailsClient<$Result.GetResult<Prisma.$Charisma_stat_detailsPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Charisma_stat_details.
     * @param {Charisma_stat_detailsDeleteManyArgs} args - Arguments to filter Charisma_stat_details to delete.
     * @example
     * // Delete a few Charisma_stat_details
     * const { count } = await prisma.charisma_stat_details.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends Charisma_stat_detailsDeleteManyArgs>(args?: SelectSubset<T, Charisma_stat_detailsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Charisma_stat_details.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Charisma_stat_detailsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Charisma_stat_details
     * const charisma_stat_details = await prisma.charisma_stat_details.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends Charisma_stat_detailsUpdateManyArgs>(args: SelectSubset<T, Charisma_stat_detailsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Charisma_stat_details and returns the data updated in the database.
     * @param {Charisma_stat_detailsUpdateManyAndReturnArgs} args - Arguments to update many Charisma_stat_details.
     * @example
     * // Update many Charisma_stat_details
     * const charisma_stat_details = await prisma.charisma_stat_details.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Charisma_stat_details and only return the `statblock_id`
     * const charisma_stat_detailsWithStatblock_idOnly = await prisma.charisma_stat_details.updateManyAndReturn({
     *   select: { statblock_id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends Charisma_stat_detailsUpdateManyAndReturnArgs>(args: SelectSubset<T, Charisma_stat_detailsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Charisma_stat_detailsPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Charisma_stat_details.
     * @param {Charisma_stat_detailsUpsertArgs} args - Arguments to update or create a Charisma_stat_details.
     * @example
     * // Update or create a Charisma_stat_details
     * const charisma_stat_details = await prisma.charisma_stat_details.upsert({
     *   create: {
     *     // ... data to create a Charisma_stat_details
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Charisma_stat_details we want to update
     *   }
     * })
     */
    upsert<T extends Charisma_stat_detailsUpsertArgs>(args: SelectSubset<T, Charisma_stat_detailsUpsertArgs<ExtArgs>>): Prisma__Charisma_stat_detailsClient<$Result.GetResult<Prisma.$Charisma_stat_detailsPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Charisma_stat_details.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Charisma_stat_detailsCountArgs} args - Arguments to filter Charisma_stat_details to count.
     * @example
     * // Count the number of Charisma_stat_details
     * const count = await prisma.charisma_stat_details.count({
     *   where: {
     *     // ... the filter for the Charisma_stat_details we want to count
     *   }
     * })
    **/
    count<T extends Charisma_stat_detailsCountArgs>(
      args?: Subset<T, Charisma_stat_detailsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Charisma_stat_detailsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Charisma_stat_details.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Charisma_stat_detailsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Charisma_stat_detailsAggregateArgs>(args: Subset<T, Charisma_stat_detailsAggregateArgs>): Prisma.PrismaPromise<GetCharisma_stat_detailsAggregateType<T>>

    /**
     * Group by Charisma_stat_details.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Charisma_stat_detailsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Charisma_stat_detailsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Charisma_stat_detailsGroupByArgs['orderBy'] }
        : { orderBy?: Charisma_stat_detailsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Charisma_stat_detailsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCharisma_stat_detailsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Charisma_stat_details model
   */
  readonly fields: Charisma_stat_detailsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Charisma_stat_details.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__Charisma_stat_detailsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    creature_stat<T extends Creature_statsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, Creature_statsDefaultArgs<ExtArgs>>): Prisma__Creature_statsClient<$Result.GetResult<Prisma.$Creature_statsPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Charisma_stat_details model
   */ 
  interface Charisma_stat_detailsFieldRefs {
    readonly statblock_id: FieldRef<"Charisma_stat_details", 'String'>
    readonly value: FieldRef<"Charisma_stat_details", 'Int'>
    readonly mastery: FieldRef<"Charisma_stat_details", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * Charisma_stat_details findUnique
   */
  export type Charisma_stat_detailsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Charisma_stat_details
     */
    select?: Charisma_stat_detailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Charisma_stat_details
     */
    omit?: Charisma_stat_detailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Charisma_stat_detailsInclude<ExtArgs> | null
    /**
     * Filter, which Charisma_stat_details to fetch.
     */
    where: Charisma_stat_detailsWhereUniqueInput
  }

  /**
   * Charisma_stat_details findUniqueOrThrow
   */
  export type Charisma_stat_detailsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Charisma_stat_details
     */
    select?: Charisma_stat_detailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Charisma_stat_details
     */
    omit?: Charisma_stat_detailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Charisma_stat_detailsInclude<ExtArgs> | null
    /**
     * Filter, which Charisma_stat_details to fetch.
     */
    where: Charisma_stat_detailsWhereUniqueInput
  }

  /**
   * Charisma_stat_details findFirst
   */
  export type Charisma_stat_detailsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Charisma_stat_details
     */
    select?: Charisma_stat_detailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Charisma_stat_details
     */
    omit?: Charisma_stat_detailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Charisma_stat_detailsInclude<ExtArgs> | null
    /**
     * Filter, which Charisma_stat_details to fetch.
     */
    where?: Charisma_stat_detailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Charisma_stat_details to fetch.
     */
    orderBy?: Charisma_stat_detailsOrderByWithRelationInput | Charisma_stat_detailsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Charisma_stat_details.
     */
    cursor?: Charisma_stat_detailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Charisma_stat_details from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Charisma_stat_details.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Charisma_stat_details.
     */
    distinct?: Charisma_stat_detailsScalarFieldEnum | Charisma_stat_detailsScalarFieldEnum[]
  }

  /**
   * Charisma_stat_details findFirstOrThrow
   */
  export type Charisma_stat_detailsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Charisma_stat_details
     */
    select?: Charisma_stat_detailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Charisma_stat_details
     */
    omit?: Charisma_stat_detailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Charisma_stat_detailsInclude<ExtArgs> | null
    /**
     * Filter, which Charisma_stat_details to fetch.
     */
    where?: Charisma_stat_detailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Charisma_stat_details to fetch.
     */
    orderBy?: Charisma_stat_detailsOrderByWithRelationInput | Charisma_stat_detailsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Charisma_stat_details.
     */
    cursor?: Charisma_stat_detailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Charisma_stat_details from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Charisma_stat_details.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Charisma_stat_details.
     */
    distinct?: Charisma_stat_detailsScalarFieldEnum | Charisma_stat_detailsScalarFieldEnum[]
  }

  /**
   * Charisma_stat_details findMany
   */
  export type Charisma_stat_detailsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Charisma_stat_details
     */
    select?: Charisma_stat_detailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Charisma_stat_details
     */
    omit?: Charisma_stat_detailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Charisma_stat_detailsInclude<ExtArgs> | null
    /**
     * Filter, which Charisma_stat_details to fetch.
     */
    where?: Charisma_stat_detailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Charisma_stat_details to fetch.
     */
    orderBy?: Charisma_stat_detailsOrderByWithRelationInput | Charisma_stat_detailsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Charisma_stat_details.
     */
    cursor?: Charisma_stat_detailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Charisma_stat_details from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Charisma_stat_details.
     */
    skip?: number
    distinct?: Charisma_stat_detailsScalarFieldEnum | Charisma_stat_detailsScalarFieldEnum[]
  }

  /**
   * Charisma_stat_details create
   */
  export type Charisma_stat_detailsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Charisma_stat_details
     */
    select?: Charisma_stat_detailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Charisma_stat_details
     */
    omit?: Charisma_stat_detailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Charisma_stat_detailsInclude<ExtArgs> | null
    /**
     * The data needed to create a Charisma_stat_details.
     */
    data: XOR<Charisma_stat_detailsCreateInput, Charisma_stat_detailsUncheckedCreateInput>
  }

  /**
   * Charisma_stat_details createMany
   */
  export type Charisma_stat_detailsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Charisma_stat_details.
     */
    data: Charisma_stat_detailsCreateManyInput | Charisma_stat_detailsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Charisma_stat_details createManyAndReturn
   */
  export type Charisma_stat_detailsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Charisma_stat_details
     */
    select?: Charisma_stat_detailsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Charisma_stat_details
     */
    omit?: Charisma_stat_detailsOmit<ExtArgs> | null
    /**
     * The data used to create many Charisma_stat_details.
     */
    data: Charisma_stat_detailsCreateManyInput | Charisma_stat_detailsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Charisma_stat_detailsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Charisma_stat_details update
   */
  export type Charisma_stat_detailsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Charisma_stat_details
     */
    select?: Charisma_stat_detailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Charisma_stat_details
     */
    omit?: Charisma_stat_detailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Charisma_stat_detailsInclude<ExtArgs> | null
    /**
     * The data needed to update a Charisma_stat_details.
     */
    data: XOR<Charisma_stat_detailsUpdateInput, Charisma_stat_detailsUncheckedUpdateInput>
    /**
     * Choose, which Charisma_stat_details to update.
     */
    where: Charisma_stat_detailsWhereUniqueInput
  }

  /**
   * Charisma_stat_details updateMany
   */
  export type Charisma_stat_detailsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Charisma_stat_details.
     */
    data: XOR<Charisma_stat_detailsUpdateManyMutationInput, Charisma_stat_detailsUncheckedUpdateManyInput>
    /**
     * Filter which Charisma_stat_details to update
     */
    where?: Charisma_stat_detailsWhereInput
    /**
     * Limit how many Charisma_stat_details to update.
     */
    limit?: number
  }

  /**
   * Charisma_stat_details updateManyAndReturn
   */
  export type Charisma_stat_detailsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Charisma_stat_details
     */
    select?: Charisma_stat_detailsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Charisma_stat_details
     */
    omit?: Charisma_stat_detailsOmit<ExtArgs> | null
    /**
     * The data used to update Charisma_stat_details.
     */
    data: XOR<Charisma_stat_detailsUpdateManyMutationInput, Charisma_stat_detailsUncheckedUpdateManyInput>
    /**
     * Filter which Charisma_stat_details to update
     */
    where?: Charisma_stat_detailsWhereInput
    /**
     * Limit how many Charisma_stat_details to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Charisma_stat_detailsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Charisma_stat_details upsert
   */
  export type Charisma_stat_detailsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Charisma_stat_details
     */
    select?: Charisma_stat_detailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Charisma_stat_details
     */
    omit?: Charisma_stat_detailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Charisma_stat_detailsInclude<ExtArgs> | null
    /**
     * The filter to search for the Charisma_stat_details to update in case it exists.
     */
    where: Charisma_stat_detailsWhereUniqueInput
    /**
     * In case the Charisma_stat_details found by the `where` argument doesn't exist, create a new Charisma_stat_details with this data.
     */
    create: XOR<Charisma_stat_detailsCreateInput, Charisma_stat_detailsUncheckedCreateInput>
    /**
     * In case the Charisma_stat_details was found with the provided `where` argument, update it with this data.
     */
    update: XOR<Charisma_stat_detailsUpdateInput, Charisma_stat_detailsUncheckedUpdateInput>
  }

  /**
   * Charisma_stat_details delete
   */
  export type Charisma_stat_detailsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Charisma_stat_details
     */
    select?: Charisma_stat_detailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Charisma_stat_details
     */
    omit?: Charisma_stat_detailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Charisma_stat_detailsInclude<ExtArgs> | null
    /**
     * Filter which Charisma_stat_details to delete.
     */
    where: Charisma_stat_detailsWhereUniqueInput
  }

  /**
   * Charisma_stat_details deleteMany
   */
  export type Charisma_stat_detailsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Charisma_stat_details to delete
     */
    where?: Charisma_stat_detailsWhereInput
    /**
     * Limit how many Charisma_stat_details to delete.
     */
    limit?: number
  }

  /**
   * Charisma_stat_details without action
   */
  export type Charisma_stat_detailsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Charisma_stat_details
     */
    select?: Charisma_stat_detailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Charisma_stat_details
     */
    omit?: Charisma_stat_detailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Charisma_stat_detailsInclude<ExtArgs> | null
  }


  /**
   * Model SkillsList
   */

  export type AggregateSkillsList = {
    _count: SkillsListCountAggregateOutputType | null
    _min: SkillsListMinAggregateOutputType | null
    _max: SkillsListMaxAggregateOutputType | null
  }

  export type SkillsListMinAggregateOutputType = {
    id: string | null
  }

  export type SkillsListMaxAggregateOutputType = {
    id: string | null
  }

  export type SkillsListCountAggregateOutputType = {
    id: number
    _all: number
  }


  export type SkillsListMinAggregateInputType = {
    id?: true
  }

  export type SkillsListMaxAggregateInputType = {
    id?: true
  }

  export type SkillsListCountAggregateInputType = {
    id?: true
    _all?: true
  }

  export type SkillsListAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SkillsList to aggregate.
     */
    where?: SkillsListWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SkillsLists to fetch.
     */
    orderBy?: SkillsListOrderByWithRelationInput | SkillsListOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SkillsListWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SkillsLists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SkillsLists.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SkillsLists
    **/
    _count?: true | SkillsListCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SkillsListMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SkillsListMaxAggregateInputType
  }

  export type GetSkillsListAggregateType<T extends SkillsListAggregateArgs> = {
        [P in keyof T & keyof AggregateSkillsList]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSkillsList[P]>
      : GetScalarType<T[P], AggregateSkillsList[P]>
  }




  export type SkillsListGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SkillsListWhereInput
    orderBy?: SkillsListOrderByWithAggregationInput | SkillsListOrderByWithAggregationInput[]
    by: SkillsListScalarFieldEnum[] | SkillsListScalarFieldEnum
    having?: SkillsListScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SkillsListCountAggregateInputType | true
    _min?: SkillsListMinAggregateInputType
    _max?: SkillsListMaxAggregateInputType
  }

  export type SkillsListGroupByOutputType = {
    id: string
    _count: SkillsListCountAggregateOutputType | null
    _min: SkillsListMinAggregateOutputType | null
    _max: SkillsListMaxAggregateOutputType | null
  }

  type GetSkillsListGroupByPayload<T extends SkillsListGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SkillsListGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SkillsListGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SkillsListGroupByOutputType[P]>
            : GetScalarType<T[P], SkillsListGroupByOutputType[P]>
        }
      >
    >


  export type SkillsListSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    strength?: boolean | SkillsList$strengthArgs<ExtArgs>
    dexterity?: boolean | SkillsList$dexterityArgs<ExtArgs>
    intelligence?: boolean | SkillsList$intelligenceArgs<ExtArgs>
    wisdom?: boolean | SkillsList$wisdomArgs<ExtArgs>
    charisma?: boolean | SkillsList$charismaArgs<ExtArgs>
    id_relation?: boolean | CreatureDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["skillsList"]>

  export type SkillsListSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    id_relation?: boolean | CreatureDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["skillsList"]>

  export type SkillsListSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    id_relation?: boolean | CreatureDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["skillsList"]>

  export type SkillsListSelectScalar = {
    id?: boolean
  }

  export type SkillsListOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id", ExtArgs["result"]["skillsList"]>
  export type SkillsListInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    strength?: boolean | SkillsList$strengthArgs<ExtArgs>
    dexterity?: boolean | SkillsList$dexterityArgs<ExtArgs>
    intelligence?: boolean | SkillsList$intelligenceArgs<ExtArgs>
    wisdom?: boolean | SkillsList$wisdomArgs<ExtArgs>
    charisma?: boolean | SkillsList$charismaArgs<ExtArgs>
    id_relation?: boolean | CreatureDefaultArgs<ExtArgs>
  }
  export type SkillsListIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    id_relation?: boolean | CreatureDefaultArgs<ExtArgs>
  }
  export type SkillsListIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    id_relation?: boolean | CreatureDefaultArgs<ExtArgs>
  }

  export type $SkillsListPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SkillsList"
    objects: {
      strength: Prisma.$StrengthBasedSkillsPayload<ExtArgs> | null
      dexterity: Prisma.$DexterityBasedSkillsPayload<ExtArgs> | null
      intelligence: Prisma.$IntellengenceBasedSkillsPayload<ExtArgs> | null
      wisdom: Prisma.$WisdomBasedSkillsPayload<ExtArgs> | null
      charisma: Prisma.$CharismaBasedSkillsPayload<ExtArgs> | null
      id_relation: Prisma.$CreaturePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
    }, ExtArgs["result"]["skillsList"]>
    composites: {}
  }

  type SkillsListGetPayload<S extends boolean | null | undefined | SkillsListDefaultArgs> = $Result.GetResult<Prisma.$SkillsListPayload, S>

  type SkillsListCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SkillsListFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SkillsListCountAggregateInputType | true
    }

  export interface SkillsListDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SkillsList'], meta: { name: 'SkillsList' } }
    /**
     * Find zero or one SkillsList that matches the filter.
     * @param {SkillsListFindUniqueArgs} args - Arguments to find a SkillsList
     * @example
     * // Get one SkillsList
     * const skillsList = await prisma.skillsList.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SkillsListFindUniqueArgs>(args: SelectSubset<T, SkillsListFindUniqueArgs<ExtArgs>>): Prisma__SkillsListClient<$Result.GetResult<Prisma.$SkillsListPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one SkillsList that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SkillsListFindUniqueOrThrowArgs} args - Arguments to find a SkillsList
     * @example
     * // Get one SkillsList
     * const skillsList = await prisma.skillsList.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SkillsListFindUniqueOrThrowArgs>(args: SelectSubset<T, SkillsListFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SkillsListClient<$Result.GetResult<Prisma.$SkillsListPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first SkillsList that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SkillsListFindFirstArgs} args - Arguments to find a SkillsList
     * @example
     * // Get one SkillsList
     * const skillsList = await prisma.skillsList.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SkillsListFindFirstArgs>(args?: SelectSubset<T, SkillsListFindFirstArgs<ExtArgs>>): Prisma__SkillsListClient<$Result.GetResult<Prisma.$SkillsListPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first SkillsList that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SkillsListFindFirstOrThrowArgs} args - Arguments to find a SkillsList
     * @example
     * // Get one SkillsList
     * const skillsList = await prisma.skillsList.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SkillsListFindFirstOrThrowArgs>(args?: SelectSubset<T, SkillsListFindFirstOrThrowArgs<ExtArgs>>): Prisma__SkillsListClient<$Result.GetResult<Prisma.$SkillsListPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more SkillsLists that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SkillsListFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SkillsLists
     * const skillsLists = await prisma.skillsList.findMany()
     * 
     * // Get first 10 SkillsLists
     * const skillsLists = await prisma.skillsList.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const skillsListWithIdOnly = await prisma.skillsList.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SkillsListFindManyArgs>(args?: SelectSubset<T, SkillsListFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SkillsListPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a SkillsList.
     * @param {SkillsListCreateArgs} args - Arguments to create a SkillsList.
     * @example
     * // Create one SkillsList
     * const SkillsList = await prisma.skillsList.create({
     *   data: {
     *     // ... data to create a SkillsList
     *   }
     * })
     * 
     */
    create<T extends SkillsListCreateArgs>(args: SelectSubset<T, SkillsListCreateArgs<ExtArgs>>): Prisma__SkillsListClient<$Result.GetResult<Prisma.$SkillsListPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many SkillsLists.
     * @param {SkillsListCreateManyArgs} args - Arguments to create many SkillsLists.
     * @example
     * // Create many SkillsLists
     * const skillsList = await prisma.skillsList.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SkillsListCreateManyArgs>(args?: SelectSubset<T, SkillsListCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SkillsLists and returns the data saved in the database.
     * @param {SkillsListCreateManyAndReturnArgs} args - Arguments to create many SkillsLists.
     * @example
     * // Create many SkillsLists
     * const skillsList = await prisma.skillsList.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SkillsLists and only return the `id`
     * const skillsListWithIdOnly = await prisma.skillsList.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SkillsListCreateManyAndReturnArgs>(args?: SelectSubset<T, SkillsListCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SkillsListPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a SkillsList.
     * @param {SkillsListDeleteArgs} args - Arguments to delete one SkillsList.
     * @example
     * // Delete one SkillsList
     * const SkillsList = await prisma.skillsList.delete({
     *   where: {
     *     // ... filter to delete one SkillsList
     *   }
     * })
     * 
     */
    delete<T extends SkillsListDeleteArgs>(args: SelectSubset<T, SkillsListDeleteArgs<ExtArgs>>): Prisma__SkillsListClient<$Result.GetResult<Prisma.$SkillsListPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one SkillsList.
     * @param {SkillsListUpdateArgs} args - Arguments to update one SkillsList.
     * @example
     * // Update one SkillsList
     * const skillsList = await prisma.skillsList.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SkillsListUpdateArgs>(args: SelectSubset<T, SkillsListUpdateArgs<ExtArgs>>): Prisma__SkillsListClient<$Result.GetResult<Prisma.$SkillsListPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more SkillsLists.
     * @param {SkillsListDeleteManyArgs} args - Arguments to filter SkillsLists to delete.
     * @example
     * // Delete a few SkillsLists
     * const { count } = await prisma.skillsList.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SkillsListDeleteManyArgs>(args?: SelectSubset<T, SkillsListDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SkillsLists.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SkillsListUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SkillsLists
     * const skillsList = await prisma.skillsList.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SkillsListUpdateManyArgs>(args: SelectSubset<T, SkillsListUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SkillsLists and returns the data updated in the database.
     * @param {SkillsListUpdateManyAndReturnArgs} args - Arguments to update many SkillsLists.
     * @example
     * // Update many SkillsLists
     * const skillsList = await prisma.skillsList.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SkillsLists and only return the `id`
     * const skillsListWithIdOnly = await prisma.skillsList.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SkillsListUpdateManyAndReturnArgs>(args: SelectSubset<T, SkillsListUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SkillsListPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one SkillsList.
     * @param {SkillsListUpsertArgs} args - Arguments to update or create a SkillsList.
     * @example
     * // Update or create a SkillsList
     * const skillsList = await prisma.skillsList.upsert({
     *   create: {
     *     // ... data to create a SkillsList
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SkillsList we want to update
     *   }
     * })
     */
    upsert<T extends SkillsListUpsertArgs>(args: SelectSubset<T, SkillsListUpsertArgs<ExtArgs>>): Prisma__SkillsListClient<$Result.GetResult<Prisma.$SkillsListPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of SkillsLists.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SkillsListCountArgs} args - Arguments to filter SkillsLists to count.
     * @example
     * // Count the number of SkillsLists
     * const count = await prisma.skillsList.count({
     *   where: {
     *     // ... the filter for the SkillsLists we want to count
     *   }
     * })
    **/
    count<T extends SkillsListCountArgs>(
      args?: Subset<T, SkillsListCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SkillsListCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SkillsList.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SkillsListAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SkillsListAggregateArgs>(args: Subset<T, SkillsListAggregateArgs>): Prisma.PrismaPromise<GetSkillsListAggregateType<T>>

    /**
     * Group by SkillsList.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SkillsListGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SkillsListGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SkillsListGroupByArgs['orderBy'] }
        : { orderBy?: SkillsListGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SkillsListGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSkillsListGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SkillsList model
   */
  readonly fields: SkillsListFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SkillsList.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SkillsListClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    strength<T extends SkillsList$strengthArgs<ExtArgs> = {}>(args?: Subset<T, SkillsList$strengthArgs<ExtArgs>>): Prisma__StrengthBasedSkillsClient<$Result.GetResult<Prisma.$StrengthBasedSkillsPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | null, null, ExtArgs, ClientOptions>
    dexterity<T extends SkillsList$dexterityArgs<ExtArgs> = {}>(args?: Subset<T, SkillsList$dexterityArgs<ExtArgs>>): Prisma__DexterityBasedSkillsClient<$Result.GetResult<Prisma.$DexterityBasedSkillsPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | null, null, ExtArgs, ClientOptions>
    intelligence<T extends SkillsList$intelligenceArgs<ExtArgs> = {}>(args?: Subset<T, SkillsList$intelligenceArgs<ExtArgs>>): Prisma__IntellengenceBasedSkillsClient<$Result.GetResult<Prisma.$IntellengenceBasedSkillsPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | null, null, ExtArgs, ClientOptions>
    wisdom<T extends SkillsList$wisdomArgs<ExtArgs> = {}>(args?: Subset<T, SkillsList$wisdomArgs<ExtArgs>>): Prisma__WisdomBasedSkillsClient<$Result.GetResult<Prisma.$WisdomBasedSkillsPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | null, null, ExtArgs, ClientOptions>
    charisma<T extends SkillsList$charismaArgs<ExtArgs> = {}>(args?: Subset<T, SkillsList$charismaArgs<ExtArgs>>): Prisma__CharismaBasedSkillsClient<$Result.GetResult<Prisma.$CharismaBasedSkillsPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | null, null, ExtArgs, ClientOptions>
    id_relation<T extends CreatureDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CreatureDefaultArgs<ExtArgs>>): Prisma__CreatureClient<$Result.GetResult<Prisma.$CreaturePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SkillsList model
   */ 
  interface SkillsListFieldRefs {
    readonly id: FieldRef<"SkillsList", 'String'>
  }
    

  // Custom InputTypes
  /**
   * SkillsList findUnique
   */
  export type SkillsListFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SkillsList
     */
    select?: SkillsListSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SkillsList
     */
    omit?: SkillsListOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkillsListInclude<ExtArgs> | null
    /**
     * Filter, which SkillsList to fetch.
     */
    where: SkillsListWhereUniqueInput
  }

  /**
   * SkillsList findUniqueOrThrow
   */
  export type SkillsListFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SkillsList
     */
    select?: SkillsListSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SkillsList
     */
    omit?: SkillsListOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkillsListInclude<ExtArgs> | null
    /**
     * Filter, which SkillsList to fetch.
     */
    where: SkillsListWhereUniqueInput
  }

  /**
   * SkillsList findFirst
   */
  export type SkillsListFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SkillsList
     */
    select?: SkillsListSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SkillsList
     */
    omit?: SkillsListOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkillsListInclude<ExtArgs> | null
    /**
     * Filter, which SkillsList to fetch.
     */
    where?: SkillsListWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SkillsLists to fetch.
     */
    orderBy?: SkillsListOrderByWithRelationInput | SkillsListOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SkillsLists.
     */
    cursor?: SkillsListWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SkillsLists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SkillsLists.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SkillsLists.
     */
    distinct?: SkillsListScalarFieldEnum | SkillsListScalarFieldEnum[]
  }

  /**
   * SkillsList findFirstOrThrow
   */
  export type SkillsListFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SkillsList
     */
    select?: SkillsListSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SkillsList
     */
    omit?: SkillsListOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkillsListInclude<ExtArgs> | null
    /**
     * Filter, which SkillsList to fetch.
     */
    where?: SkillsListWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SkillsLists to fetch.
     */
    orderBy?: SkillsListOrderByWithRelationInput | SkillsListOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SkillsLists.
     */
    cursor?: SkillsListWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SkillsLists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SkillsLists.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SkillsLists.
     */
    distinct?: SkillsListScalarFieldEnum | SkillsListScalarFieldEnum[]
  }

  /**
   * SkillsList findMany
   */
  export type SkillsListFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SkillsList
     */
    select?: SkillsListSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SkillsList
     */
    omit?: SkillsListOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkillsListInclude<ExtArgs> | null
    /**
     * Filter, which SkillsLists to fetch.
     */
    where?: SkillsListWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SkillsLists to fetch.
     */
    orderBy?: SkillsListOrderByWithRelationInput | SkillsListOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SkillsLists.
     */
    cursor?: SkillsListWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SkillsLists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SkillsLists.
     */
    skip?: number
    distinct?: SkillsListScalarFieldEnum | SkillsListScalarFieldEnum[]
  }

  /**
   * SkillsList create
   */
  export type SkillsListCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SkillsList
     */
    select?: SkillsListSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SkillsList
     */
    omit?: SkillsListOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkillsListInclude<ExtArgs> | null
    /**
     * The data needed to create a SkillsList.
     */
    data: XOR<SkillsListCreateInput, SkillsListUncheckedCreateInput>
  }

  /**
   * SkillsList createMany
   */
  export type SkillsListCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SkillsLists.
     */
    data: SkillsListCreateManyInput | SkillsListCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SkillsList createManyAndReturn
   */
  export type SkillsListCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SkillsList
     */
    select?: SkillsListSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SkillsList
     */
    omit?: SkillsListOmit<ExtArgs> | null
    /**
     * The data used to create many SkillsLists.
     */
    data: SkillsListCreateManyInput | SkillsListCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkillsListIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SkillsList update
   */
  export type SkillsListUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SkillsList
     */
    select?: SkillsListSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SkillsList
     */
    omit?: SkillsListOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkillsListInclude<ExtArgs> | null
    /**
     * The data needed to update a SkillsList.
     */
    data: XOR<SkillsListUpdateInput, SkillsListUncheckedUpdateInput>
    /**
     * Choose, which SkillsList to update.
     */
    where: SkillsListWhereUniqueInput
  }

  /**
   * SkillsList updateMany
   */
  export type SkillsListUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SkillsLists.
     */
    data: XOR<SkillsListUpdateManyMutationInput, SkillsListUncheckedUpdateManyInput>
    /**
     * Filter which SkillsLists to update
     */
    where?: SkillsListWhereInput
    /**
     * Limit how many SkillsLists to update.
     */
    limit?: number
  }

  /**
   * SkillsList updateManyAndReturn
   */
  export type SkillsListUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SkillsList
     */
    select?: SkillsListSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SkillsList
     */
    omit?: SkillsListOmit<ExtArgs> | null
    /**
     * The data used to update SkillsLists.
     */
    data: XOR<SkillsListUpdateManyMutationInput, SkillsListUncheckedUpdateManyInput>
    /**
     * Filter which SkillsLists to update
     */
    where?: SkillsListWhereInput
    /**
     * Limit how many SkillsLists to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkillsListIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * SkillsList upsert
   */
  export type SkillsListUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SkillsList
     */
    select?: SkillsListSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SkillsList
     */
    omit?: SkillsListOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkillsListInclude<ExtArgs> | null
    /**
     * The filter to search for the SkillsList to update in case it exists.
     */
    where: SkillsListWhereUniqueInput
    /**
     * In case the SkillsList found by the `where` argument doesn't exist, create a new SkillsList with this data.
     */
    create: XOR<SkillsListCreateInput, SkillsListUncheckedCreateInput>
    /**
     * In case the SkillsList was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SkillsListUpdateInput, SkillsListUncheckedUpdateInput>
  }

  /**
   * SkillsList delete
   */
  export type SkillsListDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SkillsList
     */
    select?: SkillsListSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SkillsList
     */
    omit?: SkillsListOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkillsListInclude<ExtArgs> | null
    /**
     * Filter which SkillsList to delete.
     */
    where: SkillsListWhereUniqueInput
  }

  /**
   * SkillsList deleteMany
   */
  export type SkillsListDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SkillsLists to delete
     */
    where?: SkillsListWhereInput
    /**
     * Limit how many SkillsLists to delete.
     */
    limit?: number
  }

  /**
   * SkillsList.strength
   */
  export type SkillsList$strengthArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StrengthBasedSkills
     */
    select?: StrengthBasedSkillsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StrengthBasedSkills
     */
    omit?: StrengthBasedSkillsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StrengthBasedSkillsInclude<ExtArgs> | null
    where?: StrengthBasedSkillsWhereInput
  }

  /**
   * SkillsList.dexterity
   */
  export type SkillsList$dexterityArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DexterityBasedSkills
     */
    select?: DexterityBasedSkillsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DexterityBasedSkills
     */
    omit?: DexterityBasedSkillsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DexterityBasedSkillsInclude<ExtArgs> | null
    where?: DexterityBasedSkillsWhereInput
  }

  /**
   * SkillsList.intelligence
   */
  export type SkillsList$intelligenceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IntellengenceBasedSkills
     */
    select?: IntellengenceBasedSkillsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IntellengenceBasedSkills
     */
    omit?: IntellengenceBasedSkillsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IntellengenceBasedSkillsInclude<ExtArgs> | null
    where?: IntellengenceBasedSkillsWhereInput
  }

  /**
   * SkillsList.wisdom
   */
  export type SkillsList$wisdomArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WisdomBasedSkills
     */
    select?: WisdomBasedSkillsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WisdomBasedSkills
     */
    omit?: WisdomBasedSkillsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WisdomBasedSkillsInclude<ExtArgs> | null
    where?: WisdomBasedSkillsWhereInput
  }

  /**
   * SkillsList.charisma
   */
  export type SkillsList$charismaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CharismaBasedSkills
     */
    select?: CharismaBasedSkillsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CharismaBasedSkills
     */
    omit?: CharismaBasedSkillsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CharismaBasedSkillsInclude<ExtArgs> | null
    where?: CharismaBasedSkillsWhereInput
  }

  /**
   * SkillsList without action
   */
  export type SkillsListDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SkillsList
     */
    select?: SkillsListSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SkillsList
     */
    omit?: SkillsListOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkillsListInclude<ExtArgs> | null
  }


  /**
   * Model StrengthBasedSkills
   */

  export type AggregateStrengthBasedSkills = {
    _count: StrengthBasedSkillsCountAggregateOutputType | null
    _min: StrengthBasedSkillsMinAggregateOutputType | null
    _max: StrengthBasedSkillsMaxAggregateOutputType | null
  }

  export type StrengthBasedSkillsMinAggregateOutputType = {
    id: string | null
  }

  export type StrengthBasedSkillsMaxAggregateOutputType = {
    id: string | null
  }

  export type StrengthBasedSkillsCountAggregateOutputType = {
    id: number
    _all: number
  }


  export type StrengthBasedSkillsMinAggregateInputType = {
    id?: true
  }

  export type StrengthBasedSkillsMaxAggregateInputType = {
    id?: true
  }

  export type StrengthBasedSkillsCountAggregateInputType = {
    id?: true
    _all?: true
  }

  export type StrengthBasedSkillsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StrengthBasedSkills to aggregate.
     */
    where?: StrengthBasedSkillsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StrengthBasedSkills to fetch.
     */
    orderBy?: StrengthBasedSkillsOrderByWithRelationInput | StrengthBasedSkillsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StrengthBasedSkillsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StrengthBasedSkills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StrengthBasedSkills.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned StrengthBasedSkills
    **/
    _count?: true | StrengthBasedSkillsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StrengthBasedSkillsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StrengthBasedSkillsMaxAggregateInputType
  }

  export type GetStrengthBasedSkillsAggregateType<T extends StrengthBasedSkillsAggregateArgs> = {
        [P in keyof T & keyof AggregateStrengthBasedSkills]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStrengthBasedSkills[P]>
      : GetScalarType<T[P], AggregateStrengthBasedSkills[P]>
  }




  export type StrengthBasedSkillsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StrengthBasedSkillsWhereInput
    orderBy?: StrengthBasedSkillsOrderByWithAggregationInput | StrengthBasedSkillsOrderByWithAggregationInput[]
    by: StrengthBasedSkillsScalarFieldEnum[] | StrengthBasedSkillsScalarFieldEnum
    having?: StrengthBasedSkillsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StrengthBasedSkillsCountAggregateInputType | true
    _min?: StrengthBasedSkillsMinAggregateInputType
    _max?: StrengthBasedSkillsMaxAggregateInputType
  }

  export type StrengthBasedSkillsGroupByOutputType = {
    id: string
    _count: StrengthBasedSkillsCountAggregateOutputType | null
    _min: StrengthBasedSkillsMinAggregateOutputType | null
    _max: StrengthBasedSkillsMaxAggregateOutputType | null
  }

  type GetStrengthBasedSkillsGroupByPayload<T extends StrengthBasedSkillsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StrengthBasedSkillsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StrengthBasedSkillsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StrengthBasedSkillsGroupByOutputType[P]>
            : GetScalarType<T[P], StrengthBasedSkillsGroupByOutputType[P]>
        }
      >
    >


  export type StrengthBasedSkillsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    athletics?: boolean | StrengthBasedSkills$athleticsArgs<ExtArgs>
    skills_list_relation?: boolean | SkillsListDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["strengthBasedSkills"]>

  export type StrengthBasedSkillsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    skills_list_relation?: boolean | SkillsListDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["strengthBasedSkills"]>

  export type StrengthBasedSkillsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    skills_list_relation?: boolean | SkillsListDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["strengthBasedSkills"]>

  export type StrengthBasedSkillsSelectScalar = {
    id?: boolean
  }

  export type StrengthBasedSkillsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id", ExtArgs["result"]["strengthBasedSkills"]>
  export type StrengthBasedSkillsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    athletics?: boolean | StrengthBasedSkills$athleticsArgs<ExtArgs>
    skills_list_relation?: boolean | SkillsListDefaultArgs<ExtArgs>
  }
  export type StrengthBasedSkillsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    skills_list_relation?: boolean | SkillsListDefaultArgs<ExtArgs>
  }
  export type StrengthBasedSkillsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    skills_list_relation?: boolean | SkillsListDefaultArgs<ExtArgs>
  }

  export type $StrengthBasedSkillsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "StrengthBasedSkills"
    objects: {
      athletics: Prisma.$AthleticsSkillPayload<ExtArgs> | null
      skills_list_relation: Prisma.$SkillsListPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
    }, ExtArgs["result"]["strengthBasedSkills"]>
    composites: {}
  }

  type StrengthBasedSkillsGetPayload<S extends boolean | null | undefined | StrengthBasedSkillsDefaultArgs> = $Result.GetResult<Prisma.$StrengthBasedSkillsPayload, S>

  type StrengthBasedSkillsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<StrengthBasedSkillsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: StrengthBasedSkillsCountAggregateInputType | true
    }

  export interface StrengthBasedSkillsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['StrengthBasedSkills'], meta: { name: 'StrengthBasedSkills' } }
    /**
     * Find zero or one StrengthBasedSkills that matches the filter.
     * @param {StrengthBasedSkillsFindUniqueArgs} args - Arguments to find a StrengthBasedSkills
     * @example
     * // Get one StrengthBasedSkills
     * const strengthBasedSkills = await prisma.strengthBasedSkills.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends StrengthBasedSkillsFindUniqueArgs>(args: SelectSubset<T, StrengthBasedSkillsFindUniqueArgs<ExtArgs>>): Prisma__StrengthBasedSkillsClient<$Result.GetResult<Prisma.$StrengthBasedSkillsPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one StrengthBasedSkills that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {StrengthBasedSkillsFindUniqueOrThrowArgs} args - Arguments to find a StrengthBasedSkills
     * @example
     * // Get one StrengthBasedSkills
     * const strengthBasedSkills = await prisma.strengthBasedSkills.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends StrengthBasedSkillsFindUniqueOrThrowArgs>(args: SelectSubset<T, StrengthBasedSkillsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__StrengthBasedSkillsClient<$Result.GetResult<Prisma.$StrengthBasedSkillsPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first StrengthBasedSkills that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StrengthBasedSkillsFindFirstArgs} args - Arguments to find a StrengthBasedSkills
     * @example
     * // Get one StrengthBasedSkills
     * const strengthBasedSkills = await prisma.strengthBasedSkills.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends StrengthBasedSkillsFindFirstArgs>(args?: SelectSubset<T, StrengthBasedSkillsFindFirstArgs<ExtArgs>>): Prisma__StrengthBasedSkillsClient<$Result.GetResult<Prisma.$StrengthBasedSkillsPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first StrengthBasedSkills that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StrengthBasedSkillsFindFirstOrThrowArgs} args - Arguments to find a StrengthBasedSkills
     * @example
     * // Get one StrengthBasedSkills
     * const strengthBasedSkills = await prisma.strengthBasedSkills.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends StrengthBasedSkillsFindFirstOrThrowArgs>(args?: SelectSubset<T, StrengthBasedSkillsFindFirstOrThrowArgs<ExtArgs>>): Prisma__StrengthBasedSkillsClient<$Result.GetResult<Prisma.$StrengthBasedSkillsPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more StrengthBasedSkills that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StrengthBasedSkillsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all StrengthBasedSkills
     * const strengthBasedSkills = await prisma.strengthBasedSkills.findMany()
     * 
     * // Get first 10 StrengthBasedSkills
     * const strengthBasedSkills = await prisma.strengthBasedSkills.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const strengthBasedSkillsWithIdOnly = await prisma.strengthBasedSkills.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends StrengthBasedSkillsFindManyArgs>(args?: SelectSubset<T, StrengthBasedSkillsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StrengthBasedSkillsPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a StrengthBasedSkills.
     * @param {StrengthBasedSkillsCreateArgs} args - Arguments to create a StrengthBasedSkills.
     * @example
     * // Create one StrengthBasedSkills
     * const StrengthBasedSkills = await prisma.strengthBasedSkills.create({
     *   data: {
     *     // ... data to create a StrengthBasedSkills
     *   }
     * })
     * 
     */
    create<T extends StrengthBasedSkillsCreateArgs>(args: SelectSubset<T, StrengthBasedSkillsCreateArgs<ExtArgs>>): Prisma__StrengthBasedSkillsClient<$Result.GetResult<Prisma.$StrengthBasedSkillsPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many StrengthBasedSkills.
     * @param {StrengthBasedSkillsCreateManyArgs} args - Arguments to create many StrengthBasedSkills.
     * @example
     * // Create many StrengthBasedSkills
     * const strengthBasedSkills = await prisma.strengthBasedSkills.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends StrengthBasedSkillsCreateManyArgs>(args?: SelectSubset<T, StrengthBasedSkillsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many StrengthBasedSkills and returns the data saved in the database.
     * @param {StrengthBasedSkillsCreateManyAndReturnArgs} args - Arguments to create many StrengthBasedSkills.
     * @example
     * // Create many StrengthBasedSkills
     * const strengthBasedSkills = await prisma.strengthBasedSkills.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many StrengthBasedSkills and only return the `id`
     * const strengthBasedSkillsWithIdOnly = await prisma.strengthBasedSkills.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends StrengthBasedSkillsCreateManyAndReturnArgs>(args?: SelectSubset<T, StrengthBasedSkillsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StrengthBasedSkillsPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a StrengthBasedSkills.
     * @param {StrengthBasedSkillsDeleteArgs} args - Arguments to delete one StrengthBasedSkills.
     * @example
     * // Delete one StrengthBasedSkills
     * const StrengthBasedSkills = await prisma.strengthBasedSkills.delete({
     *   where: {
     *     // ... filter to delete one StrengthBasedSkills
     *   }
     * })
     * 
     */
    delete<T extends StrengthBasedSkillsDeleteArgs>(args: SelectSubset<T, StrengthBasedSkillsDeleteArgs<ExtArgs>>): Prisma__StrengthBasedSkillsClient<$Result.GetResult<Prisma.$StrengthBasedSkillsPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one StrengthBasedSkills.
     * @param {StrengthBasedSkillsUpdateArgs} args - Arguments to update one StrengthBasedSkills.
     * @example
     * // Update one StrengthBasedSkills
     * const strengthBasedSkills = await prisma.strengthBasedSkills.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends StrengthBasedSkillsUpdateArgs>(args: SelectSubset<T, StrengthBasedSkillsUpdateArgs<ExtArgs>>): Prisma__StrengthBasedSkillsClient<$Result.GetResult<Prisma.$StrengthBasedSkillsPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more StrengthBasedSkills.
     * @param {StrengthBasedSkillsDeleteManyArgs} args - Arguments to filter StrengthBasedSkills to delete.
     * @example
     * // Delete a few StrengthBasedSkills
     * const { count } = await prisma.strengthBasedSkills.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends StrengthBasedSkillsDeleteManyArgs>(args?: SelectSubset<T, StrengthBasedSkillsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StrengthBasedSkills.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StrengthBasedSkillsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many StrengthBasedSkills
     * const strengthBasedSkills = await prisma.strengthBasedSkills.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends StrengthBasedSkillsUpdateManyArgs>(args: SelectSubset<T, StrengthBasedSkillsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StrengthBasedSkills and returns the data updated in the database.
     * @param {StrengthBasedSkillsUpdateManyAndReturnArgs} args - Arguments to update many StrengthBasedSkills.
     * @example
     * // Update many StrengthBasedSkills
     * const strengthBasedSkills = await prisma.strengthBasedSkills.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more StrengthBasedSkills and only return the `id`
     * const strengthBasedSkillsWithIdOnly = await prisma.strengthBasedSkills.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends StrengthBasedSkillsUpdateManyAndReturnArgs>(args: SelectSubset<T, StrengthBasedSkillsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StrengthBasedSkillsPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one StrengthBasedSkills.
     * @param {StrengthBasedSkillsUpsertArgs} args - Arguments to update or create a StrengthBasedSkills.
     * @example
     * // Update or create a StrengthBasedSkills
     * const strengthBasedSkills = await prisma.strengthBasedSkills.upsert({
     *   create: {
     *     // ... data to create a StrengthBasedSkills
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the StrengthBasedSkills we want to update
     *   }
     * })
     */
    upsert<T extends StrengthBasedSkillsUpsertArgs>(args: SelectSubset<T, StrengthBasedSkillsUpsertArgs<ExtArgs>>): Prisma__StrengthBasedSkillsClient<$Result.GetResult<Prisma.$StrengthBasedSkillsPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of StrengthBasedSkills.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StrengthBasedSkillsCountArgs} args - Arguments to filter StrengthBasedSkills to count.
     * @example
     * // Count the number of StrengthBasedSkills
     * const count = await prisma.strengthBasedSkills.count({
     *   where: {
     *     // ... the filter for the StrengthBasedSkills we want to count
     *   }
     * })
    **/
    count<T extends StrengthBasedSkillsCountArgs>(
      args?: Subset<T, StrengthBasedSkillsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StrengthBasedSkillsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a StrengthBasedSkills.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StrengthBasedSkillsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StrengthBasedSkillsAggregateArgs>(args: Subset<T, StrengthBasedSkillsAggregateArgs>): Prisma.PrismaPromise<GetStrengthBasedSkillsAggregateType<T>>

    /**
     * Group by StrengthBasedSkills.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StrengthBasedSkillsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StrengthBasedSkillsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StrengthBasedSkillsGroupByArgs['orderBy'] }
        : { orderBy?: StrengthBasedSkillsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StrengthBasedSkillsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStrengthBasedSkillsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the StrengthBasedSkills model
   */
  readonly fields: StrengthBasedSkillsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for StrengthBasedSkills.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StrengthBasedSkillsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    athletics<T extends StrengthBasedSkills$athleticsArgs<ExtArgs> = {}>(args?: Subset<T, StrengthBasedSkills$athleticsArgs<ExtArgs>>): Prisma__AthleticsSkillClient<$Result.GetResult<Prisma.$AthleticsSkillPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | null, null, ExtArgs, ClientOptions>
    skills_list_relation<T extends SkillsListDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SkillsListDefaultArgs<ExtArgs>>): Prisma__SkillsListClient<$Result.GetResult<Prisma.$SkillsListPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the StrengthBasedSkills model
   */ 
  interface StrengthBasedSkillsFieldRefs {
    readonly id: FieldRef<"StrengthBasedSkills", 'String'>
  }
    

  // Custom InputTypes
  /**
   * StrengthBasedSkills findUnique
   */
  export type StrengthBasedSkillsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StrengthBasedSkills
     */
    select?: StrengthBasedSkillsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StrengthBasedSkills
     */
    omit?: StrengthBasedSkillsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StrengthBasedSkillsInclude<ExtArgs> | null
    /**
     * Filter, which StrengthBasedSkills to fetch.
     */
    where: StrengthBasedSkillsWhereUniqueInput
  }

  /**
   * StrengthBasedSkills findUniqueOrThrow
   */
  export type StrengthBasedSkillsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StrengthBasedSkills
     */
    select?: StrengthBasedSkillsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StrengthBasedSkills
     */
    omit?: StrengthBasedSkillsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StrengthBasedSkillsInclude<ExtArgs> | null
    /**
     * Filter, which StrengthBasedSkills to fetch.
     */
    where: StrengthBasedSkillsWhereUniqueInput
  }

  /**
   * StrengthBasedSkills findFirst
   */
  export type StrengthBasedSkillsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StrengthBasedSkills
     */
    select?: StrengthBasedSkillsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StrengthBasedSkills
     */
    omit?: StrengthBasedSkillsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StrengthBasedSkillsInclude<ExtArgs> | null
    /**
     * Filter, which StrengthBasedSkills to fetch.
     */
    where?: StrengthBasedSkillsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StrengthBasedSkills to fetch.
     */
    orderBy?: StrengthBasedSkillsOrderByWithRelationInput | StrengthBasedSkillsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StrengthBasedSkills.
     */
    cursor?: StrengthBasedSkillsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StrengthBasedSkills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StrengthBasedSkills.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StrengthBasedSkills.
     */
    distinct?: StrengthBasedSkillsScalarFieldEnum | StrengthBasedSkillsScalarFieldEnum[]
  }

  /**
   * StrengthBasedSkills findFirstOrThrow
   */
  export type StrengthBasedSkillsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StrengthBasedSkills
     */
    select?: StrengthBasedSkillsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StrengthBasedSkills
     */
    omit?: StrengthBasedSkillsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StrengthBasedSkillsInclude<ExtArgs> | null
    /**
     * Filter, which StrengthBasedSkills to fetch.
     */
    where?: StrengthBasedSkillsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StrengthBasedSkills to fetch.
     */
    orderBy?: StrengthBasedSkillsOrderByWithRelationInput | StrengthBasedSkillsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StrengthBasedSkills.
     */
    cursor?: StrengthBasedSkillsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StrengthBasedSkills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StrengthBasedSkills.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StrengthBasedSkills.
     */
    distinct?: StrengthBasedSkillsScalarFieldEnum | StrengthBasedSkillsScalarFieldEnum[]
  }

  /**
   * StrengthBasedSkills findMany
   */
  export type StrengthBasedSkillsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StrengthBasedSkills
     */
    select?: StrengthBasedSkillsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StrengthBasedSkills
     */
    omit?: StrengthBasedSkillsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StrengthBasedSkillsInclude<ExtArgs> | null
    /**
     * Filter, which StrengthBasedSkills to fetch.
     */
    where?: StrengthBasedSkillsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StrengthBasedSkills to fetch.
     */
    orderBy?: StrengthBasedSkillsOrderByWithRelationInput | StrengthBasedSkillsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing StrengthBasedSkills.
     */
    cursor?: StrengthBasedSkillsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StrengthBasedSkills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StrengthBasedSkills.
     */
    skip?: number
    distinct?: StrengthBasedSkillsScalarFieldEnum | StrengthBasedSkillsScalarFieldEnum[]
  }

  /**
   * StrengthBasedSkills create
   */
  export type StrengthBasedSkillsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StrengthBasedSkills
     */
    select?: StrengthBasedSkillsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StrengthBasedSkills
     */
    omit?: StrengthBasedSkillsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StrengthBasedSkillsInclude<ExtArgs> | null
    /**
     * The data needed to create a StrengthBasedSkills.
     */
    data: XOR<StrengthBasedSkillsCreateInput, StrengthBasedSkillsUncheckedCreateInput>
  }

  /**
   * StrengthBasedSkills createMany
   */
  export type StrengthBasedSkillsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many StrengthBasedSkills.
     */
    data: StrengthBasedSkillsCreateManyInput | StrengthBasedSkillsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * StrengthBasedSkills createManyAndReturn
   */
  export type StrengthBasedSkillsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StrengthBasedSkills
     */
    select?: StrengthBasedSkillsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the StrengthBasedSkills
     */
    omit?: StrengthBasedSkillsOmit<ExtArgs> | null
    /**
     * The data used to create many StrengthBasedSkills.
     */
    data: StrengthBasedSkillsCreateManyInput | StrengthBasedSkillsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StrengthBasedSkillsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * StrengthBasedSkills update
   */
  export type StrengthBasedSkillsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StrengthBasedSkills
     */
    select?: StrengthBasedSkillsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StrengthBasedSkills
     */
    omit?: StrengthBasedSkillsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StrengthBasedSkillsInclude<ExtArgs> | null
    /**
     * The data needed to update a StrengthBasedSkills.
     */
    data: XOR<StrengthBasedSkillsUpdateInput, StrengthBasedSkillsUncheckedUpdateInput>
    /**
     * Choose, which StrengthBasedSkills to update.
     */
    where: StrengthBasedSkillsWhereUniqueInput
  }

  /**
   * StrengthBasedSkills updateMany
   */
  export type StrengthBasedSkillsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update StrengthBasedSkills.
     */
    data: XOR<StrengthBasedSkillsUpdateManyMutationInput, StrengthBasedSkillsUncheckedUpdateManyInput>
    /**
     * Filter which StrengthBasedSkills to update
     */
    where?: StrengthBasedSkillsWhereInput
    /**
     * Limit how many StrengthBasedSkills to update.
     */
    limit?: number
  }

  /**
   * StrengthBasedSkills updateManyAndReturn
   */
  export type StrengthBasedSkillsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StrengthBasedSkills
     */
    select?: StrengthBasedSkillsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the StrengthBasedSkills
     */
    omit?: StrengthBasedSkillsOmit<ExtArgs> | null
    /**
     * The data used to update StrengthBasedSkills.
     */
    data: XOR<StrengthBasedSkillsUpdateManyMutationInput, StrengthBasedSkillsUncheckedUpdateManyInput>
    /**
     * Filter which StrengthBasedSkills to update
     */
    where?: StrengthBasedSkillsWhereInput
    /**
     * Limit how many StrengthBasedSkills to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StrengthBasedSkillsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * StrengthBasedSkills upsert
   */
  export type StrengthBasedSkillsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StrengthBasedSkills
     */
    select?: StrengthBasedSkillsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StrengthBasedSkills
     */
    omit?: StrengthBasedSkillsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StrengthBasedSkillsInclude<ExtArgs> | null
    /**
     * The filter to search for the StrengthBasedSkills to update in case it exists.
     */
    where: StrengthBasedSkillsWhereUniqueInput
    /**
     * In case the StrengthBasedSkills found by the `where` argument doesn't exist, create a new StrengthBasedSkills with this data.
     */
    create: XOR<StrengthBasedSkillsCreateInput, StrengthBasedSkillsUncheckedCreateInput>
    /**
     * In case the StrengthBasedSkills was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StrengthBasedSkillsUpdateInput, StrengthBasedSkillsUncheckedUpdateInput>
  }

  /**
   * StrengthBasedSkills delete
   */
  export type StrengthBasedSkillsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StrengthBasedSkills
     */
    select?: StrengthBasedSkillsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StrengthBasedSkills
     */
    omit?: StrengthBasedSkillsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StrengthBasedSkillsInclude<ExtArgs> | null
    /**
     * Filter which StrengthBasedSkills to delete.
     */
    where: StrengthBasedSkillsWhereUniqueInput
  }

  /**
   * StrengthBasedSkills deleteMany
   */
  export type StrengthBasedSkillsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StrengthBasedSkills to delete
     */
    where?: StrengthBasedSkillsWhereInput
    /**
     * Limit how many StrengthBasedSkills to delete.
     */
    limit?: number
  }

  /**
   * StrengthBasedSkills.athletics
   */
  export type StrengthBasedSkills$athleticsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AthleticsSkill
     */
    select?: AthleticsSkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AthleticsSkill
     */
    omit?: AthleticsSkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AthleticsSkillInclude<ExtArgs> | null
    where?: AthleticsSkillWhereInput
  }

  /**
   * StrengthBasedSkills without action
   */
  export type StrengthBasedSkillsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StrengthBasedSkills
     */
    select?: StrengthBasedSkillsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StrengthBasedSkills
     */
    omit?: StrengthBasedSkillsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StrengthBasedSkillsInclude<ExtArgs> | null
  }


  /**
   * Model DexterityBasedSkills
   */

  export type AggregateDexterityBasedSkills = {
    _count: DexterityBasedSkillsCountAggregateOutputType | null
    _min: DexterityBasedSkillsMinAggregateOutputType | null
    _max: DexterityBasedSkillsMaxAggregateOutputType | null
  }

  export type DexterityBasedSkillsMinAggregateOutputType = {
    id: string | null
  }

  export type DexterityBasedSkillsMaxAggregateOutputType = {
    id: string | null
  }

  export type DexterityBasedSkillsCountAggregateOutputType = {
    id: number
    _all: number
  }


  export type DexterityBasedSkillsMinAggregateInputType = {
    id?: true
  }

  export type DexterityBasedSkillsMaxAggregateInputType = {
    id?: true
  }

  export type DexterityBasedSkillsCountAggregateInputType = {
    id?: true
    _all?: true
  }

  export type DexterityBasedSkillsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DexterityBasedSkills to aggregate.
     */
    where?: DexterityBasedSkillsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DexterityBasedSkills to fetch.
     */
    orderBy?: DexterityBasedSkillsOrderByWithRelationInput | DexterityBasedSkillsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DexterityBasedSkillsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DexterityBasedSkills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DexterityBasedSkills.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DexterityBasedSkills
    **/
    _count?: true | DexterityBasedSkillsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DexterityBasedSkillsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DexterityBasedSkillsMaxAggregateInputType
  }

  export type GetDexterityBasedSkillsAggregateType<T extends DexterityBasedSkillsAggregateArgs> = {
        [P in keyof T & keyof AggregateDexterityBasedSkills]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDexterityBasedSkills[P]>
      : GetScalarType<T[P], AggregateDexterityBasedSkills[P]>
  }




  export type DexterityBasedSkillsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DexterityBasedSkillsWhereInput
    orderBy?: DexterityBasedSkillsOrderByWithAggregationInput | DexterityBasedSkillsOrderByWithAggregationInput[]
    by: DexterityBasedSkillsScalarFieldEnum[] | DexterityBasedSkillsScalarFieldEnum
    having?: DexterityBasedSkillsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DexterityBasedSkillsCountAggregateInputType | true
    _min?: DexterityBasedSkillsMinAggregateInputType
    _max?: DexterityBasedSkillsMaxAggregateInputType
  }

  export type DexterityBasedSkillsGroupByOutputType = {
    id: string
    _count: DexterityBasedSkillsCountAggregateOutputType | null
    _min: DexterityBasedSkillsMinAggregateOutputType | null
    _max: DexterityBasedSkillsMaxAggregateOutputType | null
  }

  type GetDexterityBasedSkillsGroupByPayload<T extends DexterityBasedSkillsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DexterityBasedSkillsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DexterityBasedSkillsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DexterityBasedSkillsGroupByOutputType[P]>
            : GetScalarType<T[P], DexterityBasedSkillsGroupByOutputType[P]>
        }
      >
    >


  export type DexterityBasedSkillsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    acrobatics?: boolean | DexterityBasedSkills$acrobaticsArgs<ExtArgs>
    sleight_of_hand?: boolean | DexterityBasedSkills$sleight_of_handArgs<ExtArgs>
    stealth?: boolean | DexterityBasedSkills$stealthArgs<ExtArgs>
    skills_list_relation?: boolean | SkillsListDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["dexterityBasedSkills"]>

  export type DexterityBasedSkillsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    skills_list_relation?: boolean | SkillsListDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["dexterityBasedSkills"]>

  export type DexterityBasedSkillsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    skills_list_relation?: boolean | SkillsListDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["dexterityBasedSkills"]>

  export type DexterityBasedSkillsSelectScalar = {
    id?: boolean
  }

  export type DexterityBasedSkillsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id", ExtArgs["result"]["dexterityBasedSkills"]>
  export type DexterityBasedSkillsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    acrobatics?: boolean | DexterityBasedSkills$acrobaticsArgs<ExtArgs>
    sleight_of_hand?: boolean | DexterityBasedSkills$sleight_of_handArgs<ExtArgs>
    stealth?: boolean | DexterityBasedSkills$stealthArgs<ExtArgs>
    skills_list_relation?: boolean | SkillsListDefaultArgs<ExtArgs>
  }
  export type DexterityBasedSkillsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    skills_list_relation?: boolean | SkillsListDefaultArgs<ExtArgs>
  }
  export type DexterityBasedSkillsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    skills_list_relation?: boolean | SkillsListDefaultArgs<ExtArgs>
  }

  export type $DexterityBasedSkillsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DexterityBasedSkills"
    objects: {
      acrobatics: Prisma.$AcrobaticsSkillPayload<ExtArgs> | null
      sleight_of_hand: Prisma.$SleightOfHandSkillPayload<ExtArgs> | null
      stealth: Prisma.$StealthSkillPayload<ExtArgs> | null
      skills_list_relation: Prisma.$SkillsListPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
    }, ExtArgs["result"]["dexterityBasedSkills"]>
    composites: {}
  }

  type DexterityBasedSkillsGetPayload<S extends boolean | null | undefined | DexterityBasedSkillsDefaultArgs> = $Result.GetResult<Prisma.$DexterityBasedSkillsPayload, S>

  type DexterityBasedSkillsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DexterityBasedSkillsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DexterityBasedSkillsCountAggregateInputType | true
    }

  export interface DexterityBasedSkillsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DexterityBasedSkills'], meta: { name: 'DexterityBasedSkills' } }
    /**
     * Find zero or one DexterityBasedSkills that matches the filter.
     * @param {DexterityBasedSkillsFindUniqueArgs} args - Arguments to find a DexterityBasedSkills
     * @example
     * // Get one DexterityBasedSkills
     * const dexterityBasedSkills = await prisma.dexterityBasedSkills.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DexterityBasedSkillsFindUniqueArgs>(args: SelectSubset<T, DexterityBasedSkillsFindUniqueArgs<ExtArgs>>): Prisma__DexterityBasedSkillsClient<$Result.GetResult<Prisma.$DexterityBasedSkillsPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one DexterityBasedSkills that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DexterityBasedSkillsFindUniqueOrThrowArgs} args - Arguments to find a DexterityBasedSkills
     * @example
     * // Get one DexterityBasedSkills
     * const dexterityBasedSkills = await prisma.dexterityBasedSkills.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DexterityBasedSkillsFindUniqueOrThrowArgs>(args: SelectSubset<T, DexterityBasedSkillsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DexterityBasedSkillsClient<$Result.GetResult<Prisma.$DexterityBasedSkillsPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first DexterityBasedSkills that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DexterityBasedSkillsFindFirstArgs} args - Arguments to find a DexterityBasedSkills
     * @example
     * // Get one DexterityBasedSkills
     * const dexterityBasedSkills = await prisma.dexterityBasedSkills.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DexterityBasedSkillsFindFirstArgs>(args?: SelectSubset<T, DexterityBasedSkillsFindFirstArgs<ExtArgs>>): Prisma__DexterityBasedSkillsClient<$Result.GetResult<Prisma.$DexterityBasedSkillsPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first DexterityBasedSkills that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DexterityBasedSkillsFindFirstOrThrowArgs} args - Arguments to find a DexterityBasedSkills
     * @example
     * // Get one DexterityBasedSkills
     * const dexterityBasedSkills = await prisma.dexterityBasedSkills.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DexterityBasedSkillsFindFirstOrThrowArgs>(args?: SelectSubset<T, DexterityBasedSkillsFindFirstOrThrowArgs<ExtArgs>>): Prisma__DexterityBasedSkillsClient<$Result.GetResult<Prisma.$DexterityBasedSkillsPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more DexterityBasedSkills that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DexterityBasedSkillsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DexterityBasedSkills
     * const dexterityBasedSkills = await prisma.dexterityBasedSkills.findMany()
     * 
     * // Get first 10 DexterityBasedSkills
     * const dexterityBasedSkills = await prisma.dexterityBasedSkills.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const dexterityBasedSkillsWithIdOnly = await prisma.dexterityBasedSkills.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DexterityBasedSkillsFindManyArgs>(args?: SelectSubset<T, DexterityBasedSkillsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DexterityBasedSkillsPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a DexterityBasedSkills.
     * @param {DexterityBasedSkillsCreateArgs} args - Arguments to create a DexterityBasedSkills.
     * @example
     * // Create one DexterityBasedSkills
     * const DexterityBasedSkills = await prisma.dexterityBasedSkills.create({
     *   data: {
     *     // ... data to create a DexterityBasedSkills
     *   }
     * })
     * 
     */
    create<T extends DexterityBasedSkillsCreateArgs>(args: SelectSubset<T, DexterityBasedSkillsCreateArgs<ExtArgs>>): Prisma__DexterityBasedSkillsClient<$Result.GetResult<Prisma.$DexterityBasedSkillsPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many DexterityBasedSkills.
     * @param {DexterityBasedSkillsCreateManyArgs} args - Arguments to create many DexterityBasedSkills.
     * @example
     * // Create many DexterityBasedSkills
     * const dexterityBasedSkills = await prisma.dexterityBasedSkills.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DexterityBasedSkillsCreateManyArgs>(args?: SelectSubset<T, DexterityBasedSkillsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DexterityBasedSkills and returns the data saved in the database.
     * @param {DexterityBasedSkillsCreateManyAndReturnArgs} args - Arguments to create many DexterityBasedSkills.
     * @example
     * // Create many DexterityBasedSkills
     * const dexterityBasedSkills = await prisma.dexterityBasedSkills.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DexterityBasedSkills and only return the `id`
     * const dexterityBasedSkillsWithIdOnly = await prisma.dexterityBasedSkills.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DexterityBasedSkillsCreateManyAndReturnArgs>(args?: SelectSubset<T, DexterityBasedSkillsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DexterityBasedSkillsPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a DexterityBasedSkills.
     * @param {DexterityBasedSkillsDeleteArgs} args - Arguments to delete one DexterityBasedSkills.
     * @example
     * // Delete one DexterityBasedSkills
     * const DexterityBasedSkills = await prisma.dexterityBasedSkills.delete({
     *   where: {
     *     // ... filter to delete one DexterityBasedSkills
     *   }
     * })
     * 
     */
    delete<T extends DexterityBasedSkillsDeleteArgs>(args: SelectSubset<T, DexterityBasedSkillsDeleteArgs<ExtArgs>>): Prisma__DexterityBasedSkillsClient<$Result.GetResult<Prisma.$DexterityBasedSkillsPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one DexterityBasedSkills.
     * @param {DexterityBasedSkillsUpdateArgs} args - Arguments to update one DexterityBasedSkills.
     * @example
     * // Update one DexterityBasedSkills
     * const dexterityBasedSkills = await prisma.dexterityBasedSkills.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DexterityBasedSkillsUpdateArgs>(args: SelectSubset<T, DexterityBasedSkillsUpdateArgs<ExtArgs>>): Prisma__DexterityBasedSkillsClient<$Result.GetResult<Prisma.$DexterityBasedSkillsPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more DexterityBasedSkills.
     * @param {DexterityBasedSkillsDeleteManyArgs} args - Arguments to filter DexterityBasedSkills to delete.
     * @example
     * // Delete a few DexterityBasedSkills
     * const { count } = await prisma.dexterityBasedSkills.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DexterityBasedSkillsDeleteManyArgs>(args?: SelectSubset<T, DexterityBasedSkillsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DexterityBasedSkills.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DexterityBasedSkillsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DexterityBasedSkills
     * const dexterityBasedSkills = await prisma.dexterityBasedSkills.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DexterityBasedSkillsUpdateManyArgs>(args: SelectSubset<T, DexterityBasedSkillsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DexterityBasedSkills and returns the data updated in the database.
     * @param {DexterityBasedSkillsUpdateManyAndReturnArgs} args - Arguments to update many DexterityBasedSkills.
     * @example
     * // Update many DexterityBasedSkills
     * const dexterityBasedSkills = await prisma.dexterityBasedSkills.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more DexterityBasedSkills and only return the `id`
     * const dexterityBasedSkillsWithIdOnly = await prisma.dexterityBasedSkills.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DexterityBasedSkillsUpdateManyAndReturnArgs>(args: SelectSubset<T, DexterityBasedSkillsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DexterityBasedSkillsPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one DexterityBasedSkills.
     * @param {DexterityBasedSkillsUpsertArgs} args - Arguments to update or create a DexterityBasedSkills.
     * @example
     * // Update or create a DexterityBasedSkills
     * const dexterityBasedSkills = await prisma.dexterityBasedSkills.upsert({
     *   create: {
     *     // ... data to create a DexterityBasedSkills
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DexterityBasedSkills we want to update
     *   }
     * })
     */
    upsert<T extends DexterityBasedSkillsUpsertArgs>(args: SelectSubset<T, DexterityBasedSkillsUpsertArgs<ExtArgs>>): Prisma__DexterityBasedSkillsClient<$Result.GetResult<Prisma.$DexterityBasedSkillsPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of DexterityBasedSkills.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DexterityBasedSkillsCountArgs} args - Arguments to filter DexterityBasedSkills to count.
     * @example
     * // Count the number of DexterityBasedSkills
     * const count = await prisma.dexterityBasedSkills.count({
     *   where: {
     *     // ... the filter for the DexterityBasedSkills we want to count
     *   }
     * })
    **/
    count<T extends DexterityBasedSkillsCountArgs>(
      args?: Subset<T, DexterityBasedSkillsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DexterityBasedSkillsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DexterityBasedSkills.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DexterityBasedSkillsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DexterityBasedSkillsAggregateArgs>(args: Subset<T, DexterityBasedSkillsAggregateArgs>): Prisma.PrismaPromise<GetDexterityBasedSkillsAggregateType<T>>

    /**
     * Group by DexterityBasedSkills.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DexterityBasedSkillsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DexterityBasedSkillsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DexterityBasedSkillsGroupByArgs['orderBy'] }
        : { orderBy?: DexterityBasedSkillsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DexterityBasedSkillsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDexterityBasedSkillsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DexterityBasedSkills model
   */
  readonly fields: DexterityBasedSkillsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DexterityBasedSkills.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DexterityBasedSkillsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    acrobatics<T extends DexterityBasedSkills$acrobaticsArgs<ExtArgs> = {}>(args?: Subset<T, DexterityBasedSkills$acrobaticsArgs<ExtArgs>>): Prisma__AcrobaticsSkillClient<$Result.GetResult<Prisma.$AcrobaticsSkillPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | null, null, ExtArgs, ClientOptions>
    sleight_of_hand<T extends DexterityBasedSkills$sleight_of_handArgs<ExtArgs> = {}>(args?: Subset<T, DexterityBasedSkills$sleight_of_handArgs<ExtArgs>>): Prisma__SleightOfHandSkillClient<$Result.GetResult<Prisma.$SleightOfHandSkillPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | null, null, ExtArgs, ClientOptions>
    stealth<T extends DexterityBasedSkills$stealthArgs<ExtArgs> = {}>(args?: Subset<T, DexterityBasedSkills$stealthArgs<ExtArgs>>): Prisma__StealthSkillClient<$Result.GetResult<Prisma.$StealthSkillPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | null, null, ExtArgs, ClientOptions>
    skills_list_relation<T extends SkillsListDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SkillsListDefaultArgs<ExtArgs>>): Prisma__SkillsListClient<$Result.GetResult<Prisma.$SkillsListPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DexterityBasedSkills model
   */ 
  interface DexterityBasedSkillsFieldRefs {
    readonly id: FieldRef<"DexterityBasedSkills", 'String'>
  }
    

  // Custom InputTypes
  /**
   * DexterityBasedSkills findUnique
   */
  export type DexterityBasedSkillsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DexterityBasedSkills
     */
    select?: DexterityBasedSkillsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DexterityBasedSkills
     */
    omit?: DexterityBasedSkillsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DexterityBasedSkillsInclude<ExtArgs> | null
    /**
     * Filter, which DexterityBasedSkills to fetch.
     */
    where: DexterityBasedSkillsWhereUniqueInput
  }

  /**
   * DexterityBasedSkills findUniqueOrThrow
   */
  export type DexterityBasedSkillsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DexterityBasedSkills
     */
    select?: DexterityBasedSkillsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DexterityBasedSkills
     */
    omit?: DexterityBasedSkillsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DexterityBasedSkillsInclude<ExtArgs> | null
    /**
     * Filter, which DexterityBasedSkills to fetch.
     */
    where: DexterityBasedSkillsWhereUniqueInput
  }

  /**
   * DexterityBasedSkills findFirst
   */
  export type DexterityBasedSkillsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DexterityBasedSkills
     */
    select?: DexterityBasedSkillsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DexterityBasedSkills
     */
    omit?: DexterityBasedSkillsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DexterityBasedSkillsInclude<ExtArgs> | null
    /**
     * Filter, which DexterityBasedSkills to fetch.
     */
    where?: DexterityBasedSkillsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DexterityBasedSkills to fetch.
     */
    orderBy?: DexterityBasedSkillsOrderByWithRelationInput | DexterityBasedSkillsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DexterityBasedSkills.
     */
    cursor?: DexterityBasedSkillsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DexterityBasedSkills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DexterityBasedSkills.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DexterityBasedSkills.
     */
    distinct?: DexterityBasedSkillsScalarFieldEnum | DexterityBasedSkillsScalarFieldEnum[]
  }

  /**
   * DexterityBasedSkills findFirstOrThrow
   */
  export type DexterityBasedSkillsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DexterityBasedSkills
     */
    select?: DexterityBasedSkillsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DexterityBasedSkills
     */
    omit?: DexterityBasedSkillsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DexterityBasedSkillsInclude<ExtArgs> | null
    /**
     * Filter, which DexterityBasedSkills to fetch.
     */
    where?: DexterityBasedSkillsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DexterityBasedSkills to fetch.
     */
    orderBy?: DexterityBasedSkillsOrderByWithRelationInput | DexterityBasedSkillsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DexterityBasedSkills.
     */
    cursor?: DexterityBasedSkillsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DexterityBasedSkills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DexterityBasedSkills.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DexterityBasedSkills.
     */
    distinct?: DexterityBasedSkillsScalarFieldEnum | DexterityBasedSkillsScalarFieldEnum[]
  }

  /**
   * DexterityBasedSkills findMany
   */
  export type DexterityBasedSkillsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DexterityBasedSkills
     */
    select?: DexterityBasedSkillsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DexterityBasedSkills
     */
    omit?: DexterityBasedSkillsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DexterityBasedSkillsInclude<ExtArgs> | null
    /**
     * Filter, which DexterityBasedSkills to fetch.
     */
    where?: DexterityBasedSkillsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DexterityBasedSkills to fetch.
     */
    orderBy?: DexterityBasedSkillsOrderByWithRelationInput | DexterityBasedSkillsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DexterityBasedSkills.
     */
    cursor?: DexterityBasedSkillsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DexterityBasedSkills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DexterityBasedSkills.
     */
    skip?: number
    distinct?: DexterityBasedSkillsScalarFieldEnum | DexterityBasedSkillsScalarFieldEnum[]
  }

  /**
   * DexterityBasedSkills create
   */
  export type DexterityBasedSkillsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DexterityBasedSkills
     */
    select?: DexterityBasedSkillsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DexterityBasedSkills
     */
    omit?: DexterityBasedSkillsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DexterityBasedSkillsInclude<ExtArgs> | null
    /**
     * The data needed to create a DexterityBasedSkills.
     */
    data: XOR<DexterityBasedSkillsCreateInput, DexterityBasedSkillsUncheckedCreateInput>
  }

  /**
   * DexterityBasedSkills createMany
   */
  export type DexterityBasedSkillsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DexterityBasedSkills.
     */
    data: DexterityBasedSkillsCreateManyInput | DexterityBasedSkillsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DexterityBasedSkills createManyAndReturn
   */
  export type DexterityBasedSkillsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DexterityBasedSkills
     */
    select?: DexterityBasedSkillsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DexterityBasedSkills
     */
    omit?: DexterityBasedSkillsOmit<ExtArgs> | null
    /**
     * The data used to create many DexterityBasedSkills.
     */
    data: DexterityBasedSkillsCreateManyInput | DexterityBasedSkillsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DexterityBasedSkillsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * DexterityBasedSkills update
   */
  export type DexterityBasedSkillsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DexterityBasedSkills
     */
    select?: DexterityBasedSkillsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DexterityBasedSkills
     */
    omit?: DexterityBasedSkillsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DexterityBasedSkillsInclude<ExtArgs> | null
    /**
     * The data needed to update a DexterityBasedSkills.
     */
    data: XOR<DexterityBasedSkillsUpdateInput, DexterityBasedSkillsUncheckedUpdateInput>
    /**
     * Choose, which DexterityBasedSkills to update.
     */
    where: DexterityBasedSkillsWhereUniqueInput
  }

  /**
   * DexterityBasedSkills updateMany
   */
  export type DexterityBasedSkillsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DexterityBasedSkills.
     */
    data: XOR<DexterityBasedSkillsUpdateManyMutationInput, DexterityBasedSkillsUncheckedUpdateManyInput>
    /**
     * Filter which DexterityBasedSkills to update
     */
    where?: DexterityBasedSkillsWhereInput
    /**
     * Limit how many DexterityBasedSkills to update.
     */
    limit?: number
  }

  /**
   * DexterityBasedSkills updateManyAndReturn
   */
  export type DexterityBasedSkillsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DexterityBasedSkills
     */
    select?: DexterityBasedSkillsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DexterityBasedSkills
     */
    omit?: DexterityBasedSkillsOmit<ExtArgs> | null
    /**
     * The data used to update DexterityBasedSkills.
     */
    data: XOR<DexterityBasedSkillsUpdateManyMutationInput, DexterityBasedSkillsUncheckedUpdateManyInput>
    /**
     * Filter which DexterityBasedSkills to update
     */
    where?: DexterityBasedSkillsWhereInput
    /**
     * Limit how many DexterityBasedSkills to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DexterityBasedSkillsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * DexterityBasedSkills upsert
   */
  export type DexterityBasedSkillsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DexterityBasedSkills
     */
    select?: DexterityBasedSkillsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DexterityBasedSkills
     */
    omit?: DexterityBasedSkillsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DexterityBasedSkillsInclude<ExtArgs> | null
    /**
     * The filter to search for the DexterityBasedSkills to update in case it exists.
     */
    where: DexterityBasedSkillsWhereUniqueInput
    /**
     * In case the DexterityBasedSkills found by the `where` argument doesn't exist, create a new DexterityBasedSkills with this data.
     */
    create: XOR<DexterityBasedSkillsCreateInput, DexterityBasedSkillsUncheckedCreateInput>
    /**
     * In case the DexterityBasedSkills was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DexterityBasedSkillsUpdateInput, DexterityBasedSkillsUncheckedUpdateInput>
  }

  /**
   * DexterityBasedSkills delete
   */
  export type DexterityBasedSkillsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DexterityBasedSkills
     */
    select?: DexterityBasedSkillsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DexterityBasedSkills
     */
    omit?: DexterityBasedSkillsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DexterityBasedSkillsInclude<ExtArgs> | null
    /**
     * Filter which DexterityBasedSkills to delete.
     */
    where: DexterityBasedSkillsWhereUniqueInput
  }

  /**
   * DexterityBasedSkills deleteMany
   */
  export type DexterityBasedSkillsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DexterityBasedSkills to delete
     */
    where?: DexterityBasedSkillsWhereInput
    /**
     * Limit how many DexterityBasedSkills to delete.
     */
    limit?: number
  }

  /**
   * DexterityBasedSkills.acrobatics
   */
  export type DexterityBasedSkills$acrobaticsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcrobaticsSkill
     */
    select?: AcrobaticsSkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AcrobaticsSkill
     */
    omit?: AcrobaticsSkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcrobaticsSkillInclude<ExtArgs> | null
    where?: AcrobaticsSkillWhereInput
  }

  /**
   * DexterityBasedSkills.sleight_of_hand
   */
  export type DexterityBasedSkills$sleight_of_handArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SleightOfHandSkill
     */
    select?: SleightOfHandSkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SleightOfHandSkill
     */
    omit?: SleightOfHandSkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SleightOfHandSkillInclude<ExtArgs> | null
    where?: SleightOfHandSkillWhereInput
  }

  /**
   * DexterityBasedSkills.stealth
   */
  export type DexterityBasedSkills$stealthArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StealthSkill
     */
    select?: StealthSkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StealthSkill
     */
    omit?: StealthSkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StealthSkillInclude<ExtArgs> | null
    where?: StealthSkillWhereInput
  }

  /**
   * DexterityBasedSkills without action
   */
  export type DexterityBasedSkillsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DexterityBasedSkills
     */
    select?: DexterityBasedSkillsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DexterityBasedSkills
     */
    omit?: DexterityBasedSkillsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DexterityBasedSkillsInclude<ExtArgs> | null
  }


  /**
   * Model IntellengenceBasedSkills
   */

  export type AggregateIntellengenceBasedSkills = {
    _count: IntellengenceBasedSkillsCountAggregateOutputType | null
    _min: IntellengenceBasedSkillsMinAggregateOutputType | null
    _max: IntellengenceBasedSkillsMaxAggregateOutputType | null
  }

  export type IntellengenceBasedSkillsMinAggregateOutputType = {
    id: string | null
  }

  export type IntellengenceBasedSkillsMaxAggregateOutputType = {
    id: string | null
  }

  export type IntellengenceBasedSkillsCountAggregateOutputType = {
    id: number
    _all: number
  }


  export type IntellengenceBasedSkillsMinAggregateInputType = {
    id?: true
  }

  export type IntellengenceBasedSkillsMaxAggregateInputType = {
    id?: true
  }

  export type IntellengenceBasedSkillsCountAggregateInputType = {
    id?: true
    _all?: true
  }

  export type IntellengenceBasedSkillsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which IntellengenceBasedSkills to aggregate.
     */
    where?: IntellengenceBasedSkillsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IntellengenceBasedSkills to fetch.
     */
    orderBy?: IntellengenceBasedSkillsOrderByWithRelationInput | IntellengenceBasedSkillsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: IntellengenceBasedSkillsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IntellengenceBasedSkills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IntellengenceBasedSkills.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned IntellengenceBasedSkills
    **/
    _count?: true | IntellengenceBasedSkillsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: IntellengenceBasedSkillsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: IntellengenceBasedSkillsMaxAggregateInputType
  }

  export type GetIntellengenceBasedSkillsAggregateType<T extends IntellengenceBasedSkillsAggregateArgs> = {
        [P in keyof T & keyof AggregateIntellengenceBasedSkills]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateIntellengenceBasedSkills[P]>
      : GetScalarType<T[P], AggregateIntellengenceBasedSkills[P]>
  }




  export type IntellengenceBasedSkillsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: IntellengenceBasedSkillsWhereInput
    orderBy?: IntellengenceBasedSkillsOrderByWithAggregationInput | IntellengenceBasedSkillsOrderByWithAggregationInput[]
    by: IntellengenceBasedSkillsScalarFieldEnum[] | IntellengenceBasedSkillsScalarFieldEnum
    having?: IntellengenceBasedSkillsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: IntellengenceBasedSkillsCountAggregateInputType | true
    _min?: IntellengenceBasedSkillsMinAggregateInputType
    _max?: IntellengenceBasedSkillsMaxAggregateInputType
  }

  export type IntellengenceBasedSkillsGroupByOutputType = {
    id: string
    _count: IntellengenceBasedSkillsCountAggregateOutputType | null
    _min: IntellengenceBasedSkillsMinAggregateOutputType | null
    _max: IntellengenceBasedSkillsMaxAggregateOutputType | null
  }

  type GetIntellengenceBasedSkillsGroupByPayload<T extends IntellengenceBasedSkillsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<IntellengenceBasedSkillsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof IntellengenceBasedSkillsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], IntellengenceBasedSkillsGroupByOutputType[P]>
            : GetScalarType<T[P], IntellengenceBasedSkillsGroupByOutputType[P]>
        }
      >
    >


  export type IntellengenceBasedSkillsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    arcana?: boolean | IntellengenceBasedSkills$arcanaArgs<ExtArgs>
    history?: boolean | IntellengenceBasedSkills$historyArgs<ExtArgs>
    investigation?: boolean | IntellengenceBasedSkills$investigationArgs<ExtArgs>
    nature?: boolean | IntellengenceBasedSkills$natureArgs<ExtArgs>
    religion?: boolean | IntellengenceBasedSkills$religionArgs<ExtArgs>
    skills_list_relation?: boolean | SkillsListDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["intellengenceBasedSkills"]>

  export type IntellengenceBasedSkillsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    skills_list_relation?: boolean | SkillsListDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["intellengenceBasedSkills"]>

  export type IntellengenceBasedSkillsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    skills_list_relation?: boolean | SkillsListDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["intellengenceBasedSkills"]>

  export type IntellengenceBasedSkillsSelectScalar = {
    id?: boolean
  }

  export type IntellengenceBasedSkillsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id", ExtArgs["result"]["intellengenceBasedSkills"]>
  export type IntellengenceBasedSkillsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    arcana?: boolean | IntellengenceBasedSkills$arcanaArgs<ExtArgs>
    history?: boolean | IntellengenceBasedSkills$historyArgs<ExtArgs>
    investigation?: boolean | IntellengenceBasedSkills$investigationArgs<ExtArgs>
    nature?: boolean | IntellengenceBasedSkills$natureArgs<ExtArgs>
    religion?: boolean | IntellengenceBasedSkills$religionArgs<ExtArgs>
    skills_list_relation?: boolean | SkillsListDefaultArgs<ExtArgs>
  }
  export type IntellengenceBasedSkillsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    skills_list_relation?: boolean | SkillsListDefaultArgs<ExtArgs>
  }
  export type IntellengenceBasedSkillsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    skills_list_relation?: boolean | SkillsListDefaultArgs<ExtArgs>
  }

  export type $IntellengenceBasedSkillsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "IntellengenceBasedSkills"
    objects: {
      arcana: Prisma.$ArcanaSkillPayload<ExtArgs> | null
      history: Prisma.$HistorySkillPayload<ExtArgs> | null
      investigation: Prisma.$InvestigationSkillPayload<ExtArgs> | null
      nature: Prisma.$NatureSkillPayload<ExtArgs> | null
      religion: Prisma.$ReligionSkillPayload<ExtArgs> | null
      skills_list_relation: Prisma.$SkillsListPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
    }, ExtArgs["result"]["intellengenceBasedSkills"]>
    composites: {}
  }

  type IntellengenceBasedSkillsGetPayload<S extends boolean | null | undefined | IntellengenceBasedSkillsDefaultArgs> = $Result.GetResult<Prisma.$IntellengenceBasedSkillsPayload, S>

  type IntellengenceBasedSkillsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<IntellengenceBasedSkillsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: IntellengenceBasedSkillsCountAggregateInputType | true
    }

  export interface IntellengenceBasedSkillsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['IntellengenceBasedSkills'], meta: { name: 'IntellengenceBasedSkills' } }
    /**
     * Find zero or one IntellengenceBasedSkills that matches the filter.
     * @param {IntellengenceBasedSkillsFindUniqueArgs} args - Arguments to find a IntellengenceBasedSkills
     * @example
     * // Get one IntellengenceBasedSkills
     * const intellengenceBasedSkills = await prisma.intellengenceBasedSkills.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends IntellengenceBasedSkillsFindUniqueArgs>(args: SelectSubset<T, IntellengenceBasedSkillsFindUniqueArgs<ExtArgs>>): Prisma__IntellengenceBasedSkillsClient<$Result.GetResult<Prisma.$IntellengenceBasedSkillsPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one IntellengenceBasedSkills that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {IntellengenceBasedSkillsFindUniqueOrThrowArgs} args - Arguments to find a IntellengenceBasedSkills
     * @example
     * // Get one IntellengenceBasedSkills
     * const intellengenceBasedSkills = await prisma.intellengenceBasedSkills.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends IntellengenceBasedSkillsFindUniqueOrThrowArgs>(args: SelectSubset<T, IntellengenceBasedSkillsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__IntellengenceBasedSkillsClient<$Result.GetResult<Prisma.$IntellengenceBasedSkillsPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first IntellengenceBasedSkills that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IntellengenceBasedSkillsFindFirstArgs} args - Arguments to find a IntellengenceBasedSkills
     * @example
     * // Get one IntellengenceBasedSkills
     * const intellengenceBasedSkills = await prisma.intellengenceBasedSkills.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends IntellengenceBasedSkillsFindFirstArgs>(args?: SelectSubset<T, IntellengenceBasedSkillsFindFirstArgs<ExtArgs>>): Prisma__IntellengenceBasedSkillsClient<$Result.GetResult<Prisma.$IntellengenceBasedSkillsPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first IntellengenceBasedSkills that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IntellengenceBasedSkillsFindFirstOrThrowArgs} args - Arguments to find a IntellengenceBasedSkills
     * @example
     * // Get one IntellengenceBasedSkills
     * const intellengenceBasedSkills = await prisma.intellengenceBasedSkills.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends IntellengenceBasedSkillsFindFirstOrThrowArgs>(args?: SelectSubset<T, IntellengenceBasedSkillsFindFirstOrThrowArgs<ExtArgs>>): Prisma__IntellengenceBasedSkillsClient<$Result.GetResult<Prisma.$IntellengenceBasedSkillsPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more IntellengenceBasedSkills that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IntellengenceBasedSkillsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all IntellengenceBasedSkills
     * const intellengenceBasedSkills = await prisma.intellengenceBasedSkills.findMany()
     * 
     * // Get first 10 IntellengenceBasedSkills
     * const intellengenceBasedSkills = await prisma.intellengenceBasedSkills.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const intellengenceBasedSkillsWithIdOnly = await prisma.intellengenceBasedSkills.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends IntellengenceBasedSkillsFindManyArgs>(args?: SelectSubset<T, IntellengenceBasedSkillsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IntellengenceBasedSkillsPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a IntellengenceBasedSkills.
     * @param {IntellengenceBasedSkillsCreateArgs} args - Arguments to create a IntellengenceBasedSkills.
     * @example
     * // Create one IntellengenceBasedSkills
     * const IntellengenceBasedSkills = await prisma.intellengenceBasedSkills.create({
     *   data: {
     *     // ... data to create a IntellengenceBasedSkills
     *   }
     * })
     * 
     */
    create<T extends IntellengenceBasedSkillsCreateArgs>(args: SelectSubset<T, IntellengenceBasedSkillsCreateArgs<ExtArgs>>): Prisma__IntellengenceBasedSkillsClient<$Result.GetResult<Prisma.$IntellengenceBasedSkillsPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many IntellengenceBasedSkills.
     * @param {IntellengenceBasedSkillsCreateManyArgs} args - Arguments to create many IntellengenceBasedSkills.
     * @example
     * // Create many IntellengenceBasedSkills
     * const intellengenceBasedSkills = await prisma.intellengenceBasedSkills.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends IntellengenceBasedSkillsCreateManyArgs>(args?: SelectSubset<T, IntellengenceBasedSkillsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many IntellengenceBasedSkills and returns the data saved in the database.
     * @param {IntellengenceBasedSkillsCreateManyAndReturnArgs} args - Arguments to create many IntellengenceBasedSkills.
     * @example
     * // Create many IntellengenceBasedSkills
     * const intellengenceBasedSkills = await prisma.intellengenceBasedSkills.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many IntellengenceBasedSkills and only return the `id`
     * const intellengenceBasedSkillsWithIdOnly = await prisma.intellengenceBasedSkills.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends IntellengenceBasedSkillsCreateManyAndReturnArgs>(args?: SelectSubset<T, IntellengenceBasedSkillsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IntellengenceBasedSkillsPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a IntellengenceBasedSkills.
     * @param {IntellengenceBasedSkillsDeleteArgs} args - Arguments to delete one IntellengenceBasedSkills.
     * @example
     * // Delete one IntellengenceBasedSkills
     * const IntellengenceBasedSkills = await prisma.intellengenceBasedSkills.delete({
     *   where: {
     *     // ... filter to delete one IntellengenceBasedSkills
     *   }
     * })
     * 
     */
    delete<T extends IntellengenceBasedSkillsDeleteArgs>(args: SelectSubset<T, IntellengenceBasedSkillsDeleteArgs<ExtArgs>>): Prisma__IntellengenceBasedSkillsClient<$Result.GetResult<Prisma.$IntellengenceBasedSkillsPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one IntellengenceBasedSkills.
     * @param {IntellengenceBasedSkillsUpdateArgs} args - Arguments to update one IntellengenceBasedSkills.
     * @example
     * // Update one IntellengenceBasedSkills
     * const intellengenceBasedSkills = await prisma.intellengenceBasedSkills.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends IntellengenceBasedSkillsUpdateArgs>(args: SelectSubset<T, IntellengenceBasedSkillsUpdateArgs<ExtArgs>>): Prisma__IntellengenceBasedSkillsClient<$Result.GetResult<Prisma.$IntellengenceBasedSkillsPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more IntellengenceBasedSkills.
     * @param {IntellengenceBasedSkillsDeleteManyArgs} args - Arguments to filter IntellengenceBasedSkills to delete.
     * @example
     * // Delete a few IntellengenceBasedSkills
     * const { count } = await prisma.intellengenceBasedSkills.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends IntellengenceBasedSkillsDeleteManyArgs>(args?: SelectSubset<T, IntellengenceBasedSkillsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more IntellengenceBasedSkills.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IntellengenceBasedSkillsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many IntellengenceBasedSkills
     * const intellengenceBasedSkills = await prisma.intellengenceBasedSkills.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends IntellengenceBasedSkillsUpdateManyArgs>(args: SelectSubset<T, IntellengenceBasedSkillsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more IntellengenceBasedSkills and returns the data updated in the database.
     * @param {IntellengenceBasedSkillsUpdateManyAndReturnArgs} args - Arguments to update many IntellengenceBasedSkills.
     * @example
     * // Update many IntellengenceBasedSkills
     * const intellengenceBasedSkills = await prisma.intellengenceBasedSkills.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more IntellengenceBasedSkills and only return the `id`
     * const intellengenceBasedSkillsWithIdOnly = await prisma.intellengenceBasedSkills.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends IntellengenceBasedSkillsUpdateManyAndReturnArgs>(args: SelectSubset<T, IntellengenceBasedSkillsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IntellengenceBasedSkillsPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one IntellengenceBasedSkills.
     * @param {IntellengenceBasedSkillsUpsertArgs} args - Arguments to update or create a IntellengenceBasedSkills.
     * @example
     * // Update or create a IntellengenceBasedSkills
     * const intellengenceBasedSkills = await prisma.intellengenceBasedSkills.upsert({
     *   create: {
     *     // ... data to create a IntellengenceBasedSkills
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the IntellengenceBasedSkills we want to update
     *   }
     * })
     */
    upsert<T extends IntellengenceBasedSkillsUpsertArgs>(args: SelectSubset<T, IntellengenceBasedSkillsUpsertArgs<ExtArgs>>): Prisma__IntellengenceBasedSkillsClient<$Result.GetResult<Prisma.$IntellengenceBasedSkillsPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of IntellengenceBasedSkills.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IntellengenceBasedSkillsCountArgs} args - Arguments to filter IntellengenceBasedSkills to count.
     * @example
     * // Count the number of IntellengenceBasedSkills
     * const count = await prisma.intellengenceBasedSkills.count({
     *   where: {
     *     // ... the filter for the IntellengenceBasedSkills we want to count
     *   }
     * })
    **/
    count<T extends IntellengenceBasedSkillsCountArgs>(
      args?: Subset<T, IntellengenceBasedSkillsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], IntellengenceBasedSkillsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a IntellengenceBasedSkills.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IntellengenceBasedSkillsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends IntellengenceBasedSkillsAggregateArgs>(args: Subset<T, IntellengenceBasedSkillsAggregateArgs>): Prisma.PrismaPromise<GetIntellengenceBasedSkillsAggregateType<T>>

    /**
     * Group by IntellengenceBasedSkills.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IntellengenceBasedSkillsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends IntellengenceBasedSkillsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: IntellengenceBasedSkillsGroupByArgs['orderBy'] }
        : { orderBy?: IntellengenceBasedSkillsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, IntellengenceBasedSkillsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetIntellengenceBasedSkillsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the IntellengenceBasedSkills model
   */
  readonly fields: IntellengenceBasedSkillsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for IntellengenceBasedSkills.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__IntellengenceBasedSkillsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    arcana<T extends IntellengenceBasedSkills$arcanaArgs<ExtArgs> = {}>(args?: Subset<T, IntellengenceBasedSkills$arcanaArgs<ExtArgs>>): Prisma__ArcanaSkillClient<$Result.GetResult<Prisma.$ArcanaSkillPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | null, null, ExtArgs, ClientOptions>
    history<T extends IntellengenceBasedSkills$historyArgs<ExtArgs> = {}>(args?: Subset<T, IntellengenceBasedSkills$historyArgs<ExtArgs>>): Prisma__HistorySkillClient<$Result.GetResult<Prisma.$HistorySkillPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | null, null, ExtArgs, ClientOptions>
    investigation<T extends IntellengenceBasedSkills$investigationArgs<ExtArgs> = {}>(args?: Subset<T, IntellengenceBasedSkills$investigationArgs<ExtArgs>>): Prisma__InvestigationSkillClient<$Result.GetResult<Prisma.$InvestigationSkillPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | null, null, ExtArgs, ClientOptions>
    nature<T extends IntellengenceBasedSkills$natureArgs<ExtArgs> = {}>(args?: Subset<T, IntellengenceBasedSkills$natureArgs<ExtArgs>>): Prisma__NatureSkillClient<$Result.GetResult<Prisma.$NatureSkillPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | null, null, ExtArgs, ClientOptions>
    religion<T extends IntellengenceBasedSkills$religionArgs<ExtArgs> = {}>(args?: Subset<T, IntellengenceBasedSkills$religionArgs<ExtArgs>>): Prisma__ReligionSkillClient<$Result.GetResult<Prisma.$ReligionSkillPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | null, null, ExtArgs, ClientOptions>
    skills_list_relation<T extends SkillsListDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SkillsListDefaultArgs<ExtArgs>>): Prisma__SkillsListClient<$Result.GetResult<Prisma.$SkillsListPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the IntellengenceBasedSkills model
   */ 
  interface IntellengenceBasedSkillsFieldRefs {
    readonly id: FieldRef<"IntellengenceBasedSkills", 'String'>
  }
    

  // Custom InputTypes
  /**
   * IntellengenceBasedSkills findUnique
   */
  export type IntellengenceBasedSkillsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IntellengenceBasedSkills
     */
    select?: IntellengenceBasedSkillsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IntellengenceBasedSkills
     */
    omit?: IntellengenceBasedSkillsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IntellengenceBasedSkillsInclude<ExtArgs> | null
    /**
     * Filter, which IntellengenceBasedSkills to fetch.
     */
    where: IntellengenceBasedSkillsWhereUniqueInput
  }

  /**
   * IntellengenceBasedSkills findUniqueOrThrow
   */
  export type IntellengenceBasedSkillsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IntellengenceBasedSkills
     */
    select?: IntellengenceBasedSkillsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IntellengenceBasedSkills
     */
    omit?: IntellengenceBasedSkillsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IntellengenceBasedSkillsInclude<ExtArgs> | null
    /**
     * Filter, which IntellengenceBasedSkills to fetch.
     */
    where: IntellengenceBasedSkillsWhereUniqueInput
  }

  /**
   * IntellengenceBasedSkills findFirst
   */
  export type IntellengenceBasedSkillsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IntellengenceBasedSkills
     */
    select?: IntellengenceBasedSkillsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IntellengenceBasedSkills
     */
    omit?: IntellengenceBasedSkillsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IntellengenceBasedSkillsInclude<ExtArgs> | null
    /**
     * Filter, which IntellengenceBasedSkills to fetch.
     */
    where?: IntellengenceBasedSkillsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IntellengenceBasedSkills to fetch.
     */
    orderBy?: IntellengenceBasedSkillsOrderByWithRelationInput | IntellengenceBasedSkillsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for IntellengenceBasedSkills.
     */
    cursor?: IntellengenceBasedSkillsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IntellengenceBasedSkills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IntellengenceBasedSkills.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of IntellengenceBasedSkills.
     */
    distinct?: IntellengenceBasedSkillsScalarFieldEnum | IntellengenceBasedSkillsScalarFieldEnum[]
  }

  /**
   * IntellengenceBasedSkills findFirstOrThrow
   */
  export type IntellengenceBasedSkillsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IntellengenceBasedSkills
     */
    select?: IntellengenceBasedSkillsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IntellengenceBasedSkills
     */
    omit?: IntellengenceBasedSkillsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IntellengenceBasedSkillsInclude<ExtArgs> | null
    /**
     * Filter, which IntellengenceBasedSkills to fetch.
     */
    where?: IntellengenceBasedSkillsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IntellengenceBasedSkills to fetch.
     */
    orderBy?: IntellengenceBasedSkillsOrderByWithRelationInput | IntellengenceBasedSkillsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for IntellengenceBasedSkills.
     */
    cursor?: IntellengenceBasedSkillsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IntellengenceBasedSkills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IntellengenceBasedSkills.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of IntellengenceBasedSkills.
     */
    distinct?: IntellengenceBasedSkillsScalarFieldEnum | IntellengenceBasedSkillsScalarFieldEnum[]
  }

  /**
   * IntellengenceBasedSkills findMany
   */
  export type IntellengenceBasedSkillsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IntellengenceBasedSkills
     */
    select?: IntellengenceBasedSkillsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IntellengenceBasedSkills
     */
    omit?: IntellengenceBasedSkillsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IntellengenceBasedSkillsInclude<ExtArgs> | null
    /**
     * Filter, which IntellengenceBasedSkills to fetch.
     */
    where?: IntellengenceBasedSkillsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IntellengenceBasedSkills to fetch.
     */
    orderBy?: IntellengenceBasedSkillsOrderByWithRelationInput | IntellengenceBasedSkillsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing IntellengenceBasedSkills.
     */
    cursor?: IntellengenceBasedSkillsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IntellengenceBasedSkills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IntellengenceBasedSkills.
     */
    skip?: number
    distinct?: IntellengenceBasedSkillsScalarFieldEnum | IntellengenceBasedSkillsScalarFieldEnum[]
  }

  /**
   * IntellengenceBasedSkills create
   */
  export type IntellengenceBasedSkillsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IntellengenceBasedSkills
     */
    select?: IntellengenceBasedSkillsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IntellengenceBasedSkills
     */
    omit?: IntellengenceBasedSkillsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IntellengenceBasedSkillsInclude<ExtArgs> | null
    /**
     * The data needed to create a IntellengenceBasedSkills.
     */
    data: XOR<IntellengenceBasedSkillsCreateInput, IntellengenceBasedSkillsUncheckedCreateInput>
  }

  /**
   * IntellengenceBasedSkills createMany
   */
  export type IntellengenceBasedSkillsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many IntellengenceBasedSkills.
     */
    data: IntellengenceBasedSkillsCreateManyInput | IntellengenceBasedSkillsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * IntellengenceBasedSkills createManyAndReturn
   */
  export type IntellengenceBasedSkillsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IntellengenceBasedSkills
     */
    select?: IntellengenceBasedSkillsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the IntellengenceBasedSkills
     */
    omit?: IntellengenceBasedSkillsOmit<ExtArgs> | null
    /**
     * The data used to create many IntellengenceBasedSkills.
     */
    data: IntellengenceBasedSkillsCreateManyInput | IntellengenceBasedSkillsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IntellengenceBasedSkillsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * IntellengenceBasedSkills update
   */
  export type IntellengenceBasedSkillsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IntellengenceBasedSkills
     */
    select?: IntellengenceBasedSkillsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IntellengenceBasedSkills
     */
    omit?: IntellengenceBasedSkillsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IntellengenceBasedSkillsInclude<ExtArgs> | null
    /**
     * The data needed to update a IntellengenceBasedSkills.
     */
    data: XOR<IntellengenceBasedSkillsUpdateInput, IntellengenceBasedSkillsUncheckedUpdateInput>
    /**
     * Choose, which IntellengenceBasedSkills to update.
     */
    where: IntellengenceBasedSkillsWhereUniqueInput
  }

  /**
   * IntellengenceBasedSkills updateMany
   */
  export type IntellengenceBasedSkillsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update IntellengenceBasedSkills.
     */
    data: XOR<IntellengenceBasedSkillsUpdateManyMutationInput, IntellengenceBasedSkillsUncheckedUpdateManyInput>
    /**
     * Filter which IntellengenceBasedSkills to update
     */
    where?: IntellengenceBasedSkillsWhereInput
    /**
     * Limit how many IntellengenceBasedSkills to update.
     */
    limit?: number
  }

  /**
   * IntellengenceBasedSkills updateManyAndReturn
   */
  export type IntellengenceBasedSkillsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IntellengenceBasedSkills
     */
    select?: IntellengenceBasedSkillsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the IntellengenceBasedSkills
     */
    omit?: IntellengenceBasedSkillsOmit<ExtArgs> | null
    /**
     * The data used to update IntellengenceBasedSkills.
     */
    data: XOR<IntellengenceBasedSkillsUpdateManyMutationInput, IntellengenceBasedSkillsUncheckedUpdateManyInput>
    /**
     * Filter which IntellengenceBasedSkills to update
     */
    where?: IntellengenceBasedSkillsWhereInput
    /**
     * Limit how many IntellengenceBasedSkills to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IntellengenceBasedSkillsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * IntellengenceBasedSkills upsert
   */
  export type IntellengenceBasedSkillsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IntellengenceBasedSkills
     */
    select?: IntellengenceBasedSkillsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IntellengenceBasedSkills
     */
    omit?: IntellengenceBasedSkillsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IntellengenceBasedSkillsInclude<ExtArgs> | null
    /**
     * The filter to search for the IntellengenceBasedSkills to update in case it exists.
     */
    where: IntellengenceBasedSkillsWhereUniqueInput
    /**
     * In case the IntellengenceBasedSkills found by the `where` argument doesn't exist, create a new IntellengenceBasedSkills with this data.
     */
    create: XOR<IntellengenceBasedSkillsCreateInput, IntellengenceBasedSkillsUncheckedCreateInput>
    /**
     * In case the IntellengenceBasedSkills was found with the provided `where` argument, update it with this data.
     */
    update: XOR<IntellengenceBasedSkillsUpdateInput, IntellengenceBasedSkillsUncheckedUpdateInput>
  }

  /**
   * IntellengenceBasedSkills delete
   */
  export type IntellengenceBasedSkillsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IntellengenceBasedSkills
     */
    select?: IntellengenceBasedSkillsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IntellengenceBasedSkills
     */
    omit?: IntellengenceBasedSkillsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IntellengenceBasedSkillsInclude<ExtArgs> | null
    /**
     * Filter which IntellengenceBasedSkills to delete.
     */
    where: IntellengenceBasedSkillsWhereUniqueInput
  }

  /**
   * IntellengenceBasedSkills deleteMany
   */
  export type IntellengenceBasedSkillsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which IntellengenceBasedSkills to delete
     */
    where?: IntellengenceBasedSkillsWhereInput
    /**
     * Limit how many IntellengenceBasedSkills to delete.
     */
    limit?: number
  }

  /**
   * IntellengenceBasedSkills.arcana
   */
  export type IntellengenceBasedSkills$arcanaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ArcanaSkill
     */
    select?: ArcanaSkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ArcanaSkill
     */
    omit?: ArcanaSkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArcanaSkillInclude<ExtArgs> | null
    where?: ArcanaSkillWhereInput
  }

  /**
   * IntellengenceBasedSkills.history
   */
  export type IntellengenceBasedSkills$historyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HistorySkill
     */
    select?: HistorySkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HistorySkill
     */
    omit?: HistorySkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HistorySkillInclude<ExtArgs> | null
    where?: HistorySkillWhereInput
  }

  /**
   * IntellengenceBasedSkills.investigation
   */
  export type IntellengenceBasedSkills$investigationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvestigationSkill
     */
    select?: InvestigationSkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvestigationSkill
     */
    omit?: InvestigationSkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvestigationSkillInclude<ExtArgs> | null
    where?: InvestigationSkillWhereInput
  }

  /**
   * IntellengenceBasedSkills.nature
   */
  export type IntellengenceBasedSkills$natureArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NatureSkill
     */
    select?: NatureSkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NatureSkill
     */
    omit?: NatureSkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NatureSkillInclude<ExtArgs> | null
    where?: NatureSkillWhereInput
  }

  /**
   * IntellengenceBasedSkills.religion
   */
  export type IntellengenceBasedSkills$religionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReligionSkill
     */
    select?: ReligionSkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReligionSkill
     */
    omit?: ReligionSkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReligionSkillInclude<ExtArgs> | null
    where?: ReligionSkillWhereInput
  }

  /**
   * IntellengenceBasedSkills without action
   */
  export type IntellengenceBasedSkillsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IntellengenceBasedSkills
     */
    select?: IntellengenceBasedSkillsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IntellengenceBasedSkills
     */
    omit?: IntellengenceBasedSkillsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IntellengenceBasedSkillsInclude<ExtArgs> | null
  }


  /**
   * Model WisdomBasedSkills
   */

  export type AggregateWisdomBasedSkills = {
    _count: WisdomBasedSkillsCountAggregateOutputType | null
    _min: WisdomBasedSkillsMinAggregateOutputType | null
    _max: WisdomBasedSkillsMaxAggregateOutputType | null
  }

  export type WisdomBasedSkillsMinAggregateOutputType = {
    id: string | null
  }

  export type WisdomBasedSkillsMaxAggregateOutputType = {
    id: string | null
  }

  export type WisdomBasedSkillsCountAggregateOutputType = {
    id: number
    _all: number
  }


  export type WisdomBasedSkillsMinAggregateInputType = {
    id?: true
  }

  export type WisdomBasedSkillsMaxAggregateInputType = {
    id?: true
  }

  export type WisdomBasedSkillsCountAggregateInputType = {
    id?: true
    _all?: true
  }

  export type WisdomBasedSkillsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WisdomBasedSkills to aggregate.
     */
    where?: WisdomBasedSkillsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WisdomBasedSkills to fetch.
     */
    orderBy?: WisdomBasedSkillsOrderByWithRelationInput | WisdomBasedSkillsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WisdomBasedSkillsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WisdomBasedSkills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WisdomBasedSkills.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned WisdomBasedSkills
    **/
    _count?: true | WisdomBasedSkillsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WisdomBasedSkillsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WisdomBasedSkillsMaxAggregateInputType
  }

  export type GetWisdomBasedSkillsAggregateType<T extends WisdomBasedSkillsAggregateArgs> = {
        [P in keyof T & keyof AggregateWisdomBasedSkills]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWisdomBasedSkills[P]>
      : GetScalarType<T[P], AggregateWisdomBasedSkills[P]>
  }




  export type WisdomBasedSkillsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WisdomBasedSkillsWhereInput
    orderBy?: WisdomBasedSkillsOrderByWithAggregationInput | WisdomBasedSkillsOrderByWithAggregationInput[]
    by: WisdomBasedSkillsScalarFieldEnum[] | WisdomBasedSkillsScalarFieldEnum
    having?: WisdomBasedSkillsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WisdomBasedSkillsCountAggregateInputType | true
    _min?: WisdomBasedSkillsMinAggregateInputType
    _max?: WisdomBasedSkillsMaxAggregateInputType
  }

  export type WisdomBasedSkillsGroupByOutputType = {
    id: string
    _count: WisdomBasedSkillsCountAggregateOutputType | null
    _min: WisdomBasedSkillsMinAggregateOutputType | null
    _max: WisdomBasedSkillsMaxAggregateOutputType | null
  }

  type GetWisdomBasedSkillsGroupByPayload<T extends WisdomBasedSkillsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WisdomBasedSkillsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WisdomBasedSkillsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WisdomBasedSkillsGroupByOutputType[P]>
            : GetScalarType<T[P], WisdomBasedSkillsGroupByOutputType[P]>
        }
      >
    >


  export type WisdomBasedSkillsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    animal_handling?: boolean | WisdomBasedSkills$animal_handlingArgs<ExtArgs>
    insight?: boolean | WisdomBasedSkills$insightArgs<ExtArgs>
    medicine?: boolean | WisdomBasedSkills$medicineArgs<ExtArgs>
    perception?: boolean | WisdomBasedSkills$perceptionArgs<ExtArgs>
    survival?: boolean | WisdomBasedSkills$survivalArgs<ExtArgs>
    skills_list_relation?: boolean | SkillsListDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["wisdomBasedSkills"]>

  export type WisdomBasedSkillsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    skills_list_relation?: boolean | SkillsListDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["wisdomBasedSkills"]>

  export type WisdomBasedSkillsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    skills_list_relation?: boolean | SkillsListDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["wisdomBasedSkills"]>

  export type WisdomBasedSkillsSelectScalar = {
    id?: boolean
  }

  export type WisdomBasedSkillsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id", ExtArgs["result"]["wisdomBasedSkills"]>
  export type WisdomBasedSkillsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    animal_handling?: boolean | WisdomBasedSkills$animal_handlingArgs<ExtArgs>
    insight?: boolean | WisdomBasedSkills$insightArgs<ExtArgs>
    medicine?: boolean | WisdomBasedSkills$medicineArgs<ExtArgs>
    perception?: boolean | WisdomBasedSkills$perceptionArgs<ExtArgs>
    survival?: boolean | WisdomBasedSkills$survivalArgs<ExtArgs>
    skills_list_relation?: boolean | SkillsListDefaultArgs<ExtArgs>
  }
  export type WisdomBasedSkillsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    skills_list_relation?: boolean | SkillsListDefaultArgs<ExtArgs>
  }
  export type WisdomBasedSkillsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    skills_list_relation?: boolean | SkillsListDefaultArgs<ExtArgs>
  }

  export type $WisdomBasedSkillsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "WisdomBasedSkills"
    objects: {
      animal_handling: Prisma.$AnimalHandlingSkillPayload<ExtArgs> | null
      insight: Prisma.$InsightSkillPayload<ExtArgs> | null
      medicine: Prisma.$MedicineSkillPayload<ExtArgs> | null
      perception: Prisma.$PerceptionSkillPayload<ExtArgs> | null
      survival: Prisma.$SurvivalSkillPayload<ExtArgs> | null
      skills_list_relation: Prisma.$SkillsListPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
    }, ExtArgs["result"]["wisdomBasedSkills"]>
    composites: {}
  }

  type WisdomBasedSkillsGetPayload<S extends boolean | null | undefined | WisdomBasedSkillsDefaultArgs> = $Result.GetResult<Prisma.$WisdomBasedSkillsPayload, S>

  type WisdomBasedSkillsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<WisdomBasedSkillsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: WisdomBasedSkillsCountAggregateInputType | true
    }

  export interface WisdomBasedSkillsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['WisdomBasedSkills'], meta: { name: 'WisdomBasedSkills' } }
    /**
     * Find zero or one WisdomBasedSkills that matches the filter.
     * @param {WisdomBasedSkillsFindUniqueArgs} args - Arguments to find a WisdomBasedSkills
     * @example
     * // Get one WisdomBasedSkills
     * const wisdomBasedSkills = await prisma.wisdomBasedSkills.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WisdomBasedSkillsFindUniqueArgs>(args: SelectSubset<T, WisdomBasedSkillsFindUniqueArgs<ExtArgs>>): Prisma__WisdomBasedSkillsClient<$Result.GetResult<Prisma.$WisdomBasedSkillsPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one WisdomBasedSkills that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {WisdomBasedSkillsFindUniqueOrThrowArgs} args - Arguments to find a WisdomBasedSkills
     * @example
     * // Get one WisdomBasedSkills
     * const wisdomBasedSkills = await prisma.wisdomBasedSkills.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WisdomBasedSkillsFindUniqueOrThrowArgs>(args: SelectSubset<T, WisdomBasedSkillsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WisdomBasedSkillsClient<$Result.GetResult<Prisma.$WisdomBasedSkillsPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first WisdomBasedSkills that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WisdomBasedSkillsFindFirstArgs} args - Arguments to find a WisdomBasedSkills
     * @example
     * // Get one WisdomBasedSkills
     * const wisdomBasedSkills = await prisma.wisdomBasedSkills.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WisdomBasedSkillsFindFirstArgs>(args?: SelectSubset<T, WisdomBasedSkillsFindFirstArgs<ExtArgs>>): Prisma__WisdomBasedSkillsClient<$Result.GetResult<Prisma.$WisdomBasedSkillsPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first WisdomBasedSkills that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WisdomBasedSkillsFindFirstOrThrowArgs} args - Arguments to find a WisdomBasedSkills
     * @example
     * // Get one WisdomBasedSkills
     * const wisdomBasedSkills = await prisma.wisdomBasedSkills.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WisdomBasedSkillsFindFirstOrThrowArgs>(args?: SelectSubset<T, WisdomBasedSkillsFindFirstOrThrowArgs<ExtArgs>>): Prisma__WisdomBasedSkillsClient<$Result.GetResult<Prisma.$WisdomBasedSkillsPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more WisdomBasedSkills that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WisdomBasedSkillsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WisdomBasedSkills
     * const wisdomBasedSkills = await prisma.wisdomBasedSkills.findMany()
     * 
     * // Get first 10 WisdomBasedSkills
     * const wisdomBasedSkills = await prisma.wisdomBasedSkills.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const wisdomBasedSkillsWithIdOnly = await prisma.wisdomBasedSkills.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WisdomBasedSkillsFindManyArgs>(args?: SelectSubset<T, WisdomBasedSkillsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WisdomBasedSkillsPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a WisdomBasedSkills.
     * @param {WisdomBasedSkillsCreateArgs} args - Arguments to create a WisdomBasedSkills.
     * @example
     * // Create one WisdomBasedSkills
     * const WisdomBasedSkills = await prisma.wisdomBasedSkills.create({
     *   data: {
     *     // ... data to create a WisdomBasedSkills
     *   }
     * })
     * 
     */
    create<T extends WisdomBasedSkillsCreateArgs>(args: SelectSubset<T, WisdomBasedSkillsCreateArgs<ExtArgs>>): Prisma__WisdomBasedSkillsClient<$Result.GetResult<Prisma.$WisdomBasedSkillsPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many WisdomBasedSkills.
     * @param {WisdomBasedSkillsCreateManyArgs} args - Arguments to create many WisdomBasedSkills.
     * @example
     * // Create many WisdomBasedSkills
     * const wisdomBasedSkills = await prisma.wisdomBasedSkills.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WisdomBasedSkillsCreateManyArgs>(args?: SelectSubset<T, WisdomBasedSkillsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many WisdomBasedSkills and returns the data saved in the database.
     * @param {WisdomBasedSkillsCreateManyAndReturnArgs} args - Arguments to create many WisdomBasedSkills.
     * @example
     * // Create many WisdomBasedSkills
     * const wisdomBasedSkills = await prisma.wisdomBasedSkills.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many WisdomBasedSkills and only return the `id`
     * const wisdomBasedSkillsWithIdOnly = await prisma.wisdomBasedSkills.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends WisdomBasedSkillsCreateManyAndReturnArgs>(args?: SelectSubset<T, WisdomBasedSkillsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WisdomBasedSkillsPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a WisdomBasedSkills.
     * @param {WisdomBasedSkillsDeleteArgs} args - Arguments to delete one WisdomBasedSkills.
     * @example
     * // Delete one WisdomBasedSkills
     * const WisdomBasedSkills = await prisma.wisdomBasedSkills.delete({
     *   where: {
     *     // ... filter to delete one WisdomBasedSkills
     *   }
     * })
     * 
     */
    delete<T extends WisdomBasedSkillsDeleteArgs>(args: SelectSubset<T, WisdomBasedSkillsDeleteArgs<ExtArgs>>): Prisma__WisdomBasedSkillsClient<$Result.GetResult<Prisma.$WisdomBasedSkillsPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one WisdomBasedSkills.
     * @param {WisdomBasedSkillsUpdateArgs} args - Arguments to update one WisdomBasedSkills.
     * @example
     * // Update one WisdomBasedSkills
     * const wisdomBasedSkills = await prisma.wisdomBasedSkills.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WisdomBasedSkillsUpdateArgs>(args: SelectSubset<T, WisdomBasedSkillsUpdateArgs<ExtArgs>>): Prisma__WisdomBasedSkillsClient<$Result.GetResult<Prisma.$WisdomBasedSkillsPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more WisdomBasedSkills.
     * @param {WisdomBasedSkillsDeleteManyArgs} args - Arguments to filter WisdomBasedSkills to delete.
     * @example
     * // Delete a few WisdomBasedSkills
     * const { count } = await prisma.wisdomBasedSkills.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WisdomBasedSkillsDeleteManyArgs>(args?: SelectSubset<T, WisdomBasedSkillsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WisdomBasedSkills.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WisdomBasedSkillsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WisdomBasedSkills
     * const wisdomBasedSkills = await prisma.wisdomBasedSkills.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WisdomBasedSkillsUpdateManyArgs>(args: SelectSubset<T, WisdomBasedSkillsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WisdomBasedSkills and returns the data updated in the database.
     * @param {WisdomBasedSkillsUpdateManyAndReturnArgs} args - Arguments to update many WisdomBasedSkills.
     * @example
     * // Update many WisdomBasedSkills
     * const wisdomBasedSkills = await prisma.wisdomBasedSkills.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more WisdomBasedSkills and only return the `id`
     * const wisdomBasedSkillsWithIdOnly = await prisma.wisdomBasedSkills.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends WisdomBasedSkillsUpdateManyAndReturnArgs>(args: SelectSubset<T, WisdomBasedSkillsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WisdomBasedSkillsPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one WisdomBasedSkills.
     * @param {WisdomBasedSkillsUpsertArgs} args - Arguments to update or create a WisdomBasedSkills.
     * @example
     * // Update or create a WisdomBasedSkills
     * const wisdomBasedSkills = await prisma.wisdomBasedSkills.upsert({
     *   create: {
     *     // ... data to create a WisdomBasedSkills
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WisdomBasedSkills we want to update
     *   }
     * })
     */
    upsert<T extends WisdomBasedSkillsUpsertArgs>(args: SelectSubset<T, WisdomBasedSkillsUpsertArgs<ExtArgs>>): Prisma__WisdomBasedSkillsClient<$Result.GetResult<Prisma.$WisdomBasedSkillsPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of WisdomBasedSkills.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WisdomBasedSkillsCountArgs} args - Arguments to filter WisdomBasedSkills to count.
     * @example
     * // Count the number of WisdomBasedSkills
     * const count = await prisma.wisdomBasedSkills.count({
     *   where: {
     *     // ... the filter for the WisdomBasedSkills we want to count
     *   }
     * })
    **/
    count<T extends WisdomBasedSkillsCountArgs>(
      args?: Subset<T, WisdomBasedSkillsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WisdomBasedSkillsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WisdomBasedSkills.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WisdomBasedSkillsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WisdomBasedSkillsAggregateArgs>(args: Subset<T, WisdomBasedSkillsAggregateArgs>): Prisma.PrismaPromise<GetWisdomBasedSkillsAggregateType<T>>

    /**
     * Group by WisdomBasedSkills.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WisdomBasedSkillsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WisdomBasedSkillsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WisdomBasedSkillsGroupByArgs['orderBy'] }
        : { orderBy?: WisdomBasedSkillsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WisdomBasedSkillsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWisdomBasedSkillsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the WisdomBasedSkills model
   */
  readonly fields: WisdomBasedSkillsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for WisdomBasedSkills.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WisdomBasedSkillsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    animal_handling<T extends WisdomBasedSkills$animal_handlingArgs<ExtArgs> = {}>(args?: Subset<T, WisdomBasedSkills$animal_handlingArgs<ExtArgs>>): Prisma__AnimalHandlingSkillClient<$Result.GetResult<Prisma.$AnimalHandlingSkillPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | null, null, ExtArgs, ClientOptions>
    insight<T extends WisdomBasedSkills$insightArgs<ExtArgs> = {}>(args?: Subset<T, WisdomBasedSkills$insightArgs<ExtArgs>>): Prisma__InsightSkillClient<$Result.GetResult<Prisma.$InsightSkillPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | null, null, ExtArgs, ClientOptions>
    medicine<T extends WisdomBasedSkills$medicineArgs<ExtArgs> = {}>(args?: Subset<T, WisdomBasedSkills$medicineArgs<ExtArgs>>): Prisma__MedicineSkillClient<$Result.GetResult<Prisma.$MedicineSkillPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | null, null, ExtArgs, ClientOptions>
    perception<T extends WisdomBasedSkills$perceptionArgs<ExtArgs> = {}>(args?: Subset<T, WisdomBasedSkills$perceptionArgs<ExtArgs>>): Prisma__PerceptionSkillClient<$Result.GetResult<Prisma.$PerceptionSkillPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | null, null, ExtArgs, ClientOptions>
    survival<T extends WisdomBasedSkills$survivalArgs<ExtArgs> = {}>(args?: Subset<T, WisdomBasedSkills$survivalArgs<ExtArgs>>): Prisma__SurvivalSkillClient<$Result.GetResult<Prisma.$SurvivalSkillPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | null, null, ExtArgs, ClientOptions>
    skills_list_relation<T extends SkillsListDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SkillsListDefaultArgs<ExtArgs>>): Prisma__SkillsListClient<$Result.GetResult<Prisma.$SkillsListPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the WisdomBasedSkills model
   */ 
  interface WisdomBasedSkillsFieldRefs {
    readonly id: FieldRef<"WisdomBasedSkills", 'String'>
  }
    

  // Custom InputTypes
  /**
   * WisdomBasedSkills findUnique
   */
  export type WisdomBasedSkillsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WisdomBasedSkills
     */
    select?: WisdomBasedSkillsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WisdomBasedSkills
     */
    omit?: WisdomBasedSkillsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WisdomBasedSkillsInclude<ExtArgs> | null
    /**
     * Filter, which WisdomBasedSkills to fetch.
     */
    where: WisdomBasedSkillsWhereUniqueInput
  }

  /**
   * WisdomBasedSkills findUniqueOrThrow
   */
  export type WisdomBasedSkillsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WisdomBasedSkills
     */
    select?: WisdomBasedSkillsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WisdomBasedSkills
     */
    omit?: WisdomBasedSkillsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WisdomBasedSkillsInclude<ExtArgs> | null
    /**
     * Filter, which WisdomBasedSkills to fetch.
     */
    where: WisdomBasedSkillsWhereUniqueInput
  }

  /**
   * WisdomBasedSkills findFirst
   */
  export type WisdomBasedSkillsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WisdomBasedSkills
     */
    select?: WisdomBasedSkillsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WisdomBasedSkills
     */
    omit?: WisdomBasedSkillsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WisdomBasedSkillsInclude<ExtArgs> | null
    /**
     * Filter, which WisdomBasedSkills to fetch.
     */
    where?: WisdomBasedSkillsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WisdomBasedSkills to fetch.
     */
    orderBy?: WisdomBasedSkillsOrderByWithRelationInput | WisdomBasedSkillsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WisdomBasedSkills.
     */
    cursor?: WisdomBasedSkillsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WisdomBasedSkills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WisdomBasedSkills.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WisdomBasedSkills.
     */
    distinct?: WisdomBasedSkillsScalarFieldEnum | WisdomBasedSkillsScalarFieldEnum[]
  }

  /**
   * WisdomBasedSkills findFirstOrThrow
   */
  export type WisdomBasedSkillsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WisdomBasedSkills
     */
    select?: WisdomBasedSkillsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WisdomBasedSkills
     */
    omit?: WisdomBasedSkillsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WisdomBasedSkillsInclude<ExtArgs> | null
    /**
     * Filter, which WisdomBasedSkills to fetch.
     */
    where?: WisdomBasedSkillsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WisdomBasedSkills to fetch.
     */
    orderBy?: WisdomBasedSkillsOrderByWithRelationInput | WisdomBasedSkillsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WisdomBasedSkills.
     */
    cursor?: WisdomBasedSkillsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WisdomBasedSkills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WisdomBasedSkills.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WisdomBasedSkills.
     */
    distinct?: WisdomBasedSkillsScalarFieldEnum | WisdomBasedSkillsScalarFieldEnum[]
  }

  /**
   * WisdomBasedSkills findMany
   */
  export type WisdomBasedSkillsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WisdomBasedSkills
     */
    select?: WisdomBasedSkillsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WisdomBasedSkills
     */
    omit?: WisdomBasedSkillsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WisdomBasedSkillsInclude<ExtArgs> | null
    /**
     * Filter, which WisdomBasedSkills to fetch.
     */
    where?: WisdomBasedSkillsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WisdomBasedSkills to fetch.
     */
    orderBy?: WisdomBasedSkillsOrderByWithRelationInput | WisdomBasedSkillsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing WisdomBasedSkills.
     */
    cursor?: WisdomBasedSkillsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WisdomBasedSkills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WisdomBasedSkills.
     */
    skip?: number
    distinct?: WisdomBasedSkillsScalarFieldEnum | WisdomBasedSkillsScalarFieldEnum[]
  }

  /**
   * WisdomBasedSkills create
   */
  export type WisdomBasedSkillsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WisdomBasedSkills
     */
    select?: WisdomBasedSkillsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WisdomBasedSkills
     */
    omit?: WisdomBasedSkillsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WisdomBasedSkillsInclude<ExtArgs> | null
    /**
     * The data needed to create a WisdomBasedSkills.
     */
    data: XOR<WisdomBasedSkillsCreateInput, WisdomBasedSkillsUncheckedCreateInput>
  }

  /**
   * WisdomBasedSkills createMany
   */
  export type WisdomBasedSkillsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many WisdomBasedSkills.
     */
    data: WisdomBasedSkillsCreateManyInput | WisdomBasedSkillsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * WisdomBasedSkills createManyAndReturn
   */
  export type WisdomBasedSkillsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WisdomBasedSkills
     */
    select?: WisdomBasedSkillsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the WisdomBasedSkills
     */
    omit?: WisdomBasedSkillsOmit<ExtArgs> | null
    /**
     * The data used to create many WisdomBasedSkills.
     */
    data: WisdomBasedSkillsCreateManyInput | WisdomBasedSkillsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WisdomBasedSkillsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * WisdomBasedSkills update
   */
  export type WisdomBasedSkillsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WisdomBasedSkills
     */
    select?: WisdomBasedSkillsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WisdomBasedSkills
     */
    omit?: WisdomBasedSkillsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WisdomBasedSkillsInclude<ExtArgs> | null
    /**
     * The data needed to update a WisdomBasedSkills.
     */
    data: XOR<WisdomBasedSkillsUpdateInput, WisdomBasedSkillsUncheckedUpdateInput>
    /**
     * Choose, which WisdomBasedSkills to update.
     */
    where: WisdomBasedSkillsWhereUniqueInput
  }

  /**
   * WisdomBasedSkills updateMany
   */
  export type WisdomBasedSkillsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update WisdomBasedSkills.
     */
    data: XOR<WisdomBasedSkillsUpdateManyMutationInput, WisdomBasedSkillsUncheckedUpdateManyInput>
    /**
     * Filter which WisdomBasedSkills to update
     */
    where?: WisdomBasedSkillsWhereInput
    /**
     * Limit how many WisdomBasedSkills to update.
     */
    limit?: number
  }

  /**
   * WisdomBasedSkills updateManyAndReturn
   */
  export type WisdomBasedSkillsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WisdomBasedSkills
     */
    select?: WisdomBasedSkillsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the WisdomBasedSkills
     */
    omit?: WisdomBasedSkillsOmit<ExtArgs> | null
    /**
     * The data used to update WisdomBasedSkills.
     */
    data: XOR<WisdomBasedSkillsUpdateManyMutationInput, WisdomBasedSkillsUncheckedUpdateManyInput>
    /**
     * Filter which WisdomBasedSkills to update
     */
    where?: WisdomBasedSkillsWhereInput
    /**
     * Limit how many WisdomBasedSkills to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WisdomBasedSkillsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * WisdomBasedSkills upsert
   */
  export type WisdomBasedSkillsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WisdomBasedSkills
     */
    select?: WisdomBasedSkillsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WisdomBasedSkills
     */
    omit?: WisdomBasedSkillsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WisdomBasedSkillsInclude<ExtArgs> | null
    /**
     * The filter to search for the WisdomBasedSkills to update in case it exists.
     */
    where: WisdomBasedSkillsWhereUniqueInput
    /**
     * In case the WisdomBasedSkills found by the `where` argument doesn't exist, create a new WisdomBasedSkills with this data.
     */
    create: XOR<WisdomBasedSkillsCreateInput, WisdomBasedSkillsUncheckedCreateInput>
    /**
     * In case the WisdomBasedSkills was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WisdomBasedSkillsUpdateInput, WisdomBasedSkillsUncheckedUpdateInput>
  }

  /**
   * WisdomBasedSkills delete
   */
  export type WisdomBasedSkillsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WisdomBasedSkills
     */
    select?: WisdomBasedSkillsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WisdomBasedSkills
     */
    omit?: WisdomBasedSkillsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WisdomBasedSkillsInclude<ExtArgs> | null
    /**
     * Filter which WisdomBasedSkills to delete.
     */
    where: WisdomBasedSkillsWhereUniqueInput
  }

  /**
   * WisdomBasedSkills deleteMany
   */
  export type WisdomBasedSkillsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WisdomBasedSkills to delete
     */
    where?: WisdomBasedSkillsWhereInput
    /**
     * Limit how many WisdomBasedSkills to delete.
     */
    limit?: number
  }

  /**
   * WisdomBasedSkills.animal_handling
   */
  export type WisdomBasedSkills$animal_handlingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnimalHandlingSkill
     */
    select?: AnimalHandlingSkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnimalHandlingSkill
     */
    omit?: AnimalHandlingSkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnimalHandlingSkillInclude<ExtArgs> | null
    where?: AnimalHandlingSkillWhereInput
  }

  /**
   * WisdomBasedSkills.insight
   */
  export type WisdomBasedSkills$insightArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InsightSkill
     */
    select?: InsightSkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InsightSkill
     */
    omit?: InsightSkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InsightSkillInclude<ExtArgs> | null
    where?: InsightSkillWhereInput
  }

  /**
   * WisdomBasedSkills.medicine
   */
  export type WisdomBasedSkills$medicineArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicineSkill
     */
    select?: MedicineSkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MedicineSkill
     */
    omit?: MedicineSkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicineSkillInclude<ExtArgs> | null
    where?: MedicineSkillWhereInput
  }

  /**
   * WisdomBasedSkills.perception
   */
  export type WisdomBasedSkills$perceptionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PerceptionSkill
     */
    select?: PerceptionSkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PerceptionSkill
     */
    omit?: PerceptionSkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PerceptionSkillInclude<ExtArgs> | null
    where?: PerceptionSkillWhereInput
  }

  /**
   * WisdomBasedSkills.survival
   */
  export type WisdomBasedSkills$survivalArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SurvivalSkill
     */
    select?: SurvivalSkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SurvivalSkill
     */
    omit?: SurvivalSkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SurvivalSkillInclude<ExtArgs> | null
    where?: SurvivalSkillWhereInput
  }

  /**
   * WisdomBasedSkills without action
   */
  export type WisdomBasedSkillsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WisdomBasedSkills
     */
    select?: WisdomBasedSkillsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WisdomBasedSkills
     */
    omit?: WisdomBasedSkillsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WisdomBasedSkillsInclude<ExtArgs> | null
  }


  /**
   * Model CharismaBasedSkills
   */

  export type AggregateCharismaBasedSkills = {
    _count: CharismaBasedSkillsCountAggregateOutputType | null
    _min: CharismaBasedSkillsMinAggregateOutputType | null
    _max: CharismaBasedSkillsMaxAggregateOutputType | null
  }

  export type CharismaBasedSkillsMinAggregateOutputType = {
    id: string | null
  }

  export type CharismaBasedSkillsMaxAggregateOutputType = {
    id: string | null
  }

  export type CharismaBasedSkillsCountAggregateOutputType = {
    id: number
    _all: number
  }


  export type CharismaBasedSkillsMinAggregateInputType = {
    id?: true
  }

  export type CharismaBasedSkillsMaxAggregateInputType = {
    id?: true
  }

  export type CharismaBasedSkillsCountAggregateInputType = {
    id?: true
    _all?: true
  }

  export type CharismaBasedSkillsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CharismaBasedSkills to aggregate.
     */
    where?: CharismaBasedSkillsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CharismaBasedSkills to fetch.
     */
    orderBy?: CharismaBasedSkillsOrderByWithRelationInput | CharismaBasedSkillsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CharismaBasedSkillsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CharismaBasedSkills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CharismaBasedSkills.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CharismaBasedSkills
    **/
    _count?: true | CharismaBasedSkillsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CharismaBasedSkillsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CharismaBasedSkillsMaxAggregateInputType
  }

  export type GetCharismaBasedSkillsAggregateType<T extends CharismaBasedSkillsAggregateArgs> = {
        [P in keyof T & keyof AggregateCharismaBasedSkills]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCharismaBasedSkills[P]>
      : GetScalarType<T[P], AggregateCharismaBasedSkills[P]>
  }




  export type CharismaBasedSkillsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CharismaBasedSkillsWhereInput
    orderBy?: CharismaBasedSkillsOrderByWithAggregationInput | CharismaBasedSkillsOrderByWithAggregationInput[]
    by: CharismaBasedSkillsScalarFieldEnum[] | CharismaBasedSkillsScalarFieldEnum
    having?: CharismaBasedSkillsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CharismaBasedSkillsCountAggregateInputType | true
    _min?: CharismaBasedSkillsMinAggregateInputType
    _max?: CharismaBasedSkillsMaxAggregateInputType
  }

  export type CharismaBasedSkillsGroupByOutputType = {
    id: string
    _count: CharismaBasedSkillsCountAggregateOutputType | null
    _min: CharismaBasedSkillsMinAggregateOutputType | null
    _max: CharismaBasedSkillsMaxAggregateOutputType | null
  }

  type GetCharismaBasedSkillsGroupByPayload<T extends CharismaBasedSkillsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CharismaBasedSkillsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CharismaBasedSkillsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CharismaBasedSkillsGroupByOutputType[P]>
            : GetScalarType<T[P], CharismaBasedSkillsGroupByOutputType[P]>
        }
      >
    >


  export type CharismaBasedSkillsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    deception?: boolean | CharismaBasedSkills$deceptionArgs<ExtArgs>
    intimidation?: boolean | CharismaBasedSkills$intimidationArgs<ExtArgs>
    performance?: boolean | CharismaBasedSkills$performanceArgs<ExtArgs>
    persuasion?: boolean | CharismaBasedSkills$persuasionArgs<ExtArgs>
    skills_list_relation?: boolean | SkillsListDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["charismaBasedSkills"]>

  export type CharismaBasedSkillsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    skills_list_relation?: boolean | SkillsListDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["charismaBasedSkills"]>

  export type CharismaBasedSkillsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    skills_list_relation?: boolean | SkillsListDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["charismaBasedSkills"]>

  export type CharismaBasedSkillsSelectScalar = {
    id?: boolean
  }

  export type CharismaBasedSkillsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id", ExtArgs["result"]["charismaBasedSkills"]>
  export type CharismaBasedSkillsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    deception?: boolean | CharismaBasedSkills$deceptionArgs<ExtArgs>
    intimidation?: boolean | CharismaBasedSkills$intimidationArgs<ExtArgs>
    performance?: boolean | CharismaBasedSkills$performanceArgs<ExtArgs>
    persuasion?: boolean | CharismaBasedSkills$persuasionArgs<ExtArgs>
    skills_list_relation?: boolean | SkillsListDefaultArgs<ExtArgs>
  }
  export type CharismaBasedSkillsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    skills_list_relation?: boolean | SkillsListDefaultArgs<ExtArgs>
  }
  export type CharismaBasedSkillsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    skills_list_relation?: boolean | SkillsListDefaultArgs<ExtArgs>
  }

  export type $CharismaBasedSkillsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CharismaBasedSkills"
    objects: {
      deception: Prisma.$DeceptionSkillPayload<ExtArgs> | null
      intimidation: Prisma.$IntimidationSkillPayload<ExtArgs> | null
      performance: Prisma.$PerformanceSkillPayload<ExtArgs> | null
      persuasion: Prisma.$PersuasionSkillPayload<ExtArgs> | null
      skills_list_relation: Prisma.$SkillsListPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
    }, ExtArgs["result"]["charismaBasedSkills"]>
    composites: {}
  }

  type CharismaBasedSkillsGetPayload<S extends boolean | null | undefined | CharismaBasedSkillsDefaultArgs> = $Result.GetResult<Prisma.$CharismaBasedSkillsPayload, S>

  type CharismaBasedSkillsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CharismaBasedSkillsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CharismaBasedSkillsCountAggregateInputType | true
    }

  export interface CharismaBasedSkillsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CharismaBasedSkills'], meta: { name: 'CharismaBasedSkills' } }
    /**
     * Find zero or one CharismaBasedSkills that matches the filter.
     * @param {CharismaBasedSkillsFindUniqueArgs} args - Arguments to find a CharismaBasedSkills
     * @example
     * // Get one CharismaBasedSkills
     * const charismaBasedSkills = await prisma.charismaBasedSkills.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CharismaBasedSkillsFindUniqueArgs>(args: SelectSubset<T, CharismaBasedSkillsFindUniqueArgs<ExtArgs>>): Prisma__CharismaBasedSkillsClient<$Result.GetResult<Prisma.$CharismaBasedSkillsPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one CharismaBasedSkills that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CharismaBasedSkillsFindUniqueOrThrowArgs} args - Arguments to find a CharismaBasedSkills
     * @example
     * // Get one CharismaBasedSkills
     * const charismaBasedSkills = await prisma.charismaBasedSkills.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CharismaBasedSkillsFindUniqueOrThrowArgs>(args: SelectSubset<T, CharismaBasedSkillsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CharismaBasedSkillsClient<$Result.GetResult<Prisma.$CharismaBasedSkillsPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first CharismaBasedSkills that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CharismaBasedSkillsFindFirstArgs} args - Arguments to find a CharismaBasedSkills
     * @example
     * // Get one CharismaBasedSkills
     * const charismaBasedSkills = await prisma.charismaBasedSkills.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CharismaBasedSkillsFindFirstArgs>(args?: SelectSubset<T, CharismaBasedSkillsFindFirstArgs<ExtArgs>>): Prisma__CharismaBasedSkillsClient<$Result.GetResult<Prisma.$CharismaBasedSkillsPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first CharismaBasedSkills that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CharismaBasedSkillsFindFirstOrThrowArgs} args - Arguments to find a CharismaBasedSkills
     * @example
     * // Get one CharismaBasedSkills
     * const charismaBasedSkills = await prisma.charismaBasedSkills.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CharismaBasedSkillsFindFirstOrThrowArgs>(args?: SelectSubset<T, CharismaBasedSkillsFindFirstOrThrowArgs<ExtArgs>>): Prisma__CharismaBasedSkillsClient<$Result.GetResult<Prisma.$CharismaBasedSkillsPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more CharismaBasedSkills that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CharismaBasedSkillsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CharismaBasedSkills
     * const charismaBasedSkills = await prisma.charismaBasedSkills.findMany()
     * 
     * // Get first 10 CharismaBasedSkills
     * const charismaBasedSkills = await prisma.charismaBasedSkills.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const charismaBasedSkillsWithIdOnly = await prisma.charismaBasedSkills.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CharismaBasedSkillsFindManyArgs>(args?: SelectSubset<T, CharismaBasedSkillsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CharismaBasedSkillsPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a CharismaBasedSkills.
     * @param {CharismaBasedSkillsCreateArgs} args - Arguments to create a CharismaBasedSkills.
     * @example
     * // Create one CharismaBasedSkills
     * const CharismaBasedSkills = await prisma.charismaBasedSkills.create({
     *   data: {
     *     // ... data to create a CharismaBasedSkills
     *   }
     * })
     * 
     */
    create<T extends CharismaBasedSkillsCreateArgs>(args: SelectSubset<T, CharismaBasedSkillsCreateArgs<ExtArgs>>): Prisma__CharismaBasedSkillsClient<$Result.GetResult<Prisma.$CharismaBasedSkillsPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many CharismaBasedSkills.
     * @param {CharismaBasedSkillsCreateManyArgs} args - Arguments to create many CharismaBasedSkills.
     * @example
     * // Create many CharismaBasedSkills
     * const charismaBasedSkills = await prisma.charismaBasedSkills.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CharismaBasedSkillsCreateManyArgs>(args?: SelectSubset<T, CharismaBasedSkillsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CharismaBasedSkills and returns the data saved in the database.
     * @param {CharismaBasedSkillsCreateManyAndReturnArgs} args - Arguments to create many CharismaBasedSkills.
     * @example
     * // Create many CharismaBasedSkills
     * const charismaBasedSkills = await prisma.charismaBasedSkills.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CharismaBasedSkills and only return the `id`
     * const charismaBasedSkillsWithIdOnly = await prisma.charismaBasedSkills.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CharismaBasedSkillsCreateManyAndReturnArgs>(args?: SelectSubset<T, CharismaBasedSkillsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CharismaBasedSkillsPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a CharismaBasedSkills.
     * @param {CharismaBasedSkillsDeleteArgs} args - Arguments to delete one CharismaBasedSkills.
     * @example
     * // Delete one CharismaBasedSkills
     * const CharismaBasedSkills = await prisma.charismaBasedSkills.delete({
     *   where: {
     *     // ... filter to delete one CharismaBasedSkills
     *   }
     * })
     * 
     */
    delete<T extends CharismaBasedSkillsDeleteArgs>(args: SelectSubset<T, CharismaBasedSkillsDeleteArgs<ExtArgs>>): Prisma__CharismaBasedSkillsClient<$Result.GetResult<Prisma.$CharismaBasedSkillsPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one CharismaBasedSkills.
     * @param {CharismaBasedSkillsUpdateArgs} args - Arguments to update one CharismaBasedSkills.
     * @example
     * // Update one CharismaBasedSkills
     * const charismaBasedSkills = await prisma.charismaBasedSkills.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CharismaBasedSkillsUpdateArgs>(args: SelectSubset<T, CharismaBasedSkillsUpdateArgs<ExtArgs>>): Prisma__CharismaBasedSkillsClient<$Result.GetResult<Prisma.$CharismaBasedSkillsPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more CharismaBasedSkills.
     * @param {CharismaBasedSkillsDeleteManyArgs} args - Arguments to filter CharismaBasedSkills to delete.
     * @example
     * // Delete a few CharismaBasedSkills
     * const { count } = await prisma.charismaBasedSkills.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CharismaBasedSkillsDeleteManyArgs>(args?: SelectSubset<T, CharismaBasedSkillsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CharismaBasedSkills.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CharismaBasedSkillsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CharismaBasedSkills
     * const charismaBasedSkills = await prisma.charismaBasedSkills.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CharismaBasedSkillsUpdateManyArgs>(args: SelectSubset<T, CharismaBasedSkillsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CharismaBasedSkills and returns the data updated in the database.
     * @param {CharismaBasedSkillsUpdateManyAndReturnArgs} args - Arguments to update many CharismaBasedSkills.
     * @example
     * // Update many CharismaBasedSkills
     * const charismaBasedSkills = await prisma.charismaBasedSkills.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CharismaBasedSkills and only return the `id`
     * const charismaBasedSkillsWithIdOnly = await prisma.charismaBasedSkills.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CharismaBasedSkillsUpdateManyAndReturnArgs>(args: SelectSubset<T, CharismaBasedSkillsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CharismaBasedSkillsPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one CharismaBasedSkills.
     * @param {CharismaBasedSkillsUpsertArgs} args - Arguments to update or create a CharismaBasedSkills.
     * @example
     * // Update or create a CharismaBasedSkills
     * const charismaBasedSkills = await prisma.charismaBasedSkills.upsert({
     *   create: {
     *     // ... data to create a CharismaBasedSkills
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CharismaBasedSkills we want to update
     *   }
     * })
     */
    upsert<T extends CharismaBasedSkillsUpsertArgs>(args: SelectSubset<T, CharismaBasedSkillsUpsertArgs<ExtArgs>>): Prisma__CharismaBasedSkillsClient<$Result.GetResult<Prisma.$CharismaBasedSkillsPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of CharismaBasedSkills.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CharismaBasedSkillsCountArgs} args - Arguments to filter CharismaBasedSkills to count.
     * @example
     * // Count the number of CharismaBasedSkills
     * const count = await prisma.charismaBasedSkills.count({
     *   where: {
     *     // ... the filter for the CharismaBasedSkills we want to count
     *   }
     * })
    **/
    count<T extends CharismaBasedSkillsCountArgs>(
      args?: Subset<T, CharismaBasedSkillsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CharismaBasedSkillsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CharismaBasedSkills.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CharismaBasedSkillsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CharismaBasedSkillsAggregateArgs>(args: Subset<T, CharismaBasedSkillsAggregateArgs>): Prisma.PrismaPromise<GetCharismaBasedSkillsAggregateType<T>>

    /**
     * Group by CharismaBasedSkills.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CharismaBasedSkillsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CharismaBasedSkillsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CharismaBasedSkillsGroupByArgs['orderBy'] }
        : { orderBy?: CharismaBasedSkillsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CharismaBasedSkillsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCharismaBasedSkillsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CharismaBasedSkills model
   */
  readonly fields: CharismaBasedSkillsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CharismaBasedSkills.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CharismaBasedSkillsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    deception<T extends CharismaBasedSkills$deceptionArgs<ExtArgs> = {}>(args?: Subset<T, CharismaBasedSkills$deceptionArgs<ExtArgs>>): Prisma__DeceptionSkillClient<$Result.GetResult<Prisma.$DeceptionSkillPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | null, null, ExtArgs, ClientOptions>
    intimidation<T extends CharismaBasedSkills$intimidationArgs<ExtArgs> = {}>(args?: Subset<T, CharismaBasedSkills$intimidationArgs<ExtArgs>>): Prisma__IntimidationSkillClient<$Result.GetResult<Prisma.$IntimidationSkillPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | null, null, ExtArgs, ClientOptions>
    performance<T extends CharismaBasedSkills$performanceArgs<ExtArgs> = {}>(args?: Subset<T, CharismaBasedSkills$performanceArgs<ExtArgs>>): Prisma__PerformanceSkillClient<$Result.GetResult<Prisma.$PerformanceSkillPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | null, null, ExtArgs, ClientOptions>
    persuasion<T extends CharismaBasedSkills$persuasionArgs<ExtArgs> = {}>(args?: Subset<T, CharismaBasedSkills$persuasionArgs<ExtArgs>>): Prisma__PersuasionSkillClient<$Result.GetResult<Prisma.$PersuasionSkillPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | null, null, ExtArgs, ClientOptions>
    skills_list_relation<T extends SkillsListDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SkillsListDefaultArgs<ExtArgs>>): Prisma__SkillsListClient<$Result.GetResult<Prisma.$SkillsListPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CharismaBasedSkills model
   */ 
  interface CharismaBasedSkillsFieldRefs {
    readonly id: FieldRef<"CharismaBasedSkills", 'String'>
  }
    

  // Custom InputTypes
  /**
   * CharismaBasedSkills findUnique
   */
  export type CharismaBasedSkillsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CharismaBasedSkills
     */
    select?: CharismaBasedSkillsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CharismaBasedSkills
     */
    omit?: CharismaBasedSkillsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CharismaBasedSkillsInclude<ExtArgs> | null
    /**
     * Filter, which CharismaBasedSkills to fetch.
     */
    where: CharismaBasedSkillsWhereUniqueInput
  }

  /**
   * CharismaBasedSkills findUniqueOrThrow
   */
  export type CharismaBasedSkillsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CharismaBasedSkills
     */
    select?: CharismaBasedSkillsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CharismaBasedSkills
     */
    omit?: CharismaBasedSkillsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CharismaBasedSkillsInclude<ExtArgs> | null
    /**
     * Filter, which CharismaBasedSkills to fetch.
     */
    where: CharismaBasedSkillsWhereUniqueInput
  }

  /**
   * CharismaBasedSkills findFirst
   */
  export type CharismaBasedSkillsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CharismaBasedSkills
     */
    select?: CharismaBasedSkillsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CharismaBasedSkills
     */
    omit?: CharismaBasedSkillsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CharismaBasedSkillsInclude<ExtArgs> | null
    /**
     * Filter, which CharismaBasedSkills to fetch.
     */
    where?: CharismaBasedSkillsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CharismaBasedSkills to fetch.
     */
    orderBy?: CharismaBasedSkillsOrderByWithRelationInput | CharismaBasedSkillsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CharismaBasedSkills.
     */
    cursor?: CharismaBasedSkillsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CharismaBasedSkills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CharismaBasedSkills.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CharismaBasedSkills.
     */
    distinct?: CharismaBasedSkillsScalarFieldEnum | CharismaBasedSkillsScalarFieldEnum[]
  }

  /**
   * CharismaBasedSkills findFirstOrThrow
   */
  export type CharismaBasedSkillsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CharismaBasedSkills
     */
    select?: CharismaBasedSkillsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CharismaBasedSkills
     */
    omit?: CharismaBasedSkillsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CharismaBasedSkillsInclude<ExtArgs> | null
    /**
     * Filter, which CharismaBasedSkills to fetch.
     */
    where?: CharismaBasedSkillsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CharismaBasedSkills to fetch.
     */
    orderBy?: CharismaBasedSkillsOrderByWithRelationInput | CharismaBasedSkillsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CharismaBasedSkills.
     */
    cursor?: CharismaBasedSkillsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CharismaBasedSkills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CharismaBasedSkills.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CharismaBasedSkills.
     */
    distinct?: CharismaBasedSkillsScalarFieldEnum | CharismaBasedSkillsScalarFieldEnum[]
  }

  /**
   * CharismaBasedSkills findMany
   */
  export type CharismaBasedSkillsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CharismaBasedSkills
     */
    select?: CharismaBasedSkillsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CharismaBasedSkills
     */
    omit?: CharismaBasedSkillsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CharismaBasedSkillsInclude<ExtArgs> | null
    /**
     * Filter, which CharismaBasedSkills to fetch.
     */
    where?: CharismaBasedSkillsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CharismaBasedSkills to fetch.
     */
    orderBy?: CharismaBasedSkillsOrderByWithRelationInput | CharismaBasedSkillsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CharismaBasedSkills.
     */
    cursor?: CharismaBasedSkillsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CharismaBasedSkills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CharismaBasedSkills.
     */
    skip?: number
    distinct?: CharismaBasedSkillsScalarFieldEnum | CharismaBasedSkillsScalarFieldEnum[]
  }

  /**
   * CharismaBasedSkills create
   */
  export type CharismaBasedSkillsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CharismaBasedSkills
     */
    select?: CharismaBasedSkillsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CharismaBasedSkills
     */
    omit?: CharismaBasedSkillsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CharismaBasedSkillsInclude<ExtArgs> | null
    /**
     * The data needed to create a CharismaBasedSkills.
     */
    data: XOR<CharismaBasedSkillsCreateInput, CharismaBasedSkillsUncheckedCreateInput>
  }

  /**
   * CharismaBasedSkills createMany
   */
  export type CharismaBasedSkillsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CharismaBasedSkills.
     */
    data: CharismaBasedSkillsCreateManyInput | CharismaBasedSkillsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CharismaBasedSkills createManyAndReturn
   */
  export type CharismaBasedSkillsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CharismaBasedSkills
     */
    select?: CharismaBasedSkillsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CharismaBasedSkills
     */
    omit?: CharismaBasedSkillsOmit<ExtArgs> | null
    /**
     * The data used to create many CharismaBasedSkills.
     */
    data: CharismaBasedSkillsCreateManyInput | CharismaBasedSkillsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CharismaBasedSkillsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CharismaBasedSkills update
   */
  export type CharismaBasedSkillsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CharismaBasedSkills
     */
    select?: CharismaBasedSkillsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CharismaBasedSkills
     */
    omit?: CharismaBasedSkillsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CharismaBasedSkillsInclude<ExtArgs> | null
    /**
     * The data needed to update a CharismaBasedSkills.
     */
    data: XOR<CharismaBasedSkillsUpdateInput, CharismaBasedSkillsUncheckedUpdateInput>
    /**
     * Choose, which CharismaBasedSkills to update.
     */
    where: CharismaBasedSkillsWhereUniqueInput
  }

  /**
   * CharismaBasedSkills updateMany
   */
  export type CharismaBasedSkillsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CharismaBasedSkills.
     */
    data: XOR<CharismaBasedSkillsUpdateManyMutationInput, CharismaBasedSkillsUncheckedUpdateManyInput>
    /**
     * Filter which CharismaBasedSkills to update
     */
    where?: CharismaBasedSkillsWhereInput
    /**
     * Limit how many CharismaBasedSkills to update.
     */
    limit?: number
  }

  /**
   * CharismaBasedSkills updateManyAndReturn
   */
  export type CharismaBasedSkillsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CharismaBasedSkills
     */
    select?: CharismaBasedSkillsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CharismaBasedSkills
     */
    omit?: CharismaBasedSkillsOmit<ExtArgs> | null
    /**
     * The data used to update CharismaBasedSkills.
     */
    data: XOR<CharismaBasedSkillsUpdateManyMutationInput, CharismaBasedSkillsUncheckedUpdateManyInput>
    /**
     * Filter which CharismaBasedSkills to update
     */
    where?: CharismaBasedSkillsWhereInput
    /**
     * Limit how many CharismaBasedSkills to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CharismaBasedSkillsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CharismaBasedSkills upsert
   */
  export type CharismaBasedSkillsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CharismaBasedSkills
     */
    select?: CharismaBasedSkillsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CharismaBasedSkills
     */
    omit?: CharismaBasedSkillsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CharismaBasedSkillsInclude<ExtArgs> | null
    /**
     * The filter to search for the CharismaBasedSkills to update in case it exists.
     */
    where: CharismaBasedSkillsWhereUniqueInput
    /**
     * In case the CharismaBasedSkills found by the `where` argument doesn't exist, create a new CharismaBasedSkills with this data.
     */
    create: XOR<CharismaBasedSkillsCreateInput, CharismaBasedSkillsUncheckedCreateInput>
    /**
     * In case the CharismaBasedSkills was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CharismaBasedSkillsUpdateInput, CharismaBasedSkillsUncheckedUpdateInput>
  }

  /**
   * CharismaBasedSkills delete
   */
  export type CharismaBasedSkillsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CharismaBasedSkills
     */
    select?: CharismaBasedSkillsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CharismaBasedSkills
     */
    omit?: CharismaBasedSkillsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CharismaBasedSkillsInclude<ExtArgs> | null
    /**
     * Filter which CharismaBasedSkills to delete.
     */
    where: CharismaBasedSkillsWhereUniqueInput
  }

  /**
   * CharismaBasedSkills deleteMany
   */
  export type CharismaBasedSkillsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CharismaBasedSkills to delete
     */
    where?: CharismaBasedSkillsWhereInput
    /**
     * Limit how many CharismaBasedSkills to delete.
     */
    limit?: number
  }

  /**
   * CharismaBasedSkills.deception
   */
  export type CharismaBasedSkills$deceptionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeceptionSkill
     */
    select?: DeceptionSkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeceptionSkill
     */
    omit?: DeceptionSkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeceptionSkillInclude<ExtArgs> | null
    where?: DeceptionSkillWhereInput
  }

  /**
   * CharismaBasedSkills.intimidation
   */
  export type CharismaBasedSkills$intimidationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IntimidationSkill
     */
    select?: IntimidationSkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IntimidationSkill
     */
    omit?: IntimidationSkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IntimidationSkillInclude<ExtArgs> | null
    where?: IntimidationSkillWhereInput
  }

  /**
   * CharismaBasedSkills.performance
   */
  export type CharismaBasedSkills$performanceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PerformanceSkill
     */
    select?: PerformanceSkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PerformanceSkill
     */
    omit?: PerformanceSkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PerformanceSkillInclude<ExtArgs> | null
    where?: PerformanceSkillWhereInput
  }

  /**
   * CharismaBasedSkills.persuasion
   */
  export type CharismaBasedSkills$persuasionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersuasionSkill
     */
    select?: PersuasionSkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PersuasionSkill
     */
    omit?: PersuasionSkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersuasionSkillInclude<ExtArgs> | null
    where?: PersuasionSkillWhereInput
  }

  /**
   * CharismaBasedSkills without action
   */
  export type CharismaBasedSkillsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CharismaBasedSkills
     */
    select?: CharismaBasedSkillsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CharismaBasedSkills
     */
    omit?: CharismaBasedSkillsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CharismaBasedSkillsInclude<ExtArgs> | null
  }


  /**
   * Model AthleticsSkill
   */

  export type AggregateAthleticsSkill = {
    _count: AthleticsSkillCountAggregateOutputType | null
    _avg: AthleticsSkillAvgAggregateOutputType | null
    _sum: AthleticsSkillSumAggregateOutputType | null
    _min: AthleticsSkillMinAggregateOutputType | null
    _max: AthleticsSkillMaxAggregateOutputType | null
  }

  export type AthleticsSkillAvgAggregateOutputType = {
    value: number | null
  }

  export type AthleticsSkillSumAggregateOutputType = {
    value: number | null
  }

  export type AthleticsSkillMinAggregateOutputType = {
    id: string | null
    value: number | null
    mastery: boolean | null
    name: string | null
  }

  export type AthleticsSkillMaxAggregateOutputType = {
    id: string | null
    value: number | null
    mastery: boolean | null
    name: string | null
  }

  export type AthleticsSkillCountAggregateOutputType = {
    id: number
    value: number
    mastery: number
    name: number
    _all: number
  }


  export type AthleticsSkillAvgAggregateInputType = {
    value?: true
  }

  export type AthleticsSkillSumAggregateInputType = {
    value?: true
  }

  export type AthleticsSkillMinAggregateInputType = {
    id?: true
    value?: true
    mastery?: true
    name?: true
  }

  export type AthleticsSkillMaxAggregateInputType = {
    id?: true
    value?: true
    mastery?: true
    name?: true
  }

  export type AthleticsSkillCountAggregateInputType = {
    id?: true
    value?: true
    mastery?: true
    name?: true
    _all?: true
  }

  export type AthleticsSkillAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AthleticsSkill to aggregate.
     */
    where?: AthleticsSkillWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AthleticsSkills to fetch.
     */
    orderBy?: AthleticsSkillOrderByWithRelationInput | AthleticsSkillOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AthleticsSkillWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AthleticsSkills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AthleticsSkills.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AthleticsSkills
    **/
    _count?: true | AthleticsSkillCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AthleticsSkillAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AthleticsSkillSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AthleticsSkillMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AthleticsSkillMaxAggregateInputType
  }

  export type GetAthleticsSkillAggregateType<T extends AthleticsSkillAggregateArgs> = {
        [P in keyof T & keyof AggregateAthleticsSkill]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAthleticsSkill[P]>
      : GetScalarType<T[P], AggregateAthleticsSkill[P]>
  }




  export type AthleticsSkillGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AthleticsSkillWhereInput
    orderBy?: AthleticsSkillOrderByWithAggregationInput | AthleticsSkillOrderByWithAggregationInput[]
    by: AthleticsSkillScalarFieldEnum[] | AthleticsSkillScalarFieldEnum
    having?: AthleticsSkillScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AthleticsSkillCountAggregateInputType | true
    _avg?: AthleticsSkillAvgAggregateInputType
    _sum?: AthleticsSkillSumAggregateInputType
    _min?: AthleticsSkillMinAggregateInputType
    _max?: AthleticsSkillMaxAggregateInputType
  }

  export type AthleticsSkillGroupByOutputType = {
    id: string
    value: number | null
    mastery: boolean
    name: string
    _count: AthleticsSkillCountAggregateOutputType | null
    _avg: AthleticsSkillAvgAggregateOutputType | null
    _sum: AthleticsSkillSumAggregateOutputType | null
    _min: AthleticsSkillMinAggregateOutputType | null
    _max: AthleticsSkillMaxAggregateOutputType | null
  }

  type GetAthleticsSkillGroupByPayload<T extends AthleticsSkillGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AthleticsSkillGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AthleticsSkillGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AthleticsSkillGroupByOutputType[P]>
            : GetScalarType<T[P], AthleticsSkillGroupByOutputType[P]>
        }
      >
    >


  export type AthleticsSkillSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    value?: boolean
    mastery?: boolean
    name?: boolean
    skill_list?: boolean | StrengthBasedSkillsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["athleticsSkill"]>

  export type AthleticsSkillSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    value?: boolean
    mastery?: boolean
    name?: boolean
    skill_list?: boolean | StrengthBasedSkillsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["athleticsSkill"]>

  export type AthleticsSkillSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    value?: boolean
    mastery?: boolean
    name?: boolean
    skill_list?: boolean | StrengthBasedSkillsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["athleticsSkill"]>

  export type AthleticsSkillSelectScalar = {
    id?: boolean
    value?: boolean
    mastery?: boolean
    name?: boolean
  }

  export type AthleticsSkillOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "value" | "mastery" | "name", ExtArgs["result"]["athleticsSkill"]>
  export type AthleticsSkillInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    skill_list?: boolean | StrengthBasedSkillsDefaultArgs<ExtArgs>
  }
  export type AthleticsSkillIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    skill_list?: boolean | StrengthBasedSkillsDefaultArgs<ExtArgs>
  }
  export type AthleticsSkillIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    skill_list?: boolean | StrengthBasedSkillsDefaultArgs<ExtArgs>
  }

  export type $AthleticsSkillPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AthleticsSkill"
    objects: {
      skill_list: Prisma.$StrengthBasedSkillsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      value: number | null
      mastery: boolean
      name: string
    }, ExtArgs["result"]["athleticsSkill"]>
    composites: {}
  }

  type AthleticsSkillGetPayload<S extends boolean | null | undefined | AthleticsSkillDefaultArgs> = $Result.GetResult<Prisma.$AthleticsSkillPayload, S>

  type AthleticsSkillCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AthleticsSkillFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AthleticsSkillCountAggregateInputType | true
    }

  export interface AthleticsSkillDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AthleticsSkill'], meta: { name: 'AthleticsSkill' } }
    /**
     * Find zero or one AthleticsSkill that matches the filter.
     * @param {AthleticsSkillFindUniqueArgs} args - Arguments to find a AthleticsSkill
     * @example
     * // Get one AthleticsSkill
     * const athleticsSkill = await prisma.athleticsSkill.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AthleticsSkillFindUniqueArgs>(args: SelectSubset<T, AthleticsSkillFindUniqueArgs<ExtArgs>>): Prisma__AthleticsSkillClient<$Result.GetResult<Prisma.$AthleticsSkillPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one AthleticsSkill that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AthleticsSkillFindUniqueOrThrowArgs} args - Arguments to find a AthleticsSkill
     * @example
     * // Get one AthleticsSkill
     * const athleticsSkill = await prisma.athleticsSkill.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AthleticsSkillFindUniqueOrThrowArgs>(args: SelectSubset<T, AthleticsSkillFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AthleticsSkillClient<$Result.GetResult<Prisma.$AthleticsSkillPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first AthleticsSkill that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AthleticsSkillFindFirstArgs} args - Arguments to find a AthleticsSkill
     * @example
     * // Get one AthleticsSkill
     * const athleticsSkill = await prisma.athleticsSkill.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AthleticsSkillFindFirstArgs>(args?: SelectSubset<T, AthleticsSkillFindFirstArgs<ExtArgs>>): Prisma__AthleticsSkillClient<$Result.GetResult<Prisma.$AthleticsSkillPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first AthleticsSkill that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AthleticsSkillFindFirstOrThrowArgs} args - Arguments to find a AthleticsSkill
     * @example
     * // Get one AthleticsSkill
     * const athleticsSkill = await prisma.athleticsSkill.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AthleticsSkillFindFirstOrThrowArgs>(args?: SelectSubset<T, AthleticsSkillFindFirstOrThrowArgs<ExtArgs>>): Prisma__AthleticsSkillClient<$Result.GetResult<Prisma.$AthleticsSkillPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more AthleticsSkills that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AthleticsSkillFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AthleticsSkills
     * const athleticsSkills = await prisma.athleticsSkill.findMany()
     * 
     * // Get first 10 AthleticsSkills
     * const athleticsSkills = await prisma.athleticsSkill.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const athleticsSkillWithIdOnly = await prisma.athleticsSkill.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AthleticsSkillFindManyArgs>(args?: SelectSubset<T, AthleticsSkillFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AthleticsSkillPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a AthleticsSkill.
     * @param {AthleticsSkillCreateArgs} args - Arguments to create a AthleticsSkill.
     * @example
     * // Create one AthleticsSkill
     * const AthleticsSkill = await prisma.athleticsSkill.create({
     *   data: {
     *     // ... data to create a AthleticsSkill
     *   }
     * })
     * 
     */
    create<T extends AthleticsSkillCreateArgs>(args: SelectSubset<T, AthleticsSkillCreateArgs<ExtArgs>>): Prisma__AthleticsSkillClient<$Result.GetResult<Prisma.$AthleticsSkillPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many AthleticsSkills.
     * @param {AthleticsSkillCreateManyArgs} args - Arguments to create many AthleticsSkills.
     * @example
     * // Create many AthleticsSkills
     * const athleticsSkill = await prisma.athleticsSkill.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AthleticsSkillCreateManyArgs>(args?: SelectSubset<T, AthleticsSkillCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AthleticsSkills and returns the data saved in the database.
     * @param {AthleticsSkillCreateManyAndReturnArgs} args - Arguments to create many AthleticsSkills.
     * @example
     * // Create many AthleticsSkills
     * const athleticsSkill = await prisma.athleticsSkill.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AthleticsSkills and only return the `id`
     * const athleticsSkillWithIdOnly = await prisma.athleticsSkill.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AthleticsSkillCreateManyAndReturnArgs>(args?: SelectSubset<T, AthleticsSkillCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AthleticsSkillPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a AthleticsSkill.
     * @param {AthleticsSkillDeleteArgs} args - Arguments to delete one AthleticsSkill.
     * @example
     * // Delete one AthleticsSkill
     * const AthleticsSkill = await prisma.athleticsSkill.delete({
     *   where: {
     *     // ... filter to delete one AthleticsSkill
     *   }
     * })
     * 
     */
    delete<T extends AthleticsSkillDeleteArgs>(args: SelectSubset<T, AthleticsSkillDeleteArgs<ExtArgs>>): Prisma__AthleticsSkillClient<$Result.GetResult<Prisma.$AthleticsSkillPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one AthleticsSkill.
     * @param {AthleticsSkillUpdateArgs} args - Arguments to update one AthleticsSkill.
     * @example
     * // Update one AthleticsSkill
     * const athleticsSkill = await prisma.athleticsSkill.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AthleticsSkillUpdateArgs>(args: SelectSubset<T, AthleticsSkillUpdateArgs<ExtArgs>>): Prisma__AthleticsSkillClient<$Result.GetResult<Prisma.$AthleticsSkillPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more AthleticsSkills.
     * @param {AthleticsSkillDeleteManyArgs} args - Arguments to filter AthleticsSkills to delete.
     * @example
     * // Delete a few AthleticsSkills
     * const { count } = await prisma.athleticsSkill.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AthleticsSkillDeleteManyArgs>(args?: SelectSubset<T, AthleticsSkillDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AthleticsSkills.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AthleticsSkillUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AthleticsSkills
     * const athleticsSkill = await prisma.athleticsSkill.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AthleticsSkillUpdateManyArgs>(args: SelectSubset<T, AthleticsSkillUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AthleticsSkills and returns the data updated in the database.
     * @param {AthleticsSkillUpdateManyAndReturnArgs} args - Arguments to update many AthleticsSkills.
     * @example
     * // Update many AthleticsSkills
     * const athleticsSkill = await prisma.athleticsSkill.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AthleticsSkills and only return the `id`
     * const athleticsSkillWithIdOnly = await prisma.athleticsSkill.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AthleticsSkillUpdateManyAndReturnArgs>(args: SelectSubset<T, AthleticsSkillUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AthleticsSkillPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one AthleticsSkill.
     * @param {AthleticsSkillUpsertArgs} args - Arguments to update or create a AthleticsSkill.
     * @example
     * // Update or create a AthleticsSkill
     * const athleticsSkill = await prisma.athleticsSkill.upsert({
     *   create: {
     *     // ... data to create a AthleticsSkill
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AthleticsSkill we want to update
     *   }
     * })
     */
    upsert<T extends AthleticsSkillUpsertArgs>(args: SelectSubset<T, AthleticsSkillUpsertArgs<ExtArgs>>): Prisma__AthleticsSkillClient<$Result.GetResult<Prisma.$AthleticsSkillPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of AthleticsSkills.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AthleticsSkillCountArgs} args - Arguments to filter AthleticsSkills to count.
     * @example
     * // Count the number of AthleticsSkills
     * const count = await prisma.athleticsSkill.count({
     *   where: {
     *     // ... the filter for the AthleticsSkills we want to count
     *   }
     * })
    **/
    count<T extends AthleticsSkillCountArgs>(
      args?: Subset<T, AthleticsSkillCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AthleticsSkillCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AthleticsSkill.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AthleticsSkillAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AthleticsSkillAggregateArgs>(args: Subset<T, AthleticsSkillAggregateArgs>): Prisma.PrismaPromise<GetAthleticsSkillAggregateType<T>>

    /**
     * Group by AthleticsSkill.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AthleticsSkillGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AthleticsSkillGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AthleticsSkillGroupByArgs['orderBy'] }
        : { orderBy?: AthleticsSkillGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AthleticsSkillGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAthleticsSkillGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AthleticsSkill model
   */
  readonly fields: AthleticsSkillFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AthleticsSkill.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AthleticsSkillClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    skill_list<T extends StrengthBasedSkillsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StrengthBasedSkillsDefaultArgs<ExtArgs>>): Prisma__StrengthBasedSkillsClient<$Result.GetResult<Prisma.$StrengthBasedSkillsPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AthleticsSkill model
   */ 
  interface AthleticsSkillFieldRefs {
    readonly id: FieldRef<"AthleticsSkill", 'String'>
    readonly value: FieldRef<"AthleticsSkill", 'Int'>
    readonly mastery: FieldRef<"AthleticsSkill", 'Boolean'>
    readonly name: FieldRef<"AthleticsSkill", 'String'>
  }
    

  // Custom InputTypes
  /**
   * AthleticsSkill findUnique
   */
  export type AthleticsSkillFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AthleticsSkill
     */
    select?: AthleticsSkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AthleticsSkill
     */
    omit?: AthleticsSkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AthleticsSkillInclude<ExtArgs> | null
    /**
     * Filter, which AthleticsSkill to fetch.
     */
    where: AthleticsSkillWhereUniqueInput
  }

  /**
   * AthleticsSkill findUniqueOrThrow
   */
  export type AthleticsSkillFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AthleticsSkill
     */
    select?: AthleticsSkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AthleticsSkill
     */
    omit?: AthleticsSkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AthleticsSkillInclude<ExtArgs> | null
    /**
     * Filter, which AthleticsSkill to fetch.
     */
    where: AthleticsSkillWhereUniqueInput
  }

  /**
   * AthleticsSkill findFirst
   */
  export type AthleticsSkillFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AthleticsSkill
     */
    select?: AthleticsSkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AthleticsSkill
     */
    omit?: AthleticsSkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AthleticsSkillInclude<ExtArgs> | null
    /**
     * Filter, which AthleticsSkill to fetch.
     */
    where?: AthleticsSkillWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AthleticsSkills to fetch.
     */
    orderBy?: AthleticsSkillOrderByWithRelationInput | AthleticsSkillOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AthleticsSkills.
     */
    cursor?: AthleticsSkillWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AthleticsSkills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AthleticsSkills.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AthleticsSkills.
     */
    distinct?: AthleticsSkillScalarFieldEnum | AthleticsSkillScalarFieldEnum[]
  }

  /**
   * AthleticsSkill findFirstOrThrow
   */
  export type AthleticsSkillFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AthleticsSkill
     */
    select?: AthleticsSkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AthleticsSkill
     */
    omit?: AthleticsSkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AthleticsSkillInclude<ExtArgs> | null
    /**
     * Filter, which AthleticsSkill to fetch.
     */
    where?: AthleticsSkillWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AthleticsSkills to fetch.
     */
    orderBy?: AthleticsSkillOrderByWithRelationInput | AthleticsSkillOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AthleticsSkills.
     */
    cursor?: AthleticsSkillWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AthleticsSkills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AthleticsSkills.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AthleticsSkills.
     */
    distinct?: AthleticsSkillScalarFieldEnum | AthleticsSkillScalarFieldEnum[]
  }

  /**
   * AthleticsSkill findMany
   */
  export type AthleticsSkillFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AthleticsSkill
     */
    select?: AthleticsSkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AthleticsSkill
     */
    omit?: AthleticsSkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AthleticsSkillInclude<ExtArgs> | null
    /**
     * Filter, which AthleticsSkills to fetch.
     */
    where?: AthleticsSkillWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AthleticsSkills to fetch.
     */
    orderBy?: AthleticsSkillOrderByWithRelationInput | AthleticsSkillOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AthleticsSkills.
     */
    cursor?: AthleticsSkillWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AthleticsSkills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AthleticsSkills.
     */
    skip?: number
    distinct?: AthleticsSkillScalarFieldEnum | AthleticsSkillScalarFieldEnum[]
  }

  /**
   * AthleticsSkill create
   */
  export type AthleticsSkillCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AthleticsSkill
     */
    select?: AthleticsSkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AthleticsSkill
     */
    omit?: AthleticsSkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AthleticsSkillInclude<ExtArgs> | null
    /**
     * The data needed to create a AthleticsSkill.
     */
    data: XOR<AthleticsSkillCreateInput, AthleticsSkillUncheckedCreateInput>
  }

  /**
   * AthleticsSkill createMany
   */
  export type AthleticsSkillCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AthleticsSkills.
     */
    data: AthleticsSkillCreateManyInput | AthleticsSkillCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AthleticsSkill createManyAndReturn
   */
  export type AthleticsSkillCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AthleticsSkill
     */
    select?: AthleticsSkillSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AthleticsSkill
     */
    omit?: AthleticsSkillOmit<ExtArgs> | null
    /**
     * The data used to create many AthleticsSkills.
     */
    data: AthleticsSkillCreateManyInput | AthleticsSkillCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AthleticsSkillIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AthleticsSkill update
   */
  export type AthleticsSkillUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AthleticsSkill
     */
    select?: AthleticsSkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AthleticsSkill
     */
    omit?: AthleticsSkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AthleticsSkillInclude<ExtArgs> | null
    /**
     * The data needed to update a AthleticsSkill.
     */
    data: XOR<AthleticsSkillUpdateInput, AthleticsSkillUncheckedUpdateInput>
    /**
     * Choose, which AthleticsSkill to update.
     */
    where: AthleticsSkillWhereUniqueInput
  }

  /**
   * AthleticsSkill updateMany
   */
  export type AthleticsSkillUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AthleticsSkills.
     */
    data: XOR<AthleticsSkillUpdateManyMutationInput, AthleticsSkillUncheckedUpdateManyInput>
    /**
     * Filter which AthleticsSkills to update
     */
    where?: AthleticsSkillWhereInput
    /**
     * Limit how many AthleticsSkills to update.
     */
    limit?: number
  }

  /**
   * AthleticsSkill updateManyAndReturn
   */
  export type AthleticsSkillUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AthleticsSkill
     */
    select?: AthleticsSkillSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AthleticsSkill
     */
    omit?: AthleticsSkillOmit<ExtArgs> | null
    /**
     * The data used to update AthleticsSkills.
     */
    data: XOR<AthleticsSkillUpdateManyMutationInput, AthleticsSkillUncheckedUpdateManyInput>
    /**
     * Filter which AthleticsSkills to update
     */
    where?: AthleticsSkillWhereInput
    /**
     * Limit how many AthleticsSkills to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AthleticsSkillIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AthleticsSkill upsert
   */
  export type AthleticsSkillUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AthleticsSkill
     */
    select?: AthleticsSkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AthleticsSkill
     */
    omit?: AthleticsSkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AthleticsSkillInclude<ExtArgs> | null
    /**
     * The filter to search for the AthleticsSkill to update in case it exists.
     */
    where: AthleticsSkillWhereUniqueInput
    /**
     * In case the AthleticsSkill found by the `where` argument doesn't exist, create a new AthleticsSkill with this data.
     */
    create: XOR<AthleticsSkillCreateInput, AthleticsSkillUncheckedCreateInput>
    /**
     * In case the AthleticsSkill was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AthleticsSkillUpdateInput, AthleticsSkillUncheckedUpdateInput>
  }

  /**
   * AthleticsSkill delete
   */
  export type AthleticsSkillDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AthleticsSkill
     */
    select?: AthleticsSkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AthleticsSkill
     */
    omit?: AthleticsSkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AthleticsSkillInclude<ExtArgs> | null
    /**
     * Filter which AthleticsSkill to delete.
     */
    where: AthleticsSkillWhereUniqueInput
  }

  /**
   * AthleticsSkill deleteMany
   */
  export type AthleticsSkillDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AthleticsSkills to delete
     */
    where?: AthleticsSkillWhereInput
    /**
     * Limit how many AthleticsSkills to delete.
     */
    limit?: number
  }

  /**
   * AthleticsSkill without action
   */
  export type AthleticsSkillDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AthleticsSkill
     */
    select?: AthleticsSkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AthleticsSkill
     */
    omit?: AthleticsSkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AthleticsSkillInclude<ExtArgs> | null
  }


  /**
   * Model AcrobaticsSkill
   */

  export type AggregateAcrobaticsSkill = {
    _count: AcrobaticsSkillCountAggregateOutputType | null
    _avg: AcrobaticsSkillAvgAggregateOutputType | null
    _sum: AcrobaticsSkillSumAggregateOutputType | null
    _min: AcrobaticsSkillMinAggregateOutputType | null
    _max: AcrobaticsSkillMaxAggregateOutputType | null
  }

  export type AcrobaticsSkillAvgAggregateOutputType = {
    value: number | null
  }

  export type AcrobaticsSkillSumAggregateOutputType = {
    value: number | null
  }

  export type AcrobaticsSkillMinAggregateOutputType = {
    id: string | null
    value: number | null
    mastery: boolean | null
    name: string | null
  }

  export type AcrobaticsSkillMaxAggregateOutputType = {
    id: string | null
    value: number | null
    mastery: boolean | null
    name: string | null
  }

  export type AcrobaticsSkillCountAggregateOutputType = {
    id: number
    value: number
    mastery: number
    name: number
    _all: number
  }


  export type AcrobaticsSkillAvgAggregateInputType = {
    value?: true
  }

  export type AcrobaticsSkillSumAggregateInputType = {
    value?: true
  }

  export type AcrobaticsSkillMinAggregateInputType = {
    id?: true
    value?: true
    mastery?: true
    name?: true
  }

  export type AcrobaticsSkillMaxAggregateInputType = {
    id?: true
    value?: true
    mastery?: true
    name?: true
  }

  export type AcrobaticsSkillCountAggregateInputType = {
    id?: true
    value?: true
    mastery?: true
    name?: true
    _all?: true
  }

  export type AcrobaticsSkillAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AcrobaticsSkill to aggregate.
     */
    where?: AcrobaticsSkillWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AcrobaticsSkills to fetch.
     */
    orderBy?: AcrobaticsSkillOrderByWithRelationInput | AcrobaticsSkillOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AcrobaticsSkillWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AcrobaticsSkills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AcrobaticsSkills.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AcrobaticsSkills
    **/
    _count?: true | AcrobaticsSkillCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AcrobaticsSkillAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AcrobaticsSkillSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AcrobaticsSkillMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AcrobaticsSkillMaxAggregateInputType
  }

  export type GetAcrobaticsSkillAggregateType<T extends AcrobaticsSkillAggregateArgs> = {
        [P in keyof T & keyof AggregateAcrobaticsSkill]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAcrobaticsSkill[P]>
      : GetScalarType<T[P], AggregateAcrobaticsSkill[P]>
  }




  export type AcrobaticsSkillGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AcrobaticsSkillWhereInput
    orderBy?: AcrobaticsSkillOrderByWithAggregationInput | AcrobaticsSkillOrderByWithAggregationInput[]
    by: AcrobaticsSkillScalarFieldEnum[] | AcrobaticsSkillScalarFieldEnum
    having?: AcrobaticsSkillScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AcrobaticsSkillCountAggregateInputType | true
    _avg?: AcrobaticsSkillAvgAggregateInputType
    _sum?: AcrobaticsSkillSumAggregateInputType
    _min?: AcrobaticsSkillMinAggregateInputType
    _max?: AcrobaticsSkillMaxAggregateInputType
  }

  export type AcrobaticsSkillGroupByOutputType = {
    id: string
    value: number | null
    mastery: boolean
    name: string
    _count: AcrobaticsSkillCountAggregateOutputType | null
    _avg: AcrobaticsSkillAvgAggregateOutputType | null
    _sum: AcrobaticsSkillSumAggregateOutputType | null
    _min: AcrobaticsSkillMinAggregateOutputType | null
    _max: AcrobaticsSkillMaxAggregateOutputType | null
  }

  type GetAcrobaticsSkillGroupByPayload<T extends AcrobaticsSkillGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AcrobaticsSkillGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AcrobaticsSkillGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AcrobaticsSkillGroupByOutputType[P]>
            : GetScalarType<T[P], AcrobaticsSkillGroupByOutputType[P]>
        }
      >
    >


  export type AcrobaticsSkillSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    value?: boolean
    mastery?: boolean
    name?: boolean
    skill_list?: boolean | DexterityBasedSkillsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["acrobaticsSkill"]>

  export type AcrobaticsSkillSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    value?: boolean
    mastery?: boolean
    name?: boolean
    skill_list?: boolean | DexterityBasedSkillsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["acrobaticsSkill"]>

  export type AcrobaticsSkillSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    value?: boolean
    mastery?: boolean
    name?: boolean
    skill_list?: boolean | DexterityBasedSkillsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["acrobaticsSkill"]>

  export type AcrobaticsSkillSelectScalar = {
    id?: boolean
    value?: boolean
    mastery?: boolean
    name?: boolean
  }

  export type AcrobaticsSkillOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "value" | "mastery" | "name", ExtArgs["result"]["acrobaticsSkill"]>
  export type AcrobaticsSkillInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    skill_list?: boolean | DexterityBasedSkillsDefaultArgs<ExtArgs>
  }
  export type AcrobaticsSkillIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    skill_list?: boolean | DexterityBasedSkillsDefaultArgs<ExtArgs>
  }
  export type AcrobaticsSkillIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    skill_list?: boolean | DexterityBasedSkillsDefaultArgs<ExtArgs>
  }

  export type $AcrobaticsSkillPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AcrobaticsSkill"
    objects: {
      skill_list: Prisma.$DexterityBasedSkillsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      value: number | null
      mastery: boolean
      name: string
    }, ExtArgs["result"]["acrobaticsSkill"]>
    composites: {}
  }

  type AcrobaticsSkillGetPayload<S extends boolean | null | undefined | AcrobaticsSkillDefaultArgs> = $Result.GetResult<Prisma.$AcrobaticsSkillPayload, S>

  type AcrobaticsSkillCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AcrobaticsSkillFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AcrobaticsSkillCountAggregateInputType | true
    }

  export interface AcrobaticsSkillDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AcrobaticsSkill'], meta: { name: 'AcrobaticsSkill' } }
    /**
     * Find zero or one AcrobaticsSkill that matches the filter.
     * @param {AcrobaticsSkillFindUniqueArgs} args - Arguments to find a AcrobaticsSkill
     * @example
     * // Get one AcrobaticsSkill
     * const acrobaticsSkill = await prisma.acrobaticsSkill.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AcrobaticsSkillFindUniqueArgs>(args: SelectSubset<T, AcrobaticsSkillFindUniqueArgs<ExtArgs>>): Prisma__AcrobaticsSkillClient<$Result.GetResult<Prisma.$AcrobaticsSkillPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one AcrobaticsSkill that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AcrobaticsSkillFindUniqueOrThrowArgs} args - Arguments to find a AcrobaticsSkill
     * @example
     * // Get one AcrobaticsSkill
     * const acrobaticsSkill = await prisma.acrobaticsSkill.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AcrobaticsSkillFindUniqueOrThrowArgs>(args: SelectSubset<T, AcrobaticsSkillFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AcrobaticsSkillClient<$Result.GetResult<Prisma.$AcrobaticsSkillPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first AcrobaticsSkill that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AcrobaticsSkillFindFirstArgs} args - Arguments to find a AcrobaticsSkill
     * @example
     * // Get one AcrobaticsSkill
     * const acrobaticsSkill = await prisma.acrobaticsSkill.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AcrobaticsSkillFindFirstArgs>(args?: SelectSubset<T, AcrobaticsSkillFindFirstArgs<ExtArgs>>): Prisma__AcrobaticsSkillClient<$Result.GetResult<Prisma.$AcrobaticsSkillPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first AcrobaticsSkill that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AcrobaticsSkillFindFirstOrThrowArgs} args - Arguments to find a AcrobaticsSkill
     * @example
     * // Get one AcrobaticsSkill
     * const acrobaticsSkill = await prisma.acrobaticsSkill.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AcrobaticsSkillFindFirstOrThrowArgs>(args?: SelectSubset<T, AcrobaticsSkillFindFirstOrThrowArgs<ExtArgs>>): Prisma__AcrobaticsSkillClient<$Result.GetResult<Prisma.$AcrobaticsSkillPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more AcrobaticsSkills that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AcrobaticsSkillFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AcrobaticsSkills
     * const acrobaticsSkills = await prisma.acrobaticsSkill.findMany()
     * 
     * // Get first 10 AcrobaticsSkills
     * const acrobaticsSkills = await prisma.acrobaticsSkill.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const acrobaticsSkillWithIdOnly = await prisma.acrobaticsSkill.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AcrobaticsSkillFindManyArgs>(args?: SelectSubset<T, AcrobaticsSkillFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AcrobaticsSkillPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a AcrobaticsSkill.
     * @param {AcrobaticsSkillCreateArgs} args - Arguments to create a AcrobaticsSkill.
     * @example
     * // Create one AcrobaticsSkill
     * const AcrobaticsSkill = await prisma.acrobaticsSkill.create({
     *   data: {
     *     // ... data to create a AcrobaticsSkill
     *   }
     * })
     * 
     */
    create<T extends AcrobaticsSkillCreateArgs>(args: SelectSubset<T, AcrobaticsSkillCreateArgs<ExtArgs>>): Prisma__AcrobaticsSkillClient<$Result.GetResult<Prisma.$AcrobaticsSkillPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many AcrobaticsSkills.
     * @param {AcrobaticsSkillCreateManyArgs} args - Arguments to create many AcrobaticsSkills.
     * @example
     * // Create many AcrobaticsSkills
     * const acrobaticsSkill = await prisma.acrobaticsSkill.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AcrobaticsSkillCreateManyArgs>(args?: SelectSubset<T, AcrobaticsSkillCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AcrobaticsSkills and returns the data saved in the database.
     * @param {AcrobaticsSkillCreateManyAndReturnArgs} args - Arguments to create many AcrobaticsSkills.
     * @example
     * // Create many AcrobaticsSkills
     * const acrobaticsSkill = await prisma.acrobaticsSkill.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AcrobaticsSkills and only return the `id`
     * const acrobaticsSkillWithIdOnly = await prisma.acrobaticsSkill.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AcrobaticsSkillCreateManyAndReturnArgs>(args?: SelectSubset<T, AcrobaticsSkillCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AcrobaticsSkillPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a AcrobaticsSkill.
     * @param {AcrobaticsSkillDeleteArgs} args - Arguments to delete one AcrobaticsSkill.
     * @example
     * // Delete one AcrobaticsSkill
     * const AcrobaticsSkill = await prisma.acrobaticsSkill.delete({
     *   where: {
     *     // ... filter to delete one AcrobaticsSkill
     *   }
     * })
     * 
     */
    delete<T extends AcrobaticsSkillDeleteArgs>(args: SelectSubset<T, AcrobaticsSkillDeleteArgs<ExtArgs>>): Prisma__AcrobaticsSkillClient<$Result.GetResult<Prisma.$AcrobaticsSkillPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one AcrobaticsSkill.
     * @param {AcrobaticsSkillUpdateArgs} args - Arguments to update one AcrobaticsSkill.
     * @example
     * // Update one AcrobaticsSkill
     * const acrobaticsSkill = await prisma.acrobaticsSkill.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AcrobaticsSkillUpdateArgs>(args: SelectSubset<T, AcrobaticsSkillUpdateArgs<ExtArgs>>): Prisma__AcrobaticsSkillClient<$Result.GetResult<Prisma.$AcrobaticsSkillPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more AcrobaticsSkills.
     * @param {AcrobaticsSkillDeleteManyArgs} args - Arguments to filter AcrobaticsSkills to delete.
     * @example
     * // Delete a few AcrobaticsSkills
     * const { count } = await prisma.acrobaticsSkill.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AcrobaticsSkillDeleteManyArgs>(args?: SelectSubset<T, AcrobaticsSkillDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AcrobaticsSkills.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AcrobaticsSkillUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AcrobaticsSkills
     * const acrobaticsSkill = await prisma.acrobaticsSkill.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AcrobaticsSkillUpdateManyArgs>(args: SelectSubset<T, AcrobaticsSkillUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AcrobaticsSkills and returns the data updated in the database.
     * @param {AcrobaticsSkillUpdateManyAndReturnArgs} args - Arguments to update many AcrobaticsSkills.
     * @example
     * // Update many AcrobaticsSkills
     * const acrobaticsSkill = await prisma.acrobaticsSkill.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AcrobaticsSkills and only return the `id`
     * const acrobaticsSkillWithIdOnly = await prisma.acrobaticsSkill.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AcrobaticsSkillUpdateManyAndReturnArgs>(args: SelectSubset<T, AcrobaticsSkillUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AcrobaticsSkillPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one AcrobaticsSkill.
     * @param {AcrobaticsSkillUpsertArgs} args - Arguments to update or create a AcrobaticsSkill.
     * @example
     * // Update or create a AcrobaticsSkill
     * const acrobaticsSkill = await prisma.acrobaticsSkill.upsert({
     *   create: {
     *     // ... data to create a AcrobaticsSkill
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AcrobaticsSkill we want to update
     *   }
     * })
     */
    upsert<T extends AcrobaticsSkillUpsertArgs>(args: SelectSubset<T, AcrobaticsSkillUpsertArgs<ExtArgs>>): Prisma__AcrobaticsSkillClient<$Result.GetResult<Prisma.$AcrobaticsSkillPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of AcrobaticsSkills.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AcrobaticsSkillCountArgs} args - Arguments to filter AcrobaticsSkills to count.
     * @example
     * // Count the number of AcrobaticsSkills
     * const count = await prisma.acrobaticsSkill.count({
     *   where: {
     *     // ... the filter for the AcrobaticsSkills we want to count
     *   }
     * })
    **/
    count<T extends AcrobaticsSkillCountArgs>(
      args?: Subset<T, AcrobaticsSkillCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AcrobaticsSkillCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AcrobaticsSkill.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AcrobaticsSkillAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AcrobaticsSkillAggregateArgs>(args: Subset<T, AcrobaticsSkillAggregateArgs>): Prisma.PrismaPromise<GetAcrobaticsSkillAggregateType<T>>

    /**
     * Group by AcrobaticsSkill.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AcrobaticsSkillGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AcrobaticsSkillGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AcrobaticsSkillGroupByArgs['orderBy'] }
        : { orderBy?: AcrobaticsSkillGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AcrobaticsSkillGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAcrobaticsSkillGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AcrobaticsSkill model
   */
  readonly fields: AcrobaticsSkillFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AcrobaticsSkill.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AcrobaticsSkillClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    skill_list<T extends DexterityBasedSkillsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DexterityBasedSkillsDefaultArgs<ExtArgs>>): Prisma__DexterityBasedSkillsClient<$Result.GetResult<Prisma.$DexterityBasedSkillsPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AcrobaticsSkill model
   */ 
  interface AcrobaticsSkillFieldRefs {
    readonly id: FieldRef<"AcrobaticsSkill", 'String'>
    readonly value: FieldRef<"AcrobaticsSkill", 'Int'>
    readonly mastery: FieldRef<"AcrobaticsSkill", 'Boolean'>
    readonly name: FieldRef<"AcrobaticsSkill", 'String'>
  }
    

  // Custom InputTypes
  /**
   * AcrobaticsSkill findUnique
   */
  export type AcrobaticsSkillFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcrobaticsSkill
     */
    select?: AcrobaticsSkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AcrobaticsSkill
     */
    omit?: AcrobaticsSkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcrobaticsSkillInclude<ExtArgs> | null
    /**
     * Filter, which AcrobaticsSkill to fetch.
     */
    where: AcrobaticsSkillWhereUniqueInput
  }

  /**
   * AcrobaticsSkill findUniqueOrThrow
   */
  export type AcrobaticsSkillFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcrobaticsSkill
     */
    select?: AcrobaticsSkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AcrobaticsSkill
     */
    omit?: AcrobaticsSkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcrobaticsSkillInclude<ExtArgs> | null
    /**
     * Filter, which AcrobaticsSkill to fetch.
     */
    where: AcrobaticsSkillWhereUniqueInput
  }

  /**
   * AcrobaticsSkill findFirst
   */
  export type AcrobaticsSkillFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcrobaticsSkill
     */
    select?: AcrobaticsSkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AcrobaticsSkill
     */
    omit?: AcrobaticsSkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcrobaticsSkillInclude<ExtArgs> | null
    /**
     * Filter, which AcrobaticsSkill to fetch.
     */
    where?: AcrobaticsSkillWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AcrobaticsSkills to fetch.
     */
    orderBy?: AcrobaticsSkillOrderByWithRelationInput | AcrobaticsSkillOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AcrobaticsSkills.
     */
    cursor?: AcrobaticsSkillWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AcrobaticsSkills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AcrobaticsSkills.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AcrobaticsSkills.
     */
    distinct?: AcrobaticsSkillScalarFieldEnum | AcrobaticsSkillScalarFieldEnum[]
  }

  /**
   * AcrobaticsSkill findFirstOrThrow
   */
  export type AcrobaticsSkillFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcrobaticsSkill
     */
    select?: AcrobaticsSkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AcrobaticsSkill
     */
    omit?: AcrobaticsSkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcrobaticsSkillInclude<ExtArgs> | null
    /**
     * Filter, which AcrobaticsSkill to fetch.
     */
    where?: AcrobaticsSkillWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AcrobaticsSkills to fetch.
     */
    orderBy?: AcrobaticsSkillOrderByWithRelationInput | AcrobaticsSkillOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AcrobaticsSkills.
     */
    cursor?: AcrobaticsSkillWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AcrobaticsSkills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AcrobaticsSkills.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AcrobaticsSkills.
     */
    distinct?: AcrobaticsSkillScalarFieldEnum | AcrobaticsSkillScalarFieldEnum[]
  }

  /**
   * AcrobaticsSkill findMany
   */
  export type AcrobaticsSkillFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcrobaticsSkill
     */
    select?: AcrobaticsSkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AcrobaticsSkill
     */
    omit?: AcrobaticsSkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcrobaticsSkillInclude<ExtArgs> | null
    /**
     * Filter, which AcrobaticsSkills to fetch.
     */
    where?: AcrobaticsSkillWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AcrobaticsSkills to fetch.
     */
    orderBy?: AcrobaticsSkillOrderByWithRelationInput | AcrobaticsSkillOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AcrobaticsSkills.
     */
    cursor?: AcrobaticsSkillWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AcrobaticsSkills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AcrobaticsSkills.
     */
    skip?: number
    distinct?: AcrobaticsSkillScalarFieldEnum | AcrobaticsSkillScalarFieldEnum[]
  }

  /**
   * AcrobaticsSkill create
   */
  export type AcrobaticsSkillCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcrobaticsSkill
     */
    select?: AcrobaticsSkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AcrobaticsSkill
     */
    omit?: AcrobaticsSkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcrobaticsSkillInclude<ExtArgs> | null
    /**
     * The data needed to create a AcrobaticsSkill.
     */
    data: XOR<AcrobaticsSkillCreateInput, AcrobaticsSkillUncheckedCreateInput>
  }

  /**
   * AcrobaticsSkill createMany
   */
  export type AcrobaticsSkillCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AcrobaticsSkills.
     */
    data: AcrobaticsSkillCreateManyInput | AcrobaticsSkillCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AcrobaticsSkill createManyAndReturn
   */
  export type AcrobaticsSkillCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcrobaticsSkill
     */
    select?: AcrobaticsSkillSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AcrobaticsSkill
     */
    omit?: AcrobaticsSkillOmit<ExtArgs> | null
    /**
     * The data used to create many AcrobaticsSkills.
     */
    data: AcrobaticsSkillCreateManyInput | AcrobaticsSkillCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcrobaticsSkillIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AcrobaticsSkill update
   */
  export type AcrobaticsSkillUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcrobaticsSkill
     */
    select?: AcrobaticsSkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AcrobaticsSkill
     */
    omit?: AcrobaticsSkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcrobaticsSkillInclude<ExtArgs> | null
    /**
     * The data needed to update a AcrobaticsSkill.
     */
    data: XOR<AcrobaticsSkillUpdateInput, AcrobaticsSkillUncheckedUpdateInput>
    /**
     * Choose, which AcrobaticsSkill to update.
     */
    where: AcrobaticsSkillWhereUniqueInput
  }

  /**
   * AcrobaticsSkill updateMany
   */
  export type AcrobaticsSkillUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AcrobaticsSkills.
     */
    data: XOR<AcrobaticsSkillUpdateManyMutationInput, AcrobaticsSkillUncheckedUpdateManyInput>
    /**
     * Filter which AcrobaticsSkills to update
     */
    where?: AcrobaticsSkillWhereInput
    /**
     * Limit how many AcrobaticsSkills to update.
     */
    limit?: number
  }

  /**
   * AcrobaticsSkill updateManyAndReturn
   */
  export type AcrobaticsSkillUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcrobaticsSkill
     */
    select?: AcrobaticsSkillSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AcrobaticsSkill
     */
    omit?: AcrobaticsSkillOmit<ExtArgs> | null
    /**
     * The data used to update AcrobaticsSkills.
     */
    data: XOR<AcrobaticsSkillUpdateManyMutationInput, AcrobaticsSkillUncheckedUpdateManyInput>
    /**
     * Filter which AcrobaticsSkills to update
     */
    where?: AcrobaticsSkillWhereInput
    /**
     * Limit how many AcrobaticsSkills to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcrobaticsSkillIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AcrobaticsSkill upsert
   */
  export type AcrobaticsSkillUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcrobaticsSkill
     */
    select?: AcrobaticsSkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AcrobaticsSkill
     */
    omit?: AcrobaticsSkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcrobaticsSkillInclude<ExtArgs> | null
    /**
     * The filter to search for the AcrobaticsSkill to update in case it exists.
     */
    where: AcrobaticsSkillWhereUniqueInput
    /**
     * In case the AcrobaticsSkill found by the `where` argument doesn't exist, create a new AcrobaticsSkill with this data.
     */
    create: XOR<AcrobaticsSkillCreateInput, AcrobaticsSkillUncheckedCreateInput>
    /**
     * In case the AcrobaticsSkill was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AcrobaticsSkillUpdateInput, AcrobaticsSkillUncheckedUpdateInput>
  }

  /**
   * AcrobaticsSkill delete
   */
  export type AcrobaticsSkillDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcrobaticsSkill
     */
    select?: AcrobaticsSkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AcrobaticsSkill
     */
    omit?: AcrobaticsSkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcrobaticsSkillInclude<ExtArgs> | null
    /**
     * Filter which AcrobaticsSkill to delete.
     */
    where: AcrobaticsSkillWhereUniqueInput
  }

  /**
   * AcrobaticsSkill deleteMany
   */
  export type AcrobaticsSkillDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AcrobaticsSkills to delete
     */
    where?: AcrobaticsSkillWhereInput
    /**
     * Limit how many AcrobaticsSkills to delete.
     */
    limit?: number
  }

  /**
   * AcrobaticsSkill without action
   */
  export type AcrobaticsSkillDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcrobaticsSkill
     */
    select?: AcrobaticsSkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AcrobaticsSkill
     */
    omit?: AcrobaticsSkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcrobaticsSkillInclude<ExtArgs> | null
  }


  /**
   * Model SleightOfHandSkill
   */

  export type AggregateSleightOfHandSkill = {
    _count: SleightOfHandSkillCountAggregateOutputType | null
    _avg: SleightOfHandSkillAvgAggregateOutputType | null
    _sum: SleightOfHandSkillSumAggregateOutputType | null
    _min: SleightOfHandSkillMinAggregateOutputType | null
    _max: SleightOfHandSkillMaxAggregateOutputType | null
  }

  export type SleightOfHandSkillAvgAggregateOutputType = {
    value: number | null
  }

  export type SleightOfHandSkillSumAggregateOutputType = {
    value: number | null
  }

  export type SleightOfHandSkillMinAggregateOutputType = {
    id: string | null
    value: number | null
    mastery: boolean | null
    name: string | null
  }

  export type SleightOfHandSkillMaxAggregateOutputType = {
    id: string | null
    value: number | null
    mastery: boolean | null
    name: string | null
  }

  export type SleightOfHandSkillCountAggregateOutputType = {
    id: number
    value: number
    mastery: number
    name: number
    _all: number
  }


  export type SleightOfHandSkillAvgAggregateInputType = {
    value?: true
  }

  export type SleightOfHandSkillSumAggregateInputType = {
    value?: true
  }

  export type SleightOfHandSkillMinAggregateInputType = {
    id?: true
    value?: true
    mastery?: true
    name?: true
  }

  export type SleightOfHandSkillMaxAggregateInputType = {
    id?: true
    value?: true
    mastery?: true
    name?: true
  }

  export type SleightOfHandSkillCountAggregateInputType = {
    id?: true
    value?: true
    mastery?: true
    name?: true
    _all?: true
  }

  export type SleightOfHandSkillAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SleightOfHandSkill to aggregate.
     */
    where?: SleightOfHandSkillWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SleightOfHandSkills to fetch.
     */
    orderBy?: SleightOfHandSkillOrderByWithRelationInput | SleightOfHandSkillOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SleightOfHandSkillWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SleightOfHandSkills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SleightOfHandSkills.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SleightOfHandSkills
    **/
    _count?: true | SleightOfHandSkillCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SleightOfHandSkillAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SleightOfHandSkillSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SleightOfHandSkillMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SleightOfHandSkillMaxAggregateInputType
  }

  export type GetSleightOfHandSkillAggregateType<T extends SleightOfHandSkillAggregateArgs> = {
        [P in keyof T & keyof AggregateSleightOfHandSkill]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSleightOfHandSkill[P]>
      : GetScalarType<T[P], AggregateSleightOfHandSkill[P]>
  }




  export type SleightOfHandSkillGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SleightOfHandSkillWhereInput
    orderBy?: SleightOfHandSkillOrderByWithAggregationInput | SleightOfHandSkillOrderByWithAggregationInput[]
    by: SleightOfHandSkillScalarFieldEnum[] | SleightOfHandSkillScalarFieldEnum
    having?: SleightOfHandSkillScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SleightOfHandSkillCountAggregateInputType | true
    _avg?: SleightOfHandSkillAvgAggregateInputType
    _sum?: SleightOfHandSkillSumAggregateInputType
    _min?: SleightOfHandSkillMinAggregateInputType
    _max?: SleightOfHandSkillMaxAggregateInputType
  }

  export type SleightOfHandSkillGroupByOutputType = {
    id: string
    value: number | null
    mastery: boolean
    name: string
    _count: SleightOfHandSkillCountAggregateOutputType | null
    _avg: SleightOfHandSkillAvgAggregateOutputType | null
    _sum: SleightOfHandSkillSumAggregateOutputType | null
    _min: SleightOfHandSkillMinAggregateOutputType | null
    _max: SleightOfHandSkillMaxAggregateOutputType | null
  }

  type GetSleightOfHandSkillGroupByPayload<T extends SleightOfHandSkillGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SleightOfHandSkillGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SleightOfHandSkillGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SleightOfHandSkillGroupByOutputType[P]>
            : GetScalarType<T[P], SleightOfHandSkillGroupByOutputType[P]>
        }
      >
    >


  export type SleightOfHandSkillSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    value?: boolean
    mastery?: boolean
    name?: boolean
    skill_list?: boolean | DexterityBasedSkillsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sleightOfHandSkill"]>

  export type SleightOfHandSkillSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    value?: boolean
    mastery?: boolean
    name?: boolean
    skill_list?: boolean | DexterityBasedSkillsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sleightOfHandSkill"]>

  export type SleightOfHandSkillSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    value?: boolean
    mastery?: boolean
    name?: boolean
    skill_list?: boolean | DexterityBasedSkillsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sleightOfHandSkill"]>

  export type SleightOfHandSkillSelectScalar = {
    id?: boolean
    value?: boolean
    mastery?: boolean
    name?: boolean
  }

  export type SleightOfHandSkillOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "value" | "mastery" | "name", ExtArgs["result"]["sleightOfHandSkill"]>
  export type SleightOfHandSkillInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    skill_list?: boolean | DexterityBasedSkillsDefaultArgs<ExtArgs>
  }
  export type SleightOfHandSkillIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    skill_list?: boolean | DexterityBasedSkillsDefaultArgs<ExtArgs>
  }
  export type SleightOfHandSkillIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    skill_list?: boolean | DexterityBasedSkillsDefaultArgs<ExtArgs>
  }

  export type $SleightOfHandSkillPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SleightOfHandSkill"
    objects: {
      skill_list: Prisma.$DexterityBasedSkillsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      value: number | null
      mastery: boolean
      name: string
    }, ExtArgs["result"]["sleightOfHandSkill"]>
    composites: {}
  }

  type SleightOfHandSkillGetPayload<S extends boolean | null | undefined | SleightOfHandSkillDefaultArgs> = $Result.GetResult<Prisma.$SleightOfHandSkillPayload, S>

  type SleightOfHandSkillCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SleightOfHandSkillFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SleightOfHandSkillCountAggregateInputType | true
    }

  export interface SleightOfHandSkillDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SleightOfHandSkill'], meta: { name: 'SleightOfHandSkill' } }
    /**
     * Find zero or one SleightOfHandSkill that matches the filter.
     * @param {SleightOfHandSkillFindUniqueArgs} args - Arguments to find a SleightOfHandSkill
     * @example
     * // Get one SleightOfHandSkill
     * const sleightOfHandSkill = await prisma.sleightOfHandSkill.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SleightOfHandSkillFindUniqueArgs>(args: SelectSubset<T, SleightOfHandSkillFindUniqueArgs<ExtArgs>>): Prisma__SleightOfHandSkillClient<$Result.GetResult<Prisma.$SleightOfHandSkillPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one SleightOfHandSkill that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SleightOfHandSkillFindUniqueOrThrowArgs} args - Arguments to find a SleightOfHandSkill
     * @example
     * // Get one SleightOfHandSkill
     * const sleightOfHandSkill = await prisma.sleightOfHandSkill.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SleightOfHandSkillFindUniqueOrThrowArgs>(args: SelectSubset<T, SleightOfHandSkillFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SleightOfHandSkillClient<$Result.GetResult<Prisma.$SleightOfHandSkillPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first SleightOfHandSkill that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SleightOfHandSkillFindFirstArgs} args - Arguments to find a SleightOfHandSkill
     * @example
     * // Get one SleightOfHandSkill
     * const sleightOfHandSkill = await prisma.sleightOfHandSkill.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SleightOfHandSkillFindFirstArgs>(args?: SelectSubset<T, SleightOfHandSkillFindFirstArgs<ExtArgs>>): Prisma__SleightOfHandSkillClient<$Result.GetResult<Prisma.$SleightOfHandSkillPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first SleightOfHandSkill that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SleightOfHandSkillFindFirstOrThrowArgs} args - Arguments to find a SleightOfHandSkill
     * @example
     * // Get one SleightOfHandSkill
     * const sleightOfHandSkill = await prisma.sleightOfHandSkill.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SleightOfHandSkillFindFirstOrThrowArgs>(args?: SelectSubset<T, SleightOfHandSkillFindFirstOrThrowArgs<ExtArgs>>): Prisma__SleightOfHandSkillClient<$Result.GetResult<Prisma.$SleightOfHandSkillPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more SleightOfHandSkills that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SleightOfHandSkillFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SleightOfHandSkills
     * const sleightOfHandSkills = await prisma.sleightOfHandSkill.findMany()
     * 
     * // Get first 10 SleightOfHandSkills
     * const sleightOfHandSkills = await prisma.sleightOfHandSkill.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sleightOfHandSkillWithIdOnly = await prisma.sleightOfHandSkill.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SleightOfHandSkillFindManyArgs>(args?: SelectSubset<T, SleightOfHandSkillFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SleightOfHandSkillPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a SleightOfHandSkill.
     * @param {SleightOfHandSkillCreateArgs} args - Arguments to create a SleightOfHandSkill.
     * @example
     * // Create one SleightOfHandSkill
     * const SleightOfHandSkill = await prisma.sleightOfHandSkill.create({
     *   data: {
     *     // ... data to create a SleightOfHandSkill
     *   }
     * })
     * 
     */
    create<T extends SleightOfHandSkillCreateArgs>(args: SelectSubset<T, SleightOfHandSkillCreateArgs<ExtArgs>>): Prisma__SleightOfHandSkillClient<$Result.GetResult<Prisma.$SleightOfHandSkillPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many SleightOfHandSkills.
     * @param {SleightOfHandSkillCreateManyArgs} args - Arguments to create many SleightOfHandSkills.
     * @example
     * // Create many SleightOfHandSkills
     * const sleightOfHandSkill = await prisma.sleightOfHandSkill.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SleightOfHandSkillCreateManyArgs>(args?: SelectSubset<T, SleightOfHandSkillCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SleightOfHandSkills and returns the data saved in the database.
     * @param {SleightOfHandSkillCreateManyAndReturnArgs} args - Arguments to create many SleightOfHandSkills.
     * @example
     * // Create many SleightOfHandSkills
     * const sleightOfHandSkill = await prisma.sleightOfHandSkill.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SleightOfHandSkills and only return the `id`
     * const sleightOfHandSkillWithIdOnly = await prisma.sleightOfHandSkill.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SleightOfHandSkillCreateManyAndReturnArgs>(args?: SelectSubset<T, SleightOfHandSkillCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SleightOfHandSkillPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a SleightOfHandSkill.
     * @param {SleightOfHandSkillDeleteArgs} args - Arguments to delete one SleightOfHandSkill.
     * @example
     * // Delete one SleightOfHandSkill
     * const SleightOfHandSkill = await prisma.sleightOfHandSkill.delete({
     *   where: {
     *     // ... filter to delete one SleightOfHandSkill
     *   }
     * })
     * 
     */
    delete<T extends SleightOfHandSkillDeleteArgs>(args: SelectSubset<T, SleightOfHandSkillDeleteArgs<ExtArgs>>): Prisma__SleightOfHandSkillClient<$Result.GetResult<Prisma.$SleightOfHandSkillPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one SleightOfHandSkill.
     * @param {SleightOfHandSkillUpdateArgs} args - Arguments to update one SleightOfHandSkill.
     * @example
     * // Update one SleightOfHandSkill
     * const sleightOfHandSkill = await prisma.sleightOfHandSkill.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SleightOfHandSkillUpdateArgs>(args: SelectSubset<T, SleightOfHandSkillUpdateArgs<ExtArgs>>): Prisma__SleightOfHandSkillClient<$Result.GetResult<Prisma.$SleightOfHandSkillPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more SleightOfHandSkills.
     * @param {SleightOfHandSkillDeleteManyArgs} args - Arguments to filter SleightOfHandSkills to delete.
     * @example
     * // Delete a few SleightOfHandSkills
     * const { count } = await prisma.sleightOfHandSkill.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SleightOfHandSkillDeleteManyArgs>(args?: SelectSubset<T, SleightOfHandSkillDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SleightOfHandSkills.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SleightOfHandSkillUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SleightOfHandSkills
     * const sleightOfHandSkill = await prisma.sleightOfHandSkill.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SleightOfHandSkillUpdateManyArgs>(args: SelectSubset<T, SleightOfHandSkillUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SleightOfHandSkills and returns the data updated in the database.
     * @param {SleightOfHandSkillUpdateManyAndReturnArgs} args - Arguments to update many SleightOfHandSkills.
     * @example
     * // Update many SleightOfHandSkills
     * const sleightOfHandSkill = await prisma.sleightOfHandSkill.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SleightOfHandSkills and only return the `id`
     * const sleightOfHandSkillWithIdOnly = await prisma.sleightOfHandSkill.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SleightOfHandSkillUpdateManyAndReturnArgs>(args: SelectSubset<T, SleightOfHandSkillUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SleightOfHandSkillPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one SleightOfHandSkill.
     * @param {SleightOfHandSkillUpsertArgs} args - Arguments to update or create a SleightOfHandSkill.
     * @example
     * // Update or create a SleightOfHandSkill
     * const sleightOfHandSkill = await prisma.sleightOfHandSkill.upsert({
     *   create: {
     *     // ... data to create a SleightOfHandSkill
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SleightOfHandSkill we want to update
     *   }
     * })
     */
    upsert<T extends SleightOfHandSkillUpsertArgs>(args: SelectSubset<T, SleightOfHandSkillUpsertArgs<ExtArgs>>): Prisma__SleightOfHandSkillClient<$Result.GetResult<Prisma.$SleightOfHandSkillPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of SleightOfHandSkills.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SleightOfHandSkillCountArgs} args - Arguments to filter SleightOfHandSkills to count.
     * @example
     * // Count the number of SleightOfHandSkills
     * const count = await prisma.sleightOfHandSkill.count({
     *   where: {
     *     // ... the filter for the SleightOfHandSkills we want to count
     *   }
     * })
    **/
    count<T extends SleightOfHandSkillCountArgs>(
      args?: Subset<T, SleightOfHandSkillCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SleightOfHandSkillCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SleightOfHandSkill.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SleightOfHandSkillAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SleightOfHandSkillAggregateArgs>(args: Subset<T, SleightOfHandSkillAggregateArgs>): Prisma.PrismaPromise<GetSleightOfHandSkillAggregateType<T>>

    /**
     * Group by SleightOfHandSkill.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SleightOfHandSkillGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SleightOfHandSkillGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SleightOfHandSkillGroupByArgs['orderBy'] }
        : { orderBy?: SleightOfHandSkillGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SleightOfHandSkillGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSleightOfHandSkillGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SleightOfHandSkill model
   */
  readonly fields: SleightOfHandSkillFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SleightOfHandSkill.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SleightOfHandSkillClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    skill_list<T extends DexterityBasedSkillsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DexterityBasedSkillsDefaultArgs<ExtArgs>>): Prisma__DexterityBasedSkillsClient<$Result.GetResult<Prisma.$DexterityBasedSkillsPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SleightOfHandSkill model
   */ 
  interface SleightOfHandSkillFieldRefs {
    readonly id: FieldRef<"SleightOfHandSkill", 'String'>
    readonly value: FieldRef<"SleightOfHandSkill", 'Int'>
    readonly mastery: FieldRef<"SleightOfHandSkill", 'Boolean'>
    readonly name: FieldRef<"SleightOfHandSkill", 'String'>
  }
    

  // Custom InputTypes
  /**
   * SleightOfHandSkill findUnique
   */
  export type SleightOfHandSkillFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SleightOfHandSkill
     */
    select?: SleightOfHandSkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SleightOfHandSkill
     */
    omit?: SleightOfHandSkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SleightOfHandSkillInclude<ExtArgs> | null
    /**
     * Filter, which SleightOfHandSkill to fetch.
     */
    where: SleightOfHandSkillWhereUniqueInput
  }

  /**
   * SleightOfHandSkill findUniqueOrThrow
   */
  export type SleightOfHandSkillFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SleightOfHandSkill
     */
    select?: SleightOfHandSkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SleightOfHandSkill
     */
    omit?: SleightOfHandSkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SleightOfHandSkillInclude<ExtArgs> | null
    /**
     * Filter, which SleightOfHandSkill to fetch.
     */
    where: SleightOfHandSkillWhereUniqueInput
  }

  /**
   * SleightOfHandSkill findFirst
   */
  export type SleightOfHandSkillFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SleightOfHandSkill
     */
    select?: SleightOfHandSkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SleightOfHandSkill
     */
    omit?: SleightOfHandSkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SleightOfHandSkillInclude<ExtArgs> | null
    /**
     * Filter, which SleightOfHandSkill to fetch.
     */
    where?: SleightOfHandSkillWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SleightOfHandSkills to fetch.
     */
    orderBy?: SleightOfHandSkillOrderByWithRelationInput | SleightOfHandSkillOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SleightOfHandSkills.
     */
    cursor?: SleightOfHandSkillWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SleightOfHandSkills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SleightOfHandSkills.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SleightOfHandSkills.
     */
    distinct?: SleightOfHandSkillScalarFieldEnum | SleightOfHandSkillScalarFieldEnum[]
  }

  /**
   * SleightOfHandSkill findFirstOrThrow
   */
  export type SleightOfHandSkillFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SleightOfHandSkill
     */
    select?: SleightOfHandSkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SleightOfHandSkill
     */
    omit?: SleightOfHandSkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SleightOfHandSkillInclude<ExtArgs> | null
    /**
     * Filter, which SleightOfHandSkill to fetch.
     */
    where?: SleightOfHandSkillWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SleightOfHandSkills to fetch.
     */
    orderBy?: SleightOfHandSkillOrderByWithRelationInput | SleightOfHandSkillOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SleightOfHandSkills.
     */
    cursor?: SleightOfHandSkillWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SleightOfHandSkills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SleightOfHandSkills.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SleightOfHandSkills.
     */
    distinct?: SleightOfHandSkillScalarFieldEnum | SleightOfHandSkillScalarFieldEnum[]
  }

  /**
   * SleightOfHandSkill findMany
   */
  export type SleightOfHandSkillFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SleightOfHandSkill
     */
    select?: SleightOfHandSkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SleightOfHandSkill
     */
    omit?: SleightOfHandSkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SleightOfHandSkillInclude<ExtArgs> | null
    /**
     * Filter, which SleightOfHandSkills to fetch.
     */
    where?: SleightOfHandSkillWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SleightOfHandSkills to fetch.
     */
    orderBy?: SleightOfHandSkillOrderByWithRelationInput | SleightOfHandSkillOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SleightOfHandSkills.
     */
    cursor?: SleightOfHandSkillWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SleightOfHandSkills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SleightOfHandSkills.
     */
    skip?: number
    distinct?: SleightOfHandSkillScalarFieldEnum | SleightOfHandSkillScalarFieldEnum[]
  }

  /**
   * SleightOfHandSkill create
   */
  export type SleightOfHandSkillCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SleightOfHandSkill
     */
    select?: SleightOfHandSkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SleightOfHandSkill
     */
    omit?: SleightOfHandSkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SleightOfHandSkillInclude<ExtArgs> | null
    /**
     * The data needed to create a SleightOfHandSkill.
     */
    data: XOR<SleightOfHandSkillCreateInput, SleightOfHandSkillUncheckedCreateInput>
  }

  /**
   * SleightOfHandSkill createMany
   */
  export type SleightOfHandSkillCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SleightOfHandSkills.
     */
    data: SleightOfHandSkillCreateManyInput | SleightOfHandSkillCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SleightOfHandSkill createManyAndReturn
   */
  export type SleightOfHandSkillCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SleightOfHandSkill
     */
    select?: SleightOfHandSkillSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SleightOfHandSkill
     */
    omit?: SleightOfHandSkillOmit<ExtArgs> | null
    /**
     * The data used to create many SleightOfHandSkills.
     */
    data: SleightOfHandSkillCreateManyInput | SleightOfHandSkillCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SleightOfHandSkillIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SleightOfHandSkill update
   */
  export type SleightOfHandSkillUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SleightOfHandSkill
     */
    select?: SleightOfHandSkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SleightOfHandSkill
     */
    omit?: SleightOfHandSkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SleightOfHandSkillInclude<ExtArgs> | null
    /**
     * The data needed to update a SleightOfHandSkill.
     */
    data: XOR<SleightOfHandSkillUpdateInput, SleightOfHandSkillUncheckedUpdateInput>
    /**
     * Choose, which SleightOfHandSkill to update.
     */
    where: SleightOfHandSkillWhereUniqueInput
  }

  /**
   * SleightOfHandSkill updateMany
   */
  export type SleightOfHandSkillUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SleightOfHandSkills.
     */
    data: XOR<SleightOfHandSkillUpdateManyMutationInput, SleightOfHandSkillUncheckedUpdateManyInput>
    /**
     * Filter which SleightOfHandSkills to update
     */
    where?: SleightOfHandSkillWhereInput
    /**
     * Limit how many SleightOfHandSkills to update.
     */
    limit?: number
  }

  /**
   * SleightOfHandSkill updateManyAndReturn
   */
  export type SleightOfHandSkillUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SleightOfHandSkill
     */
    select?: SleightOfHandSkillSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SleightOfHandSkill
     */
    omit?: SleightOfHandSkillOmit<ExtArgs> | null
    /**
     * The data used to update SleightOfHandSkills.
     */
    data: XOR<SleightOfHandSkillUpdateManyMutationInput, SleightOfHandSkillUncheckedUpdateManyInput>
    /**
     * Filter which SleightOfHandSkills to update
     */
    where?: SleightOfHandSkillWhereInput
    /**
     * Limit how many SleightOfHandSkills to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SleightOfHandSkillIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * SleightOfHandSkill upsert
   */
  export type SleightOfHandSkillUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SleightOfHandSkill
     */
    select?: SleightOfHandSkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SleightOfHandSkill
     */
    omit?: SleightOfHandSkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SleightOfHandSkillInclude<ExtArgs> | null
    /**
     * The filter to search for the SleightOfHandSkill to update in case it exists.
     */
    where: SleightOfHandSkillWhereUniqueInput
    /**
     * In case the SleightOfHandSkill found by the `where` argument doesn't exist, create a new SleightOfHandSkill with this data.
     */
    create: XOR<SleightOfHandSkillCreateInput, SleightOfHandSkillUncheckedCreateInput>
    /**
     * In case the SleightOfHandSkill was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SleightOfHandSkillUpdateInput, SleightOfHandSkillUncheckedUpdateInput>
  }

  /**
   * SleightOfHandSkill delete
   */
  export type SleightOfHandSkillDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SleightOfHandSkill
     */
    select?: SleightOfHandSkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SleightOfHandSkill
     */
    omit?: SleightOfHandSkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SleightOfHandSkillInclude<ExtArgs> | null
    /**
     * Filter which SleightOfHandSkill to delete.
     */
    where: SleightOfHandSkillWhereUniqueInput
  }

  /**
   * SleightOfHandSkill deleteMany
   */
  export type SleightOfHandSkillDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SleightOfHandSkills to delete
     */
    where?: SleightOfHandSkillWhereInput
    /**
     * Limit how many SleightOfHandSkills to delete.
     */
    limit?: number
  }

  /**
   * SleightOfHandSkill without action
   */
  export type SleightOfHandSkillDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SleightOfHandSkill
     */
    select?: SleightOfHandSkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SleightOfHandSkill
     */
    omit?: SleightOfHandSkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SleightOfHandSkillInclude<ExtArgs> | null
  }


  /**
   * Model StealthSkill
   */

  export type AggregateStealthSkill = {
    _count: StealthSkillCountAggregateOutputType | null
    _avg: StealthSkillAvgAggregateOutputType | null
    _sum: StealthSkillSumAggregateOutputType | null
    _min: StealthSkillMinAggregateOutputType | null
    _max: StealthSkillMaxAggregateOutputType | null
  }

  export type StealthSkillAvgAggregateOutputType = {
    value: number | null
  }

  export type StealthSkillSumAggregateOutputType = {
    value: number | null
  }

  export type StealthSkillMinAggregateOutputType = {
    id: string | null
    value: number | null
    mastery: boolean | null
    name: string | null
  }

  export type StealthSkillMaxAggregateOutputType = {
    id: string | null
    value: number | null
    mastery: boolean | null
    name: string | null
  }

  export type StealthSkillCountAggregateOutputType = {
    id: number
    value: number
    mastery: number
    name: number
    _all: number
  }


  export type StealthSkillAvgAggregateInputType = {
    value?: true
  }

  export type StealthSkillSumAggregateInputType = {
    value?: true
  }

  export type StealthSkillMinAggregateInputType = {
    id?: true
    value?: true
    mastery?: true
    name?: true
  }

  export type StealthSkillMaxAggregateInputType = {
    id?: true
    value?: true
    mastery?: true
    name?: true
  }

  export type StealthSkillCountAggregateInputType = {
    id?: true
    value?: true
    mastery?: true
    name?: true
    _all?: true
  }

  export type StealthSkillAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StealthSkill to aggregate.
     */
    where?: StealthSkillWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StealthSkills to fetch.
     */
    orderBy?: StealthSkillOrderByWithRelationInput | StealthSkillOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StealthSkillWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StealthSkills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StealthSkills.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned StealthSkills
    **/
    _count?: true | StealthSkillCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: StealthSkillAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: StealthSkillSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StealthSkillMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StealthSkillMaxAggregateInputType
  }

  export type GetStealthSkillAggregateType<T extends StealthSkillAggregateArgs> = {
        [P in keyof T & keyof AggregateStealthSkill]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStealthSkill[P]>
      : GetScalarType<T[P], AggregateStealthSkill[P]>
  }




  export type StealthSkillGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StealthSkillWhereInput
    orderBy?: StealthSkillOrderByWithAggregationInput | StealthSkillOrderByWithAggregationInput[]
    by: StealthSkillScalarFieldEnum[] | StealthSkillScalarFieldEnum
    having?: StealthSkillScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StealthSkillCountAggregateInputType | true
    _avg?: StealthSkillAvgAggregateInputType
    _sum?: StealthSkillSumAggregateInputType
    _min?: StealthSkillMinAggregateInputType
    _max?: StealthSkillMaxAggregateInputType
  }

  export type StealthSkillGroupByOutputType = {
    id: string
    value: number | null
    mastery: boolean
    name: string
    _count: StealthSkillCountAggregateOutputType | null
    _avg: StealthSkillAvgAggregateOutputType | null
    _sum: StealthSkillSumAggregateOutputType | null
    _min: StealthSkillMinAggregateOutputType | null
    _max: StealthSkillMaxAggregateOutputType | null
  }

  type GetStealthSkillGroupByPayload<T extends StealthSkillGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StealthSkillGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StealthSkillGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StealthSkillGroupByOutputType[P]>
            : GetScalarType<T[P], StealthSkillGroupByOutputType[P]>
        }
      >
    >


  export type StealthSkillSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    value?: boolean
    mastery?: boolean
    name?: boolean
    skill_list?: boolean | DexterityBasedSkillsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["stealthSkill"]>

  export type StealthSkillSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    value?: boolean
    mastery?: boolean
    name?: boolean
    skill_list?: boolean | DexterityBasedSkillsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["stealthSkill"]>

  export type StealthSkillSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    value?: boolean
    mastery?: boolean
    name?: boolean
    skill_list?: boolean | DexterityBasedSkillsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["stealthSkill"]>

  export type StealthSkillSelectScalar = {
    id?: boolean
    value?: boolean
    mastery?: boolean
    name?: boolean
  }

  export type StealthSkillOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "value" | "mastery" | "name", ExtArgs["result"]["stealthSkill"]>
  export type StealthSkillInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    skill_list?: boolean | DexterityBasedSkillsDefaultArgs<ExtArgs>
  }
  export type StealthSkillIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    skill_list?: boolean | DexterityBasedSkillsDefaultArgs<ExtArgs>
  }
  export type StealthSkillIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    skill_list?: boolean | DexterityBasedSkillsDefaultArgs<ExtArgs>
  }

  export type $StealthSkillPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "StealthSkill"
    objects: {
      skill_list: Prisma.$DexterityBasedSkillsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      value: number | null
      mastery: boolean
      name: string
    }, ExtArgs["result"]["stealthSkill"]>
    composites: {}
  }

  type StealthSkillGetPayload<S extends boolean | null | undefined | StealthSkillDefaultArgs> = $Result.GetResult<Prisma.$StealthSkillPayload, S>

  type StealthSkillCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<StealthSkillFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: StealthSkillCountAggregateInputType | true
    }

  export interface StealthSkillDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['StealthSkill'], meta: { name: 'StealthSkill' } }
    /**
     * Find zero or one StealthSkill that matches the filter.
     * @param {StealthSkillFindUniqueArgs} args - Arguments to find a StealthSkill
     * @example
     * // Get one StealthSkill
     * const stealthSkill = await prisma.stealthSkill.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends StealthSkillFindUniqueArgs>(args: SelectSubset<T, StealthSkillFindUniqueArgs<ExtArgs>>): Prisma__StealthSkillClient<$Result.GetResult<Prisma.$StealthSkillPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one StealthSkill that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {StealthSkillFindUniqueOrThrowArgs} args - Arguments to find a StealthSkill
     * @example
     * // Get one StealthSkill
     * const stealthSkill = await prisma.stealthSkill.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends StealthSkillFindUniqueOrThrowArgs>(args: SelectSubset<T, StealthSkillFindUniqueOrThrowArgs<ExtArgs>>): Prisma__StealthSkillClient<$Result.GetResult<Prisma.$StealthSkillPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first StealthSkill that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StealthSkillFindFirstArgs} args - Arguments to find a StealthSkill
     * @example
     * // Get one StealthSkill
     * const stealthSkill = await prisma.stealthSkill.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends StealthSkillFindFirstArgs>(args?: SelectSubset<T, StealthSkillFindFirstArgs<ExtArgs>>): Prisma__StealthSkillClient<$Result.GetResult<Prisma.$StealthSkillPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first StealthSkill that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StealthSkillFindFirstOrThrowArgs} args - Arguments to find a StealthSkill
     * @example
     * // Get one StealthSkill
     * const stealthSkill = await prisma.stealthSkill.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends StealthSkillFindFirstOrThrowArgs>(args?: SelectSubset<T, StealthSkillFindFirstOrThrowArgs<ExtArgs>>): Prisma__StealthSkillClient<$Result.GetResult<Prisma.$StealthSkillPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more StealthSkills that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StealthSkillFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all StealthSkills
     * const stealthSkills = await prisma.stealthSkill.findMany()
     * 
     * // Get first 10 StealthSkills
     * const stealthSkills = await prisma.stealthSkill.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const stealthSkillWithIdOnly = await prisma.stealthSkill.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends StealthSkillFindManyArgs>(args?: SelectSubset<T, StealthSkillFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StealthSkillPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a StealthSkill.
     * @param {StealthSkillCreateArgs} args - Arguments to create a StealthSkill.
     * @example
     * // Create one StealthSkill
     * const StealthSkill = await prisma.stealthSkill.create({
     *   data: {
     *     // ... data to create a StealthSkill
     *   }
     * })
     * 
     */
    create<T extends StealthSkillCreateArgs>(args: SelectSubset<T, StealthSkillCreateArgs<ExtArgs>>): Prisma__StealthSkillClient<$Result.GetResult<Prisma.$StealthSkillPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many StealthSkills.
     * @param {StealthSkillCreateManyArgs} args - Arguments to create many StealthSkills.
     * @example
     * // Create many StealthSkills
     * const stealthSkill = await prisma.stealthSkill.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends StealthSkillCreateManyArgs>(args?: SelectSubset<T, StealthSkillCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many StealthSkills and returns the data saved in the database.
     * @param {StealthSkillCreateManyAndReturnArgs} args - Arguments to create many StealthSkills.
     * @example
     * // Create many StealthSkills
     * const stealthSkill = await prisma.stealthSkill.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many StealthSkills and only return the `id`
     * const stealthSkillWithIdOnly = await prisma.stealthSkill.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends StealthSkillCreateManyAndReturnArgs>(args?: SelectSubset<T, StealthSkillCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StealthSkillPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a StealthSkill.
     * @param {StealthSkillDeleteArgs} args - Arguments to delete one StealthSkill.
     * @example
     * // Delete one StealthSkill
     * const StealthSkill = await prisma.stealthSkill.delete({
     *   where: {
     *     // ... filter to delete one StealthSkill
     *   }
     * })
     * 
     */
    delete<T extends StealthSkillDeleteArgs>(args: SelectSubset<T, StealthSkillDeleteArgs<ExtArgs>>): Prisma__StealthSkillClient<$Result.GetResult<Prisma.$StealthSkillPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one StealthSkill.
     * @param {StealthSkillUpdateArgs} args - Arguments to update one StealthSkill.
     * @example
     * // Update one StealthSkill
     * const stealthSkill = await prisma.stealthSkill.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends StealthSkillUpdateArgs>(args: SelectSubset<T, StealthSkillUpdateArgs<ExtArgs>>): Prisma__StealthSkillClient<$Result.GetResult<Prisma.$StealthSkillPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more StealthSkills.
     * @param {StealthSkillDeleteManyArgs} args - Arguments to filter StealthSkills to delete.
     * @example
     * // Delete a few StealthSkills
     * const { count } = await prisma.stealthSkill.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends StealthSkillDeleteManyArgs>(args?: SelectSubset<T, StealthSkillDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StealthSkills.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StealthSkillUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many StealthSkills
     * const stealthSkill = await prisma.stealthSkill.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends StealthSkillUpdateManyArgs>(args: SelectSubset<T, StealthSkillUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StealthSkills and returns the data updated in the database.
     * @param {StealthSkillUpdateManyAndReturnArgs} args - Arguments to update many StealthSkills.
     * @example
     * // Update many StealthSkills
     * const stealthSkill = await prisma.stealthSkill.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more StealthSkills and only return the `id`
     * const stealthSkillWithIdOnly = await prisma.stealthSkill.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends StealthSkillUpdateManyAndReturnArgs>(args: SelectSubset<T, StealthSkillUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StealthSkillPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one StealthSkill.
     * @param {StealthSkillUpsertArgs} args - Arguments to update or create a StealthSkill.
     * @example
     * // Update or create a StealthSkill
     * const stealthSkill = await prisma.stealthSkill.upsert({
     *   create: {
     *     // ... data to create a StealthSkill
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the StealthSkill we want to update
     *   }
     * })
     */
    upsert<T extends StealthSkillUpsertArgs>(args: SelectSubset<T, StealthSkillUpsertArgs<ExtArgs>>): Prisma__StealthSkillClient<$Result.GetResult<Prisma.$StealthSkillPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of StealthSkills.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StealthSkillCountArgs} args - Arguments to filter StealthSkills to count.
     * @example
     * // Count the number of StealthSkills
     * const count = await prisma.stealthSkill.count({
     *   where: {
     *     // ... the filter for the StealthSkills we want to count
     *   }
     * })
    **/
    count<T extends StealthSkillCountArgs>(
      args?: Subset<T, StealthSkillCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StealthSkillCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a StealthSkill.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StealthSkillAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StealthSkillAggregateArgs>(args: Subset<T, StealthSkillAggregateArgs>): Prisma.PrismaPromise<GetStealthSkillAggregateType<T>>

    /**
     * Group by StealthSkill.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StealthSkillGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StealthSkillGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StealthSkillGroupByArgs['orderBy'] }
        : { orderBy?: StealthSkillGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StealthSkillGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStealthSkillGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the StealthSkill model
   */
  readonly fields: StealthSkillFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for StealthSkill.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StealthSkillClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    skill_list<T extends DexterityBasedSkillsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DexterityBasedSkillsDefaultArgs<ExtArgs>>): Prisma__DexterityBasedSkillsClient<$Result.GetResult<Prisma.$DexterityBasedSkillsPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the StealthSkill model
   */ 
  interface StealthSkillFieldRefs {
    readonly id: FieldRef<"StealthSkill", 'String'>
    readonly value: FieldRef<"StealthSkill", 'Int'>
    readonly mastery: FieldRef<"StealthSkill", 'Boolean'>
    readonly name: FieldRef<"StealthSkill", 'String'>
  }
    

  // Custom InputTypes
  /**
   * StealthSkill findUnique
   */
  export type StealthSkillFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StealthSkill
     */
    select?: StealthSkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StealthSkill
     */
    omit?: StealthSkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StealthSkillInclude<ExtArgs> | null
    /**
     * Filter, which StealthSkill to fetch.
     */
    where: StealthSkillWhereUniqueInput
  }

  /**
   * StealthSkill findUniqueOrThrow
   */
  export type StealthSkillFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StealthSkill
     */
    select?: StealthSkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StealthSkill
     */
    omit?: StealthSkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StealthSkillInclude<ExtArgs> | null
    /**
     * Filter, which StealthSkill to fetch.
     */
    where: StealthSkillWhereUniqueInput
  }

  /**
   * StealthSkill findFirst
   */
  export type StealthSkillFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StealthSkill
     */
    select?: StealthSkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StealthSkill
     */
    omit?: StealthSkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StealthSkillInclude<ExtArgs> | null
    /**
     * Filter, which StealthSkill to fetch.
     */
    where?: StealthSkillWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StealthSkills to fetch.
     */
    orderBy?: StealthSkillOrderByWithRelationInput | StealthSkillOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StealthSkills.
     */
    cursor?: StealthSkillWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StealthSkills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StealthSkills.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StealthSkills.
     */
    distinct?: StealthSkillScalarFieldEnum | StealthSkillScalarFieldEnum[]
  }

  /**
   * StealthSkill findFirstOrThrow
   */
  export type StealthSkillFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StealthSkill
     */
    select?: StealthSkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StealthSkill
     */
    omit?: StealthSkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StealthSkillInclude<ExtArgs> | null
    /**
     * Filter, which StealthSkill to fetch.
     */
    where?: StealthSkillWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StealthSkills to fetch.
     */
    orderBy?: StealthSkillOrderByWithRelationInput | StealthSkillOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StealthSkills.
     */
    cursor?: StealthSkillWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StealthSkills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StealthSkills.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StealthSkills.
     */
    distinct?: StealthSkillScalarFieldEnum | StealthSkillScalarFieldEnum[]
  }

  /**
   * StealthSkill findMany
   */
  export type StealthSkillFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StealthSkill
     */
    select?: StealthSkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StealthSkill
     */
    omit?: StealthSkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StealthSkillInclude<ExtArgs> | null
    /**
     * Filter, which StealthSkills to fetch.
     */
    where?: StealthSkillWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StealthSkills to fetch.
     */
    orderBy?: StealthSkillOrderByWithRelationInput | StealthSkillOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing StealthSkills.
     */
    cursor?: StealthSkillWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StealthSkills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StealthSkills.
     */
    skip?: number
    distinct?: StealthSkillScalarFieldEnum | StealthSkillScalarFieldEnum[]
  }

  /**
   * StealthSkill create
   */
  export type StealthSkillCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StealthSkill
     */
    select?: StealthSkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StealthSkill
     */
    omit?: StealthSkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StealthSkillInclude<ExtArgs> | null
    /**
     * The data needed to create a StealthSkill.
     */
    data: XOR<StealthSkillCreateInput, StealthSkillUncheckedCreateInput>
  }

  /**
   * StealthSkill createMany
   */
  export type StealthSkillCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many StealthSkills.
     */
    data: StealthSkillCreateManyInput | StealthSkillCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * StealthSkill createManyAndReturn
   */
  export type StealthSkillCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StealthSkill
     */
    select?: StealthSkillSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the StealthSkill
     */
    omit?: StealthSkillOmit<ExtArgs> | null
    /**
     * The data used to create many StealthSkills.
     */
    data: StealthSkillCreateManyInput | StealthSkillCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StealthSkillIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * StealthSkill update
   */
  export type StealthSkillUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StealthSkill
     */
    select?: StealthSkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StealthSkill
     */
    omit?: StealthSkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StealthSkillInclude<ExtArgs> | null
    /**
     * The data needed to update a StealthSkill.
     */
    data: XOR<StealthSkillUpdateInput, StealthSkillUncheckedUpdateInput>
    /**
     * Choose, which StealthSkill to update.
     */
    where: StealthSkillWhereUniqueInput
  }

  /**
   * StealthSkill updateMany
   */
  export type StealthSkillUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update StealthSkills.
     */
    data: XOR<StealthSkillUpdateManyMutationInput, StealthSkillUncheckedUpdateManyInput>
    /**
     * Filter which StealthSkills to update
     */
    where?: StealthSkillWhereInput
    /**
     * Limit how many StealthSkills to update.
     */
    limit?: number
  }

  /**
   * StealthSkill updateManyAndReturn
   */
  export type StealthSkillUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StealthSkill
     */
    select?: StealthSkillSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the StealthSkill
     */
    omit?: StealthSkillOmit<ExtArgs> | null
    /**
     * The data used to update StealthSkills.
     */
    data: XOR<StealthSkillUpdateManyMutationInput, StealthSkillUncheckedUpdateManyInput>
    /**
     * Filter which StealthSkills to update
     */
    where?: StealthSkillWhereInput
    /**
     * Limit how many StealthSkills to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StealthSkillIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * StealthSkill upsert
   */
  export type StealthSkillUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StealthSkill
     */
    select?: StealthSkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StealthSkill
     */
    omit?: StealthSkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StealthSkillInclude<ExtArgs> | null
    /**
     * The filter to search for the StealthSkill to update in case it exists.
     */
    where: StealthSkillWhereUniqueInput
    /**
     * In case the StealthSkill found by the `where` argument doesn't exist, create a new StealthSkill with this data.
     */
    create: XOR<StealthSkillCreateInput, StealthSkillUncheckedCreateInput>
    /**
     * In case the StealthSkill was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StealthSkillUpdateInput, StealthSkillUncheckedUpdateInput>
  }

  /**
   * StealthSkill delete
   */
  export type StealthSkillDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StealthSkill
     */
    select?: StealthSkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StealthSkill
     */
    omit?: StealthSkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StealthSkillInclude<ExtArgs> | null
    /**
     * Filter which StealthSkill to delete.
     */
    where: StealthSkillWhereUniqueInput
  }

  /**
   * StealthSkill deleteMany
   */
  export type StealthSkillDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StealthSkills to delete
     */
    where?: StealthSkillWhereInput
    /**
     * Limit how many StealthSkills to delete.
     */
    limit?: number
  }

  /**
   * StealthSkill without action
   */
  export type StealthSkillDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StealthSkill
     */
    select?: StealthSkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StealthSkill
     */
    omit?: StealthSkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StealthSkillInclude<ExtArgs> | null
  }


  /**
   * Model ArcanaSkill
   */

  export type AggregateArcanaSkill = {
    _count: ArcanaSkillCountAggregateOutputType | null
    _avg: ArcanaSkillAvgAggregateOutputType | null
    _sum: ArcanaSkillSumAggregateOutputType | null
    _min: ArcanaSkillMinAggregateOutputType | null
    _max: ArcanaSkillMaxAggregateOutputType | null
  }

  export type ArcanaSkillAvgAggregateOutputType = {
    value: number | null
  }

  export type ArcanaSkillSumAggregateOutputType = {
    value: number | null
  }

  export type ArcanaSkillMinAggregateOutputType = {
    id: string | null
    value: number | null
    mastery: boolean | null
    name: string | null
  }

  export type ArcanaSkillMaxAggregateOutputType = {
    id: string | null
    value: number | null
    mastery: boolean | null
    name: string | null
  }

  export type ArcanaSkillCountAggregateOutputType = {
    id: number
    value: number
    mastery: number
    name: number
    _all: number
  }


  export type ArcanaSkillAvgAggregateInputType = {
    value?: true
  }

  export type ArcanaSkillSumAggregateInputType = {
    value?: true
  }

  export type ArcanaSkillMinAggregateInputType = {
    id?: true
    value?: true
    mastery?: true
    name?: true
  }

  export type ArcanaSkillMaxAggregateInputType = {
    id?: true
    value?: true
    mastery?: true
    name?: true
  }

  export type ArcanaSkillCountAggregateInputType = {
    id?: true
    value?: true
    mastery?: true
    name?: true
    _all?: true
  }

  export type ArcanaSkillAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ArcanaSkill to aggregate.
     */
    where?: ArcanaSkillWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ArcanaSkills to fetch.
     */
    orderBy?: ArcanaSkillOrderByWithRelationInput | ArcanaSkillOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ArcanaSkillWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ArcanaSkills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ArcanaSkills.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ArcanaSkills
    **/
    _count?: true | ArcanaSkillCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ArcanaSkillAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ArcanaSkillSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ArcanaSkillMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ArcanaSkillMaxAggregateInputType
  }

  export type GetArcanaSkillAggregateType<T extends ArcanaSkillAggregateArgs> = {
        [P in keyof T & keyof AggregateArcanaSkill]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateArcanaSkill[P]>
      : GetScalarType<T[P], AggregateArcanaSkill[P]>
  }




  export type ArcanaSkillGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ArcanaSkillWhereInput
    orderBy?: ArcanaSkillOrderByWithAggregationInput | ArcanaSkillOrderByWithAggregationInput[]
    by: ArcanaSkillScalarFieldEnum[] | ArcanaSkillScalarFieldEnum
    having?: ArcanaSkillScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ArcanaSkillCountAggregateInputType | true
    _avg?: ArcanaSkillAvgAggregateInputType
    _sum?: ArcanaSkillSumAggregateInputType
    _min?: ArcanaSkillMinAggregateInputType
    _max?: ArcanaSkillMaxAggregateInputType
  }

  export type ArcanaSkillGroupByOutputType = {
    id: string
    value: number | null
    mastery: boolean
    name: string
    _count: ArcanaSkillCountAggregateOutputType | null
    _avg: ArcanaSkillAvgAggregateOutputType | null
    _sum: ArcanaSkillSumAggregateOutputType | null
    _min: ArcanaSkillMinAggregateOutputType | null
    _max: ArcanaSkillMaxAggregateOutputType | null
  }

  type GetArcanaSkillGroupByPayload<T extends ArcanaSkillGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ArcanaSkillGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ArcanaSkillGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ArcanaSkillGroupByOutputType[P]>
            : GetScalarType<T[P], ArcanaSkillGroupByOutputType[P]>
        }
      >
    >


  export type ArcanaSkillSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    value?: boolean
    mastery?: boolean
    name?: boolean
    skill_list?: boolean | IntellengenceBasedSkillsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["arcanaSkill"]>

  export type ArcanaSkillSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    value?: boolean
    mastery?: boolean
    name?: boolean
    skill_list?: boolean | IntellengenceBasedSkillsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["arcanaSkill"]>

  export type ArcanaSkillSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    value?: boolean
    mastery?: boolean
    name?: boolean
    skill_list?: boolean | IntellengenceBasedSkillsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["arcanaSkill"]>

  export type ArcanaSkillSelectScalar = {
    id?: boolean
    value?: boolean
    mastery?: boolean
    name?: boolean
  }

  export type ArcanaSkillOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "value" | "mastery" | "name", ExtArgs["result"]["arcanaSkill"]>
  export type ArcanaSkillInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    skill_list?: boolean | IntellengenceBasedSkillsDefaultArgs<ExtArgs>
  }
  export type ArcanaSkillIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    skill_list?: boolean | IntellengenceBasedSkillsDefaultArgs<ExtArgs>
  }
  export type ArcanaSkillIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    skill_list?: boolean | IntellengenceBasedSkillsDefaultArgs<ExtArgs>
  }

  export type $ArcanaSkillPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ArcanaSkill"
    objects: {
      skill_list: Prisma.$IntellengenceBasedSkillsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      value: number | null
      mastery: boolean
      name: string
    }, ExtArgs["result"]["arcanaSkill"]>
    composites: {}
  }

  type ArcanaSkillGetPayload<S extends boolean | null | undefined | ArcanaSkillDefaultArgs> = $Result.GetResult<Prisma.$ArcanaSkillPayload, S>

  type ArcanaSkillCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ArcanaSkillFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ArcanaSkillCountAggregateInputType | true
    }

  export interface ArcanaSkillDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ArcanaSkill'], meta: { name: 'ArcanaSkill' } }
    /**
     * Find zero or one ArcanaSkill that matches the filter.
     * @param {ArcanaSkillFindUniqueArgs} args - Arguments to find a ArcanaSkill
     * @example
     * // Get one ArcanaSkill
     * const arcanaSkill = await prisma.arcanaSkill.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ArcanaSkillFindUniqueArgs>(args: SelectSubset<T, ArcanaSkillFindUniqueArgs<ExtArgs>>): Prisma__ArcanaSkillClient<$Result.GetResult<Prisma.$ArcanaSkillPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one ArcanaSkill that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ArcanaSkillFindUniqueOrThrowArgs} args - Arguments to find a ArcanaSkill
     * @example
     * // Get one ArcanaSkill
     * const arcanaSkill = await prisma.arcanaSkill.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ArcanaSkillFindUniqueOrThrowArgs>(args: SelectSubset<T, ArcanaSkillFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ArcanaSkillClient<$Result.GetResult<Prisma.$ArcanaSkillPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first ArcanaSkill that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArcanaSkillFindFirstArgs} args - Arguments to find a ArcanaSkill
     * @example
     * // Get one ArcanaSkill
     * const arcanaSkill = await prisma.arcanaSkill.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ArcanaSkillFindFirstArgs>(args?: SelectSubset<T, ArcanaSkillFindFirstArgs<ExtArgs>>): Prisma__ArcanaSkillClient<$Result.GetResult<Prisma.$ArcanaSkillPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first ArcanaSkill that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArcanaSkillFindFirstOrThrowArgs} args - Arguments to find a ArcanaSkill
     * @example
     * // Get one ArcanaSkill
     * const arcanaSkill = await prisma.arcanaSkill.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ArcanaSkillFindFirstOrThrowArgs>(args?: SelectSubset<T, ArcanaSkillFindFirstOrThrowArgs<ExtArgs>>): Prisma__ArcanaSkillClient<$Result.GetResult<Prisma.$ArcanaSkillPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more ArcanaSkills that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArcanaSkillFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ArcanaSkills
     * const arcanaSkills = await prisma.arcanaSkill.findMany()
     * 
     * // Get first 10 ArcanaSkills
     * const arcanaSkills = await prisma.arcanaSkill.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const arcanaSkillWithIdOnly = await prisma.arcanaSkill.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ArcanaSkillFindManyArgs>(args?: SelectSubset<T, ArcanaSkillFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ArcanaSkillPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a ArcanaSkill.
     * @param {ArcanaSkillCreateArgs} args - Arguments to create a ArcanaSkill.
     * @example
     * // Create one ArcanaSkill
     * const ArcanaSkill = await prisma.arcanaSkill.create({
     *   data: {
     *     // ... data to create a ArcanaSkill
     *   }
     * })
     * 
     */
    create<T extends ArcanaSkillCreateArgs>(args: SelectSubset<T, ArcanaSkillCreateArgs<ExtArgs>>): Prisma__ArcanaSkillClient<$Result.GetResult<Prisma.$ArcanaSkillPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many ArcanaSkills.
     * @param {ArcanaSkillCreateManyArgs} args - Arguments to create many ArcanaSkills.
     * @example
     * // Create many ArcanaSkills
     * const arcanaSkill = await prisma.arcanaSkill.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ArcanaSkillCreateManyArgs>(args?: SelectSubset<T, ArcanaSkillCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ArcanaSkills and returns the data saved in the database.
     * @param {ArcanaSkillCreateManyAndReturnArgs} args - Arguments to create many ArcanaSkills.
     * @example
     * // Create many ArcanaSkills
     * const arcanaSkill = await prisma.arcanaSkill.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ArcanaSkills and only return the `id`
     * const arcanaSkillWithIdOnly = await prisma.arcanaSkill.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ArcanaSkillCreateManyAndReturnArgs>(args?: SelectSubset<T, ArcanaSkillCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ArcanaSkillPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a ArcanaSkill.
     * @param {ArcanaSkillDeleteArgs} args - Arguments to delete one ArcanaSkill.
     * @example
     * // Delete one ArcanaSkill
     * const ArcanaSkill = await prisma.arcanaSkill.delete({
     *   where: {
     *     // ... filter to delete one ArcanaSkill
     *   }
     * })
     * 
     */
    delete<T extends ArcanaSkillDeleteArgs>(args: SelectSubset<T, ArcanaSkillDeleteArgs<ExtArgs>>): Prisma__ArcanaSkillClient<$Result.GetResult<Prisma.$ArcanaSkillPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one ArcanaSkill.
     * @param {ArcanaSkillUpdateArgs} args - Arguments to update one ArcanaSkill.
     * @example
     * // Update one ArcanaSkill
     * const arcanaSkill = await prisma.arcanaSkill.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ArcanaSkillUpdateArgs>(args: SelectSubset<T, ArcanaSkillUpdateArgs<ExtArgs>>): Prisma__ArcanaSkillClient<$Result.GetResult<Prisma.$ArcanaSkillPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more ArcanaSkills.
     * @param {ArcanaSkillDeleteManyArgs} args - Arguments to filter ArcanaSkills to delete.
     * @example
     * // Delete a few ArcanaSkills
     * const { count } = await prisma.arcanaSkill.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ArcanaSkillDeleteManyArgs>(args?: SelectSubset<T, ArcanaSkillDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ArcanaSkills.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArcanaSkillUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ArcanaSkills
     * const arcanaSkill = await prisma.arcanaSkill.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ArcanaSkillUpdateManyArgs>(args: SelectSubset<T, ArcanaSkillUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ArcanaSkills and returns the data updated in the database.
     * @param {ArcanaSkillUpdateManyAndReturnArgs} args - Arguments to update many ArcanaSkills.
     * @example
     * // Update many ArcanaSkills
     * const arcanaSkill = await prisma.arcanaSkill.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ArcanaSkills and only return the `id`
     * const arcanaSkillWithIdOnly = await prisma.arcanaSkill.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ArcanaSkillUpdateManyAndReturnArgs>(args: SelectSubset<T, ArcanaSkillUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ArcanaSkillPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one ArcanaSkill.
     * @param {ArcanaSkillUpsertArgs} args - Arguments to update or create a ArcanaSkill.
     * @example
     * // Update or create a ArcanaSkill
     * const arcanaSkill = await prisma.arcanaSkill.upsert({
     *   create: {
     *     // ... data to create a ArcanaSkill
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ArcanaSkill we want to update
     *   }
     * })
     */
    upsert<T extends ArcanaSkillUpsertArgs>(args: SelectSubset<T, ArcanaSkillUpsertArgs<ExtArgs>>): Prisma__ArcanaSkillClient<$Result.GetResult<Prisma.$ArcanaSkillPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of ArcanaSkills.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArcanaSkillCountArgs} args - Arguments to filter ArcanaSkills to count.
     * @example
     * // Count the number of ArcanaSkills
     * const count = await prisma.arcanaSkill.count({
     *   where: {
     *     // ... the filter for the ArcanaSkills we want to count
     *   }
     * })
    **/
    count<T extends ArcanaSkillCountArgs>(
      args?: Subset<T, ArcanaSkillCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ArcanaSkillCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ArcanaSkill.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArcanaSkillAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ArcanaSkillAggregateArgs>(args: Subset<T, ArcanaSkillAggregateArgs>): Prisma.PrismaPromise<GetArcanaSkillAggregateType<T>>

    /**
     * Group by ArcanaSkill.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArcanaSkillGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ArcanaSkillGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ArcanaSkillGroupByArgs['orderBy'] }
        : { orderBy?: ArcanaSkillGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ArcanaSkillGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetArcanaSkillGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ArcanaSkill model
   */
  readonly fields: ArcanaSkillFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ArcanaSkill.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ArcanaSkillClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    skill_list<T extends IntellengenceBasedSkillsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, IntellengenceBasedSkillsDefaultArgs<ExtArgs>>): Prisma__IntellengenceBasedSkillsClient<$Result.GetResult<Prisma.$IntellengenceBasedSkillsPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ArcanaSkill model
   */ 
  interface ArcanaSkillFieldRefs {
    readonly id: FieldRef<"ArcanaSkill", 'String'>
    readonly value: FieldRef<"ArcanaSkill", 'Int'>
    readonly mastery: FieldRef<"ArcanaSkill", 'Boolean'>
    readonly name: FieldRef<"ArcanaSkill", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ArcanaSkill findUnique
   */
  export type ArcanaSkillFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ArcanaSkill
     */
    select?: ArcanaSkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ArcanaSkill
     */
    omit?: ArcanaSkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArcanaSkillInclude<ExtArgs> | null
    /**
     * Filter, which ArcanaSkill to fetch.
     */
    where: ArcanaSkillWhereUniqueInput
  }

  /**
   * ArcanaSkill findUniqueOrThrow
   */
  export type ArcanaSkillFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ArcanaSkill
     */
    select?: ArcanaSkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ArcanaSkill
     */
    omit?: ArcanaSkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArcanaSkillInclude<ExtArgs> | null
    /**
     * Filter, which ArcanaSkill to fetch.
     */
    where: ArcanaSkillWhereUniqueInput
  }

  /**
   * ArcanaSkill findFirst
   */
  export type ArcanaSkillFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ArcanaSkill
     */
    select?: ArcanaSkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ArcanaSkill
     */
    omit?: ArcanaSkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArcanaSkillInclude<ExtArgs> | null
    /**
     * Filter, which ArcanaSkill to fetch.
     */
    where?: ArcanaSkillWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ArcanaSkills to fetch.
     */
    orderBy?: ArcanaSkillOrderByWithRelationInput | ArcanaSkillOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ArcanaSkills.
     */
    cursor?: ArcanaSkillWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ArcanaSkills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ArcanaSkills.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ArcanaSkills.
     */
    distinct?: ArcanaSkillScalarFieldEnum | ArcanaSkillScalarFieldEnum[]
  }

  /**
   * ArcanaSkill findFirstOrThrow
   */
  export type ArcanaSkillFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ArcanaSkill
     */
    select?: ArcanaSkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ArcanaSkill
     */
    omit?: ArcanaSkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArcanaSkillInclude<ExtArgs> | null
    /**
     * Filter, which ArcanaSkill to fetch.
     */
    where?: ArcanaSkillWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ArcanaSkills to fetch.
     */
    orderBy?: ArcanaSkillOrderByWithRelationInput | ArcanaSkillOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ArcanaSkills.
     */
    cursor?: ArcanaSkillWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ArcanaSkills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ArcanaSkills.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ArcanaSkills.
     */
    distinct?: ArcanaSkillScalarFieldEnum | ArcanaSkillScalarFieldEnum[]
  }

  /**
   * ArcanaSkill findMany
   */
  export type ArcanaSkillFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ArcanaSkill
     */
    select?: ArcanaSkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ArcanaSkill
     */
    omit?: ArcanaSkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArcanaSkillInclude<ExtArgs> | null
    /**
     * Filter, which ArcanaSkills to fetch.
     */
    where?: ArcanaSkillWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ArcanaSkills to fetch.
     */
    orderBy?: ArcanaSkillOrderByWithRelationInput | ArcanaSkillOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ArcanaSkills.
     */
    cursor?: ArcanaSkillWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ArcanaSkills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ArcanaSkills.
     */
    skip?: number
    distinct?: ArcanaSkillScalarFieldEnum | ArcanaSkillScalarFieldEnum[]
  }

  /**
   * ArcanaSkill create
   */
  export type ArcanaSkillCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ArcanaSkill
     */
    select?: ArcanaSkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ArcanaSkill
     */
    omit?: ArcanaSkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArcanaSkillInclude<ExtArgs> | null
    /**
     * The data needed to create a ArcanaSkill.
     */
    data: XOR<ArcanaSkillCreateInput, ArcanaSkillUncheckedCreateInput>
  }

  /**
   * ArcanaSkill createMany
   */
  export type ArcanaSkillCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ArcanaSkills.
     */
    data: ArcanaSkillCreateManyInput | ArcanaSkillCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ArcanaSkill createManyAndReturn
   */
  export type ArcanaSkillCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ArcanaSkill
     */
    select?: ArcanaSkillSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ArcanaSkill
     */
    omit?: ArcanaSkillOmit<ExtArgs> | null
    /**
     * The data used to create many ArcanaSkills.
     */
    data: ArcanaSkillCreateManyInput | ArcanaSkillCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArcanaSkillIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ArcanaSkill update
   */
  export type ArcanaSkillUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ArcanaSkill
     */
    select?: ArcanaSkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ArcanaSkill
     */
    omit?: ArcanaSkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArcanaSkillInclude<ExtArgs> | null
    /**
     * The data needed to update a ArcanaSkill.
     */
    data: XOR<ArcanaSkillUpdateInput, ArcanaSkillUncheckedUpdateInput>
    /**
     * Choose, which ArcanaSkill to update.
     */
    where: ArcanaSkillWhereUniqueInput
  }

  /**
   * ArcanaSkill updateMany
   */
  export type ArcanaSkillUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ArcanaSkills.
     */
    data: XOR<ArcanaSkillUpdateManyMutationInput, ArcanaSkillUncheckedUpdateManyInput>
    /**
     * Filter which ArcanaSkills to update
     */
    where?: ArcanaSkillWhereInput
    /**
     * Limit how many ArcanaSkills to update.
     */
    limit?: number
  }

  /**
   * ArcanaSkill updateManyAndReturn
   */
  export type ArcanaSkillUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ArcanaSkill
     */
    select?: ArcanaSkillSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ArcanaSkill
     */
    omit?: ArcanaSkillOmit<ExtArgs> | null
    /**
     * The data used to update ArcanaSkills.
     */
    data: XOR<ArcanaSkillUpdateManyMutationInput, ArcanaSkillUncheckedUpdateManyInput>
    /**
     * Filter which ArcanaSkills to update
     */
    where?: ArcanaSkillWhereInput
    /**
     * Limit how many ArcanaSkills to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArcanaSkillIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ArcanaSkill upsert
   */
  export type ArcanaSkillUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ArcanaSkill
     */
    select?: ArcanaSkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ArcanaSkill
     */
    omit?: ArcanaSkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArcanaSkillInclude<ExtArgs> | null
    /**
     * The filter to search for the ArcanaSkill to update in case it exists.
     */
    where: ArcanaSkillWhereUniqueInput
    /**
     * In case the ArcanaSkill found by the `where` argument doesn't exist, create a new ArcanaSkill with this data.
     */
    create: XOR<ArcanaSkillCreateInput, ArcanaSkillUncheckedCreateInput>
    /**
     * In case the ArcanaSkill was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ArcanaSkillUpdateInput, ArcanaSkillUncheckedUpdateInput>
  }

  /**
   * ArcanaSkill delete
   */
  export type ArcanaSkillDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ArcanaSkill
     */
    select?: ArcanaSkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ArcanaSkill
     */
    omit?: ArcanaSkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArcanaSkillInclude<ExtArgs> | null
    /**
     * Filter which ArcanaSkill to delete.
     */
    where: ArcanaSkillWhereUniqueInput
  }

  /**
   * ArcanaSkill deleteMany
   */
  export type ArcanaSkillDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ArcanaSkills to delete
     */
    where?: ArcanaSkillWhereInput
    /**
     * Limit how many ArcanaSkills to delete.
     */
    limit?: number
  }

  /**
   * ArcanaSkill without action
   */
  export type ArcanaSkillDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ArcanaSkill
     */
    select?: ArcanaSkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ArcanaSkill
     */
    omit?: ArcanaSkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArcanaSkillInclude<ExtArgs> | null
  }


  /**
   * Model HistorySkill
   */

  export type AggregateHistorySkill = {
    _count: HistorySkillCountAggregateOutputType | null
    _avg: HistorySkillAvgAggregateOutputType | null
    _sum: HistorySkillSumAggregateOutputType | null
    _min: HistorySkillMinAggregateOutputType | null
    _max: HistorySkillMaxAggregateOutputType | null
  }

  export type HistorySkillAvgAggregateOutputType = {
    value: number | null
  }

  export type HistorySkillSumAggregateOutputType = {
    value: number | null
  }

  export type HistorySkillMinAggregateOutputType = {
    id: string | null
    value: number | null
    mastery: boolean | null
    name: string | null
  }

  export type HistorySkillMaxAggregateOutputType = {
    id: string | null
    value: number | null
    mastery: boolean | null
    name: string | null
  }

  export type HistorySkillCountAggregateOutputType = {
    id: number
    value: number
    mastery: number
    name: number
    _all: number
  }


  export type HistorySkillAvgAggregateInputType = {
    value?: true
  }

  export type HistorySkillSumAggregateInputType = {
    value?: true
  }

  export type HistorySkillMinAggregateInputType = {
    id?: true
    value?: true
    mastery?: true
    name?: true
  }

  export type HistorySkillMaxAggregateInputType = {
    id?: true
    value?: true
    mastery?: true
    name?: true
  }

  export type HistorySkillCountAggregateInputType = {
    id?: true
    value?: true
    mastery?: true
    name?: true
    _all?: true
  }

  export type HistorySkillAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which HistorySkill to aggregate.
     */
    where?: HistorySkillWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HistorySkills to fetch.
     */
    orderBy?: HistorySkillOrderByWithRelationInput | HistorySkillOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: HistorySkillWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HistorySkills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HistorySkills.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned HistorySkills
    **/
    _count?: true | HistorySkillCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: HistorySkillAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: HistorySkillSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: HistorySkillMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: HistorySkillMaxAggregateInputType
  }

  export type GetHistorySkillAggregateType<T extends HistorySkillAggregateArgs> = {
        [P in keyof T & keyof AggregateHistorySkill]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateHistorySkill[P]>
      : GetScalarType<T[P], AggregateHistorySkill[P]>
  }




  export type HistorySkillGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HistorySkillWhereInput
    orderBy?: HistorySkillOrderByWithAggregationInput | HistorySkillOrderByWithAggregationInput[]
    by: HistorySkillScalarFieldEnum[] | HistorySkillScalarFieldEnum
    having?: HistorySkillScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: HistorySkillCountAggregateInputType | true
    _avg?: HistorySkillAvgAggregateInputType
    _sum?: HistorySkillSumAggregateInputType
    _min?: HistorySkillMinAggregateInputType
    _max?: HistorySkillMaxAggregateInputType
  }

  export type HistorySkillGroupByOutputType = {
    id: string
    value: number | null
    mastery: boolean
    name: string
    _count: HistorySkillCountAggregateOutputType | null
    _avg: HistorySkillAvgAggregateOutputType | null
    _sum: HistorySkillSumAggregateOutputType | null
    _min: HistorySkillMinAggregateOutputType | null
    _max: HistorySkillMaxAggregateOutputType | null
  }

  type GetHistorySkillGroupByPayload<T extends HistorySkillGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<HistorySkillGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof HistorySkillGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], HistorySkillGroupByOutputType[P]>
            : GetScalarType<T[P], HistorySkillGroupByOutputType[P]>
        }
      >
    >


  export type HistorySkillSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    value?: boolean
    mastery?: boolean
    name?: boolean
    skill_list?: boolean | IntellengenceBasedSkillsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["historySkill"]>

  export type HistorySkillSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    value?: boolean
    mastery?: boolean
    name?: boolean
    skill_list?: boolean | IntellengenceBasedSkillsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["historySkill"]>

  export type HistorySkillSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    value?: boolean
    mastery?: boolean
    name?: boolean
    skill_list?: boolean | IntellengenceBasedSkillsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["historySkill"]>

  export type HistorySkillSelectScalar = {
    id?: boolean
    value?: boolean
    mastery?: boolean
    name?: boolean
  }

  export type HistorySkillOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "value" | "mastery" | "name", ExtArgs["result"]["historySkill"]>
  export type HistorySkillInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    skill_list?: boolean | IntellengenceBasedSkillsDefaultArgs<ExtArgs>
  }
  export type HistorySkillIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    skill_list?: boolean | IntellengenceBasedSkillsDefaultArgs<ExtArgs>
  }
  export type HistorySkillIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    skill_list?: boolean | IntellengenceBasedSkillsDefaultArgs<ExtArgs>
  }

  export type $HistorySkillPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "HistorySkill"
    objects: {
      skill_list: Prisma.$IntellengenceBasedSkillsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      value: number | null
      mastery: boolean
      name: string
    }, ExtArgs["result"]["historySkill"]>
    composites: {}
  }

  type HistorySkillGetPayload<S extends boolean | null | undefined | HistorySkillDefaultArgs> = $Result.GetResult<Prisma.$HistorySkillPayload, S>

  type HistorySkillCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<HistorySkillFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: HistorySkillCountAggregateInputType | true
    }

  export interface HistorySkillDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['HistorySkill'], meta: { name: 'HistorySkill' } }
    /**
     * Find zero or one HistorySkill that matches the filter.
     * @param {HistorySkillFindUniqueArgs} args - Arguments to find a HistorySkill
     * @example
     * // Get one HistorySkill
     * const historySkill = await prisma.historySkill.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends HistorySkillFindUniqueArgs>(args: SelectSubset<T, HistorySkillFindUniqueArgs<ExtArgs>>): Prisma__HistorySkillClient<$Result.GetResult<Prisma.$HistorySkillPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one HistorySkill that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {HistorySkillFindUniqueOrThrowArgs} args - Arguments to find a HistorySkill
     * @example
     * // Get one HistorySkill
     * const historySkill = await prisma.historySkill.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends HistorySkillFindUniqueOrThrowArgs>(args: SelectSubset<T, HistorySkillFindUniqueOrThrowArgs<ExtArgs>>): Prisma__HistorySkillClient<$Result.GetResult<Prisma.$HistorySkillPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first HistorySkill that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HistorySkillFindFirstArgs} args - Arguments to find a HistorySkill
     * @example
     * // Get one HistorySkill
     * const historySkill = await prisma.historySkill.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends HistorySkillFindFirstArgs>(args?: SelectSubset<T, HistorySkillFindFirstArgs<ExtArgs>>): Prisma__HistorySkillClient<$Result.GetResult<Prisma.$HistorySkillPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first HistorySkill that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HistorySkillFindFirstOrThrowArgs} args - Arguments to find a HistorySkill
     * @example
     * // Get one HistorySkill
     * const historySkill = await prisma.historySkill.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends HistorySkillFindFirstOrThrowArgs>(args?: SelectSubset<T, HistorySkillFindFirstOrThrowArgs<ExtArgs>>): Prisma__HistorySkillClient<$Result.GetResult<Prisma.$HistorySkillPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more HistorySkills that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HistorySkillFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all HistorySkills
     * const historySkills = await prisma.historySkill.findMany()
     * 
     * // Get first 10 HistorySkills
     * const historySkills = await prisma.historySkill.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const historySkillWithIdOnly = await prisma.historySkill.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends HistorySkillFindManyArgs>(args?: SelectSubset<T, HistorySkillFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HistorySkillPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a HistorySkill.
     * @param {HistorySkillCreateArgs} args - Arguments to create a HistorySkill.
     * @example
     * // Create one HistorySkill
     * const HistorySkill = await prisma.historySkill.create({
     *   data: {
     *     // ... data to create a HistorySkill
     *   }
     * })
     * 
     */
    create<T extends HistorySkillCreateArgs>(args: SelectSubset<T, HistorySkillCreateArgs<ExtArgs>>): Prisma__HistorySkillClient<$Result.GetResult<Prisma.$HistorySkillPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many HistorySkills.
     * @param {HistorySkillCreateManyArgs} args - Arguments to create many HistorySkills.
     * @example
     * // Create many HistorySkills
     * const historySkill = await prisma.historySkill.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends HistorySkillCreateManyArgs>(args?: SelectSubset<T, HistorySkillCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many HistorySkills and returns the data saved in the database.
     * @param {HistorySkillCreateManyAndReturnArgs} args - Arguments to create many HistorySkills.
     * @example
     * // Create many HistorySkills
     * const historySkill = await prisma.historySkill.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many HistorySkills and only return the `id`
     * const historySkillWithIdOnly = await prisma.historySkill.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends HistorySkillCreateManyAndReturnArgs>(args?: SelectSubset<T, HistorySkillCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HistorySkillPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a HistorySkill.
     * @param {HistorySkillDeleteArgs} args - Arguments to delete one HistorySkill.
     * @example
     * // Delete one HistorySkill
     * const HistorySkill = await prisma.historySkill.delete({
     *   where: {
     *     // ... filter to delete one HistorySkill
     *   }
     * })
     * 
     */
    delete<T extends HistorySkillDeleteArgs>(args: SelectSubset<T, HistorySkillDeleteArgs<ExtArgs>>): Prisma__HistorySkillClient<$Result.GetResult<Prisma.$HistorySkillPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one HistorySkill.
     * @param {HistorySkillUpdateArgs} args - Arguments to update one HistorySkill.
     * @example
     * // Update one HistorySkill
     * const historySkill = await prisma.historySkill.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends HistorySkillUpdateArgs>(args: SelectSubset<T, HistorySkillUpdateArgs<ExtArgs>>): Prisma__HistorySkillClient<$Result.GetResult<Prisma.$HistorySkillPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more HistorySkills.
     * @param {HistorySkillDeleteManyArgs} args - Arguments to filter HistorySkills to delete.
     * @example
     * // Delete a few HistorySkills
     * const { count } = await prisma.historySkill.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends HistorySkillDeleteManyArgs>(args?: SelectSubset<T, HistorySkillDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more HistorySkills.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HistorySkillUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many HistorySkills
     * const historySkill = await prisma.historySkill.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends HistorySkillUpdateManyArgs>(args: SelectSubset<T, HistorySkillUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more HistorySkills and returns the data updated in the database.
     * @param {HistorySkillUpdateManyAndReturnArgs} args - Arguments to update many HistorySkills.
     * @example
     * // Update many HistorySkills
     * const historySkill = await prisma.historySkill.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more HistorySkills and only return the `id`
     * const historySkillWithIdOnly = await prisma.historySkill.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends HistorySkillUpdateManyAndReturnArgs>(args: SelectSubset<T, HistorySkillUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HistorySkillPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one HistorySkill.
     * @param {HistorySkillUpsertArgs} args - Arguments to update or create a HistorySkill.
     * @example
     * // Update or create a HistorySkill
     * const historySkill = await prisma.historySkill.upsert({
     *   create: {
     *     // ... data to create a HistorySkill
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the HistorySkill we want to update
     *   }
     * })
     */
    upsert<T extends HistorySkillUpsertArgs>(args: SelectSubset<T, HistorySkillUpsertArgs<ExtArgs>>): Prisma__HistorySkillClient<$Result.GetResult<Prisma.$HistorySkillPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of HistorySkills.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HistorySkillCountArgs} args - Arguments to filter HistorySkills to count.
     * @example
     * // Count the number of HistorySkills
     * const count = await prisma.historySkill.count({
     *   where: {
     *     // ... the filter for the HistorySkills we want to count
     *   }
     * })
    **/
    count<T extends HistorySkillCountArgs>(
      args?: Subset<T, HistorySkillCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], HistorySkillCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a HistorySkill.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HistorySkillAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends HistorySkillAggregateArgs>(args: Subset<T, HistorySkillAggregateArgs>): Prisma.PrismaPromise<GetHistorySkillAggregateType<T>>

    /**
     * Group by HistorySkill.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HistorySkillGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends HistorySkillGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: HistorySkillGroupByArgs['orderBy'] }
        : { orderBy?: HistorySkillGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, HistorySkillGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetHistorySkillGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the HistorySkill model
   */
  readonly fields: HistorySkillFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for HistorySkill.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__HistorySkillClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    skill_list<T extends IntellengenceBasedSkillsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, IntellengenceBasedSkillsDefaultArgs<ExtArgs>>): Prisma__IntellengenceBasedSkillsClient<$Result.GetResult<Prisma.$IntellengenceBasedSkillsPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the HistorySkill model
   */ 
  interface HistorySkillFieldRefs {
    readonly id: FieldRef<"HistorySkill", 'String'>
    readonly value: FieldRef<"HistorySkill", 'Int'>
    readonly mastery: FieldRef<"HistorySkill", 'Boolean'>
    readonly name: FieldRef<"HistorySkill", 'String'>
  }
    

  // Custom InputTypes
  /**
   * HistorySkill findUnique
   */
  export type HistorySkillFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HistorySkill
     */
    select?: HistorySkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HistorySkill
     */
    omit?: HistorySkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HistorySkillInclude<ExtArgs> | null
    /**
     * Filter, which HistorySkill to fetch.
     */
    where: HistorySkillWhereUniqueInput
  }

  /**
   * HistorySkill findUniqueOrThrow
   */
  export type HistorySkillFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HistorySkill
     */
    select?: HistorySkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HistorySkill
     */
    omit?: HistorySkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HistorySkillInclude<ExtArgs> | null
    /**
     * Filter, which HistorySkill to fetch.
     */
    where: HistorySkillWhereUniqueInput
  }

  /**
   * HistorySkill findFirst
   */
  export type HistorySkillFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HistorySkill
     */
    select?: HistorySkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HistorySkill
     */
    omit?: HistorySkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HistorySkillInclude<ExtArgs> | null
    /**
     * Filter, which HistorySkill to fetch.
     */
    where?: HistorySkillWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HistorySkills to fetch.
     */
    orderBy?: HistorySkillOrderByWithRelationInput | HistorySkillOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for HistorySkills.
     */
    cursor?: HistorySkillWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HistorySkills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HistorySkills.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of HistorySkills.
     */
    distinct?: HistorySkillScalarFieldEnum | HistorySkillScalarFieldEnum[]
  }

  /**
   * HistorySkill findFirstOrThrow
   */
  export type HistorySkillFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HistorySkill
     */
    select?: HistorySkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HistorySkill
     */
    omit?: HistorySkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HistorySkillInclude<ExtArgs> | null
    /**
     * Filter, which HistorySkill to fetch.
     */
    where?: HistorySkillWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HistorySkills to fetch.
     */
    orderBy?: HistorySkillOrderByWithRelationInput | HistorySkillOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for HistorySkills.
     */
    cursor?: HistorySkillWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HistorySkills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HistorySkills.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of HistorySkills.
     */
    distinct?: HistorySkillScalarFieldEnum | HistorySkillScalarFieldEnum[]
  }

  /**
   * HistorySkill findMany
   */
  export type HistorySkillFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HistorySkill
     */
    select?: HistorySkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HistorySkill
     */
    omit?: HistorySkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HistorySkillInclude<ExtArgs> | null
    /**
     * Filter, which HistorySkills to fetch.
     */
    where?: HistorySkillWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HistorySkills to fetch.
     */
    orderBy?: HistorySkillOrderByWithRelationInput | HistorySkillOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing HistorySkills.
     */
    cursor?: HistorySkillWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HistorySkills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HistorySkills.
     */
    skip?: number
    distinct?: HistorySkillScalarFieldEnum | HistorySkillScalarFieldEnum[]
  }

  /**
   * HistorySkill create
   */
  export type HistorySkillCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HistorySkill
     */
    select?: HistorySkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HistorySkill
     */
    omit?: HistorySkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HistorySkillInclude<ExtArgs> | null
    /**
     * The data needed to create a HistorySkill.
     */
    data: XOR<HistorySkillCreateInput, HistorySkillUncheckedCreateInput>
  }

  /**
   * HistorySkill createMany
   */
  export type HistorySkillCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many HistorySkills.
     */
    data: HistorySkillCreateManyInput | HistorySkillCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * HistorySkill createManyAndReturn
   */
  export type HistorySkillCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HistorySkill
     */
    select?: HistorySkillSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the HistorySkill
     */
    omit?: HistorySkillOmit<ExtArgs> | null
    /**
     * The data used to create many HistorySkills.
     */
    data: HistorySkillCreateManyInput | HistorySkillCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HistorySkillIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * HistorySkill update
   */
  export type HistorySkillUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HistorySkill
     */
    select?: HistorySkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HistorySkill
     */
    omit?: HistorySkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HistorySkillInclude<ExtArgs> | null
    /**
     * The data needed to update a HistorySkill.
     */
    data: XOR<HistorySkillUpdateInput, HistorySkillUncheckedUpdateInput>
    /**
     * Choose, which HistorySkill to update.
     */
    where: HistorySkillWhereUniqueInput
  }

  /**
   * HistorySkill updateMany
   */
  export type HistorySkillUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update HistorySkills.
     */
    data: XOR<HistorySkillUpdateManyMutationInput, HistorySkillUncheckedUpdateManyInput>
    /**
     * Filter which HistorySkills to update
     */
    where?: HistorySkillWhereInput
    /**
     * Limit how many HistorySkills to update.
     */
    limit?: number
  }

  /**
   * HistorySkill updateManyAndReturn
   */
  export type HistorySkillUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HistorySkill
     */
    select?: HistorySkillSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the HistorySkill
     */
    omit?: HistorySkillOmit<ExtArgs> | null
    /**
     * The data used to update HistorySkills.
     */
    data: XOR<HistorySkillUpdateManyMutationInput, HistorySkillUncheckedUpdateManyInput>
    /**
     * Filter which HistorySkills to update
     */
    where?: HistorySkillWhereInput
    /**
     * Limit how many HistorySkills to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HistorySkillIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * HistorySkill upsert
   */
  export type HistorySkillUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HistorySkill
     */
    select?: HistorySkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HistorySkill
     */
    omit?: HistorySkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HistorySkillInclude<ExtArgs> | null
    /**
     * The filter to search for the HistorySkill to update in case it exists.
     */
    where: HistorySkillWhereUniqueInput
    /**
     * In case the HistorySkill found by the `where` argument doesn't exist, create a new HistorySkill with this data.
     */
    create: XOR<HistorySkillCreateInput, HistorySkillUncheckedCreateInput>
    /**
     * In case the HistorySkill was found with the provided `where` argument, update it with this data.
     */
    update: XOR<HistorySkillUpdateInput, HistorySkillUncheckedUpdateInput>
  }

  /**
   * HistorySkill delete
   */
  export type HistorySkillDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HistorySkill
     */
    select?: HistorySkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HistorySkill
     */
    omit?: HistorySkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HistorySkillInclude<ExtArgs> | null
    /**
     * Filter which HistorySkill to delete.
     */
    where: HistorySkillWhereUniqueInput
  }

  /**
   * HistorySkill deleteMany
   */
  export type HistorySkillDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which HistorySkills to delete
     */
    where?: HistorySkillWhereInput
    /**
     * Limit how many HistorySkills to delete.
     */
    limit?: number
  }

  /**
   * HistorySkill without action
   */
  export type HistorySkillDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HistorySkill
     */
    select?: HistorySkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HistorySkill
     */
    omit?: HistorySkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HistorySkillInclude<ExtArgs> | null
  }


  /**
   * Model InvestigationSkill
   */

  export type AggregateInvestigationSkill = {
    _count: InvestigationSkillCountAggregateOutputType | null
    _avg: InvestigationSkillAvgAggregateOutputType | null
    _sum: InvestigationSkillSumAggregateOutputType | null
    _min: InvestigationSkillMinAggregateOutputType | null
    _max: InvestigationSkillMaxAggregateOutputType | null
  }

  export type InvestigationSkillAvgAggregateOutputType = {
    value: number | null
  }

  export type InvestigationSkillSumAggregateOutputType = {
    value: number | null
  }

  export type InvestigationSkillMinAggregateOutputType = {
    id: string | null
    value: number | null
    mastery: boolean | null
    name: string | null
  }

  export type InvestigationSkillMaxAggregateOutputType = {
    id: string | null
    value: number | null
    mastery: boolean | null
    name: string | null
  }

  export type InvestigationSkillCountAggregateOutputType = {
    id: number
    value: number
    mastery: number
    name: number
    _all: number
  }


  export type InvestigationSkillAvgAggregateInputType = {
    value?: true
  }

  export type InvestigationSkillSumAggregateInputType = {
    value?: true
  }

  export type InvestigationSkillMinAggregateInputType = {
    id?: true
    value?: true
    mastery?: true
    name?: true
  }

  export type InvestigationSkillMaxAggregateInputType = {
    id?: true
    value?: true
    mastery?: true
    name?: true
  }

  export type InvestigationSkillCountAggregateInputType = {
    id?: true
    value?: true
    mastery?: true
    name?: true
    _all?: true
  }

  export type InvestigationSkillAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InvestigationSkill to aggregate.
     */
    where?: InvestigationSkillWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InvestigationSkills to fetch.
     */
    orderBy?: InvestigationSkillOrderByWithRelationInput | InvestigationSkillOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InvestigationSkillWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InvestigationSkills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InvestigationSkills.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned InvestigationSkills
    **/
    _count?: true | InvestigationSkillCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InvestigationSkillAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InvestigationSkillSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InvestigationSkillMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InvestigationSkillMaxAggregateInputType
  }

  export type GetInvestigationSkillAggregateType<T extends InvestigationSkillAggregateArgs> = {
        [P in keyof T & keyof AggregateInvestigationSkill]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInvestigationSkill[P]>
      : GetScalarType<T[P], AggregateInvestigationSkill[P]>
  }




  export type InvestigationSkillGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvestigationSkillWhereInput
    orderBy?: InvestigationSkillOrderByWithAggregationInput | InvestigationSkillOrderByWithAggregationInput[]
    by: InvestigationSkillScalarFieldEnum[] | InvestigationSkillScalarFieldEnum
    having?: InvestigationSkillScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InvestigationSkillCountAggregateInputType | true
    _avg?: InvestigationSkillAvgAggregateInputType
    _sum?: InvestigationSkillSumAggregateInputType
    _min?: InvestigationSkillMinAggregateInputType
    _max?: InvestigationSkillMaxAggregateInputType
  }

  export type InvestigationSkillGroupByOutputType = {
    id: string
    value: number | null
    mastery: boolean
    name: string
    _count: InvestigationSkillCountAggregateOutputType | null
    _avg: InvestigationSkillAvgAggregateOutputType | null
    _sum: InvestigationSkillSumAggregateOutputType | null
    _min: InvestigationSkillMinAggregateOutputType | null
    _max: InvestigationSkillMaxAggregateOutputType | null
  }

  type GetInvestigationSkillGroupByPayload<T extends InvestigationSkillGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InvestigationSkillGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InvestigationSkillGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InvestigationSkillGroupByOutputType[P]>
            : GetScalarType<T[P], InvestigationSkillGroupByOutputType[P]>
        }
      >
    >


  export type InvestigationSkillSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    value?: boolean
    mastery?: boolean
    name?: boolean
    skill_list?: boolean | IntellengenceBasedSkillsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["investigationSkill"]>

  export type InvestigationSkillSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    value?: boolean
    mastery?: boolean
    name?: boolean
    skill_list?: boolean | IntellengenceBasedSkillsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["investigationSkill"]>

  export type InvestigationSkillSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    value?: boolean
    mastery?: boolean
    name?: boolean
    skill_list?: boolean | IntellengenceBasedSkillsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["investigationSkill"]>

  export type InvestigationSkillSelectScalar = {
    id?: boolean
    value?: boolean
    mastery?: boolean
    name?: boolean
  }

  export type InvestigationSkillOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "value" | "mastery" | "name", ExtArgs["result"]["investigationSkill"]>
  export type InvestigationSkillInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    skill_list?: boolean | IntellengenceBasedSkillsDefaultArgs<ExtArgs>
  }
  export type InvestigationSkillIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    skill_list?: boolean | IntellengenceBasedSkillsDefaultArgs<ExtArgs>
  }
  export type InvestigationSkillIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    skill_list?: boolean | IntellengenceBasedSkillsDefaultArgs<ExtArgs>
  }

  export type $InvestigationSkillPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "InvestigationSkill"
    objects: {
      skill_list: Prisma.$IntellengenceBasedSkillsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      value: number | null
      mastery: boolean
      name: string
    }, ExtArgs["result"]["investigationSkill"]>
    composites: {}
  }

  type InvestigationSkillGetPayload<S extends boolean | null | undefined | InvestigationSkillDefaultArgs> = $Result.GetResult<Prisma.$InvestigationSkillPayload, S>

  type InvestigationSkillCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<InvestigationSkillFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: InvestigationSkillCountAggregateInputType | true
    }

  export interface InvestigationSkillDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['InvestigationSkill'], meta: { name: 'InvestigationSkill' } }
    /**
     * Find zero or one InvestigationSkill that matches the filter.
     * @param {InvestigationSkillFindUniqueArgs} args - Arguments to find a InvestigationSkill
     * @example
     * // Get one InvestigationSkill
     * const investigationSkill = await prisma.investigationSkill.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InvestigationSkillFindUniqueArgs>(args: SelectSubset<T, InvestigationSkillFindUniqueArgs<ExtArgs>>): Prisma__InvestigationSkillClient<$Result.GetResult<Prisma.$InvestigationSkillPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one InvestigationSkill that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {InvestigationSkillFindUniqueOrThrowArgs} args - Arguments to find a InvestigationSkill
     * @example
     * // Get one InvestigationSkill
     * const investigationSkill = await prisma.investigationSkill.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InvestigationSkillFindUniqueOrThrowArgs>(args: SelectSubset<T, InvestigationSkillFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InvestigationSkillClient<$Result.GetResult<Prisma.$InvestigationSkillPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first InvestigationSkill that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvestigationSkillFindFirstArgs} args - Arguments to find a InvestigationSkill
     * @example
     * // Get one InvestigationSkill
     * const investigationSkill = await prisma.investigationSkill.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InvestigationSkillFindFirstArgs>(args?: SelectSubset<T, InvestigationSkillFindFirstArgs<ExtArgs>>): Prisma__InvestigationSkillClient<$Result.GetResult<Prisma.$InvestigationSkillPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first InvestigationSkill that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvestigationSkillFindFirstOrThrowArgs} args - Arguments to find a InvestigationSkill
     * @example
     * // Get one InvestigationSkill
     * const investigationSkill = await prisma.investigationSkill.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InvestigationSkillFindFirstOrThrowArgs>(args?: SelectSubset<T, InvestigationSkillFindFirstOrThrowArgs<ExtArgs>>): Prisma__InvestigationSkillClient<$Result.GetResult<Prisma.$InvestigationSkillPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more InvestigationSkills that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvestigationSkillFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all InvestigationSkills
     * const investigationSkills = await prisma.investigationSkill.findMany()
     * 
     * // Get first 10 InvestigationSkills
     * const investigationSkills = await prisma.investigationSkill.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const investigationSkillWithIdOnly = await prisma.investigationSkill.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends InvestigationSkillFindManyArgs>(args?: SelectSubset<T, InvestigationSkillFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvestigationSkillPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a InvestigationSkill.
     * @param {InvestigationSkillCreateArgs} args - Arguments to create a InvestigationSkill.
     * @example
     * // Create one InvestigationSkill
     * const InvestigationSkill = await prisma.investigationSkill.create({
     *   data: {
     *     // ... data to create a InvestigationSkill
     *   }
     * })
     * 
     */
    create<T extends InvestigationSkillCreateArgs>(args: SelectSubset<T, InvestigationSkillCreateArgs<ExtArgs>>): Prisma__InvestigationSkillClient<$Result.GetResult<Prisma.$InvestigationSkillPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many InvestigationSkills.
     * @param {InvestigationSkillCreateManyArgs} args - Arguments to create many InvestigationSkills.
     * @example
     * // Create many InvestigationSkills
     * const investigationSkill = await prisma.investigationSkill.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InvestigationSkillCreateManyArgs>(args?: SelectSubset<T, InvestigationSkillCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many InvestigationSkills and returns the data saved in the database.
     * @param {InvestigationSkillCreateManyAndReturnArgs} args - Arguments to create many InvestigationSkills.
     * @example
     * // Create many InvestigationSkills
     * const investigationSkill = await prisma.investigationSkill.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many InvestigationSkills and only return the `id`
     * const investigationSkillWithIdOnly = await prisma.investigationSkill.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends InvestigationSkillCreateManyAndReturnArgs>(args?: SelectSubset<T, InvestigationSkillCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvestigationSkillPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a InvestigationSkill.
     * @param {InvestigationSkillDeleteArgs} args - Arguments to delete one InvestigationSkill.
     * @example
     * // Delete one InvestigationSkill
     * const InvestigationSkill = await prisma.investigationSkill.delete({
     *   where: {
     *     // ... filter to delete one InvestigationSkill
     *   }
     * })
     * 
     */
    delete<T extends InvestigationSkillDeleteArgs>(args: SelectSubset<T, InvestigationSkillDeleteArgs<ExtArgs>>): Prisma__InvestigationSkillClient<$Result.GetResult<Prisma.$InvestigationSkillPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one InvestigationSkill.
     * @param {InvestigationSkillUpdateArgs} args - Arguments to update one InvestigationSkill.
     * @example
     * // Update one InvestigationSkill
     * const investigationSkill = await prisma.investigationSkill.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InvestigationSkillUpdateArgs>(args: SelectSubset<T, InvestigationSkillUpdateArgs<ExtArgs>>): Prisma__InvestigationSkillClient<$Result.GetResult<Prisma.$InvestigationSkillPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more InvestigationSkills.
     * @param {InvestigationSkillDeleteManyArgs} args - Arguments to filter InvestigationSkills to delete.
     * @example
     * // Delete a few InvestigationSkills
     * const { count } = await prisma.investigationSkill.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InvestigationSkillDeleteManyArgs>(args?: SelectSubset<T, InvestigationSkillDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more InvestigationSkills.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvestigationSkillUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many InvestigationSkills
     * const investigationSkill = await prisma.investigationSkill.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InvestigationSkillUpdateManyArgs>(args: SelectSubset<T, InvestigationSkillUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more InvestigationSkills and returns the data updated in the database.
     * @param {InvestigationSkillUpdateManyAndReturnArgs} args - Arguments to update many InvestigationSkills.
     * @example
     * // Update many InvestigationSkills
     * const investigationSkill = await prisma.investigationSkill.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more InvestigationSkills and only return the `id`
     * const investigationSkillWithIdOnly = await prisma.investigationSkill.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends InvestigationSkillUpdateManyAndReturnArgs>(args: SelectSubset<T, InvestigationSkillUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvestigationSkillPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one InvestigationSkill.
     * @param {InvestigationSkillUpsertArgs} args - Arguments to update or create a InvestigationSkill.
     * @example
     * // Update or create a InvestigationSkill
     * const investigationSkill = await prisma.investigationSkill.upsert({
     *   create: {
     *     // ... data to create a InvestigationSkill
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the InvestigationSkill we want to update
     *   }
     * })
     */
    upsert<T extends InvestigationSkillUpsertArgs>(args: SelectSubset<T, InvestigationSkillUpsertArgs<ExtArgs>>): Prisma__InvestigationSkillClient<$Result.GetResult<Prisma.$InvestigationSkillPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of InvestigationSkills.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvestigationSkillCountArgs} args - Arguments to filter InvestigationSkills to count.
     * @example
     * // Count the number of InvestigationSkills
     * const count = await prisma.investigationSkill.count({
     *   where: {
     *     // ... the filter for the InvestigationSkills we want to count
     *   }
     * })
    **/
    count<T extends InvestigationSkillCountArgs>(
      args?: Subset<T, InvestigationSkillCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InvestigationSkillCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a InvestigationSkill.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvestigationSkillAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InvestigationSkillAggregateArgs>(args: Subset<T, InvestigationSkillAggregateArgs>): Prisma.PrismaPromise<GetInvestigationSkillAggregateType<T>>

    /**
     * Group by InvestigationSkill.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvestigationSkillGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InvestigationSkillGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InvestigationSkillGroupByArgs['orderBy'] }
        : { orderBy?: InvestigationSkillGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InvestigationSkillGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInvestigationSkillGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the InvestigationSkill model
   */
  readonly fields: InvestigationSkillFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for InvestigationSkill.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InvestigationSkillClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    skill_list<T extends IntellengenceBasedSkillsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, IntellengenceBasedSkillsDefaultArgs<ExtArgs>>): Prisma__IntellengenceBasedSkillsClient<$Result.GetResult<Prisma.$IntellengenceBasedSkillsPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the InvestigationSkill model
   */ 
  interface InvestigationSkillFieldRefs {
    readonly id: FieldRef<"InvestigationSkill", 'String'>
    readonly value: FieldRef<"InvestigationSkill", 'Int'>
    readonly mastery: FieldRef<"InvestigationSkill", 'Boolean'>
    readonly name: FieldRef<"InvestigationSkill", 'String'>
  }
    

  // Custom InputTypes
  /**
   * InvestigationSkill findUnique
   */
  export type InvestigationSkillFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvestigationSkill
     */
    select?: InvestigationSkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvestigationSkill
     */
    omit?: InvestigationSkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvestigationSkillInclude<ExtArgs> | null
    /**
     * Filter, which InvestigationSkill to fetch.
     */
    where: InvestigationSkillWhereUniqueInput
  }

  /**
   * InvestigationSkill findUniqueOrThrow
   */
  export type InvestigationSkillFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvestigationSkill
     */
    select?: InvestigationSkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvestigationSkill
     */
    omit?: InvestigationSkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvestigationSkillInclude<ExtArgs> | null
    /**
     * Filter, which InvestigationSkill to fetch.
     */
    where: InvestigationSkillWhereUniqueInput
  }

  /**
   * InvestigationSkill findFirst
   */
  export type InvestigationSkillFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvestigationSkill
     */
    select?: InvestigationSkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvestigationSkill
     */
    omit?: InvestigationSkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvestigationSkillInclude<ExtArgs> | null
    /**
     * Filter, which InvestigationSkill to fetch.
     */
    where?: InvestigationSkillWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InvestigationSkills to fetch.
     */
    orderBy?: InvestigationSkillOrderByWithRelationInput | InvestigationSkillOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InvestigationSkills.
     */
    cursor?: InvestigationSkillWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InvestigationSkills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InvestigationSkills.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InvestigationSkills.
     */
    distinct?: InvestigationSkillScalarFieldEnum | InvestigationSkillScalarFieldEnum[]
  }

  /**
   * InvestigationSkill findFirstOrThrow
   */
  export type InvestigationSkillFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvestigationSkill
     */
    select?: InvestigationSkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvestigationSkill
     */
    omit?: InvestigationSkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvestigationSkillInclude<ExtArgs> | null
    /**
     * Filter, which InvestigationSkill to fetch.
     */
    where?: InvestigationSkillWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InvestigationSkills to fetch.
     */
    orderBy?: InvestigationSkillOrderByWithRelationInput | InvestigationSkillOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InvestigationSkills.
     */
    cursor?: InvestigationSkillWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InvestigationSkills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InvestigationSkills.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InvestigationSkills.
     */
    distinct?: InvestigationSkillScalarFieldEnum | InvestigationSkillScalarFieldEnum[]
  }

  /**
   * InvestigationSkill findMany
   */
  export type InvestigationSkillFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvestigationSkill
     */
    select?: InvestigationSkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvestigationSkill
     */
    omit?: InvestigationSkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvestigationSkillInclude<ExtArgs> | null
    /**
     * Filter, which InvestigationSkills to fetch.
     */
    where?: InvestigationSkillWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InvestigationSkills to fetch.
     */
    orderBy?: InvestigationSkillOrderByWithRelationInput | InvestigationSkillOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing InvestigationSkills.
     */
    cursor?: InvestigationSkillWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InvestigationSkills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InvestigationSkills.
     */
    skip?: number
    distinct?: InvestigationSkillScalarFieldEnum | InvestigationSkillScalarFieldEnum[]
  }

  /**
   * InvestigationSkill create
   */
  export type InvestigationSkillCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvestigationSkill
     */
    select?: InvestigationSkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvestigationSkill
     */
    omit?: InvestigationSkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvestigationSkillInclude<ExtArgs> | null
    /**
     * The data needed to create a InvestigationSkill.
     */
    data: XOR<InvestigationSkillCreateInput, InvestigationSkillUncheckedCreateInput>
  }

  /**
   * InvestigationSkill createMany
   */
  export type InvestigationSkillCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many InvestigationSkills.
     */
    data: InvestigationSkillCreateManyInput | InvestigationSkillCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * InvestigationSkill createManyAndReturn
   */
  export type InvestigationSkillCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvestigationSkill
     */
    select?: InvestigationSkillSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the InvestigationSkill
     */
    omit?: InvestigationSkillOmit<ExtArgs> | null
    /**
     * The data used to create many InvestigationSkills.
     */
    data: InvestigationSkillCreateManyInput | InvestigationSkillCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvestigationSkillIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * InvestigationSkill update
   */
  export type InvestigationSkillUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvestigationSkill
     */
    select?: InvestigationSkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvestigationSkill
     */
    omit?: InvestigationSkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvestigationSkillInclude<ExtArgs> | null
    /**
     * The data needed to update a InvestigationSkill.
     */
    data: XOR<InvestigationSkillUpdateInput, InvestigationSkillUncheckedUpdateInput>
    /**
     * Choose, which InvestigationSkill to update.
     */
    where: InvestigationSkillWhereUniqueInput
  }

  /**
   * InvestigationSkill updateMany
   */
  export type InvestigationSkillUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update InvestigationSkills.
     */
    data: XOR<InvestigationSkillUpdateManyMutationInput, InvestigationSkillUncheckedUpdateManyInput>
    /**
     * Filter which InvestigationSkills to update
     */
    where?: InvestigationSkillWhereInput
    /**
     * Limit how many InvestigationSkills to update.
     */
    limit?: number
  }

  /**
   * InvestigationSkill updateManyAndReturn
   */
  export type InvestigationSkillUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvestigationSkill
     */
    select?: InvestigationSkillSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the InvestigationSkill
     */
    omit?: InvestigationSkillOmit<ExtArgs> | null
    /**
     * The data used to update InvestigationSkills.
     */
    data: XOR<InvestigationSkillUpdateManyMutationInput, InvestigationSkillUncheckedUpdateManyInput>
    /**
     * Filter which InvestigationSkills to update
     */
    where?: InvestigationSkillWhereInput
    /**
     * Limit how many InvestigationSkills to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvestigationSkillIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * InvestigationSkill upsert
   */
  export type InvestigationSkillUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvestigationSkill
     */
    select?: InvestigationSkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvestigationSkill
     */
    omit?: InvestigationSkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvestigationSkillInclude<ExtArgs> | null
    /**
     * The filter to search for the InvestigationSkill to update in case it exists.
     */
    where: InvestigationSkillWhereUniqueInput
    /**
     * In case the InvestigationSkill found by the `where` argument doesn't exist, create a new InvestigationSkill with this data.
     */
    create: XOR<InvestigationSkillCreateInput, InvestigationSkillUncheckedCreateInput>
    /**
     * In case the InvestigationSkill was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InvestigationSkillUpdateInput, InvestigationSkillUncheckedUpdateInput>
  }

  /**
   * InvestigationSkill delete
   */
  export type InvestigationSkillDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvestigationSkill
     */
    select?: InvestigationSkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvestigationSkill
     */
    omit?: InvestigationSkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvestigationSkillInclude<ExtArgs> | null
    /**
     * Filter which InvestigationSkill to delete.
     */
    where: InvestigationSkillWhereUniqueInput
  }

  /**
   * InvestigationSkill deleteMany
   */
  export type InvestigationSkillDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InvestigationSkills to delete
     */
    where?: InvestigationSkillWhereInput
    /**
     * Limit how many InvestigationSkills to delete.
     */
    limit?: number
  }

  /**
   * InvestigationSkill without action
   */
  export type InvestigationSkillDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvestigationSkill
     */
    select?: InvestigationSkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvestigationSkill
     */
    omit?: InvestigationSkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvestigationSkillInclude<ExtArgs> | null
  }


  /**
   * Model NatureSkill
   */

  export type AggregateNatureSkill = {
    _count: NatureSkillCountAggregateOutputType | null
    _avg: NatureSkillAvgAggregateOutputType | null
    _sum: NatureSkillSumAggregateOutputType | null
    _min: NatureSkillMinAggregateOutputType | null
    _max: NatureSkillMaxAggregateOutputType | null
  }

  export type NatureSkillAvgAggregateOutputType = {
    value: number | null
  }

  export type NatureSkillSumAggregateOutputType = {
    value: number | null
  }

  export type NatureSkillMinAggregateOutputType = {
    id: string | null
    value: number | null
    mastery: boolean | null
    name: string | null
  }

  export type NatureSkillMaxAggregateOutputType = {
    id: string | null
    value: number | null
    mastery: boolean | null
    name: string | null
  }

  export type NatureSkillCountAggregateOutputType = {
    id: number
    value: number
    mastery: number
    name: number
    _all: number
  }


  export type NatureSkillAvgAggregateInputType = {
    value?: true
  }

  export type NatureSkillSumAggregateInputType = {
    value?: true
  }

  export type NatureSkillMinAggregateInputType = {
    id?: true
    value?: true
    mastery?: true
    name?: true
  }

  export type NatureSkillMaxAggregateInputType = {
    id?: true
    value?: true
    mastery?: true
    name?: true
  }

  export type NatureSkillCountAggregateInputType = {
    id?: true
    value?: true
    mastery?: true
    name?: true
    _all?: true
  }

  export type NatureSkillAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NatureSkill to aggregate.
     */
    where?: NatureSkillWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NatureSkills to fetch.
     */
    orderBy?: NatureSkillOrderByWithRelationInput | NatureSkillOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NatureSkillWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NatureSkills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NatureSkills.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned NatureSkills
    **/
    _count?: true | NatureSkillCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: NatureSkillAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: NatureSkillSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NatureSkillMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NatureSkillMaxAggregateInputType
  }

  export type GetNatureSkillAggregateType<T extends NatureSkillAggregateArgs> = {
        [P in keyof T & keyof AggregateNatureSkill]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNatureSkill[P]>
      : GetScalarType<T[P], AggregateNatureSkill[P]>
  }




  export type NatureSkillGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NatureSkillWhereInput
    orderBy?: NatureSkillOrderByWithAggregationInput | NatureSkillOrderByWithAggregationInput[]
    by: NatureSkillScalarFieldEnum[] | NatureSkillScalarFieldEnum
    having?: NatureSkillScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NatureSkillCountAggregateInputType | true
    _avg?: NatureSkillAvgAggregateInputType
    _sum?: NatureSkillSumAggregateInputType
    _min?: NatureSkillMinAggregateInputType
    _max?: NatureSkillMaxAggregateInputType
  }

  export type NatureSkillGroupByOutputType = {
    id: string
    value: number | null
    mastery: boolean
    name: string
    _count: NatureSkillCountAggregateOutputType | null
    _avg: NatureSkillAvgAggregateOutputType | null
    _sum: NatureSkillSumAggregateOutputType | null
    _min: NatureSkillMinAggregateOutputType | null
    _max: NatureSkillMaxAggregateOutputType | null
  }

  type GetNatureSkillGroupByPayload<T extends NatureSkillGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NatureSkillGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NatureSkillGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NatureSkillGroupByOutputType[P]>
            : GetScalarType<T[P], NatureSkillGroupByOutputType[P]>
        }
      >
    >


  export type NatureSkillSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    value?: boolean
    mastery?: boolean
    name?: boolean
    skill_list?: boolean | IntellengenceBasedSkillsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["natureSkill"]>

  export type NatureSkillSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    value?: boolean
    mastery?: boolean
    name?: boolean
    skill_list?: boolean | IntellengenceBasedSkillsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["natureSkill"]>

  export type NatureSkillSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    value?: boolean
    mastery?: boolean
    name?: boolean
    skill_list?: boolean | IntellengenceBasedSkillsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["natureSkill"]>

  export type NatureSkillSelectScalar = {
    id?: boolean
    value?: boolean
    mastery?: boolean
    name?: boolean
  }

  export type NatureSkillOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "value" | "mastery" | "name", ExtArgs["result"]["natureSkill"]>
  export type NatureSkillInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    skill_list?: boolean | IntellengenceBasedSkillsDefaultArgs<ExtArgs>
  }
  export type NatureSkillIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    skill_list?: boolean | IntellengenceBasedSkillsDefaultArgs<ExtArgs>
  }
  export type NatureSkillIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    skill_list?: boolean | IntellengenceBasedSkillsDefaultArgs<ExtArgs>
  }

  export type $NatureSkillPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "NatureSkill"
    objects: {
      skill_list: Prisma.$IntellengenceBasedSkillsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      value: number | null
      mastery: boolean
      name: string
    }, ExtArgs["result"]["natureSkill"]>
    composites: {}
  }

  type NatureSkillGetPayload<S extends boolean | null | undefined | NatureSkillDefaultArgs> = $Result.GetResult<Prisma.$NatureSkillPayload, S>

  type NatureSkillCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<NatureSkillFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: NatureSkillCountAggregateInputType | true
    }

  export interface NatureSkillDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['NatureSkill'], meta: { name: 'NatureSkill' } }
    /**
     * Find zero or one NatureSkill that matches the filter.
     * @param {NatureSkillFindUniqueArgs} args - Arguments to find a NatureSkill
     * @example
     * // Get one NatureSkill
     * const natureSkill = await prisma.natureSkill.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NatureSkillFindUniqueArgs>(args: SelectSubset<T, NatureSkillFindUniqueArgs<ExtArgs>>): Prisma__NatureSkillClient<$Result.GetResult<Prisma.$NatureSkillPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one NatureSkill that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {NatureSkillFindUniqueOrThrowArgs} args - Arguments to find a NatureSkill
     * @example
     * // Get one NatureSkill
     * const natureSkill = await prisma.natureSkill.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NatureSkillFindUniqueOrThrowArgs>(args: SelectSubset<T, NatureSkillFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NatureSkillClient<$Result.GetResult<Prisma.$NatureSkillPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first NatureSkill that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NatureSkillFindFirstArgs} args - Arguments to find a NatureSkill
     * @example
     * // Get one NatureSkill
     * const natureSkill = await prisma.natureSkill.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NatureSkillFindFirstArgs>(args?: SelectSubset<T, NatureSkillFindFirstArgs<ExtArgs>>): Prisma__NatureSkillClient<$Result.GetResult<Prisma.$NatureSkillPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first NatureSkill that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NatureSkillFindFirstOrThrowArgs} args - Arguments to find a NatureSkill
     * @example
     * // Get one NatureSkill
     * const natureSkill = await prisma.natureSkill.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NatureSkillFindFirstOrThrowArgs>(args?: SelectSubset<T, NatureSkillFindFirstOrThrowArgs<ExtArgs>>): Prisma__NatureSkillClient<$Result.GetResult<Prisma.$NatureSkillPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more NatureSkills that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NatureSkillFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all NatureSkills
     * const natureSkills = await prisma.natureSkill.findMany()
     * 
     * // Get first 10 NatureSkills
     * const natureSkills = await prisma.natureSkill.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const natureSkillWithIdOnly = await prisma.natureSkill.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NatureSkillFindManyArgs>(args?: SelectSubset<T, NatureSkillFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NatureSkillPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a NatureSkill.
     * @param {NatureSkillCreateArgs} args - Arguments to create a NatureSkill.
     * @example
     * // Create one NatureSkill
     * const NatureSkill = await prisma.natureSkill.create({
     *   data: {
     *     // ... data to create a NatureSkill
     *   }
     * })
     * 
     */
    create<T extends NatureSkillCreateArgs>(args: SelectSubset<T, NatureSkillCreateArgs<ExtArgs>>): Prisma__NatureSkillClient<$Result.GetResult<Prisma.$NatureSkillPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many NatureSkills.
     * @param {NatureSkillCreateManyArgs} args - Arguments to create many NatureSkills.
     * @example
     * // Create many NatureSkills
     * const natureSkill = await prisma.natureSkill.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NatureSkillCreateManyArgs>(args?: SelectSubset<T, NatureSkillCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many NatureSkills and returns the data saved in the database.
     * @param {NatureSkillCreateManyAndReturnArgs} args - Arguments to create many NatureSkills.
     * @example
     * // Create many NatureSkills
     * const natureSkill = await prisma.natureSkill.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many NatureSkills and only return the `id`
     * const natureSkillWithIdOnly = await prisma.natureSkill.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NatureSkillCreateManyAndReturnArgs>(args?: SelectSubset<T, NatureSkillCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NatureSkillPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a NatureSkill.
     * @param {NatureSkillDeleteArgs} args - Arguments to delete one NatureSkill.
     * @example
     * // Delete one NatureSkill
     * const NatureSkill = await prisma.natureSkill.delete({
     *   where: {
     *     // ... filter to delete one NatureSkill
     *   }
     * })
     * 
     */
    delete<T extends NatureSkillDeleteArgs>(args: SelectSubset<T, NatureSkillDeleteArgs<ExtArgs>>): Prisma__NatureSkillClient<$Result.GetResult<Prisma.$NatureSkillPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one NatureSkill.
     * @param {NatureSkillUpdateArgs} args - Arguments to update one NatureSkill.
     * @example
     * // Update one NatureSkill
     * const natureSkill = await prisma.natureSkill.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NatureSkillUpdateArgs>(args: SelectSubset<T, NatureSkillUpdateArgs<ExtArgs>>): Prisma__NatureSkillClient<$Result.GetResult<Prisma.$NatureSkillPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more NatureSkills.
     * @param {NatureSkillDeleteManyArgs} args - Arguments to filter NatureSkills to delete.
     * @example
     * // Delete a few NatureSkills
     * const { count } = await prisma.natureSkill.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NatureSkillDeleteManyArgs>(args?: SelectSubset<T, NatureSkillDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more NatureSkills.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NatureSkillUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many NatureSkills
     * const natureSkill = await prisma.natureSkill.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NatureSkillUpdateManyArgs>(args: SelectSubset<T, NatureSkillUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more NatureSkills and returns the data updated in the database.
     * @param {NatureSkillUpdateManyAndReturnArgs} args - Arguments to update many NatureSkills.
     * @example
     * // Update many NatureSkills
     * const natureSkill = await prisma.natureSkill.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more NatureSkills and only return the `id`
     * const natureSkillWithIdOnly = await prisma.natureSkill.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends NatureSkillUpdateManyAndReturnArgs>(args: SelectSubset<T, NatureSkillUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NatureSkillPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one NatureSkill.
     * @param {NatureSkillUpsertArgs} args - Arguments to update or create a NatureSkill.
     * @example
     * // Update or create a NatureSkill
     * const natureSkill = await prisma.natureSkill.upsert({
     *   create: {
     *     // ... data to create a NatureSkill
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the NatureSkill we want to update
     *   }
     * })
     */
    upsert<T extends NatureSkillUpsertArgs>(args: SelectSubset<T, NatureSkillUpsertArgs<ExtArgs>>): Prisma__NatureSkillClient<$Result.GetResult<Prisma.$NatureSkillPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of NatureSkills.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NatureSkillCountArgs} args - Arguments to filter NatureSkills to count.
     * @example
     * // Count the number of NatureSkills
     * const count = await prisma.natureSkill.count({
     *   where: {
     *     // ... the filter for the NatureSkills we want to count
     *   }
     * })
    **/
    count<T extends NatureSkillCountArgs>(
      args?: Subset<T, NatureSkillCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NatureSkillCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a NatureSkill.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NatureSkillAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NatureSkillAggregateArgs>(args: Subset<T, NatureSkillAggregateArgs>): Prisma.PrismaPromise<GetNatureSkillAggregateType<T>>

    /**
     * Group by NatureSkill.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NatureSkillGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NatureSkillGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NatureSkillGroupByArgs['orderBy'] }
        : { orderBy?: NatureSkillGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NatureSkillGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNatureSkillGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the NatureSkill model
   */
  readonly fields: NatureSkillFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for NatureSkill.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NatureSkillClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    skill_list<T extends IntellengenceBasedSkillsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, IntellengenceBasedSkillsDefaultArgs<ExtArgs>>): Prisma__IntellengenceBasedSkillsClient<$Result.GetResult<Prisma.$IntellengenceBasedSkillsPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the NatureSkill model
   */ 
  interface NatureSkillFieldRefs {
    readonly id: FieldRef<"NatureSkill", 'String'>
    readonly value: FieldRef<"NatureSkill", 'Int'>
    readonly mastery: FieldRef<"NatureSkill", 'Boolean'>
    readonly name: FieldRef<"NatureSkill", 'String'>
  }
    

  // Custom InputTypes
  /**
   * NatureSkill findUnique
   */
  export type NatureSkillFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NatureSkill
     */
    select?: NatureSkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NatureSkill
     */
    omit?: NatureSkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NatureSkillInclude<ExtArgs> | null
    /**
     * Filter, which NatureSkill to fetch.
     */
    where: NatureSkillWhereUniqueInput
  }

  /**
   * NatureSkill findUniqueOrThrow
   */
  export type NatureSkillFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NatureSkill
     */
    select?: NatureSkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NatureSkill
     */
    omit?: NatureSkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NatureSkillInclude<ExtArgs> | null
    /**
     * Filter, which NatureSkill to fetch.
     */
    where: NatureSkillWhereUniqueInput
  }

  /**
   * NatureSkill findFirst
   */
  export type NatureSkillFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NatureSkill
     */
    select?: NatureSkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NatureSkill
     */
    omit?: NatureSkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NatureSkillInclude<ExtArgs> | null
    /**
     * Filter, which NatureSkill to fetch.
     */
    where?: NatureSkillWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NatureSkills to fetch.
     */
    orderBy?: NatureSkillOrderByWithRelationInput | NatureSkillOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NatureSkills.
     */
    cursor?: NatureSkillWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NatureSkills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NatureSkills.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NatureSkills.
     */
    distinct?: NatureSkillScalarFieldEnum | NatureSkillScalarFieldEnum[]
  }

  /**
   * NatureSkill findFirstOrThrow
   */
  export type NatureSkillFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NatureSkill
     */
    select?: NatureSkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NatureSkill
     */
    omit?: NatureSkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NatureSkillInclude<ExtArgs> | null
    /**
     * Filter, which NatureSkill to fetch.
     */
    where?: NatureSkillWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NatureSkills to fetch.
     */
    orderBy?: NatureSkillOrderByWithRelationInput | NatureSkillOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NatureSkills.
     */
    cursor?: NatureSkillWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NatureSkills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NatureSkills.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NatureSkills.
     */
    distinct?: NatureSkillScalarFieldEnum | NatureSkillScalarFieldEnum[]
  }

  /**
   * NatureSkill findMany
   */
  export type NatureSkillFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NatureSkill
     */
    select?: NatureSkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NatureSkill
     */
    omit?: NatureSkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NatureSkillInclude<ExtArgs> | null
    /**
     * Filter, which NatureSkills to fetch.
     */
    where?: NatureSkillWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NatureSkills to fetch.
     */
    orderBy?: NatureSkillOrderByWithRelationInput | NatureSkillOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing NatureSkills.
     */
    cursor?: NatureSkillWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NatureSkills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NatureSkills.
     */
    skip?: number
    distinct?: NatureSkillScalarFieldEnum | NatureSkillScalarFieldEnum[]
  }

  /**
   * NatureSkill create
   */
  export type NatureSkillCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NatureSkill
     */
    select?: NatureSkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NatureSkill
     */
    omit?: NatureSkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NatureSkillInclude<ExtArgs> | null
    /**
     * The data needed to create a NatureSkill.
     */
    data: XOR<NatureSkillCreateInput, NatureSkillUncheckedCreateInput>
  }

  /**
   * NatureSkill createMany
   */
  export type NatureSkillCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many NatureSkills.
     */
    data: NatureSkillCreateManyInput | NatureSkillCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * NatureSkill createManyAndReturn
   */
  export type NatureSkillCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NatureSkill
     */
    select?: NatureSkillSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the NatureSkill
     */
    omit?: NatureSkillOmit<ExtArgs> | null
    /**
     * The data used to create many NatureSkills.
     */
    data: NatureSkillCreateManyInput | NatureSkillCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NatureSkillIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * NatureSkill update
   */
  export type NatureSkillUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NatureSkill
     */
    select?: NatureSkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NatureSkill
     */
    omit?: NatureSkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NatureSkillInclude<ExtArgs> | null
    /**
     * The data needed to update a NatureSkill.
     */
    data: XOR<NatureSkillUpdateInput, NatureSkillUncheckedUpdateInput>
    /**
     * Choose, which NatureSkill to update.
     */
    where: NatureSkillWhereUniqueInput
  }

  /**
   * NatureSkill updateMany
   */
  export type NatureSkillUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update NatureSkills.
     */
    data: XOR<NatureSkillUpdateManyMutationInput, NatureSkillUncheckedUpdateManyInput>
    /**
     * Filter which NatureSkills to update
     */
    where?: NatureSkillWhereInput
    /**
     * Limit how many NatureSkills to update.
     */
    limit?: number
  }

  /**
   * NatureSkill updateManyAndReturn
   */
  export type NatureSkillUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NatureSkill
     */
    select?: NatureSkillSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the NatureSkill
     */
    omit?: NatureSkillOmit<ExtArgs> | null
    /**
     * The data used to update NatureSkills.
     */
    data: XOR<NatureSkillUpdateManyMutationInput, NatureSkillUncheckedUpdateManyInput>
    /**
     * Filter which NatureSkills to update
     */
    where?: NatureSkillWhereInput
    /**
     * Limit how many NatureSkills to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NatureSkillIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * NatureSkill upsert
   */
  export type NatureSkillUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NatureSkill
     */
    select?: NatureSkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NatureSkill
     */
    omit?: NatureSkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NatureSkillInclude<ExtArgs> | null
    /**
     * The filter to search for the NatureSkill to update in case it exists.
     */
    where: NatureSkillWhereUniqueInput
    /**
     * In case the NatureSkill found by the `where` argument doesn't exist, create a new NatureSkill with this data.
     */
    create: XOR<NatureSkillCreateInput, NatureSkillUncheckedCreateInput>
    /**
     * In case the NatureSkill was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NatureSkillUpdateInput, NatureSkillUncheckedUpdateInput>
  }

  /**
   * NatureSkill delete
   */
  export type NatureSkillDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NatureSkill
     */
    select?: NatureSkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NatureSkill
     */
    omit?: NatureSkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NatureSkillInclude<ExtArgs> | null
    /**
     * Filter which NatureSkill to delete.
     */
    where: NatureSkillWhereUniqueInput
  }

  /**
   * NatureSkill deleteMany
   */
  export type NatureSkillDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NatureSkills to delete
     */
    where?: NatureSkillWhereInput
    /**
     * Limit how many NatureSkills to delete.
     */
    limit?: number
  }

  /**
   * NatureSkill without action
   */
  export type NatureSkillDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NatureSkill
     */
    select?: NatureSkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NatureSkill
     */
    omit?: NatureSkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NatureSkillInclude<ExtArgs> | null
  }


  /**
   * Model ReligionSkill
   */

  export type AggregateReligionSkill = {
    _count: ReligionSkillCountAggregateOutputType | null
    _avg: ReligionSkillAvgAggregateOutputType | null
    _sum: ReligionSkillSumAggregateOutputType | null
    _min: ReligionSkillMinAggregateOutputType | null
    _max: ReligionSkillMaxAggregateOutputType | null
  }

  export type ReligionSkillAvgAggregateOutputType = {
    value: number | null
  }

  export type ReligionSkillSumAggregateOutputType = {
    value: number | null
  }

  export type ReligionSkillMinAggregateOutputType = {
    id: string | null
    value: number | null
    mastery: boolean | null
    name: string | null
  }

  export type ReligionSkillMaxAggregateOutputType = {
    id: string | null
    value: number | null
    mastery: boolean | null
    name: string | null
  }

  export type ReligionSkillCountAggregateOutputType = {
    id: number
    value: number
    mastery: number
    name: number
    _all: number
  }


  export type ReligionSkillAvgAggregateInputType = {
    value?: true
  }

  export type ReligionSkillSumAggregateInputType = {
    value?: true
  }

  export type ReligionSkillMinAggregateInputType = {
    id?: true
    value?: true
    mastery?: true
    name?: true
  }

  export type ReligionSkillMaxAggregateInputType = {
    id?: true
    value?: true
    mastery?: true
    name?: true
  }

  export type ReligionSkillCountAggregateInputType = {
    id?: true
    value?: true
    mastery?: true
    name?: true
    _all?: true
  }

  export type ReligionSkillAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ReligionSkill to aggregate.
     */
    where?: ReligionSkillWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReligionSkills to fetch.
     */
    orderBy?: ReligionSkillOrderByWithRelationInput | ReligionSkillOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ReligionSkillWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReligionSkills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReligionSkills.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ReligionSkills
    **/
    _count?: true | ReligionSkillCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ReligionSkillAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ReligionSkillSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ReligionSkillMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ReligionSkillMaxAggregateInputType
  }

  export type GetReligionSkillAggregateType<T extends ReligionSkillAggregateArgs> = {
        [P in keyof T & keyof AggregateReligionSkill]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReligionSkill[P]>
      : GetScalarType<T[P], AggregateReligionSkill[P]>
  }




  export type ReligionSkillGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReligionSkillWhereInput
    orderBy?: ReligionSkillOrderByWithAggregationInput | ReligionSkillOrderByWithAggregationInput[]
    by: ReligionSkillScalarFieldEnum[] | ReligionSkillScalarFieldEnum
    having?: ReligionSkillScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ReligionSkillCountAggregateInputType | true
    _avg?: ReligionSkillAvgAggregateInputType
    _sum?: ReligionSkillSumAggregateInputType
    _min?: ReligionSkillMinAggregateInputType
    _max?: ReligionSkillMaxAggregateInputType
  }

  export type ReligionSkillGroupByOutputType = {
    id: string
    value: number | null
    mastery: boolean
    name: string
    _count: ReligionSkillCountAggregateOutputType | null
    _avg: ReligionSkillAvgAggregateOutputType | null
    _sum: ReligionSkillSumAggregateOutputType | null
    _min: ReligionSkillMinAggregateOutputType | null
    _max: ReligionSkillMaxAggregateOutputType | null
  }

  type GetReligionSkillGroupByPayload<T extends ReligionSkillGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ReligionSkillGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ReligionSkillGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ReligionSkillGroupByOutputType[P]>
            : GetScalarType<T[P], ReligionSkillGroupByOutputType[P]>
        }
      >
    >


  export type ReligionSkillSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    value?: boolean
    mastery?: boolean
    name?: boolean
    skill_list?: boolean | IntellengenceBasedSkillsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["religionSkill"]>

  export type ReligionSkillSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    value?: boolean
    mastery?: boolean
    name?: boolean
    skill_list?: boolean | IntellengenceBasedSkillsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["religionSkill"]>

  export type ReligionSkillSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    value?: boolean
    mastery?: boolean
    name?: boolean
    skill_list?: boolean | IntellengenceBasedSkillsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["religionSkill"]>

  export type ReligionSkillSelectScalar = {
    id?: boolean
    value?: boolean
    mastery?: boolean
    name?: boolean
  }

  export type ReligionSkillOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "value" | "mastery" | "name", ExtArgs["result"]["religionSkill"]>
  export type ReligionSkillInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    skill_list?: boolean | IntellengenceBasedSkillsDefaultArgs<ExtArgs>
  }
  export type ReligionSkillIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    skill_list?: boolean | IntellengenceBasedSkillsDefaultArgs<ExtArgs>
  }
  export type ReligionSkillIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    skill_list?: boolean | IntellengenceBasedSkillsDefaultArgs<ExtArgs>
  }

  export type $ReligionSkillPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ReligionSkill"
    objects: {
      skill_list: Prisma.$IntellengenceBasedSkillsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      value: number | null
      mastery: boolean
      name: string
    }, ExtArgs["result"]["religionSkill"]>
    composites: {}
  }

  type ReligionSkillGetPayload<S extends boolean | null | undefined | ReligionSkillDefaultArgs> = $Result.GetResult<Prisma.$ReligionSkillPayload, S>

  type ReligionSkillCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ReligionSkillFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ReligionSkillCountAggregateInputType | true
    }

  export interface ReligionSkillDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ReligionSkill'], meta: { name: 'ReligionSkill' } }
    /**
     * Find zero or one ReligionSkill that matches the filter.
     * @param {ReligionSkillFindUniqueArgs} args - Arguments to find a ReligionSkill
     * @example
     * // Get one ReligionSkill
     * const religionSkill = await prisma.religionSkill.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ReligionSkillFindUniqueArgs>(args: SelectSubset<T, ReligionSkillFindUniqueArgs<ExtArgs>>): Prisma__ReligionSkillClient<$Result.GetResult<Prisma.$ReligionSkillPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one ReligionSkill that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ReligionSkillFindUniqueOrThrowArgs} args - Arguments to find a ReligionSkill
     * @example
     * // Get one ReligionSkill
     * const religionSkill = await prisma.religionSkill.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ReligionSkillFindUniqueOrThrowArgs>(args: SelectSubset<T, ReligionSkillFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ReligionSkillClient<$Result.GetResult<Prisma.$ReligionSkillPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first ReligionSkill that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReligionSkillFindFirstArgs} args - Arguments to find a ReligionSkill
     * @example
     * // Get one ReligionSkill
     * const religionSkill = await prisma.religionSkill.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ReligionSkillFindFirstArgs>(args?: SelectSubset<T, ReligionSkillFindFirstArgs<ExtArgs>>): Prisma__ReligionSkillClient<$Result.GetResult<Prisma.$ReligionSkillPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first ReligionSkill that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReligionSkillFindFirstOrThrowArgs} args - Arguments to find a ReligionSkill
     * @example
     * // Get one ReligionSkill
     * const religionSkill = await prisma.religionSkill.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ReligionSkillFindFirstOrThrowArgs>(args?: SelectSubset<T, ReligionSkillFindFirstOrThrowArgs<ExtArgs>>): Prisma__ReligionSkillClient<$Result.GetResult<Prisma.$ReligionSkillPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more ReligionSkills that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReligionSkillFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ReligionSkills
     * const religionSkills = await prisma.religionSkill.findMany()
     * 
     * // Get first 10 ReligionSkills
     * const religionSkills = await prisma.religionSkill.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const religionSkillWithIdOnly = await prisma.religionSkill.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ReligionSkillFindManyArgs>(args?: SelectSubset<T, ReligionSkillFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReligionSkillPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a ReligionSkill.
     * @param {ReligionSkillCreateArgs} args - Arguments to create a ReligionSkill.
     * @example
     * // Create one ReligionSkill
     * const ReligionSkill = await prisma.religionSkill.create({
     *   data: {
     *     // ... data to create a ReligionSkill
     *   }
     * })
     * 
     */
    create<T extends ReligionSkillCreateArgs>(args: SelectSubset<T, ReligionSkillCreateArgs<ExtArgs>>): Prisma__ReligionSkillClient<$Result.GetResult<Prisma.$ReligionSkillPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many ReligionSkills.
     * @param {ReligionSkillCreateManyArgs} args - Arguments to create many ReligionSkills.
     * @example
     * // Create many ReligionSkills
     * const religionSkill = await prisma.religionSkill.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ReligionSkillCreateManyArgs>(args?: SelectSubset<T, ReligionSkillCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ReligionSkills and returns the data saved in the database.
     * @param {ReligionSkillCreateManyAndReturnArgs} args - Arguments to create many ReligionSkills.
     * @example
     * // Create many ReligionSkills
     * const religionSkill = await prisma.religionSkill.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ReligionSkills and only return the `id`
     * const religionSkillWithIdOnly = await prisma.religionSkill.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ReligionSkillCreateManyAndReturnArgs>(args?: SelectSubset<T, ReligionSkillCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReligionSkillPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a ReligionSkill.
     * @param {ReligionSkillDeleteArgs} args - Arguments to delete one ReligionSkill.
     * @example
     * // Delete one ReligionSkill
     * const ReligionSkill = await prisma.religionSkill.delete({
     *   where: {
     *     // ... filter to delete one ReligionSkill
     *   }
     * })
     * 
     */
    delete<T extends ReligionSkillDeleteArgs>(args: SelectSubset<T, ReligionSkillDeleteArgs<ExtArgs>>): Prisma__ReligionSkillClient<$Result.GetResult<Prisma.$ReligionSkillPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one ReligionSkill.
     * @param {ReligionSkillUpdateArgs} args - Arguments to update one ReligionSkill.
     * @example
     * // Update one ReligionSkill
     * const religionSkill = await prisma.religionSkill.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ReligionSkillUpdateArgs>(args: SelectSubset<T, ReligionSkillUpdateArgs<ExtArgs>>): Prisma__ReligionSkillClient<$Result.GetResult<Prisma.$ReligionSkillPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more ReligionSkills.
     * @param {ReligionSkillDeleteManyArgs} args - Arguments to filter ReligionSkills to delete.
     * @example
     * // Delete a few ReligionSkills
     * const { count } = await prisma.religionSkill.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ReligionSkillDeleteManyArgs>(args?: SelectSubset<T, ReligionSkillDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ReligionSkills.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReligionSkillUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ReligionSkills
     * const religionSkill = await prisma.religionSkill.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ReligionSkillUpdateManyArgs>(args: SelectSubset<T, ReligionSkillUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ReligionSkills and returns the data updated in the database.
     * @param {ReligionSkillUpdateManyAndReturnArgs} args - Arguments to update many ReligionSkills.
     * @example
     * // Update many ReligionSkills
     * const religionSkill = await prisma.religionSkill.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ReligionSkills and only return the `id`
     * const religionSkillWithIdOnly = await prisma.religionSkill.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ReligionSkillUpdateManyAndReturnArgs>(args: SelectSubset<T, ReligionSkillUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReligionSkillPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one ReligionSkill.
     * @param {ReligionSkillUpsertArgs} args - Arguments to update or create a ReligionSkill.
     * @example
     * // Update or create a ReligionSkill
     * const religionSkill = await prisma.religionSkill.upsert({
     *   create: {
     *     // ... data to create a ReligionSkill
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ReligionSkill we want to update
     *   }
     * })
     */
    upsert<T extends ReligionSkillUpsertArgs>(args: SelectSubset<T, ReligionSkillUpsertArgs<ExtArgs>>): Prisma__ReligionSkillClient<$Result.GetResult<Prisma.$ReligionSkillPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of ReligionSkills.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReligionSkillCountArgs} args - Arguments to filter ReligionSkills to count.
     * @example
     * // Count the number of ReligionSkills
     * const count = await prisma.religionSkill.count({
     *   where: {
     *     // ... the filter for the ReligionSkills we want to count
     *   }
     * })
    **/
    count<T extends ReligionSkillCountArgs>(
      args?: Subset<T, ReligionSkillCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReligionSkillCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ReligionSkill.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReligionSkillAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReligionSkillAggregateArgs>(args: Subset<T, ReligionSkillAggregateArgs>): Prisma.PrismaPromise<GetReligionSkillAggregateType<T>>

    /**
     * Group by ReligionSkill.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReligionSkillGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ReligionSkillGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ReligionSkillGroupByArgs['orderBy'] }
        : { orderBy?: ReligionSkillGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ReligionSkillGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReligionSkillGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ReligionSkill model
   */
  readonly fields: ReligionSkillFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ReligionSkill.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ReligionSkillClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    skill_list<T extends IntellengenceBasedSkillsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, IntellengenceBasedSkillsDefaultArgs<ExtArgs>>): Prisma__IntellengenceBasedSkillsClient<$Result.GetResult<Prisma.$IntellengenceBasedSkillsPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ReligionSkill model
   */ 
  interface ReligionSkillFieldRefs {
    readonly id: FieldRef<"ReligionSkill", 'String'>
    readonly value: FieldRef<"ReligionSkill", 'Int'>
    readonly mastery: FieldRef<"ReligionSkill", 'Boolean'>
    readonly name: FieldRef<"ReligionSkill", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ReligionSkill findUnique
   */
  export type ReligionSkillFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReligionSkill
     */
    select?: ReligionSkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReligionSkill
     */
    omit?: ReligionSkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReligionSkillInclude<ExtArgs> | null
    /**
     * Filter, which ReligionSkill to fetch.
     */
    where: ReligionSkillWhereUniqueInput
  }

  /**
   * ReligionSkill findUniqueOrThrow
   */
  export type ReligionSkillFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReligionSkill
     */
    select?: ReligionSkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReligionSkill
     */
    omit?: ReligionSkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReligionSkillInclude<ExtArgs> | null
    /**
     * Filter, which ReligionSkill to fetch.
     */
    where: ReligionSkillWhereUniqueInput
  }

  /**
   * ReligionSkill findFirst
   */
  export type ReligionSkillFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReligionSkill
     */
    select?: ReligionSkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReligionSkill
     */
    omit?: ReligionSkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReligionSkillInclude<ExtArgs> | null
    /**
     * Filter, which ReligionSkill to fetch.
     */
    where?: ReligionSkillWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReligionSkills to fetch.
     */
    orderBy?: ReligionSkillOrderByWithRelationInput | ReligionSkillOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ReligionSkills.
     */
    cursor?: ReligionSkillWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReligionSkills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReligionSkills.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ReligionSkills.
     */
    distinct?: ReligionSkillScalarFieldEnum | ReligionSkillScalarFieldEnum[]
  }

  /**
   * ReligionSkill findFirstOrThrow
   */
  export type ReligionSkillFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReligionSkill
     */
    select?: ReligionSkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReligionSkill
     */
    omit?: ReligionSkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReligionSkillInclude<ExtArgs> | null
    /**
     * Filter, which ReligionSkill to fetch.
     */
    where?: ReligionSkillWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReligionSkills to fetch.
     */
    orderBy?: ReligionSkillOrderByWithRelationInput | ReligionSkillOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ReligionSkills.
     */
    cursor?: ReligionSkillWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReligionSkills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReligionSkills.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ReligionSkills.
     */
    distinct?: ReligionSkillScalarFieldEnum | ReligionSkillScalarFieldEnum[]
  }

  /**
   * ReligionSkill findMany
   */
  export type ReligionSkillFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReligionSkill
     */
    select?: ReligionSkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReligionSkill
     */
    omit?: ReligionSkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReligionSkillInclude<ExtArgs> | null
    /**
     * Filter, which ReligionSkills to fetch.
     */
    where?: ReligionSkillWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReligionSkills to fetch.
     */
    orderBy?: ReligionSkillOrderByWithRelationInput | ReligionSkillOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ReligionSkills.
     */
    cursor?: ReligionSkillWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReligionSkills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReligionSkills.
     */
    skip?: number
    distinct?: ReligionSkillScalarFieldEnum | ReligionSkillScalarFieldEnum[]
  }

  /**
   * ReligionSkill create
   */
  export type ReligionSkillCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReligionSkill
     */
    select?: ReligionSkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReligionSkill
     */
    omit?: ReligionSkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReligionSkillInclude<ExtArgs> | null
    /**
     * The data needed to create a ReligionSkill.
     */
    data: XOR<ReligionSkillCreateInput, ReligionSkillUncheckedCreateInput>
  }

  /**
   * ReligionSkill createMany
   */
  export type ReligionSkillCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ReligionSkills.
     */
    data: ReligionSkillCreateManyInput | ReligionSkillCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ReligionSkill createManyAndReturn
   */
  export type ReligionSkillCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReligionSkill
     */
    select?: ReligionSkillSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ReligionSkill
     */
    omit?: ReligionSkillOmit<ExtArgs> | null
    /**
     * The data used to create many ReligionSkills.
     */
    data: ReligionSkillCreateManyInput | ReligionSkillCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReligionSkillIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ReligionSkill update
   */
  export type ReligionSkillUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReligionSkill
     */
    select?: ReligionSkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReligionSkill
     */
    omit?: ReligionSkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReligionSkillInclude<ExtArgs> | null
    /**
     * The data needed to update a ReligionSkill.
     */
    data: XOR<ReligionSkillUpdateInput, ReligionSkillUncheckedUpdateInput>
    /**
     * Choose, which ReligionSkill to update.
     */
    where: ReligionSkillWhereUniqueInput
  }

  /**
   * ReligionSkill updateMany
   */
  export type ReligionSkillUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ReligionSkills.
     */
    data: XOR<ReligionSkillUpdateManyMutationInput, ReligionSkillUncheckedUpdateManyInput>
    /**
     * Filter which ReligionSkills to update
     */
    where?: ReligionSkillWhereInput
    /**
     * Limit how many ReligionSkills to update.
     */
    limit?: number
  }

  /**
   * ReligionSkill updateManyAndReturn
   */
  export type ReligionSkillUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReligionSkill
     */
    select?: ReligionSkillSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ReligionSkill
     */
    omit?: ReligionSkillOmit<ExtArgs> | null
    /**
     * The data used to update ReligionSkills.
     */
    data: XOR<ReligionSkillUpdateManyMutationInput, ReligionSkillUncheckedUpdateManyInput>
    /**
     * Filter which ReligionSkills to update
     */
    where?: ReligionSkillWhereInput
    /**
     * Limit how many ReligionSkills to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReligionSkillIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ReligionSkill upsert
   */
  export type ReligionSkillUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReligionSkill
     */
    select?: ReligionSkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReligionSkill
     */
    omit?: ReligionSkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReligionSkillInclude<ExtArgs> | null
    /**
     * The filter to search for the ReligionSkill to update in case it exists.
     */
    where: ReligionSkillWhereUniqueInput
    /**
     * In case the ReligionSkill found by the `where` argument doesn't exist, create a new ReligionSkill with this data.
     */
    create: XOR<ReligionSkillCreateInput, ReligionSkillUncheckedCreateInput>
    /**
     * In case the ReligionSkill was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ReligionSkillUpdateInput, ReligionSkillUncheckedUpdateInput>
  }

  /**
   * ReligionSkill delete
   */
  export type ReligionSkillDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReligionSkill
     */
    select?: ReligionSkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReligionSkill
     */
    omit?: ReligionSkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReligionSkillInclude<ExtArgs> | null
    /**
     * Filter which ReligionSkill to delete.
     */
    where: ReligionSkillWhereUniqueInput
  }

  /**
   * ReligionSkill deleteMany
   */
  export type ReligionSkillDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ReligionSkills to delete
     */
    where?: ReligionSkillWhereInput
    /**
     * Limit how many ReligionSkills to delete.
     */
    limit?: number
  }

  /**
   * ReligionSkill without action
   */
  export type ReligionSkillDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReligionSkill
     */
    select?: ReligionSkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReligionSkill
     */
    omit?: ReligionSkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReligionSkillInclude<ExtArgs> | null
  }


  /**
   * Model AnimalHandlingSkill
   */

  export type AggregateAnimalHandlingSkill = {
    _count: AnimalHandlingSkillCountAggregateOutputType | null
    _avg: AnimalHandlingSkillAvgAggregateOutputType | null
    _sum: AnimalHandlingSkillSumAggregateOutputType | null
    _min: AnimalHandlingSkillMinAggregateOutputType | null
    _max: AnimalHandlingSkillMaxAggregateOutputType | null
  }

  export type AnimalHandlingSkillAvgAggregateOutputType = {
    value: number | null
  }

  export type AnimalHandlingSkillSumAggregateOutputType = {
    value: number | null
  }

  export type AnimalHandlingSkillMinAggregateOutputType = {
    id: string | null
    value: number | null
    mastery: boolean | null
    name: string | null
  }

  export type AnimalHandlingSkillMaxAggregateOutputType = {
    id: string | null
    value: number | null
    mastery: boolean | null
    name: string | null
  }

  export type AnimalHandlingSkillCountAggregateOutputType = {
    id: number
    value: number
    mastery: number
    name: number
    _all: number
  }


  export type AnimalHandlingSkillAvgAggregateInputType = {
    value?: true
  }

  export type AnimalHandlingSkillSumAggregateInputType = {
    value?: true
  }

  export type AnimalHandlingSkillMinAggregateInputType = {
    id?: true
    value?: true
    mastery?: true
    name?: true
  }

  export type AnimalHandlingSkillMaxAggregateInputType = {
    id?: true
    value?: true
    mastery?: true
    name?: true
  }

  export type AnimalHandlingSkillCountAggregateInputType = {
    id?: true
    value?: true
    mastery?: true
    name?: true
    _all?: true
  }

  export type AnimalHandlingSkillAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AnimalHandlingSkill to aggregate.
     */
    where?: AnimalHandlingSkillWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AnimalHandlingSkills to fetch.
     */
    orderBy?: AnimalHandlingSkillOrderByWithRelationInput | AnimalHandlingSkillOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AnimalHandlingSkillWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AnimalHandlingSkills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AnimalHandlingSkills.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AnimalHandlingSkills
    **/
    _count?: true | AnimalHandlingSkillCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AnimalHandlingSkillAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AnimalHandlingSkillSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AnimalHandlingSkillMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AnimalHandlingSkillMaxAggregateInputType
  }

  export type GetAnimalHandlingSkillAggregateType<T extends AnimalHandlingSkillAggregateArgs> = {
        [P in keyof T & keyof AggregateAnimalHandlingSkill]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAnimalHandlingSkill[P]>
      : GetScalarType<T[P], AggregateAnimalHandlingSkill[P]>
  }




  export type AnimalHandlingSkillGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AnimalHandlingSkillWhereInput
    orderBy?: AnimalHandlingSkillOrderByWithAggregationInput | AnimalHandlingSkillOrderByWithAggregationInput[]
    by: AnimalHandlingSkillScalarFieldEnum[] | AnimalHandlingSkillScalarFieldEnum
    having?: AnimalHandlingSkillScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AnimalHandlingSkillCountAggregateInputType | true
    _avg?: AnimalHandlingSkillAvgAggregateInputType
    _sum?: AnimalHandlingSkillSumAggregateInputType
    _min?: AnimalHandlingSkillMinAggregateInputType
    _max?: AnimalHandlingSkillMaxAggregateInputType
  }

  export type AnimalHandlingSkillGroupByOutputType = {
    id: string
    value: number | null
    mastery: boolean
    name: string
    _count: AnimalHandlingSkillCountAggregateOutputType | null
    _avg: AnimalHandlingSkillAvgAggregateOutputType | null
    _sum: AnimalHandlingSkillSumAggregateOutputType | null
    _min: AnimalHandlingSkillMinAggregateOutputType | null
    _max: AnimalHandlingSkillMaxAggregateOutputType | null
  }

  type GetAnimalHandlingSkillGroupByPayload<T extends AnimalHandlingSkillGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AnimalHandlingSkillGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AnimalHandlingSkillGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AnimalHandlingSkillGroupByOutputType[P]>
            : GetScalarType<T[P], AnimalHandlingSkillGroupByOutputType[P]>
        }
      >
    >


  export type AnimalHandlingSkillSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    value?: boolean
    mastery?: boolean
    name?: boolean
    skill_list?: boolean | WisdomBasedSkillsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["animalHandlingSkill"]>

  export type AnimalHandlingSkillSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    value?: boolean
    mastery?: boolean
    name?: boolean
    skill_list?: boolean | WisdomBasedSkillsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["animalHandlingSkill"]>

  export type AnimalHandlingSkillSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    value?: boolean
    mastery?: boolean
    name?: boolean
    skill_list?: boolean | WisdomBasedSkillsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["animalHandlingSkill"]>

  export type AnimalHandlingSkillSelectScalar = {
    id?: boolean
    value?: boolean
    mastery?: boolean
    name?: boolean
  }

  export type AnimalHandlingSkillOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "value" | "mastery" | "name", ExtArgs["result"]["animalHandlingSkill"]>
  export type AnimalHandlingSkillInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    skill_list?: boolean | WisdomBasedSkillsDefaultArgs<ExtArgs>
  }
  export type AnimalHandlingSkillIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    skill_list?: boolean | WisdomBasedSkillsDefaultArgs<ExtArgs>
  }
  export type AnimalHandlingSkillIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    skill_list?: boolean | WisdomBasedSkillsDefaultArgs<ExtArgs>
  }

  export type $AnimalHandlingSkillPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AnimalHandlingSkill"
    objects: {
      skill_list: Prisma.$WisdomBasedSkillsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      value: number | null
      mastery: boolean
      name: string
    }, ExtArgs["result"]["animalHandlingSkill"]>
    composites: {}
  }

  type AnimalHandlingSkillGetPayload<S extends boolean | null | undefined | AnimalHandlingSkillDefaultArgs> = $Result.GetResult<Prisma.$AnimalHandlingSkillPayload, S>

  type AnimalHandlingSkillCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AnimalHandlingSkillFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AnimalHandlingSkillCountAggregateInputType | true
    }

  export interface AnimalHandlingSkillDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AnimalHandlingSkill'], meta: { name: 'AnimalHandlingSkill' } }
    /**
     * Find zero or one AnimalHandlingSkill that matches the filter.
     * @param {AnimalHandlingSkillFindUniqueArgs} args - Arguments to find a AnimalHandlingSkill
     * @example
     * // Get one AnimalHandlingSkill
     * const animalHandlingSkill = await prisma.animalHandlingSkill.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AnimalHandlingSkillFindUniqueArgs>(args: SelectSubset<T, AnimalHandlingSkillFindUniqueArgs<ExtArgs>>): Prisma__AnimalHandlingSkillClient<$Result.GetResult<Prisma.$AnimalHandlingSkillPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one AnimalHandlingSkill that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AnimalHandlingSkillFindUniqueOrThrowArgs} args - Arguments to find a AnimalHandlingSkill
     * @example
     * // Get one AnimalHandlingSkill
     * const animalHandlingSkill = await prisma.animalHandlingSkill.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AnimalHandlingSkillFindUniqueOrThrowArgs>(args: SelectSubset<T, AnimalHandlingSkillFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AnimalHandlingSkillClient<$Result.GetResult<Prisma.$AnimalHandlingSkillPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first AnimalHandlingSkill that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnimalHandlingSkillFindFirstArgs} args - Arguments to find a AnimalHandlingSkill
     * @example
     * // Get one AnimalHandlingSkill
     * const animalHandlingSkill = await prisma.animalHandlingSkill.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AnimalHandlingSkillFindFirstArgs>(args?: SelectSubset<T, AnimalHandlingSkillFindFirstArgs<ExtArgs>>): Prisma__AnimalHandlingSkillClient<$Result.GetResult<Prisma.$AnimalHandlingSkillPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first AnimalHandlingSkill that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnimalHandlingSkillFindFirstOrThrowArgs} args - Arguments to find a AnimalHandlingSkill
     * @example
     * // Get one AnimalHandlingSkill
     * const animalHandlingSkill = await prisma.animalHandlingSkill.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AnimalHandlingSkillFindFirstOrThrowArgs>(args?: SelectSubset<T, AnimalHandlingSkillFindFirstOrThrowArgs<ExtArgs>>): Prisma__AnimalHandlingSkillClient<$Result.GetResult<Prisma.$AnimalHandlingSkillPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more AnimalHandlingSkills that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnimalHandlingSkillFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AnimalHandlingSkills
     * const animalHandlingSkills = await prisma.animalHandlingSkill.findMany()
     * 
     * // Get first 10 AnimalHandlingSkills
     * const animalHandlingSkills = await prisma.animalHandlingSkill.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const animalHandlingSkillWithIdOnly = await prisma.animalHandlingSkill.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AnimalHandlingSkillFindManyArgs>(args?: SelectSubset<T, AnimalHandlingSkillFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AnimalHandlingSkillPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a AnimalHandlingSkill.
     * @param {AnimalHandlingSkillCreateArgs} args - Arguments to create a AnimalHandlingSkill.
     * @example
     * // Create one AnimalHandlingSkill
     * const AnimalHandlingSkill = await prisma.animalHandlingSkill.create({
     *   data: {
     *     // ... data to create a AnimalHandlingSkill
     *   }
     * })
     * 
     */
    create<T extends AnimalHandlingSkillCreateArgs>(args: SelectSubset<T, AnimalHandlingSkillCreateArgs<ExtArgs>>): Prisma__AnimalHandlingSkillClient<$Result.GetResult<Prisma.$AnimalHandlingSkillPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many AnimalHandlingSkills.
     * @param {AnimalHandlingSkillCreateManyArgs} args - Arguments to create many AnimalHandlingSkills.
     * @example
     * // Create many AnimalHandlingSkills
     * const animalHandlingSkill = await prisma.animalHandlingSkill.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AnimalHandlingSkillCreateManyArgs>(args?: SelectSubset<T, AnimalHandlingSkillCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AnimalHandlingSkills and returns the data saved in the database.
     * @param {AnimalHandlingSkillCreateManyAndReturnArgs} args - Arguments to create many AnimalHandlingSkills.
     * @example
     * // Create many AnimalHandlingSkills
     * const animalHandlingSkill = await prisma.animalHandlingSkill.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AnimalHandlingSkills and only return the `id`
     * const animalHandlingSkillWithIdOnly = await prisma.animalHandlingSkill.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AnimalHandlingSkillCreateManyAndReturnArgs>(args?: SelectSubset<T, AnimalHandlingSkillCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AnimalHandlingSkillPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a AnimalHandlingSkill.
     * @param {AnimalHandlingSkillDeleteArgs} args - Arguments to delete one AnimalHandlingSkill.
     * @example
     * // Delete one AnimalHandlingSkill
     * const AnimalHandlingSkill = await prisma.animalHandlingSkill.delete({
     *   where: {
     *     // ... filter to delete one AnimalHandlingSkill
     *   }
     * })
     * 
     */
    delete<T extends AnimalHandlingSkillDeleteArgs>(args: SelectSubset<T, AnimalHandlingSkillDeleteArgs<ExtArgs>>): Prisma__AnimalHandlingSkillClient<$Result.GetResult<Prisma.$AnimalHandlingSkillPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one AnimalHandlingSkill.
     * @param {AnimalHandlingSkillUpdateArgs} args - Arguments to update one AnimalHandlingSkill.
     * @example
     * // Update one AnimalHandlingSkill
     * const animalHandlingSkill = await prisma.animalHandlingSkill.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AnimalHandlingSkillUpdateArgs>(args: SelectSubset<T, AnimalHandlingSkillUpdateArgs<ExtArgs>>): Prisma__AnimalHandlingSkillClient<$Result.GetResult<Prisma.$AnimalHandlingSkillPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more AnimalHandlingSkills.
     * @param {AnimalHandlingSkillDeleteManyArgs} args - Arguments to filter AnimalHandlingSkills to delete.
     * @example
     * // Delete a few AnimalHandlingSkills
     * const { count } = await prisma.animalHandlingSkill.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AnimalHandlingSkillDeleteManyArgs>(args?: SelectSubset<T, AnimalHandlingSkillDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AnimalHandlingSkills.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnimalHandlingSkillUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AnimalHandlingSkills
     * const animalHandlingSkill = await prisma.animalHandlingSkill.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AnimalHandlingSkillUpdateManyArgs>(args: SelectSubset<T, AnimalHandlingSkillUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AnimalHandlingSkills and returns the data updated in the database.
     * @param {AnimalHandlingSkillUpdateManyAndReturnArgs} args - Arguments to update many AnimalHandlingSkills.
     * @example
     * // Update many AnimalHandlingSkills
     * const animalHandlingSkill = await prisma.animalHandlingSkill.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AnimalHandlingSkills and only return the `id`
     * const animalHandlingSkillWithIdOnly = await prisma.animalHandlingSkill.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AnimalHandlingSkillUpdateManyAndReturnArgs>(args: SelectSubset<T, AnimalHandlingSkillUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AnimalHandlingSkillPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one AnimalHandlingSkill.
     * @param {AnimalHandlingSkillUpsertArgs} args - Arguments to update or create a AnimalHandlingSkill.
     * @example
     * // Update or create a AnimalHandlingSkill
     * const animalHandlingSkill = await prisma.animalHandlingSkill.upsert({
     *   create: {
     *     // ... data to create a AnimalHandlingSkill
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AnimalHandlingSkill we want to update
     *   }
     * })
     */
    upsert<T extends AnimalHandlingSkillUpsertArgs>(args: SelectSubset<T, AnimalHandlingSkillUpsertArgs<ExtArgs>>): Prisma__AnimalHandlingSkillClient<$Result.GetResult<Prisma.$AnimalHandlingSkillPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of AnimalHandlingSkills.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnimalHandlingSkillCountArgs} args - Arguments to filter AnimalHandlingSkills to count.
     * @example
     * // Count the number of AnimalHandlingSkills
     * const count = await prisma.animalHandlingSkill.count({
     *   where: {
     *     // ... the filter for the AnimalHandlingSkills we want to count
     *   }
     * })
    **/
    count<T extends AnimalHandlingSkillCountArgs>(
      args?: Subset<T, AnimalHandlingSkillCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AnimalHandlingSkillCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AnimalHandlingSkill.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnimalHandlingSkillAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AnimalHandlingSkillAggregateArgs>(args: Subset<T, AnimalHandlingSkillAggregateArgs>): Prisma.PrismaPromise<GetAnimalHandlingSkillAggregateType<T>>

    /**
     * Group by AnimalHandlingSkill.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnimalHandlingSkillGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AnimalHandlingSkillGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AnimalHandlingSkillGroupByArgs['orderBy'] }
        : { orderBy?: AnimalHandlingSkillGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AnimalHandlingSkillGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAnimalHandlingSkillGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AnimalHandlingSkill model
   */
  readonly fields: AnimalHandlingSkillFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AnimalHandlingSkill.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AnimalHandlingSkillClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    skill_list<T extends WisdomBasedSkillsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WisdomBasedSkillsDefaultArgs<ExtArgs>>): Prisma__WisdomBasedSkillsClient<$Result.GetResult<Prisma.$WisdomBasedSkillsPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AnimalHandlingSkill model
   */ 
  interface AnimalHandlingSkillFieldRefs {
    readonly id: FieldRef<"AnimalHandlingSkill", 'String'>
    readonly value: FieldRef<"AnimalHandlingSkill", 'Int'>
    readonly mastery: FieldRef<"AnimalHandlingSkill", 'Boolean'>
    readonly name: FieldRef<"AnimalHandlingSkill", 'String'>
  }
    

  // Custom InputTypes
  /**
   * AnimalHandlingSkill findUnique
   */
  export type AnimalHandlingSkillFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnimalHandlingSkill
     */
    select?: AnimalHandlingSkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnimalHandlingSkill
     */
    omit?: AnimalHandlingSkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnimalHandlingSkillInclude<ExtArgs> | null
    /**
     * Filter, which AnimalHandlingSkill to fetch.
     */
    where: AnimalHandlingSkillWhereUniqueInput
  }

  /**
   * AnimalHandlingSkill findUniqueOrThrow
   */
  export type AnimalHandlingSkillFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnimalHandlingSkill
     */
    select?: AnimalHandlingSkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnimalHandlingSkill
     */
    omit?: AnimalHandlingSkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnimalHandlingSkillInclude<ExtArgs> | null
    /**
     * Filter, which AnimalHandlingSkill to fetch.
     */
    where: AnimalHandlingSkillWhereUniqueInput
  }

  /**
   * AnimalHandlingSkill findFirst
   */
  export type AnimalHandlingSkillFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnimalHandlingSkill
     */
    select?: AnimalHandlingSkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnimalHandlingSkill
     */
    omit?: AnimalHandlingSkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnimalHandlingSkillInclude<ExtArgs> | null
    /**
     * Filter, which AnimalHandlingSkill to fetch.
     */
    where?: AnimalHandlingSkillWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AnimalHandlingSkills to fetch.
     */
    orderBy?: AnimalHandlingSkillOrderByWithRelationInput | AnimalHandlingSkillOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AnimalHandlingSkills.
     */
    cursor?: AnimalHandlingSkillWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AnimalHandlingSkills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AnimalHandlingSkills.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AnimalHandlingSkills.
     */
    distinct?: AnimalHandlingSkillScalarFieldEnum | AnimalHandlingSkillScalarFieldEnum[]
  }

  /**
   * AnimalHandlingSkill findFirstOrThrow
   */
  export type AnimalHandlingSkillFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnimalHandlingSkill
     */
    select?: AnimalHandlingSkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnimalHandlingSkill
     */
    omit?: AnimalHandlingSkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnimalHandlingSkillInclude<ExtArgs> | null
    /**
     * Filter, which AnimalHandlingSkill to fetch.
     */
    where?: AnimalHandlingSkillWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AnimalHandlingSkills to fetch.
     */
    orderBy?: AnimalHandlingSkillOrderByWithRelationInput | AnimalHandlingSkillOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AnimalHandlingSkills.
     */
    cursor?: AnimalHandlingSkillWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AnimalHandlingSkills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AnimalHandlingSkills.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AnimalHandlingSkills.
     */
    distinct?: AnimalHandlingSkillScalarFieldEnum | AnimalHandlingSkillScalarFieldEnum[]
  }

  /**
   * AnimalHandlingSkill findMany
   */
  export type AnimalHandlingSkillFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnimalHandlingSkill
     */
    select?: AnimalHandlingSkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnimalHandlingSkill
     */
    omit?: AnimalHandlingSkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnimalHandlingSkillInclude<ExtArgs> | null
    /**
     * Filter, which AnimalHandlingSkills to fetch.
     */
    where?: AnimalHandlingSkillWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AnimalHandlingSkills to fetch.
     */
    orderBy?: AnimalHandlingSkillOrderByWithRelationInput | AnimalHandlingSkillOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AnimalHandlingSkills.
     */
    cursor?: AnimalHandlingSkillWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AnimalHandlingSkills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AnimalHandlingSkills.
     */
    skip?: number
    distinct?: AnimalHandlingSkillScalarFieldEnum | AnimalHandlingSkillScalarFieldEnum[]
  }

  /**
   * AnimalHandlingSkill create
   */
  export type AnimalHandlingSkillCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnimalHandlingSkill
     */
    select?: AnimalHandlingSkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnimalHandlingSkill
     */
    omit?: AnimalHandlingSkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnimalHandlingSkillInclude<ExtArgs> | null
    /**
     * The data needed to create a AnimalHandlingSkill.
     */
    data: XOR<AnimalHandlingSkillCreateInput, AnimalHandlingSkillUncheckedCreateInput>
  }

  /**
   * AnimalHandlingSkill createMany
   */
  export type AnimalHandlingSkillCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AnimalHandlingSkills.
     */
    data: AnimalHandlingSkillCreateManyInput | AnimalHandlingSkillCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AnimalHandlingSkill createManyAndReturn
   */
  export type AnimalHandlingSkillCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnimalHandlingSkill
     */
    select?: AnimalHandlingSkillSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AnimalHandlingSkill
     */
    omit?: AnimalHandlingSkillOmit<ExtArgs> | null
    /**
     * The data used to create many AnimalHandlingSkills.
     */
    data: AnimalHandlingSkillCreateManyInput | AnimalHandlingSkillCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnimalHandlingSkillIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AnimalHandlingSkill update
   */
  export type AnimalHandlingSkillUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnimalHandlingSkill
     */
    select?: AnimalHandlingSkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnimalHandlingSkill
     */
    omit?: AnimalHandlingSkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnimalHandlingSkillInclude<ExtArgs> | null
    /**
     * The data needed to update a AnimalHandlingSkill.
     */
    data: XOR<AnimalHandlingSkillUpdateInput, AnimalHandlingSkillUncheckedUpdateInput>
    /**
     * Choose, which AnimalHandlingSkill to update.
     */
    where: AnimalHandlingSkillWhereUniqueInput
  }

  /**
   * AnimalHandlingSkill updateMany
   */
  export type AnimalHandlingSkillUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AnimalHandlingSkills.
     */
    data: XOR<AnimalHandlingSkillUpdateManyMutationInput, AnimalHandlingSkillUncheckedUpdateManyInput>
    /**
     * Filter which AnimalHandlingSkills to update
     */
    where?: AnimalHandlingSkillWhereInput
    /**
     * Limit how many AnimalHandlingSkills to update.
     */
    limit?: number
  }

  /**
   * AnimalHandlingSkill updateManyAndReturn
   */
  export type AnimalHandlingSkillUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnimalHandlingSkill
     */
    select?: AnimalHandlingSkillSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AnimalHandlingSkill
     */
    omit?: AnimalHandlingSkillOmit<ExtArgs> | null
    /**
     * The data used to update AnimalHandlingSkills.
     */
    data: XOR<AnimalHandlingSkillUpdateManyMutationInput, AnimalHandlingSkillUncheckedUpdateManyInput>
    /**
     * Filter which AnimalHandlingSkills to update
     */
    where?: AnimalHandlingSkillWhereInput
    /**
     * Limit how many AnimalHandlingSkills to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnimalHandlingSkillIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AnimalHandlingSkill upsert
   */
  export type AnimalHandlingSkillUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnimalHandlingSkill
     */
    select?: AnimalHandlingSkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnimalHandlingSkill
     */
    omit?: AnimalHandlingSkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnimalHandlingSkillInclude<ExtArgs> | null
    /**
     * The filter to search for the AnimalHandlingSkill to update in case it exists.
     */
    where: AnimalHandlingSkillWhereUniqueInput
    /**
     * In case the AnimalHandlingSkill found by the `where` argument doesn't exist, create a new AnimalHandlingSkill with this data.
     */
    create: XOR<AnimalHandlingSkillCreateInput, AnimalHandlingSkillUncheckedCreateInput>
    /**
     * In case the AnimalHandlingSkill was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AnimalHandlingSkillUpdateInput, AnimalHandlingSkillUncheckedUpdateInput>
  }

  /**
   * AnimalHandlingSkill delete
   */
  export type AnimalHandlingSkillDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnimalHandlingSkill
     */
    select?: AnimalHandlingSkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnimalHandlingSkill
     */
    omit?: AnimalHandlingSkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnimalHandlingSkillInclude<ExtArgs> | null
    /**
     * Filter which AnimalHandlingSkill to delete.
     */
    where: AnimalHandlingSkillWhereUniqueInput
  }

  /**
   * AnimalHandlingSkill deleteMany
   */
  export type AnimalHandlingSkillDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AnimalHandlingSkills to delete
     */
    where?: AnimalHandlingSkillWhereInput
    /**
     * Limit how many AnimalHandlingSkills to delete.
     */
    limit?: number
  }

  /**
   * AnimalHandlingSkill without action
   */
  export type AnimalHandlingSkillDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnimalHandlingSkill
     */
    select?: AnimalHandlingSkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnimalHandlingSkill
     */
    omit?: AnimalHandlingSkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnimalHandlingSkillInclude<ExtArgs> | null
  }


  /**
   * Model InsightSkill
   */

  export type AggregateInsightSkill = {
    _count: InsightSkillCountAggregateOutputType | null
    _avg: InsightSkillAvgAggregateOutputType | null
    _sum: InsightSkillSumAggregateOutputType | null
    _min: InsightSkillMinAggregateOutputType | null
    _max: InsightSkillMaxAggregateOutputType | null
  }

  export type InsightSkillAvgAggregateOutputType = {
    value: number | null
  }

  export type InsightSkillSumAggregateOutputType = {
    value: number | null
  }

  export type InsightSkillMinAggregateOutputType = {
    id: string | null
    value: number | null
    mastery: boolean | null
    name: string | null
  }

  export type InsightSkillMaxAggregateOutputType = {
    id: string | null
    value: number | null
    mastery: boolean | null
    name: string | null
  }

  export type InsightSkillCountAggregateOutputType = {
    id: number
    value: number
    mastery: number
    name: number
    _all: number
  }


  export type InsightSkillAvgAggregateInputType = {
    value?: true
  }

  export type InsightSkillSumAggregateInputType = {
    value?: true
  }

  export type InsightSkillMinAggregateInputType = {
    id?: true
    value?: true
    mastery?: true
    name?: true
  }

  export type InsightSkillMaxAggregateInputType = {
    id?: true
    value?: true
    mastery?: true
    name?: true
  }

  export type InsightSkillCountAggregateInputType = {
    id?: true
    value?: true
    mastery?: true
    name?: true
    _all?: true
  }

  export type InsightSkillAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InsightSkill to aggregate.
     */
    where?: InsightSkillWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InsightSkills to fetch.
     */
    orderBy?: InsightSkillOrderByWithRelationInput | InsightSkillOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InsightSkillWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InsightSkills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InsightSkills.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned InsightSkills
    **/
    _count?: true | InsightSkillCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InsightSkillAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InsightSkillSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InsightSkillMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InsightSkillMaxAggregateInputType
  }

  export type GetInsightSkillAggregateType<T extends InsightSkillAggregateArgs> = {
        [P in keyof T & keyof AggregateInsightSkill]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInsightSkill[P]>
      : GetScalarType<T[P], AggregateInsightSkill[P]>
  }




  export type InsightSkillGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InsightSkillWhereInput
    orderBy?: InsightSkillOrderByWithAggregationInput | InsightSkillOrderByWithAggregationInput[]
    by: InsightSkillScalarFieldEnum[] | InsightSkillScalarFieldEnum
    having?: InsightSkillScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InsightSkillCountAggregateInputType | true
    _avg?: InsightSkillAvgAggregateInputType
    _sum?: InsightSkillSumAggregateInputType
    _min?: InsightSkillMinAggregateInputType
    _max?: InsightSkillMaxAggregateInputType
  }

  export type InsightSkillGroupByOutputType = {
    id: string
    value: number | null
    mastery: boolean
    name: string
    _count: InsightSkillCountAggregateOutputType | null
    _avg: InsightSkillAvgAggregateOutputType | null
    _sum: InsightSkillSumAggregateOutputType | null
    _min: InsightSkillMinAggregateOutputType | null
    _max: InsightSkillMaxAggregateOutputType | null
  }

  type GetInsightSkillGroupByPayload<T extends InsightSkillGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InsightSkillGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InsightSkillGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InsightSkillGroupByOutputType[P]>
            : GetScalarType<T[P], InsightSkillGroupByOutputType[P]>
        }
      >
    >


  export type InsightSkillSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    value?: boolean
    mastery?: boolean
    name?: boolean
    skill_list?: boolean | WisdomBasedSkillsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["insightSkill"]>

  export type InsightSkillSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    value?: boolean
    mastery?: boolean
    name?: boolean
    skill_list?: boolean | WisdomBasedSkillsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["insightSkill"]>

  export type InsightSkillSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    value?: boolean
    mastery?: boolean
    name?: boolean
    skill_list?: boolean | WisdomBasedSkillsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["insightSkill"]>

  export type InsightSkillSelectScalar = {
    id?: boolean
    value?: boolean
    mastery?: boolean
    name?: boolean
  }

  export type InsightSkillOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "value" | "mastery" | "name", ExtArgs["result"]["insightSkill"]>
  export type InsightSkillInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    skill_list?: boolean | WisdomBasedSkillsDefaultArgs<ExtArgs>
  }
  export type InsightSkillIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    skill_list?: boolean | WisdomBasedSkillsDefaultArgs<ExtArgs>
  }
  export type InsightSkillIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    skill_list?: boolean | WisdomBasedSkillsDefaultArgs<ExtArgs>
  }

  export type $InsightSkillPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "InsightSkill"
    objects: {
      skill_list: Prisma.$WisdomBasedSkillsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      value: number | null
      mastery: boolean
      name: string
    }, ExtArgs["result"]["insightSkill"]>
    composites: {}
  }

  type InsightSkillGetPayload<S extends boolean | null | undefined | InsightSkillDefaultArgs> = $Result.GetResult<Prisma.$InsightSkillPayload, S>

  type InsightSkillCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<InsightSkillFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: InsightSkillCountAggregateInputType | true
    }

  export interface InsightSkillDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['InsightSkill'], meta: { name: 'InsightSkill' } }
    /**
     * Find zero or one InsightSkill that matches the filter.
     * @param {InsightSkillFindUniqueArgs} args - Arguments to find a InsightSkill
     * @example
     * // Get one InsightSkill
     * const insightSkill = await prisma.insightSkill.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InsightSkillFindUniqueArgs>(args: SelectSubset<T, InsightSkillFindUniqueArgs<ExtArgs>>): Prisma__InsightSkillClient<$Result.GetResult<Prisma.$InsightSkillPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one InsightSkill that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {InsightSkillFindUniqueOrThrowArgs} args - Arguments to find a InsightSkill
     * @example
     * // Get one InsightSkill
     * const insightSkill = await prisma.insightSkill.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InsightSkillFindUniqueOrThrowArgs>(args: SelectSubset<T, InsightSkillFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InsightSkillClient<$Result.GetResult<Prisma.$InsightSkillPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first InsightSkill that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InsightSkillFindFirstArgs} args - Arguments to find a InsightSkill
     * @example
     * // Get one InsightSkill
     * const insightSkill = await prisma.insightSkill.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InsightSkillFindFirstArgs>(args?: SelectSubset<T, InsightSkillFindFirstArgs<ExtArgs>>): Prisma__InsightSkillClient<$Result.GetResult<Prisma.$InsightSkillPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first InsightSkill that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InsightSkillFindFirstOrThrowArgs} args - Arguments to find a InsightSkill
     * @example
     * // Get one InsightSkill
     * const insightSkill = await prisma.insightSkill.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InsightSkillFindFirstOrThrowArgs>(args?: SelectSubset<T, InsightSkillFindFirstOrThrowArgs<ExtArgs>>): Prisma__InsightSkillClient<$Result.GetResult<Prisma.$InsightSkillPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more InsightSkills that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InsightSkillFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all InsightSkills
     * const insightSkills = await prisma.insightSkill.findMany()
     * 
     * // Get first 10 InsightSkills
     * const insightSkills = await prisma.insightSkill.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const insightSkillWithIdOnly = await prisma.insightSkill.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends InsightSkillFindManyArgs>(args?: SelectSubset<T, InsightSkillFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InsightSkillPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a InsightSkill.
     * @param {InsightSkillCreateArgs} args - Arguments to create a InsightSkill.
     * @example
     * // Create one InsightSkill
     * const InsightSkill = await prisma.insightSkill.create({
     *   data: {
     *     // ... data to create a InsightSkill
     *   }
     * })
     * 
     */
    create<T extends InsightSkillCreateArgs>(args: SelectSubset<T, InsightSkillCreateArgs<ExtArgs>>): Prisma__InsightSkillClient<$Result.GetResult<Prisma.$InsightSkillPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many InsightSkills.
     * @param {InsightSkillCreateManyArgs} args - Arguments to create many InsightSkills.
     * @example
     * // Create many InsightSkills
     * const insightSkill = await prisma.insightSkill.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InsightSkillCreateManyArgs>(args?: SelectSubset<T, InsightSkillCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many InsightSkills and returns the data saved in the database.
     * @param {InsightSkillCreateManyAndReturnArgs} args - Arguments to create many InsightSkills.
     * @example
     * // Create many InsightSkills
     * const insightSkill = await prisma.insightSkill.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many InsightSkills and only return the `id`
     * const insightSkillWithIdOnly = await prisma.insightSkill.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends InsightSkillCreateManyAndReturnArgs>(args?: SelectSubset<T, InsightSkillCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InsightSkillPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a InsightSkill.
     * @param {InsightSkillDeleteArgs} args - Arguments to delete one InsightSkill.
     * @example
     * // Delete one InsightSkill
     * const InsightSkill = await prisma.insightSkill.delete({
     *   where: {
     *     // ... filter to delete one InsightSkill
     *   }
     * })
     * 
     */
    delete<T extends InsightSkillDeleteArgs>(args: SelectSubset<T, InsightSkillDeleteArgs<ExtArgs>>): Prisma__InsightSkillClient<$Result.GetResult<Prisma.$InsightSkillPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one InsightSkill.
     * @param {InsightSkillUpdateArgs} args - Arguments to update one InsightSkill.
     * @example
     * // Update one InsightSkill
     * const insightSkill = await prisma.insightSkill.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InsightSkillUpdateArgs>(args: SelectSubset<T, InsightSkillUpdateArgs<ExtArgs>>): Prisma__InsightSkillClient<$Result.GetResult<Prisma.$InsightSkillPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more InsightSkills.
     * @param {InsightSkillDeleteManyArgs} args - Arguments to filter InsightSkills to delete.
     * @example
     * // Delete a few InsightSkills
     * const { count } = await prisma.insightSkill.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InsightSkillDeleteManyArgs>(args?: SelectSubset<T, InsightSkillDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more InsightSkills.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InsightSkillUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many InsightSkills
     * const insightSkill = await prisma.insightSkill.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InsightSkillUpdateManyArgs>(args: SelectSubset<T, InsightSkillUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more InsightSkills and returns the data updated in the database.
     * @param {InsightSkillUpdateManyAndReturnArgs} args - Arguments to update many InsightSkills.
     * @example
     * // Update many InsightSkills
     * const insightSkill = await prisma.insightSkill.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more InsightSkills and only return the `id`
     * const insightSkillWithIdOnly = await prisma.insightSkill.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends InsightSkillUpdateManyAndReturnArgs>(args: SelectSubset<T, InsightSkillUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InsightSkillPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one InsightSkill.
     * @param {InsightSkillUpsertArgs} args - Arguments to update or create a InsightSkill.
     * @example
     * // Update or create a InsightSkill
     * const insightSkill = await prisma.insightSkill.upsert({
     *   create: {
     *     // ... data to create a InsightSkill
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the InsightSkill we want to update
     *   }
     * })
     */
    upsert<T extends InsightSkillUpsertArgs>(args: SelectSubset<T, InsightSkillUpsertArgs<ExtArgs>>): Prisma__InsightSkillClient<$Result.GetResult<Prisma.$InsightSkillPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of InsightSkills.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InsightSkillCountArgs} args - Arguments to filter InsightSkills to count.
     * @example
     * // Count the number of InsightSkills
     * const count = await prisma.insightSkill.count({
     *   where: {
     *     // ... the filter for the InsightSkills we want to count
     *   }
     * })
    **/
    count<T extends InsightSkillCountArgs>(
      args?: Subset<T, InsightSkillCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InsightSkillCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a InsightSkill.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InsightSkillAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InsightSkillAggregateArgs>(args: Subset<T, InsightSkillAggregateArgs>): Prisma.PrismaPromise<GetInsightSkillAggregateType<T>>

    /**
     * Group by InsightSkill.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InsightSkillGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InsightSkillGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InsightSkillGroupByArgs['orderBy'] }
        : { orderBy?: InsightSkillGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InsightSkillGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInsightSkillGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the InsightSkill model
   */
  readonly fields: InsightSkillFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for InsightSkill.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InsightSkillClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    skill_list<T extends WisdomBasedSkillsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WisdomBasedSkillsDefaultArgs<ExtArgs>>): Prisma__WisdomBasedSkillsClient<$Result.GetResult<Prisma.$WisdomBasedSkillsPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the InsightSkill model
   */ 
  interface InsightSkillFieldRefs {
    readonly id: FieldRef<"InsightSkill", 'String'>
    readonly value: FieldRef<"InsightSkill", 'Int'>
    readonly mastery: FieldRef<"InsightSkill", 'Boolean'>
    readonly name: FieldRef<"InsightSkill", 'String'>
  }
    

  // Custom InputTypes
  /**
   * InsightSkill findUnique
   */
  export type InsightSkillFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InsightSkill
     */
    select?: InsightSkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InsightSkill
     */
    omit?: InsightSkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InsightSkillInclude<ExtArgs> | null
    /**
     * Filter, which InsightSkill to fetch.
     */
    where: InsightSkillWhereUniqueInput
  }

  /**
   * InsightSkill findUniqueOrThrow
   */
  export type InsightSkillFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InsightSkill
     */
    select?: InsightSkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InsightSkill
     */
    omit?: InsightSkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InsightSkillInclude<ExtArgs> | null
    /**
     * Filter, which InsightSkill to fetch.
     */
    where: InsightSkillWhereUniqueInput
  }

  /**
   * InsightSkill findFirst
   */
  export type InsightSkillFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InsightSkill
     */
    select?: InsightSkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InsightSkill
     */
    omit?: InsightSkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InsightSkillInclude<ExtArgs> | null
    /**
     * Filter, which InsightSkill to fetch.
     */
    where?: InsightSkillWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InsightSkills to fetch.
     */
    orderBy?: InsightSkillOrderByWithRelationInput | InsightSkillOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InsightSkills.
     */
    cursor?: InsightSkillWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InsightSkills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InsightSkills.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InsightSkills.
     */
    distinct?: InsightSkillScalarFieldEnum | InsightSkillScalarFieldEnum[]
  }

  /**
   * InsightSkill findFirstOrThrow
   */
  export type InsightSkillFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InsightSkill
     */
    select?: InsightSkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InsightSkill
     */
    omit?: InsightSkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InsightSkillInclude<ExtArgs> | null
    /**
     * Filter, which InsightSkill to fetch.
     */
    where?: InsightSkillWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InsightSkills to fetch.
     */
    orderBy?: InsightSkillOrderByWithRelationInput | InsightSkillOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InsightSkills.
     */
    cursor?: InsightSkillWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InsightSkills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InsightSkills.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InsightSkills.
     */
    distinct?: InsightSkillScalarFieldEnum | InsightSkillScalarFieldEnum[]
  }

  /**
   * InsightSkill findMany
   */
  export type InsightSkillFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InsightSkill
     */
    select?: InsightSkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InsightSkill
     */
    omit?: InsightSkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InsightSkillInclude<ExtArgs> | null
    /**
     * Filter, which InsightSkills to fetch.
     */
    where?: InsightSkillWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InsightSkills to fetch.
     */
    orderBy?: InsightSkillOrderByWithRelationInput | InsightSkillOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing InsightSkills.
     */
    cursor?: InsightSkillWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InsightSkills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InsightSkills.
     */
    skip?: number
    distinct?: InsightSkillScalarFieldEnum | InsightSkillScalarFieldEnum[]
  }

  /**
   * InsightSkill create
   */
  export type InsightSkillCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InsightSkill
     */
    select?: InsightSkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InsightSkill
     */
    omit?: InsightSkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InsightSkillInclude<ExtArgs> | null
    /**
     * The data needed to create a InsightSkill.
     */
    data: XOR<InsightSkillCreateInput, InsightSkillUncheckedCreateInput>
  }

  /**
   * InsightSkill createMany
   */
  export type InsightSkillCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many InsightSkills.
     */
    data: InsightSkillCreateManyInput | InsightSkillCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * InsightSkill createManyAndReturn
   */
  export type InsightSkillCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InsightSkill
     */
    select?: InsightSkillSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the InsightSkill
     */
    omit?: InsightSkillOmit<ExtArgs> | null
    /**
     * The data used to create many InsightSkills.
     */
    data: InsightSkillCreateManyInput | InsightSkillCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InsightSkillIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * InsightSkill update
   */
  export type InsightSkillUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InsightSkill
     */
    select?: InsightSkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InsightSkill
     */
    omit?: InsightSkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InsightSkillInclude<ExtArgs> | null
    /**
     * The data needed to update a InsightSkill.
     */
    data: XOR<InsightSkillUpdateInput, InsightSkillUncheckedUpdateInput>
    /**
     * Choose, which InsightSkill to update.
     */
    where: InsightSkillWhereUniqueInput
  }

  /**
   * InsightSkill updateMany
   */
  export type InsightSkillUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update InsightSkills.
     */
    data: XOR<InsightSkillUpdateManyMutationInput, InsightSkillUncheckedUpdateManyInput>
    /**
     * Filter which InsightSkills to update
     */
    where?: InsightSkillWhereInput
    /**
     * Limit how many InsightSkills to update.
     */
    limit?: number
  }

  /**
   * InsightSkill updateManyAndReturn
   */
  export type InsightSkillUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InsightSkill
     */
    select?: InsightSkillSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the InsightSkill
     */
    omit?: InsightSkillOmit<ExtArgs> | null
    /**
     * The data used to update InsightSkills.
     */
    data: XOR<InsightSkillUpdateManyMutationInput, InsightSkillUncheckedUpdateManyInput>
    /**
     * Filter which InsightSkills to update
     */
    where?: InsightSkillWhereInput
    /**
     * Limit how many InsightSkills to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InsightSkillIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * InsightSkill upsert
   */
  export type InsightSkillUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InsightSkill
     */
    select?: InsightSkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InsightSkill
     */
    omit?: InsightSkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InsightSkillInclude<ExtArgs> | null
    /**
     * The filter to search for the InsightSkill to update in case it exists.
     */
    where: InsightSkillWhereUniqueInput
    /**
     * In case the InsightSkill found by the `where` argument doesn't exist, create a new InsightSkill with this data.
     */
    create: XOR<InsightSkillCreateInput, InsightSkillUncheckedCreateInput>
    /**
     * In case the InsightSkill was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InsightSkillUpdateInput, InsightSkillUncheckedUpdateInput>
  }

  /**
   * InsightSkill delete
   */
  export type InsightSkillDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InsightSkill
     */
    select?: InsightSkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InsightSkill
     */
    omit?: InsightSkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InsightSkillInclude<ExtArgs> | null
    /**
     * Filter which InsightSkill to delete.
     */
    where: InsightSkillWhereUniqueInput
  }

  /**
   * InsightSkill deleteMany
   */
  export type InsightSkillDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InsightSkills to delete
     */
    where?: InsightSkillWhereInput
    /**
     * Limit how many InsightSkills to delete.
     */
    limit?: number
  }

  /**
   * InsightSkill without action
   */
  export type InsightSkillDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InsightSkill
     */
    select?: InsightSkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InsightSkill
     */
    omit?: InsightSkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InsightSkillInclude<ExtArgs> | null
  }


  /**
   * Model MedicineSkill
   */

  export type AggregateMedicineSkill = {
    _count: MedicineSkillCountAggregateOutputType | null
    _avg: MedicineSkillAvgAggregateOutputType | null
    _sum: MedicineSkillSumAggregateOutputType | null
    _min: MedicineSkillMinAggregateOutputType | null
    _max: MedicineSkillMaxAggregateOutputType | null
  }

  export type MedicineSkillAvgAggregateOutputType = {
    value: number | null
  }

  export type MedicineSkillSumAggregateOutputType = {
    value: number | null
  }

  export type MedicineSkillMinAggregateOutputType = {
    id: string | null
    value: number | null
    mastery: boolean | null
    name: string | null
  }

  export type MedicineSkillMaxAggregateOutputType = {
    id: string | null
    value: number | null
    mastery: boolean | null
    name: string | null
  }

  export type MedicineSkillCountAggregateOutputType = {
    id: number
    value: number
    mastery: number
    name: number
    _all: number
  }


  export type MedicineSkillAvgAggregateInputType = {
    value?: true
  }

  export type MedicineSkillSumAggregateInputType = {
    value?: true
  }

  export type MedicineSkillMinAggregateInputType = {
    id?: true
    value?: true
    mastery?: true
    name?: true
  }

  export type MedicineSkillMaxAggregateInputType = {
    id?: true
    value?: true
    mastery?: true
    name?: true
  }

  export type MedicineSkillCountAggregateInputType = {
    id?: true
    value?: true
    mastery?: true
    name?: true
    _all?: true
  }

  export type MedicineSkillAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MedicineSkill to aggregate.
     */
    where?: MedicineSkillWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MedicineSkills to fetch.
     */
    orderBy?: MedicineSkillOrderByWithRelationInput | MedicineSkillOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MedicineSkillWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MedicineSkills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MedicineSkills.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MedicineSkills
    **/
    _count?: true | MedicineSkillCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MedicineSkillAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MedicineSkillSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MedicineSkillMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MedicineSkillMaxAggregateInputType
  }

  export type GetMedicineSkillAggregateType<T extends MedicineSkillAggregateArgs> = {
        [P in keyof T & keyof AggregateMedicineSkill]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMedicineSkill[P]>
      : GetScalarType<T[P], AggregateMedicineSkill[P]>
  }




  export type MedicineSkillGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MedicineSkillWhereInput
    orderBy?: MedicineSkillOrderByWithAggregationInput | MedicineSkillOrderByWithAggregationInput[]
    by: MedicineSkillScalarFieldEnum[] | MedicineSkillScalarFieldEnum
    having?: MedicineSkillScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MedicineSkillCountAggregateInputType | true
    _avg?: MedicineSkillAvgAggregateInputType
    _sum?: MedicineSkillSumAggregateInputType
    _min?: MedicineSkillMinAggregateInputType
    _max?: MedicineSkillMaxAggregateInputType
  }

  export type MedicineSkillGroupByOutputType = {
    id: string
    value: number | null
    mastery: boolean
    name: string
    _count: MedicineSkillCountAggregateOutputType | null
    _avg: MedicineSkillAvgAggregateOutputType | null
    _sum: MedicineSkillSumAggregateOutputType | null
    _min: MedicineSkillMinAggregateOutputType | null
    _max: MedicineSkillMaxAggregateOutputType | null
  }

  type GetMedicineSkillGroupByPayload<T extends MedicineSkillGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MedicineSkillGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MedicineSkillGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MedicineSkillGroupByOutputType[P]>
            : GetScalarType<T[P], MedicineSkillGroupByOutputType[P]>
        }
      >
    >


  export type MedicineSkillSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    value?: boolean
    mastery?: boolean
    name?: boolean
    skill_list?: boolean | WisdomBasedSkillsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["medicineSkill"]>

  export type MedicineSkillSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    value?: boolean
    mastery?: boolean
    name?: boolean
    skill_list?: boolean | WisdomBasedSkillsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["medicineSkill"]>

  export type MedicineSkillSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    value?: boolean
    mastery?: boolean
    name?: boolean
    skill_list?: boolean | WisdomBasedSkillsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["medicineSkill"]>

  export type MedicineSkillSelectScalar = {
    id?: boolean
    value?: boolean
    mastery?: boolean
    name?: boolean
  }

  export type MedicineSkillOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "value" | "mastery" | "name", ExtArgs["result"]["medicineSkill"]>
  export type MedicineSkillInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    skill_list?: boolean | WisdomBasedSkillsDefaultArgs<ExtArgs>
  }
  export type MedicineSkillIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    skill_list?: boolean | WisdomBasedSkillsDefaultArgs<ExtArgs>
  }
  export type MedicineSkillIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    skill_list?: boolean | WisdomBasedSkillsDefaultArgs<ExtArgs>
  }

  export type $MedicineSkillPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MedicineSkill"
    objects: {
      skill_list: Prisma.$WisdomBasedSkillsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      value: number | null
      mastery: boolean
      name: string
    }, ExtArgs["result"]["medicineSkill"]>
    composites: {}
  }

  type MedicineSkillGetPayload<S extends boolean | null | undefined | MedicineSkillDefaultArgs> = $Result.GetResult<Prisma.$MedicineSkillPayload, S>

  type MedicineSkillCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MedicineSkillFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MedicineSkillCountAggregateInputType | true
    }

  export interface MedicineSkillDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MedicineSkill'], meta: { name: 'MedicineSkill' } }
    /**
     * Find zero or one MedicineSkill that matches the filter.
     * @param {MedicineSkillFindUniqueArgs} args - Arguments to find a MedicineSkill
     * @example
     * // Get one MedicineSkill
     * const medicineSkill = await prisma.medicineSkill.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MedicineSkillFindUniqueArgs>(args: SelectSubset<T, MedicineSkillFindUniqueArgs<ExtArgs>>): Prisma__MedicineSkillClient<$Result.GetResult<Prisma.$MedicineSkillPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one MedicineSkill that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MedicineSkillFindUniqueOrThrowArgs} args - Arguments to find a MedicineSkill
     * @example
     * // Get one MedicineSkill
     * const medicineSkill = await prisma.medicineSkill.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MedicineSkillFindUniqueOrThrowArgs>(args: SelectSubset<T, MedicineSkillFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MedicineSkillClient<$Result.GetResult<Prisma.$MedicineSkillPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first MedicineSkill that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicineSkillFindFirstArgs} args - Arguments to find a MedicineSkill
     * @example
     * // Get one MedicineSkill
     * const medicineSkill = await prisma.medicineSkill.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MedicineSkillFindFirstArgs>(args?: SelectSubset<T, MedicineSkillFindFirstArgs<ExtArgs>>): Prisma__MedicineSkillClient<$Result.GetResult<Prisma.$MedicineSkillPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first MedicineSkill that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicineSkillFindFirstOrThrowArgs} args - Arguments to find a MedicineSkill
     * @example
     * // Get one MedicineSkill
     * const medicineSkill = await prisma.medicineSkill.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MedicineSkillFindFirstOrThrowArgs>(args?: SelectSubset<T, MedicineSkillFindFirstOrThrowArgs<ExtArgs>>): Prisma__MedicineSkillClient<$Result.GetResult<Prisma.$MedicineSkillPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more MedicineSkills that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicineSkillFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MedicineSkills
     * const medicineSkills = await prisma.medicineSkill.findMany()
     * 
     * // Get first 10 MedicineSkills
     * const medicineSkills = await prisma.medicineSkill.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const medicineSkillWithIdOnly = await prisma.medicineSkill.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MedicineSkillFindManyArgs>(args?: SelectSubset<T, MedicineSkillFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MedicineSkillPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a MedicineSkill.
     * @param {MedicineSkillCreateArgs} args - Arguments to create a MedicineSkill.
     * @example
     * // Create one MedicineSkill
     * const MedicineSkill = await prisma.medicineSkill.create({
     *   data: {
     *     // ... data to create a MedicineSkill
     *   }
     * })
     * 
     */
    create<T extends MedicineSkillCreateArgs>(args: SelectSubset<T, MedicineSkillCreateArgs<ExtArgs>>): Prisma__MedicineSkillClient<$Result.GetResult<Prisma.$MedicineSkillPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many MedicineSkills.
     * @param {MedicineSkillCreateManyArgs} args - Arguments to create many MedicineSkills.
     * @example
     * // Create many MedicineSkills
     * const medicineSkill = await prisma.medicineSkill.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MedicineSkillCreateManyArgs>(args?: SelectSubset<T, MedicineSkillCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MedicineSkills and returns the data saved in the database.
     * @param {MedicineSkillCreateManyAndReturnArgs} args - Arguments to create many MedicineSkills.
     * @example
     * // Create many MedicineSkills
     * const medicineSkill = await prisma.medicineSkill.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MedicineSkills and only return the `id`
     * const medicineSkillWithIdOnly = await prisma.medicineSkill.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MedicineSkillCreateManyAndReturnArgs>(args?: SelectSubset<T, MedicineSkillCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MedicineSkillPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a MedicineSkill.
     * @param {MedicineSkillDeleteArgs} args - Arguments to delete one MedicineSkill.
     * @example
     * // Delete one MedicineSkill
     * const MedicineSkill = await prisma.medicineSkill.delete({
     *   where: {
     *     // ... filter to delete one MedicineSkill
     *   }
     * })
     * 
     */
    delete<T extends MedicineSkillDeleteArgs>(args: SelectSubset<T, MedicineSkillDeleteArgs<ExtArgs>>): Prisma__MedicineSkillClient<$Result.GetResult<Prisma.$MedicineSkillPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one MedicineSkill.
     * @param {MedicineSkillUpdateArgs} args - Arguments to update one MedicineSkill.
     * @example
     * // Update one MedicineSkill
     * const medicineSkill = await prisma.medicineSkill.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MedicineSkillUpdateArgs>(args: SelectSubset<T, MedicineSkillUpdateArgs<ExtArgs>>): Prisma__MedicineSkillClient<$Result.GetResult<Prisma.$MedicineSkillPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more MedicineSkills.
     * @param {MedicineSkillDeleteManyArgs} args - Arguments to filter MedicineSkills to delete.
     * @example
     * // Delete a few MedicineSkills
     * const { count } = await prisma.medicineSkill.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MedicineSkillDeleteManyArgs>(args?: SelectSubset<T, MedicineSkillDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MedicineSkills.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicineSkillUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MedicineSkills
     * const medicineSkill = await prisma.medicineSkill.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MedicineSkillUpdateManyArgs>(args: SelectSubset<T, MedicineSkillUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MedicineSkills and returns the data updated in the database.
     * @param {MedicineSkillUpdateManyAndReturnArgs} args - Arguments to update many MedicineSkills.
     * @example
     * // Update many MedicineSkills
     * const medicineSkill = await prisma.medicineSkill.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more MedicineSkills and only return the `id`
     * const medicineSkillWithIdOnly = await prisma.medicineSkill.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MedicineSkillUpdateManyAndReturnArgs>(args: SelectSubset<T, MedicineSkillUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MedicineSkillPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one MedicineSkill.
     * @param {MedicineSkillUpsertArgs} args - Arguments to update or create a MedicineSkill.
     * @example
     * // Update or create a MedicineSkill
     * const medicineSkill = await prisma.medicineSkill.upsert({
     *   create: {
     *     // ... data to create a MedicineSkill
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MedicineSkill we want to update
     *   }
     * })
     */
    upsert<T extends MedicineSkillUpsertArgs>(args: SelectSubset<T, MedicineSkillUpsertArgs<ExtArgs>>): Prisma__MedicineSkillClient<$Result.GetResult<Prisma.$MedicineSkillPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of MedicineSkills.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicineSkillCountArgs} args - Arguments to filter MedicineSkills to count.
     * @example
     * // Count the number of MedicineSkills
     * const count = await prisma.medicineSkill.count({
     *   where: {
     *     // ... the filter for the MedicineSkills we want to count
     *   }
     * })
    **/
    count<T extends MedicineSkillCountArgs>(
      args?: Subset<T, MedicineSkillCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MedicineSkillCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MedicineSkill.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicineSkillAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MedicineSkillAggregateArgs>(args: Subset<T, MedicineSkillAggregateArgs>): Prisma.PrismaPromise<GetMedicineSkillAggregateType<T>>

    /**
     * Group by MedicineSkill.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicineSkillGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MedicineSkillGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MedicineSkillGroupByArgs['orderBy'] }
        : { orderBy?: MedicineSkillGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MedicineSkillGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMedicineSkillGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MedicineSkill model
   */
  readonly fields: MedicineSkillFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MedicineSkill.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MedicineSkillClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    skill_list<T extends WisdomBasedSkillsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WisdomBasedSkillsDefaultArgs<ExtArgs>>): Prisma__WisdomBasedSkillsClient<$Result.GetResult<Prisma.$WisdomBasedSkillsPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MedicineSkill model
   */ 
  interface MedicineSkillFieldRefs {
    readonly id: FieldRef<"MedicineSkill", 'String'>
    readonly value: FieldRef<"MedicineSkill", 'Int'>
    readonly mastery: FieldRef<"MedicineSkill", 'Boolean'>
    readonly name: FieldRef<"MedicineSkill", 'String'>
  }
    

  // Custom InputTypes
  /**
   * MedicineSkill findUnique
   */
  export type MedicineSkillFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicineSkill
     */
    select?: MedicineSkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MedicineSkill
     */
    omit?: MedicineSkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicineSkillInclude<ExtArgs> | null
    /**
     * Filter, which MedicineSkill to fetch.
     */
    where: MedicineSkillWhereUniqueInput
  }

  /**
   * MedicineSkill findUniqueOrThrow
   */
  export type MedicineSkillFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicineSkill
     */
    select?: MedicineSkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MedicineSkill
     */
    omit?: MedicineSkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicineSkillInclude<ExtArgs> | null
    /**
     * Filter, which MedicineSkill to fetch.
     */
    where: MedicineSkillWhereUniqueInput
  }

  /**
   * MedicineSkill findFirst
   */
  export type MedicineSkillFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicineSkill
     */
    select?: MedicineSkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MedicineSkill
     */
    omit?: MedicineSkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicineSkillInclude<ExtArgs> | null
    /**
     * Filter, which MedicineSkill to fetch.
     */
    where?: MedicineSkillWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MedicineSkills to fetch.
     */
    orderBy?: MedicineSkillOrderByWithRelationInput | MedicineSkillOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MedicineSkills.
     */
    cursor?: MedicineSkillWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MedicineSkills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MedicineSkills.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MedicineSkills.
     */
    distinct?: MedicineSkillScalarFieldEnum | MedicineSkillScalarFieldEnum[]
  }

  /**
   * MedicineSkill findFirstOrThrow
   */
  export type MedicineSkillFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicineSkill
     */
    select?: MedicineSkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MedicineSkill
     */
    omit?: MedicineSkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicineSkillInclude<ExtArgs> | null
    /**
     * Filter, which MedicineSkill to fetch.
     */
    where?: MedicineSkillWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MedicineSkills to fetch.
     */
    orderBy?: MedicineSkillOrderByWithRelationInput | MedicineSkillOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MedicineSkills.
     */
    cursor?: MedicineSkillWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MedicineSkills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MedicineSkills.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MedicineSkills.
     */
    distinct?: MedicineSkillScalarFieldEnum | MedicineSkillScalarFieldEnum[]
  }

  /**
   * MedicineSkill findMany
   */
  export type MedicineSkillFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicineSkill
     */
    select?: MedicineSkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MedicineSkill
     */
    omit?: MedicineSkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicineSkillInclude<ExtArgs> | null
    /**
     * Filter, which MedicineSkills to fetch.
     */
    where?: MedicineSkillWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MedicineSkills to fetch.
     */
    orderBy?: MedicineSkillOrderByWithRelationInput | MedicineSkillOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MedicineSkills.
     */
    cursor?: MedicineSkillWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MedicineSkills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MedicineSkills.
     */
    skip?: number
    distinct?: MedicineSkillScalarFieldEnum | MedicineSkillScalarFieldEnum[]
  }

  /**
   * MedicineSkill create
   */
  export type MedicineSkillCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicineSkill
     */
    select?: MedicineSkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MedicineSkill
     */
    omit?: MedicineSkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicineSkillInclude<ExtArgs> | null
    /**
     * The data needed to create a MedicineSkill.
     */
    data: XOR<MedicineSkillCreateInput, MedicineSkillUncheckedCreateInput>
  }

  /**
   * MedicineSkill createMany
   */
  export type MedicineSkillCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MedicineSkills.
     */
    data: MedicineSkillCreateManyInput | MedicineSkillCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MedicineSkill createManyAndReturn
   */
  export type MedicineSkillCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicineSkill
     */
    select?: MedicineSkillSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MedicineSkill
     */
    omit?: MedicineSkillOmit<ExtArgs> | null
    /**
     * The data used to create many MedicineSkills.
     */
    data: MedicineSkillCreateManyInput | MedicineSkillCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicineSkillIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * MedicineSkill update
   */
  export type MedicineSkillUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicineSkill
     */
    select?: MedicineSkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MedicineSkill
     */
    omit?: MedicineSkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicineSkillInclude<ExtArgs> | null
    /**
     * The data needed to update a MedicineSkill.
     */
    data: XOR<MedicineSkillUpdateInput, MedicineSkillUncheckedUpdateInput>
    /**
     * Choose, which MedicineSkill to update.
     */
    where: MedicineSkillWhereUniqueInput
  }

  /**
   * MedicineSkill updateMany
   */
  export type MedicineSkillUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MedicineSkills.
     */
    data: XOR<MedicineSkillUpdateManyMutationInput, MedicineSkillUncheckedUpdateManyInput>
    /**
     * Filter which MedicineSkills to update
     */
    where?: MedicineSkillWhereInput
    /**
     * Limit how many MedicineSkills to update.
     */
    limit?: number
  }

  /**
   * MedicineSkill updateManyAndReturn
   */
  export type MedicineSkillUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicineSkill
     */
    select?: MedicineSkillSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MedicineSkill
     */
    omit?: MedicineSkillOmit<ExtArgs> | null
    /**
     * The data used to update MedicineSkills.
     */
    data: XOR<MedicineSkillUpdateManyMutationInput, MedicineSkillUncheckedUpdateManyInput>
    /**
     * Filter which MedicineSkills to update
     */
    where?: MedicineSkillWhereInput
    /**
     * Limit how many MedicineSkills to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicineSkillIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * MedicineSkill upsert
   */
  export type MedicineSkillUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicineSkill
     */
    select?: MedicineSkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MedicineSkill
     */
    omit?: MedicineSkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicineSkillInclude<ExtArgs> | null
    /**
     * The filter to search for the MedicineSkill to update in case it exists.
     */
    where: MedicineSkillWhereUniqueInput
    /**
     * In case the MedicineSkill found by the `where` argument doesn't exist, create a new MedicineSkill with this data.
     */
    create: XOR<MedicineSkillCreateInput, MedicineSkillUncheckedCreateInput>
    /**
     * In case the MedicineSkill was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MedicineSkillUpdateInput, MedicineSkillUncheckedUpdateInput>
  }

  /**
   * MedicineSkill delete
   */
  export type MedicineSkillDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicineSkill
     */
    select?: MedicineSkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MedicineSkill
     */
    omit?: MedicineSkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicineSkillInclude<ExtArgs> | null
    /**
     * Filter which MedicineSkill to delete.
     */
    where: MedicineSkillWhereUniqueInput
  }

  /**
   * MedicineSkill deleteMany
   */
  export type MedicineSkillDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MedicineSkills to delete
     */
    where?: MedicineSkillWhereInput
    /**
     * Limit how many MedicineSkills to delete.
     */
    limit?: number
  }

  /**
   * MedicineSkill without action
   */
  export type MedicineSkillDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicineSkill
     */
    select?: MedicineSkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MedicineSkill
     */
    omit?: MedicineSkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicineSkillInclude<ExtArgs> | null
  }


  /**
   * Model PerceptionSkill
   */

  export type AggregatePerceptionSkill = {
    _count: PerceptionSkillCountAggregateOutputType | null
    _avg: PerceptionSkillAvgAggregateOutputType | null
    _sum: PerceptionSkillSumAggregateOutputType | null
    _min: PerceptionSkillMinAggregateOutputType | null
    _max: PerceptionSkillMaxAggregateOutputType | null
  }

  export type PerceptionSkillAvgAggregateOutputType = {
    value: number | null
  }

  export type PerceptionSkillSumAggregateOutputType = {
    value: number | null
  }

  export type PerceptionSkillMinAggregateOutputType = {
    id: string | null
    value: number | null
    mastery: boolean | null
    name: string | null
  }

  export type PerceptionSkillMaxAggregateOutputType = {
    id: string | null
    value: number | null
    mastery: boolean | null
    name: string | null
  }

  export type PerceptionSkillCountAggregateOutputType = {
    id: number
    value: number
    mastery: number
    name: number
    _all: number
  }


  export type PerceptionSkillAvgAggregateInputType = {
    value?: true
  }

  export type PerceptionSkillSumAggregateInputType = {
    value?: true
  }

  export type PerceptionSkillMinAggregateInputType = {
    id?: true
    value?: true
    mastery?: true
    name?: true
  }

  export type PerceptionSkillMaxAggregateInputType = {
    id?: true
    value?: true
    mastery?: true
    name?: true
  }

  export type PerceptionSkillCountAggregateInputType = {
    id?: true
    value?: true
    mastery?: true
    name?: true
    _all?: true
  }

  export type PerceptionSkillAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PerceptionSkill to aggregate.
     */
    where?: PerceptionSkillWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PerceptionSkills to fetch.
     */
    orderBy?: PerceptionSkillOrderByWithRelationInput | PerceptionSkillOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PerceptionSkillWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PerceptionSkills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PerceptionSkills.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PerceptionSkills
    **/
    _count?: true | PerceptionSkillCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PerceptionSkillAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PerceptionSkillSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PerceptionSkillMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PerceptionSkillMaxAggregateInputType
  }

  export type GetPerceptionSkillAggregateType<T extends PerceptionSkillAggregateArgs> = {
        [P in keyof T & keyof AggregatePerceptionSkill]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePerceptionSkill[P]>
      : GetScalarType<T[P], AggregatePerceptionSkill[P]>
  }




  export type PerceptionSkillGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PerceptionSkillWhereInput
    orderBy?: PerceptionSkillOrderByWithAggregationInput | PerceptionSkillOrderByWithAggregationInput[]
    by: PerceptionSkillScalarFieldEnum[] | PerceptionSkillScalarFieldEnum
    having?: PerceptionSkillScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PerceptionSkillCountAggregateInputType | true
    _avg?: PerceptionSkillAvgAggregateInputType
    _sum?: PerceptionSkillSumAggregateInputType
    _min?: PerceptionSkillMinAggregateInputType
    _max?: PerceptionSkillMaxAggregateInputType
  }

  export type PerceptionSkillGroupByOutputType = {
    id: string
    value: number | null
    mastery: boolean
    name: string
    _count: PerceptionSkillCountAggregateOutputType | null
    _avg: PerceptionSkillAvgAggregateOutputType | null
    _sum: PerceptionSkillSumAggregateOutputType | null
    _min: PerceptionSkillMinAggregateOutputType | null
    _max: PerceptionSkillMaxAggregateOutputType | null
  }

  type GetPerceptionSkillGroupByPayload<T extends PerceptionSkillGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PerceptionSkillGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PerceptionSkillGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PerceptionSkillGroupByOutputType[P]>
            : GetScalarType<T[P], PerceptionSkillGroupByOutputType[P]>
        }
      >
    >


  export type PerceptionSkillSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    value?: boolean
    mastery?: boolean
    name?: boolean
    skill_list?: boolean | WisdomBasedSkillsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["perceptionSkill"]>

  export type PerceptionSkillSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    value?: boolean
    mastery?: boolean
    name?: boolean
    skill_list?: boolean | WisdomBasedSkillsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["perceptionSkill"]>

  export type PerceptionSkillSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    value?: boolean
    mastery?: boolean
    name?: boolean
    skill_list?: boolean | WisdomBasedSkillsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["perceptionSkill"]>

  export type PerceptionSkillSelectScalar = {
    id?: boolean
    value?: boolean
    mastery?: boolean
    name?: boolean
  }

  export type PerceptionSkillOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "value" | "mastery" | "name", ExtArgs["result"]["perceptionSkill"]>
  export type PerceptionSkillInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    skill_list?: boolean | WisdomBasedSkillsDefaultArgs<ExtArgs>
  }
  export type PerceptionSkillIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    skill_list?: boolean | WisdomBasedSkillsDefaultArgs<ExtArgs>
  }
  export type PerceptionSkillIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    skill_list?: boolean | WisdomBasedSkillsDefaultArgs<ExtArgs>
  }

  export type $PerceptionSkillPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PerceptionSkill"
    objects: {
      skill_list: Prisma.$WisdomBasedSkillsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      value: number | null
      mastery: boolean
      name: string
    }, ExtArgs["result"]["perceptionSkill"]>
    composites: {}
  }

  type PerceptionSkillGetPayload<S extends boolean | null | undefined | PerceptionSkillDefaultArgs> = $Result.GetResult<Prisma.$PerceptionSkillPayload, S>

  type PerceptionSkillCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PerceptionSkillFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PerceptionSkillCountAggregateInputType | true
    }

  export interface PerceptionSkillDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PerceptionSkill'], meta: { name: 'PerceptionSkill' } }
    /**
     * Find zero or one PerceptionSkill that matches the filter.
     * @param {PerceptionSkillFindUniqueArgs} args - Arguments to find a PerceptionSkill
     * @example
     * // Get one PerceptionSkill
     * const perceptionSkill = await prisma.perceptionSkill.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PerceptionSkillFindUniqueArgs>(args: SelectSubset<T, PerceptionSkillFindUniqueArgs<ExtArgs>>): Prisma__PerceptionSkillClient<$Result.GetResult<Prisma.$PerceptionSkillPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one PerceptionSkill that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PerceptionSkillFindUniqueOrThrowArgs} args - Arguments to find a PerceptionSkill
     * @example
     * // Get one PerceptionSkill
     * const perceptionSkill = await prisma.perceptionSkill.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PerceptionSkillFindUniqueOrThrowArgs>(args: SelectSubset<T, PerceptionSkillFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PerceptionSkillClient<$Result.GetResult<Prisma.$PerceptionSkillPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first PerceptionSkill that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PerceptionSkillFindFirstArgs} args - Arguments to find a PerceptionSkill
     * @example
     * // Get one PerceptionSkill
     * const perceptionSkill = await prisma.perceptionSkill.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PerceptionSkillFindFirstArgs>(args?: SelectSubset<T, PerceptionSkillFindFirstArgs<ExtArgs>>): Prisma__PerceptionSkillClient<$Result.GetResult<Prisma.$PerceptionSkillPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first PerceptionSkill that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PerceptionSkillFindFirstOrThrowArgs} args - Arguments to find a PerceptionSkill
     * @example
     * // Get one PerceptionSkill
     * const perceptionSkill = await prisma.perceptionSkill.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PerceptionSkillFindFirstOrThrowArgs>(args?: SelectSubset<T, PerceptionSkillFindFirstOrThrowArgs<ExtArgs>>): Prisma__PerceptionSkillClient<$Result.GetResult<Prisma.$PerceptionSkillPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more PerceptionSkills that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PerceptionSkillFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PerceptionSkills
     * const perceptionSkills = await prisma.perceptionSkill.findMany()
     * 
     * // Get first 10 PerceptionSkills
     * const perceptionSkills = await prisma.perceptionSkill.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const perceptionSkillWithIdOnly = await prisma.perceptionSkill.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PerceptionSkillFindManyArgs>(args?: SelectSubset<T, PerceptionSkillFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PerceptionSkillPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a PerceptionSkill.
     * @param {PerceptionSkillCreateArgs} args - Arguments to create a PerceptionSkill.
     * @example
     * // Create one PerceptionSkill
     * const PerceptionSkill = await prisma.perceptionSkill.create({
     *   data: {
     *     // ... data to create a PerceptionSkill
     *   }
     * })
     * 
     */
    create<T extends PerceptionSkillCreateArgs>(args: SelectSubset<T, PerceptionSkillCreateArgs<ExtArgs>>): Prisma__PerceptionSkillClient<$Result.GetResult<Prisma.$PerceptionSkillPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many PerceptionSkills.
     * @param {PerceptionSkillCreateManyArgs} args - Arguments to create many PerceptionSkills.
     * @example
     * // Create many PerceptionSkills
     * const perceptionSkill = await prisma.perceptionSkill.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PerceptionSkillCreateManyArgs>(args?: SelectSubset<T, PerceptionSkillCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PerceptionSkills and returns the data saved in the database.
     * @param {PerceptionSkillCreateManyAndReturnArgs} args - Arguments to create many PerceptionSkills.
     * @example
     * // Create many PerceptionSkills
     * const perceptionSkill = await prisma.perceptionSkill.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PerceptionSkills and only return the `id`
     * const perceptionSkillWithIdOnly = await prisma.perceptionSkill.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PerceptionSkillCreateManyAndReturnArgs>(args?: SelectSubset<T, PerceptionSkillCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PerceptionSkillPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a PerceptionSkill.
     * @param {PerceptionSkillDeleteArgs} args - Arguments to delete one PerceptionSkill.
     * @example
     * // Delete one PerceptionSkill
     * const PerceptionSkill = await prisma.perceptionSkill.delete({
     *   where: {
     *     // ... filter to delete one PerceptionSkill
     *   }
     * })
     * 
     */
    delete<T extends PerceptionSkillDeleteArgs>(args: SelectSubset<T, PerceptionSkillDeleteArgs<ExtArgs>>): Prisma__PerceptionSkillClient<$Result.GetResult<Prisma.$PerceptionSkillPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one PerceptionSkill.
     * @param {PerceptionSkillUpdateArgs} args - Arguments to update one PerceptionSkill.
     * @example
     * // Update one PerceptionSkill
     * const perceptionSkill = await prisma.perceptionSkill.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PerceptionSkillUpdateArgs>(args: SelectSubset<T, PerceptionSkillUpdateArgs<ExtArgs>>): Prisma__PerceptionSkillClient<$Result.GetResult<Prisma.$PerceptionSkillPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more PerceptionSkills.
     * @param {PerceptionSkillDeleteManyArgs} args - Arguments to filter PerceptionSkills to delete.
     * @example
     * // Delete a few PerceptionSkills
     * const { count } = await prisma.perceptionSkill.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PerceptionSkillDeleteManyArgs>(args?: SelectSubset<T, PerceptionSkillDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PerceptionSkills.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PerceptionSkillUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PerceptionSkills
     * const perceptionSkill = await prisma.perceptionSkill.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PerceptionSkillUpdateManyArgs>(args: SelectSubset<T, PerceptionSkillUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PerceptionSkills and returns the data updated in the database.
     * @param {PerceptionSkillUpdateManyAndReturnArgs} args - Arguments to update many PerceptionSkills.
     * @example
     * // Update many PerceptionSkills
     * const perceptionSkill = await prisma.perceptionSkill.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PerceptionSkills and only return the `id`
     * const perceptionSkillWithIdOnly = await prisma.perceptionSkill.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PerceptionSkillUpdateManyAndReturnArgs>(args: SelectSubset<T, PerceptionSkillUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PerceptionSkillPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one PerceptionSkill.
     * @param {PerceptionSkillUpsertArgs} args - Arguments to update or create a PerceptionSkill.
     * @example
     * // Update or create a PerceptionSkill
     * const perceptionSkill = await prisma.perceptionSkill.upsert({
     *   create: {
     *     // ... data to create a PerceptionSkill
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PerceptionSkill we want to update
     *   }
     * })
     */
    upsert<T extends PerceptionSkillUpsertArgs>(args: SelectSubset<T, PerceptionSkillUpsertArgs<ExtArgs>>): Prisma__PerceptionSkillClient<$Result.GetResult<Prisma.$PerceptionSkillPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of PerceptionSkills.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PerceptionSkillCountArgs} args - Arguments to filter PerceptionSkills to count.
     * @example
     * // Count the number of PerceptionSkills
     * const count = await prisma.perceptionSkill.count({
     *   where: {
     *     // ... the filter for the PerceptionSkills we want to count
     *   }
     * })
    **/
    count<T extends PerceptionSkillCountArgs>(
      args?: Subset<T, PerceptionSkillCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PerceptionSkillCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PerceptionSkill.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PerceptionSkillAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PerceptionSkillAggregateArgs>(args: Subset<T, PerceptionSkillAggregateArgs>): Prisma.PrismaPromise<GetPerceptionSkillAggregateType<T>>

    /**
     * Group by PerceptionSkill.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PerceptionSkillGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PerceptionSkillGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PerceptionSkillGroupByArgs['orderBy'] }
        : { orderBy?: PerceptionSkillGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PerceptionSkillGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPerceptionSkillGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PerceptionSkill model
   */
  readonly fields: PerceptionSkillFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PerceptionSkill.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PerceptionSkillClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    skill_list<T extends WisdomBasedSkillsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WisdomBasedSkillsDefaultArgs<ExtArgs>>): Prisma__WisdomBasedSkillsClient<$Result.GetResult<Prisma.$WisdomBasedSkillsPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PerceptionSkill model
   */ 
  interface PerceptionSkillFieldRefs {
    readonly id: FieldRef<"PerceptionSkill", 'String'>
    readonly value: FieldRef<"PerceptionSkill", 'Int'>
    readonly mastery: FieldRef<"PerceptionSkill", 'Boolean'>
    readonly name: FieldRef<"PerceptionSkill", 'String'>
  }
    

  // Custom InputTypes
  /**
   * PerceptionSkill findUnique
   */
  export type PerceptionSkillFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PerceptionSkill
     */
    select?: PerceptionSkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PerceptionSkill
     */
    omit?: PerceptionSkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PerceptionSkillInclude<ExtArgs> | null
    /**
     * Filter, which PerceptionSkill to fetch.
     */
    where: PerceptionSkillWhereUniqueInput
  }

  /**
   * PerceptionSkill findUniqueOrThrow
   */
  export type PerceptionSkillFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PerceptionSkill
     */
    select?: PerceptionSkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PerceptionSkill
     */
    omit?: PerceptionSkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PerceptionSkillInclude<ExtArgs> | null
    /**
     * Filter, which PerceptionSkill to fetch.
     */
    where: PerceptionSkillWhereUniqueInput
  }

  /**
   * PerceptionSkill findFirst
   */
  export type PerceptionSkillFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PerceptionSkill
     */
    select?: PerceptionSkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PerceptionSkill
     */
    omit?: PerceptionSkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PerceptionSkillInclude<ExtArgs> | null
    /**
     * Filter, which PerceptionSkill to fetch.
     */
    where?: PerceptionSkillWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PerceptionSkills to fetch.
     */
    orderBy?: PerceptionSkillOrderByWithRelationInput | PerceptionSkillOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PerceptionSkills.
     */
    cursor?: PerceptionSkillWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PerceptionSkills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PerceptionSkills.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PerceptionSkills.
     */
    distinct?: PerceptionSkillScalarFieldEnum | PerceptionSkillScalarFieldEnum[]
  }

  /**
   * PerceptionSkill findFirstOrThrow
   */
  export type PerceptionSkillFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PerceptionSkill
     */
    select?: PerceptionSkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PerceptionSkill
     */
    omit?: PerceptionSkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PerceptionSkillInclude<ExtArgs> | null
    /**
     * Filter, which PerceptionSkill to fetch.
     */
    where?: PerceptionSkillWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PerceptionSkills to fetch.
     */
    orderBy?: PerceptionSkillOrderByWithRelationInput | PerceptionSkillOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PerceptionSkills.
     */
    cursor?: PerceptionSkillWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PerceptionSkills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PerceptionSkills.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PerceptionSkills.
     */
    distinct?: PerceptionSkillScalarFieldEnum | PerceptionSkillScalarFieldEnum[]
  }

  /**
   * PerceptionSkill findMany
   */
  export type PerceptionSkillFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PerceptionSkill
     */
    select?: PerceptionSkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PerceptionSkill
     */
    omit?: PerceptionSkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PerceptionSkillInclude<ExtArgs> | null
    /**
     * Filter, which PerceptionSkills to fetch.
     */
    where?: PerceptionSkillWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PerceptionSkills to fetch.
     */
    orderBy?: PerceptionSkillOrderByWithRelationInput | PerceptionSkillOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PerceptionSkills.
     */
    cursor?: PerceptionSkillWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PerceptionSkills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PerceptionSkills.
     */
    skip?: number
    distinct?: PerceptionSkillScalarFieldEnum | PerceptionSkillScalarFieldEnum[]
  }

  /**
   * PerceptionSkill create
   */
  export type PerceptionSkillCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PerceptionSkill
     */
    select?: PerceptionSkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PerceptionSkill
     */
    omit?: PerceptionSkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PerceptionSkillInclude<ExtArgs> | null
    /**
     * The data needed to create a PerceptionSkill.
     */
    data: XOR<PerceptionSkillCreateInput, PerceptionSkillUncheckedCreateInput>
  }

  /**
   * PerceptionSkill createMany
   */
  export type PerceptionSkillCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PerceptionSkills.
     */
    data: PerceptionSkillCreateManyInput | PerceptionSkillCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PerceptionSkill createManyAndReturn
   */
  export type PerceptionSkillCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PerceptionSkill
     */
    select?: PerceptionSkillSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PerceptionSkill
     */
    omit?: PerceptionSkillOmit<ExtArgs> | null
    /**
     * The data used to create many PerceptionSkills.
     */
    data: PerceptionSkillCreateManyInput | PerceptionSkillCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PerceptionSkillIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PerceptionSkill update
   */
  export type PerceptionSkillUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PerceptionSkill
     */
    select?: PerceptionSkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PerceptionSkill
     */
    omit?: PerceptionSkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PerceptionSkillInclude<ExtArgs> | null
    /**
     * The data needed to update a PerceptionSkill.
     */
    data: XOR<PerceptionSkillUpdateInput, PerceptionSkillUncheckedUpdateInput>
    /**
     * Choose, which PerceptionSkill to update.
     */
    where: PerceptionSkillWhereUniqueInput
  }

  /**
   * PerceptionSkill updateMany
   */
  export type PerceptionSkillUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PerceptionSkills.
     */
    data: XOR<PerceptionSkillUpdateManyMutationInput, PerceptionSkillUncheckedUpdateManyInput>
    /**
     * Filter which PerceptionSkills to update
     */
    where?: PerceptionSkillWhereInput
    /**
     * Limit how many PerceptionSkills to update.
     */
    limit?: number
  }

  /**
   * PerceptionSkill updateManyAndReturn
   */
  export type PerceptionSkillUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PerceptionSkill
     */
    select?: PerceptionSkillSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PerceptionSkill
     */
    omit?: PerceptionSkillOmit<ExtArgs> | null
    /**
     * The data used to update PerceptionSkills.
     */
    data: XOR<PerceptionSkillUpdateManyMutationInput, PerceptionSkillUncheckedUpdateManyInput>
    /**
     * Filter which PerceptionSkills to update
     */
    where?: PerceptionSkillWhereInput
    /**
     * Limit how many PerceptionSkills to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PerceptionSkillIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PerceptionSkill upsert
   */
  export type PerceptionSkillUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PerceptionSkill
     */
    select?: PerceptionSkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PerceptionSkill
     */
    omit?: PerceptionSkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PerceptionSkillInclude<ExtArgs> | null
    /**
     * The filter to search for the PerceptionSkill to update in case it exists.
     */
    where: PerceptionSkillWhereUniqueInput
    /**
     * In case the PerceptionSkill found by the `where` argument doesn't exist, create a new PerceptionSkill with this data.
     */
    create: XOR<PerceptionSkillCreateInput, PerceptionSkillUncheckedCreateInput>
    /**
     * In case the PerceptionSkill was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PerceptionSkillUpdateInput, PerceptionSkillUncheckedUpdateInput>
  }

  /**
   * PerceptionSkill delete
   */
  export type PerceptionSkillDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PerceptionSkill
     */
    select?: PerceptionSkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PerceptionSkill
     */
    omit?: PerceptionSkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PerceptionSkillInclude<ExtArgs> | null
    /**
     * Filter which PerceptionSkill to delete.
     */
    where: PerceptionSkillWhereUniqueInput
  }

  /**
   * PerceptionSkill deleteMany
   */
  export type PerceptionSkillDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PerceptionSkills to delete
     */
    where?: PerceptionSkillWhereInput
    /**
     * Limit how many PerceptionSkills to delete.
     */
    limit?: number
  }

  /**
   * PerceptionSkill without action
   */
  export type PerceptionSkillDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PerceptionSkill
     */
    select?: PerceptionSkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PerceptionSkill
     */
    omit?: PerceptionSkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PerceptionSkillInclude<ExtArgs> | null
  }


  /**
   * Model SurvivalSkill
   */

  export type AggregateSurvivalSkill = {
    _count: SurvivalSkillCountAggregateOutputType | null
    _avg: SurvivalSkillAvgAggregateOutputType | null
    _sum: SurvivalSkillSumAggregateOutputType | null
    _min: SurvivalSkillMinAggregateOutputType | null
    _max: SurvivalSkillMaxAggregateOutputType | null
  }

  export type SurvivalSkillAvgAggregateOutputType = {
    value: number | null
  }

  export type SurvivalSkillSumAggregateOutputType = {
    value: number | null
  }

  export type SurvivalSkillMinAggregateOutputType = {
    id: string | null
    value: number | null
    mastery: boolean | null
    name: string | null
  }

  export type SurvivalSkillMaxAggregateOutputType = {
    id: string | null
    value: number | null
    mastery: boolean | null
    name: string | null
  }

  export type SurvivalSkillCountAggregateOutputType = {
    id: number
    value: number
    mastery: number
    name: number
    _all: number
  }


  export type SurvivalSkillAvgAggregateInputType = {
    value?: true
  }

  export type SurvivalSkillSumAggregateInputType = {
    value?: true
  }

  export type SurvivalSkillMinAggregateInputType = {
    id?: true
    value?: true
    mastery?: true
    name?: true
  }

  export type SurvivalSkillMaxAggregateInputType = {
    id?: true
    value?: true
    mastery?: true
    name?: true
  }

  export type SurvivalSkillCountAggregateInputType = {
    id?: true
    value?: true
    mastery?: true
    name?: true
    _all?: true
  }

  export type SurvivalSkillAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SurvivalSkill to aggregate.
     */
    where?: SurvivalSkillWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SurvivalSkills to fetch.
     */
    orderBy?: SurvivalSkillOrderByWithRelationInput | SurvivalSkillOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SurvivalSkillWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SurvivalSkills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SurvivalSkills.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SurvivalSkills
    **/
    _count?: true | SurvivalSkillCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SurvivalSkillAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SurvivalSkillSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SurvivalSkillMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SurvivalSkillMaxAggregateInputType
  }

  export type GetSurvivalSkillAggregateType<T extends SurvivalSkillAggregateArgs> = {
        [P in keyof T & keyof AggregateSurvivalSkill]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSurvivalSkill[P]>
      : GetScalarType<T[P], AggregateSurvivalSkill[P]>
  }




  export type SurvivalSkillGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SurvivalSkillWhereInput
    orderBy?: SurvivalSkillOrderByWithAggregationInput | SurvivalSkillOrderByWithAggregationInput[]
    by: SurvivalSkillScalarFieldEnum[] | SurvivalSkillScalarFieldEnum
    having?: SurvivalSkillScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SurvivalSkillCountAggregateInputType | true
    _avg?: SurvivalSkillAvgAggregateInputType
    _sum?: SurvivalSkillSumAggregateInputType
    _min?: SurvivalSkillMinAggregateInputType
    _max?: SurvivalSkillMaxAggregateInputType
  }

  export type SurvivalSkillGroupByOutputType = {
    id: string
    value: number | null
    mastery: boolean
    name: string
    _count: SurvivalSkillCountAggregateOutputType | null
    _avg: SurvivalSkillAvgAggregateOutputType | null
    _sum: SurvivalSkillSumAggregateOutputType | null
    _min: SurvivalSkillMinAggregateOutputType | null
    _max: SurvivalSkillMaxAggregateOutputType | null
  }

  type GetSurvivalSkillGroupByPayload<T extends SurvivalSkillGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SurvivalSkillGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SurvivalSkillGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SurvivalSkillGroupByOutputType[P]>
            : GetScalarType<T[P], SurvivalSkillGroupByOutputType[P]>
        }
      >
    >


  export type SurvivalSkillSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    value?: boolean
    mastery?: boolean
    name?: boolean
    skill_list?: boolean | WisdomBasedSkillsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["survivalSkill"]>

  export type SurvivalSkillSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    value?: boolean
    mastery?: boolean
    name?: boolean
    skill_list?: boolean | WisdomBasedSkillsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["survivalSkill"]>

  export type SurvivalSkillSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    value?: boolean
    mastery?: boolean
    name?: boolean
    skill_list?: boolean | WisdomBasedSkillsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["survivalSkill"]>

  export type SurvivalSkillSelectScalar = {
    id?: boolean
    value?: boolean
    mastery?: boolean
    name?: boolean
  }

  export type SurvivalSkillOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "value" | "mastery" | "name", ExtArgs["result"]["survivalSkill"]>
  export type SurvivalSkillInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    skill_list?: boolean | WisdomBasedSkillsDefaultArgs<ExtArgs>
  }
  export type SurvivalSkillIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    skill_list?: boolean | WisdomBasedSkillsDefaultArgs<ExtArgs>
  }
  export type SurvivalSkillIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    skill_list?: boolean | WisdomBasedSkillsDefaultArgs<ExtArgs>
  }

  export type $SurvivalSkillPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SurvivalSkill"
    objects: {
      skill_list: Prisma.$WisdomBasedSkillsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      value: number | null
      mastery: boolean
      name: string
    }, ExtArgs["result"]["survivalSkill"]>
    composites: {}
  }

  type SurvivalSkillGetPayload<S extends boolean | null | undefined | SurvivalSkillDefaultArgs> = $Result.GetResult<Prisma.$SurvivalSkillPayload, S>

  type SurvivalSkillCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SurvivalSkillFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SurvivalSkillCountAggregateInputType | true
    }

  export interface SurvivalSkillDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SurvivalSkill'], meta: { name: 'SurvivalSkill' } }
    /**
     * Find zero or one SurvivalSkill that matches the filter.
     * @param {SurvivalSkillFindUniqueArgs} args - Arguments to find a SurvivalSkill
     * @example
     * // Get one SurvivalSkill
     * const survivalSkill = await prisma.survivalSkill.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SurvivalSkillFindUniqueArgs>(args: SelectSubset<T, SurvivalSkillFindUniqueArgs<ExtArgs>>): Prisma__SurvivalSkillClient<$Result.GetResult<Prisma.$SurvivalSkillPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one SurvivalSkill that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SurvivalSkillFindUniqueOrThrowArgs} args - Arguments to find a SurvivalSkill
     * @example
     * // Get one SurvivalSkill
     * const survivalSkill = await prisma.survivalSkill.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SurvivalSkillFindUniqueOrThrowArgs>(args: SelectSubset<T, SurvivalSkillFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SurvivalSkillClient<$Result.GetResult<Prisma.$SurvivalSkillPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first SurvivalSkill that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SurvivalSkillFindFirstArgs} args - Arguments to find a SurvivalSkill
     * @example
     * // Get one SurvivalSkill
     * const survivalSkill = await prisma.survivalSkill.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SurvivalSkillFindFirstArgs>(args?: SelectSubset<T, SurvivalSkillFindFirstArgs<ExtArgs>>): Prisma__SurvivalSkillClient<$Result.GetResult<Prisma.$SurvivalSkillPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first SurvivalSkill that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SurvivalSkillFindFirstOrThrowArgs} args - Arguments to find a SurvivalSkill
     * @example
     * // Get one SurvivalSkill
     * const survivalSkill = await prisma.survivalSkill.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SurvivalSkillFindFirstOrThrowArgs>(args?: SelectSubset<T, SurvivalSkillFindFirstOrThrowArgs<ExtArgs>>): Prisma__SurvivalSkillClient<$Result.GetResult<Prisma.$SurvivalSkillPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more SurvivalSkills that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SurvivalSkillFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SurvivalSkills
     * const survivalSkills = await prisma.survivalSkill.findMany()
     * 
     * // Get first 10 SurvivalSkills
     * const survivalSkills = await prisma.survivalSkill.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const survivalSkillWithIdOnly = await prisma.survivalSkill.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SurvivalSkillFindManyArgs>(args?: SelectSubset<T, SurvivalSkillFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SurvivalSkillPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a SurvivalSkill.
     * @param {SurvivalSkillCreateArgs} args - Arguments to create a SurvivalSkill.
     * @example
     * // Create one SurvivalSkill
     * const SurvivalSkill = await prisma.survivalSkill.create({
     *   data: {
     *     // ... data to create a SurvivalSkill
     *   }
     * })
     * 
     */
    create<T extends SurvivalSkillCreateArgs>(args: SelectSubset<T, SurvivalSkillCreateArgs<ExtArgs>>): Prisma__SurvivalSkillClient<$Result.GetResult<Prisma.$SurvivalSkillPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many SurvivalSkills.
     * @param {SurvivalSkillCreateManyArgs} args - Arguments to create many SurvivalSkills.
     * @example
     * // Create many SurvivalSkills
     * const survivalSkill = await prisma.survivalSkill.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SurvivalSkillCreateManyArgs>(args?: SelectSubset<T, SurvivalSkillCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SurvivalSkills and returns the data saved in the database.
     * @param {SurvivalSkillCreateManyAndReturnArgs} args - Arguments to create many SurvivalSkills.
     * @example
     * // Create many SurvivalSkills
     * const survivalSkill = await prisma.survivalSkill.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SurvivalSkills and only return the `id`
     * const survivalSkillWithIdOnly = await prisma.survivalSkill.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SurvivalSkillCreateManyAndReturnArgs>(args?: SelectSubset<T, SurvivalSkillCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SurvivalSkillPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a SurvivalSkill.
     * @param {SurvivalSkillDeleteArgs} args - Arguments to delete one SurvivalSkill.
     * @example
     * // Delete one SurvivalSkill
     * const SurvivalSkill = await prisma.survivalSkill.delete({
     *   where: {
     *     // ... filter to delete one SurvivalSkill
     *   }
     * })
     * 
     */
    delete<T extends SurvivalSkillDeleteArgs>(args: SelectSubset<T, SurvivalSkillDeleteArgs<ExtArgs>>): Prisma__SurvivalSkillClient<$Result.GetResult<Prisma.$SurvivalSkillPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one SurvivalSkill.
     * @param {SurvivalSkillUpdateArgs} args - Arguments to update one SurvivalSkill.
     * @example
     * // Update one SurvivalSkill
     * const survivalSkill = await prisma.survivalSkill.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SurvivalSkillUpdateArgs>(args: SelectSubset<T, SurvivalSkillUpdateArgs<ExtArgs>>): Prisma__SurvivalSkillClient<$Result.GetResult<Prisma.$SurvivalSkillPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more SurvivalSkills.
     * @param {SurvivalSkillDeleteManyArgs} args - Arguments to filter SurvivalSkills to delete.
     * @example
     * // Delete a few SurvivalSkills
     * const { count } = await prisma.survivalSkill.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SurvivalSkillDeleteManyArgs>(args?: SelectSubset<T, SurvivalSkillDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SurvivalSkills.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SurvivalSkillUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SurvivalSkills
     * const survivalSkill = await prisma.survivalSkill.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SurvivalSkillUpdateManyArgs>(args: SelectSubset<T, SurvivalSkillUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SurvivalSkills and returns the data updated in the database.
     * @param {SurvivalSkillUpdateManyAndReturnArgs} args - Arguments to update many SurvivalSkills.
     * @example
     * // Update many SurvivalSkills
     * const survivalSkill = await prisma.survivalSkill.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SurvivalSkills and only return the `id`
     * const survivalSkillWithIdOnly = await prisma.survivalSkill.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SurvivalSkillUpdateManyAndReturnArgs>(args: SelectSubset<T, SurvivalSkillUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SurvivalSkillPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one SurvivalSkill.
     * @param {SurvivalSkillUpsertArgs} args - Arguments to update or create a SurvivalSkill.
     * @example
     * // Update or create a SurvivalSkill
     * const survivalSkill = await prisma.survivalSkill.upsert({
     *   create: {
     *     // ... data to create a SurvivalSkill
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SurvivalSkill we want to update
     *   }
     * })
     */
    upsert<T extends SurvivalSkillUpsertArgs>(args: SelectSubset<T, SurvivalSkillUpsertArgs<ExtArgs>>): Prisma__SurvivalSkillClient<$Result.GetResult<Prisma.$SurvivalSkillPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of SurvivalSkills.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SurvivalSkillCountArgs} args - Arguments to filter SurvivalSkills to count.
     * @example
     * // Count the number of SurvivalSkills
     * const count = await prisma.survivalSkill.count({
     *   where: {
     *     // ... the filter for the SurvivalSkills we want to count
     *   }
     * })
    **/
    count<T extends SurvivalSkillCountArgs>(
      args?: Subset<T, SurvivalSkillCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SurvivalSkillCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SurvivalSkill.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SurvivalSkillAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SurvivalSkillAggregateArgs>(args: Subset<T, SurvivalSkillAggregateArgs>): Prisma.PrismaPromise<GetSurvivalSkillAggregateType<T>>

    /**
     * Group by SurvivalSkill.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SurvivalSkillGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SurvivalSkillGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SurvivalSkillGroupByArgs['orderBy'] }
        : { orderBy?: SurvivalSkillGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SurvivalSkillGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSurvivalSkillGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SurvivalSkill model
   */
  readonly fields: SurvivalSkillFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SurvivalSkill.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SurvivalSkillClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    skill_list<T extends WisdomBasedSkillsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WisdomBasedSkillsDefaultArgs<ExtArgs>>): Prisma__WisdomBasedSkillsClient<$Result.GetResult<Prisma.$WisdomBasedSkillsPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SurvivalSkill model
   */ 
  interface SurvivalSkillFieldRefs {
    readonly id: FieldRef<"SurvivalSkill", 'String'>
    readonly value: FieldRef<"SurvivalSkill", 'Int'>
    readonly mastery: FieldRef<"SurvivalSkill", 'Boolean'>
    readonly name: FieldRef<"SurvivalSkill", 'String'>
  }
    

  // Custom InputTypes
  /**
   * SurvivalSkill findUnique
   */
  export type SurvivalSkillFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SurvivalSkill
     */
    select?: SurvivalSkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SurvivalSkill
     */
    omit?: SurvivalSkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SurvivalSkillInclude<ExtArgs> | null
    /**
     * Filter, which SurvivalSkill to fetch.
     */
    where: SurvivalSkillWhereUniqueInput
  }

  /**
   * SurvivalSkill findUniqueOrThrow
   */
  export type SurvivalSkillFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SurvivalSkill
     */
    select?: SurvivalSkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SurvivalSkill
     */
    omit?: SurvivalSkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SurvivalSkillInclude<ExtArgs> | null
    /**
     * Filter, which SurvivalSkill to fetch.
     */
    where: SurvivalSkillWhereUniqueInput
  }

  /**
   * SurvivalSkill findFirst
   */
  export type SurvivalSkillFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SurvivalSkill
     */
    select?: SurvivalSkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SurvivalSkill
     */
    omit?: SurvivalSkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SurvivalSkillInclude<ExtArgs> | null
    /**
     * Filter, which SurvivalSkill to fetch.
     */
    where?: SurvivalSkillWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SurvivalSkills to fetch.
     */
    orderBy?: SurvivalSkillOrderByWithRelationInput | SurvivalSkillOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SurvivalSkills.
     */
    cursor?: SurvivalSkillWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SurvivalSkills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SurvivalSkills.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SurvivalSkills.
     */
    distinct?: SurvivalSkillScalarFieldEnum | SurvivalSkillScalarFieldEnum[]
  }

  /**
   * SurvivalSkill findFirstOrThrow
   */
  export type SurvivalSkillFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SurvivalSkill
     */
    select?: SurvivalSkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SurvivalSkill
     */
    omit?: SurvivalSkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SurvivalSkillInclude<ExtArgs> | null
    /**
     * Filter, which SurvivalSkill to fetch.
     */
    where?: SurvivalSkillWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SurvivalSkills to fetch.
     */
    orderBy?: SurvivalSkillOrderByWithRelationInput | SurvivalSkillOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SurvivalSkills.
     */
    cursor?: SurvivalSkillWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SurvivalSkills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SurvivalSkills.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SurvivalSkills.
     */
    distinct?: SurvivalSkillScalarFieldEnum | SurvivalSkillScalarFieldEnum[]
  }

  /**
   * SurvivalSkill findMany
   */
  export type SurvivalSkillFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SurvivalSkill
     */
    select?: SurvivalSkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SurvivalSkill
     */
    omit?: SurvivalSkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SurvivalSkillInclude<ExtArgs> | null
    /**
     * Filter, which SurvivalSkills to fetch.
     */
    where?: SurvivalSkillWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SurvivalSkills to fetch.
     */
    orderBy?: SurvivalSkillOrderByWithRelationInput | SurvivalSkillOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SurvivalSkills.
     */
    cursor?: SurvivalSkillWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SurvivalSkills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SurvivalSkills.
     */
    skip?: number
    distinct?: SurvivalSkillScalarFieldEnum | SurvivalSkillScalarFieldEnum[]
  }

  /**
   * SurvivalSkill create
   */
  export type SurvivalSkillCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SurvivalSkill
     */
    select?: SurvivalSkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SurvivalSkill
     */
    omit?: SurvivalSkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SurvivalSkillInclude<ExtArgs> | null
    /**
     * The data needed to create a SurvivalSkill.
     */
    data: XOR<SurvivalSkillCreateInput, SurvivalSkillUncheckedCreateInput>
  }

  /**
   * SurvivalSkill createMany
   */
  export type SurvivalSkillCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SurvivalSkills.
     */
    data: SurvivalSkillCreateManyInput | SurvivalSkillCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SurvivalSkill createManyAndReturn
   */
  export type SurvivalSkillCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SurvivalSkill
     */
    select?: SurvivalSkillSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SurvivalSkill
     */
    omit?: SurvivalSkillOmit<ExtArgs> | null
    /**
     * The data used to create many SurvivalSkills.
     */
    data: SurvivalSkillCreateManyInput | SurvivalSkillCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SurvivalSkillIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SurvivalSkill update
   */
  export type SurvivalSkillUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SurvivalSkill
     */
    select?: SurvivalSkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SurvivalSkill
     */
    omit?: SurvivalSkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SurvivalSkillInclude<ExtArgs> | null
    /**
     * The data needed to update a SurvivalSkill.
     */
    data: XOR<SurvivalSkillUpdateInput, SurvivalSkillUncheckedUpdateInput>
    /**
     * Choose, which SurvivalSkill to update.
     */
    where: SurvivalSkillWhereUniqueInput
  }

  /**
   * SurvivalSkill updateMany
   */
  export type SurvivalSkillUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SurvivalSkills.
     */
    data: XOR<SurvivalSkillUpdateManyMutationInput, SurvivalSkillUncheckedUpdateManyInput>
    /**
     * Filter which SurvivalSkills to update
     */
    where?: SurvivalSkillWhereInput
    /**
     * Limit how many SurvivalSkills to update.
     */
    limit?: number
  }

  /**
   * SurvivalSkill updateManyAndReturn
   */
  export type SurvivalSkillUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SurvivalSkill
     */
    select?: SurvivalSkillSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SurvivalSkill
     */
    omit?: SurvivalSkillOmit<ExtArgs> | null
    /**
     * The data used to update SurvivalSkills.
     */
    data: XOR<SurvivalSkillUpdateManyMutationInput, SurvivalSkillUncheckedUpdateManyInput>
    /**
     * Filter which SurvivalSkills to update
     */
    where?: SurvivalSkillWhereInput
    /**
     * Limit how many SurvivalSkills to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SurvivalSkillIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * SurvivalSkill upsert
   */
  export type SurvivalSkillUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SurvivalSkill
     */
    select?: SurvivalSkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SurvivalSkill
     */
    omit?: SurvivalSkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SurvivalSkillInclude<ExtArgs> | null
    /**
     * The filter to search for the SurvivalSkill to update in case it exists.
     */
    where: SurvivalSkillWhereUniqueInput
    /**
     * In case the SurvivalSkill found by the `where` argument doesn't exist, create a new SurvivalSkill with this data.
     */
    create: XOR<SurvivalSkillCreateInput, SurvivalSkillUncheckedCreateInput>
    /**
     * In case the SurvivalSkill was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SurvivalSkillUpdateInput, SurvivalSkillUncheckedUpdateInput>
  }

  /**
   * SurvivalSkill delete
   */
  export type SurvivalSkillDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SurvivalSkill
     */
    select?: SurvivalSkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SurvivalSkill
     */
    omit?: SurvivalSkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SurvivalSkillInclude<ExtArgs> | null
    /**
     * Filter which SurvivalSkill to delete.
     */
    where: SurvivalSkillWhereUniqueInput
  }

  /**
   * SurvivalSkill deleteMany
   */
  export type SurvivalSkillDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SurvivalSkills to delete
     */
    where?: SurvivalSkillWhereInput
    /**
     * Limit how many SurvivalSkills to delete.
     */
    limit?: number
  }

  /**
   * SurvivalSkill without action
   */
  export type SurvivalSkillDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SurvivalSkill
     */
    select?: SurvivalSkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SurvivalSkill
     */
    omit?: SurvivalSkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SurvivalSkillInclude<ExtArgs> | null
  }


  /**
   * Model DeceptionSkill
   */

  export type AggregateDeceptionSkill = {
    _count: DeceptionSkillCountAggregateOutputType | null
    _avg: DeceptionSkillAvgAggregateOutputType | null
    _sum: DeceptionSkillSumAggregateOutputType | null
    _min: DeceptionSkillMinAggregateOutputType | null
    _max: DeceptionSkillMaxAggregateOutputType | null
  }

  export type DeceptionSkillAvgAggregateOutputType = {
    value: number | null
  }

  export type DeceptionSkillSumAggregateOutputType = {
    value: number | null
  }

  export type DeceptionSkillMinAggregateOutputType = {
    id: string | null
    value: number | null
    mastery: boolean | null
    name: string | null
  }

  export type DeceptionSkillMaxAggregateOutputType = {
    id: string | null
    value: number | null
    mastery: boolean | null
    name: string | null
  }

  export type DeceptionSkillCountAggregateOutputType = {
    id: number
    value: number
    mastery: number
    name: number
    _all: number
  }


  export type DeceptionSkillAvgAggregateInputType = {
    value?: true
  }

  export type DeceptionSkillSumAggregateInputType = {
    value?: true
  }

  export type DeceptionSkillMinAggregateInputType = {
    id?: true
    value?: true
    mastery?: true
    name?: true
  }

  export type DeceptionSkillMaxAggregateInputType = {
    id?: true
    value?: true
    mastery?: true
    name?: true
  }

  export type DeceptionSkillCountAggregateInputType = {
    id?: true
    value?: true
    mastery?: true
    name?: true
    _all?: true
  }

  export type DeceptionSkillAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DeceptionSkill to aggregate.
     */
    where?: DeceptionSkillWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeceptionSkills to fetch.
     */
    orderBy?: DeceptionSkillOrderByWithRelationInput | DeceptionSkillOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DeceptionSkillWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeceptionSkills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeceptionSkills.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DeceptionSkills
    **/
    _count?: true | DeceptionSkillCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DeceptionSkillAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DeceptionSkillSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DeceptionSkillMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DeceptionSkillMaxAggregateInputType
  }

  export type GetDeceptionSkillAggregateType<T extends DeceptionSkillAggregateArgs> = {
        [P in keyof T & keyof AggregateDeceptionSkill]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDeceptionSkill[P]>
      : GetScalarType<T[P], AggregateDeceptionSkill[P]>
  }




  export type DeceptionSkillGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DeceptionSkillWhereInput
    orderBy?: DeceptionSkillOrderByWithAggregationInput | DeceptionSkillOrderByWithAggregationInput[]
    by: DeceptionSkillScalarFieldEnum[] | DeceptionSkillScalarFieldEnum
    having?: DeceptionSkillScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DeceptionSkillCountAggregateInputType | true
    _avg?: DeceptionSkillAvgAggregateInputType
    _sum?: DeceptionSkillSumAggregateInputType
    _min?: DeceptionSkillMinAggregateInputType
    _max?: DeceptionSkillMaxAggregateInputType
  }

  export type DeceptionSkillGroupByOutputType = {
    id: string
    value: number | null
    mastery: boolean
    name: string
    _count: DeceptionSkillCountAggregateOutputType | null
    _avg: DeceptionSkillAvgAggregateOutputType | null
    _sum: DeceptionSkillSumAggregateOutputType | null
    _min: DeceptionSkillMinAggregateOutputType | null
    _max: DeceptionSkillMaxAggregateOutputType | null
  }

  type GetDeceptionSkillGroupByPayload<T extends DeceptionSkillGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DeceptionSkillGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DeceptionSkillGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DeceptionSkillGroupByOutputType[P]>
            : GetScalarType<T[P], DeceptionSkillGroupByOutputType[P]>
        }
      >
    >


  export type DeceptionSkillSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    value?: boolean
    mastery?: boolean
    name?: boolean
    skill_list?: boolean | CharismaBasedSkillsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["deceptionSkill"]>

  export type DeceptionSkillSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    value?: boolean
    mastery?: boolean
    name?: boolean
    skill_list?: boolean | CharismaBasedSkillsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["deceptionSkill"]>

  export type DeceptionSkillSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    value?: boolean
    mastery?: boolean
    name?: boolean
    skill_list?: boolean | CharismaBasedSkillsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["deceptionSkill"]>

  export type DeceptionSkillSelectScalar = {
    id?: boolean
    value?: boolean
    mastery?: boolean
    name?: boolean
  }

  export type DeceptionSkillOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "value" | "mastery" | "name", ExtArgs["result"]["deceptionSkill"]>
  export type DeceptionSkillInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    skill_list?: boolean | CharismaBasedSkillsDefaultArgs<ExtArgs>
  }
  export type DeceptionSkillIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    skill_list?: boolean | CharismaBasedSkillsDefaultArgs<ExtArgs>
  }
  export type DeceptionSkillIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    skill_list?: boolean | CharismaBasedSkillsDefaultArgs<ExtArgs>
  }

  export type $DeceptionSkillPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DeceptionSkill"
    objects: {
      skill_list: Prisma.$CharismaBasedSkillsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      value: number | null
      mastery: boolean
      name: string
    }, ExtArgs["result"]["deceptionSkill"]>
    composites: {}
  }

  type DeceptionSkillGetPayload<S extends boolean | null | undefined | DeceptionSkillDefaultArgs> = $Result.GetResult<Prisma.$DeceptionSkillPayload, S>

  type DeceptionSkillCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DeceptionSkillFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DeceptionSkillCountAggregateInputType | true
    }

  export interface DeceptionSkillDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DeceptionSkill'], meta: { name: 'DeceptionSkill' } }
    /**
     * Find zero or one DeceptionSkill that matches the filter.
     * @param {DeceptionSkillFindUniqueArgs} args - Arguments to find a DeceptionSkill
     * @example
     * // Get one DeceptionSkill
     * const deceptionSkill = await prisma.deceptionSkill.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DeceptionSkillFindUniqueArgs>(args: SelectSubset<T, DeceptionSkillFindUniqueArgs<ExtArgs>>): Prisma__DeceptionSkillClient<$Result.GetResult<Prisma.$DeceptionSkillPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one DeceptionSkill that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DeceptionSkillFindUniqueOrThrowArgs} args - Arguments to find a DeceptionSkill
     * @example
     * // Get one DeceptionSkill
     * const deceptionSkill = await prisma.deceptionSkill.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DeceptionSkillFindUniqueOrThrowArgs>(args: SelectSubset<T, DeceptionSkillFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DeceptionSkillClient<$Result.GetResult<Prisma.$DeceptionSkillPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first DeceptionSkill that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeceptionSkillFindFirstArgs} args - Arguments to find a DeceptionSkill
     * @example
     * // Get one DeceptionSkill
     * const deceptionSkill = await prisma.deceptionSkill.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DeceptionSkillFindFirstArgs>(args?: SelectSubset<T, DeceptionSkillFindFirstArgs<ExtArgs>>): Prisma__DeceptionSkillClient<$Result.GetResult<Prisma.$DeceptionSkillPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first DeceptionSkill that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeceptionSkillFindFirstOrThrowArgs} args - Arguments to find a DeceptionSkill
     * @example
     * // Get one DeceptionSkill
     * const deceptionSkill = await prisma.deceptionSkill.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DeceptionSkillFindFirstOrThrowArgs>(args?: SelectSubset<T, DeceptionSkillFindFirstOrThrowArgs<ExtArgs>>): Prisma__DeceptionSkillClient<$Result.GetResult<Prisma.$DeceptionSkillPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more DeceptionSkills that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeceptionSkillFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DeceptionSkills
     * const deceptionSkills = await prisma.deceptionSkill.findMany()
     * 
     * // Get first 10 DeceptionSkills
     * const deceptionSkills = await prisma.deceptionSkill.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const deceptionSkillWithIdOnly = await prisma.deceptionSkill.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DeceptionSkillFindManyArgs>(args?: SelectSubset<T, DeceptionSkillFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeceptionSkillPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a DeceptionSkill.
     * @param {DeceptionSkillCreateArgs} args - Arguments to create a DeceptionSkill.
     * @example
     * // Create one DeceptionSkill
     * const DeceptionSkill = await prisma.deceptionSkill.create({
     *   data: {
     *     // ... data to create a DeceptionSkill
     *   }
     * })
     * 
     */
    create<T extends DeceptionSkillCreateArgs>(args: SelectSubset<T, DeceptionSkillCreateArgs<ExtArgs>>): Prisma__DeceptionSkillClient<$Result.GetResult<Prisma.$DeceptionSkillPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many DeceptionSkills.
     * @param {DeceptionSkillCreateManyArgs} args - Arguments to create many DeceptionSkills.
     * @example
     * // Create many DeceptionSkills
     * const deceptionSkill = await prisma.deceptionSkill.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DeceptionSkillCreateManyArgs>(args?: SelectSubset<T, DeceptionSkillCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DeceptionSkills and returns the data saved in the database.
     * @param {DeceptionSkillCreateManyAndReturnArgs} args - Arguments to create many DeceptionSkills.
     * @example
     * // Create many DeceptionSkills
     * const deceptionSkill = await prisma.deceptionSkill.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DeceptionSkills and only return the `id`
     * const deceptionSkillWithIdOnly = await prisma.deceptionSkill.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DeceptionSkillCreateManyAndReturnArgs>(args?: SelectSubset<T, DeceptionSkillCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeceptionSkillPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a DeceptionSkill.
     * @param {DeceptionSkillDeleteArgs} args - Arguments to delete one DeceptionSkill.
     * @example
     * // Delete one DeceptionSkill
     * const DeceptionSkill = await prisma.deceptionSkill.delete({
     *   where: {
     *     // ... filter to delete one DeceptionSkill
     *   }
     * })
     * 
     */
    delete<T extends DeceptionSkillDeleteArgs>(args: SelectSubset<T, DeceptionSkillDeleteArgs<ExtArgs>>): Prisma__DeceptionSkillClient<$Result.GetResult<Prisma.$DeceptionSkillPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one DeceptionSkill.
     * @param {DeceptionSkillUpdateArgs} args - Arguments to update one DeceptionSkill.
     * @example
     * // Update one DeceptionSkill
     * const deceptionSkill = await prisma.deceptionSkill.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DeceptionSkillUpdateArgs>(args: SelectSubset<T, DeceptionSkillUpdateArgs<ExtArgs>>): Prisma__DeceptionSkillClient<$Result.GetResult<Prisma.$DeceptionSkillPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more DeceptionSkills.
     * @param {DeceptionSkillDeleteManyArgs} args - Arguments to filter DeceptionSkills to delete.
     * @example
     * // Delete a few DeceptionSkills
     * const { count } = await prisma.deceptionSkill.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DeceptionSkillDeleteManyArgs>(args?: SelectSubset<T, DeceptionSkillDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DeceptionSkills.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeceptionSkillUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DeceptionSkills
     * const deceptionSkill = await prisma.deceptionSkill.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DeceptionSkillUpdateManyArgs>(args: SelectSubset<T, DeceptionSkillUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DeceptionSkills and returns the data updated in the database.
     * @param {DeceptionSkillUpdateManyAndReturnArgs} args - Arguments to update many DeceptionSkills.
     * @example
     * // Update many DeceptionSkills
     * const deceptionSkill = await prisma.deceptionSkill.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more DeceptionSkills and only return the `id`
     * const deceptionSkillWithIdOnly = await prisma.deceptionSkill.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DeceptionSkillUpdateManyAndReturnArgs>(args: SelectSubset<T, DeceptionSkillUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeceptionSkillPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one DeceptionSkill.
     * @param {DeceptionSkillUpsertArgs} args - Arguments to update or create a DeceptionSkill.
     * @example
     * // Update or create a DeceptionSkill
     * const deceptionSkill = await prisma.deceptionSkill.upsert({
     *   create: {
     *     // ... data to create a DeceptionSkill
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DeceptionSkill we want to update
     *   }
     * })
     */
    upsert<T extends DeceptionSkillUpsertArgs>(args: SelectSubset<T, DeceptionSkillUpsertArgs<ExtArgs>>): Prisma__DeceptionSkillClient<$Result.GetResult<Prisma.$DeceptionSkillPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of DeceptionSkills.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeceptionSkillCountArgs} args - Arguments to filter DeceptionSkills to count.
     * @example
     * // Count the number of DeceptionSkills
     * const count = await prisma.deceptionSkill.count({
     *   where: {
     *     // ... the filter for the DeceptionSkills we want to count
     *   }
     * })
    **/
    count<T extends DeceptionSkillCountArgs>(
      args?: Subset<T, DeceptionSkillCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DeceptionSkillCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DeceptionSkill.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeceptionSkillAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DeceptionSkillAggregateArgs>(args: Subset<T, DeceptionSkillAggregateArgs>): Prisma.PrismaPromise<GetDeceptionSkillAggregateType<T>>

    /**
     * Group by DeceptionSkill.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeceptionSkillGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DeceptionSkillGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DeceptionSkillGroupByArgs['orderBy'] }
        : { orderBy?: DeceptionSkillGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DeceptionSkillGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDeceptionSkillGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DeceptionSkill model
   */
  readonly fields: DeceptionSkillFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DeceptionSkill.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DeceptionSkillClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    skill_list<T extends CharismaBasedSkillsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CharismaBasedSkillsDefaultArgs<ExtArgs>>): Prisma__CharismaBasedSkillsClient<$Result.GetResult<Prisma.$CharismaBasedSkillsPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DeceptionSkill model
   */ 
  interface DeceptionSkillFieldRefs {
    readonly id: FieldRef<"DeceptionSkill", 'String'>
    readonly value: FieldRef<"DeceptionSkill", 'Int'>
    readonly mastery: FieldRef<"DeceptionSkill", 'Boolean'>
    readonly name: FieldRef<"DeceptionSkill", 'String'>
  }
    

  // Custom InputTypes
  /**
   * DeceptionSkill findUnique
   */
  export type DeceptionSkillFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeceptionSkill
     */
    select?: DeceptionSkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeceptionSkill
     */
    omit?: DeceptionSkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeceptionSkillInclude<ExtArgs> | null
    /**
     * Filter, which DeceptionSkill to fetch.
     */
    where: DeceptionSkillWhereUniqueInput
  }

  /**
   * DeceptionSkill findUniqueOrThrow
   */
  export type DeceptionSkillFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeceptionSkill
     */
    select?: DeceptionSkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeceptionSkill
     */
    omit?: DeceptionSkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeceptionSkillInclude<ExtArgs> | null
    /**
     * Filter, which DeceptionSkill to fetch.
     */
    where: DeceptionSkillWhereUniqueInput
  }

  /**
   * DeceptionSkill findFirst
   */
  export type DeceptionSkillFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeceptionSkill
     */
    select?: DeceptionSkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeceptionSkill
     */
    omit?: DeceptionSkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeceptionSkillInclude<ExtArgs> | null
    /**
     * Filter, which DeceptionSkill to fetch.
     */
    where?: DeceptionSkillWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeceptionSkills to fetch.
     */
    orderBy?: DeceptionSkillOrderByWithRelationInput | DeceptionSkillOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DeceptionSkills.
     */
    cursor?: DeceptionSkillWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeceptionSkills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeceptionSkills.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DeceptionSkills.
     */
    distinct?: DeceptionSkillScalarFieldEnum | DeceptionSkillScalarFieldEnum[]
  }

  /**
   * DeceptionSkill findFirstOrThrow
   */
  export type DeceptionSkillFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeceptionSkill
     */
    select?: DeceptionSkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeceptionSkill
     */
    omit?: DeceptionSkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeceptionSkillInclude<ExtArgs> | null
    /**
     * Filter, which DeceptionSkill to fetch.
     */
    where?: DeceptionSkillWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeceptionSkills to fetch.
     */
    orderBy?: DeceptionSkillOrderByWithRelationInput | DeceptionSkillOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DeceptionSkills.
     */
    cursor?: DeceptionSkillWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeceptionSkills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeceptionSkills.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DeceptionSkills.
     */
    distinct?: DeceptionSkillScalarFieldEnum | DeceptionSkillScalarFieldEnum[]
  }

  /**
   * DeceptionSkill findMany
   */
  export type DeceptionSkillFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeceptionSkill
     */
    select?: DeceptionSkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeceptionSkill
     */
    omit?: DeceptionSkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeceptionSkillInclude<ExtArgs> | null
    /**
     * Filter, which DeceptionSkills to fetch.
     */
    where?: DeceptionSkillWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeceptionSkills to fetch.
     */
    orderBy?: DeceptionSkillOrderByWithRelationInput | DeceptionSkillOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DeceptionSkills.
     */
    cursor?: DeceptionSkillWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeceptionSkills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeceptionSkills.
     */
    skip?: number
    distinct?: DeceptionSkillScalarFieldEnum | DeceptionSkillScalarFieldEnum[]
  }

  /**
   * DeceptionSkill create
   */
  export type DeceptionSkillCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeceptionSkill
     */
    select?: DeceptionSkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeceptionSkill
     */
    omit?: DeceptionSkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeceptionSkillInclude<ExtArgs> | null
    /**
     * The data needed to create a DeceptionSkill.
     */
    data: XOR<DeceptionSkillCreateInput, DeceptionSkillUncheckedCreateInput>
  }

  /**
   * DeceptionSkill createMany
   */
  export type DeceptionSkillCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DeceptionSkills.
     */
    data: DeceptionSkillCreateManyInput | DeceptionSkillCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DeceptionSkill createManyAndReturn
   */
  export type DeceptionSkillCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeceptionSkill
     */
    select?: DeceptionSkillSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DeceptionSkill
     */
    omit?: DeceptionSkillOmit<ExtArgs> | null
    /**
     * The data used to create many DeceptionSkills.
     */
    data: DeceptionSkillCreateManyInput | DeceptionSkillCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeceptionSkillIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * DeceptionSkill update
   */
  export type DeceptionSkillUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeceptionSkill
     */
    select?: DeceptionSkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeceptionSkill
     */
    omit?: DeceptionSkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeceptionSkillInclude<ExtArgs> | null
    /**
     * The data needed to update a DeceptionSkill.
     */
    data: XOR<DeceptionSkillUpdateInput, DeceptionSkillUncheckedUpdateInput>
    /**
     * Choose, which DeceptionSkill to update.
     */
    where: DeceptionSkillWhereUniqueInput
  }

  /**
   * DeceptionSkill updateMany
   */
  export type DeceptionSkillUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DeceptionSkills.
     */
    data: XOR<DeceptionSkillUpdateManyMutationInput, DeceptionSkillUncheckedUpdateManyInput>
    /**
     * Filter which DeceptionSkills to update
     */
    where?: DeceptionSkillWhereInput
    /**
     * Limit how many DeceptionSkills to update.
     */
    limit?: number
  }

  /**
   * DeceptionSkill updateManyAndReturn
   */
  export type DeceptionSkillUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeceptionSkill
     */
    select?: DeceptionSkillSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DeceptionSkill
     */
    omit?: DeceptionSkillOmit<ExtArgs> | null
    /**
     * The data used to update DeceptionSkills.
     */
    data: XOR<DeceptionSkillUpdateManyMutationInput, DeceptionSkillUncheckedUpdateManyInput>
    /**
     * Filter which DeceptionSkills to update
     */
    where?: DeceptionSkillWhereInput
    /**
     * Limit how many DeceptionSkills to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeceptionSkillIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * DeceptionSkill upsert
   */
  export type DeceptionSkillUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeceptionSkill
     */
    select?: DeceptionSkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeceptionSkill
     */
    omit?: DeceptionSkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeceptionSkillInclude<ExtArgs> | null
    /**
     * The filter to search for the DeceptionSkill to update in case it exists.
     */
    where: DeceptionSkillWhereUniqueInput
    /**
     * In case the DeceptionSkill found by the `where` argument doesn't exist, create a new DeceptionSkill with this data.
     */
    create: XOR<DeceptionSkillCreateInput, DeceptionSkillUncheckedCreateInput>
    /**
     * In case the DeceptionSkill was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DeceptionSkillUpdateInput, DeceptionSkillUncheckedUpdateInput>
  }

  /**
   * DeceptionSkill delete
   */
  export type DeceptionSkillDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeceptionSkill
     */
    select?: DeceptionSkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeceptionSkill
     */
    omit?: DeceptionSkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeceptionSkillInclude<ExtArgs> | null
    /**
     * Filter which DeceptionSkill to delete.
     */
    where: DeceptionSkillWhereUniqueInput
  }

  /**
   * DeceptionSkill deleteMany
   */
  export type DeceptionSkillDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DeceptionSkills to delete
     */
    where?: DeceptionSkillWhereInput
    /**
     * Limit how many DeceptionSkills to delete.
     */
    limit?: number
  }

  /**
   * DeceptionSkill without action
   */
  export type DeceptionSkillDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeceptionSkill
     */
    select?: DeceptionSkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeceptionSkill
     */
    omit?: DeceptionSkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeceptionSkillInclude<ExtArgs> | null
  }


  /**
   * Model IntimidationSkill
   */

  export type AggregateIntimidationSkill = {
    _count: IntimidationSkillCountAggregateOutputType | null
    _avg: IntimidationSkillAvgAggregateOutputType | null
    _sum: IntimidationSkillSumAggregateOutputType | null
    _min: IntimidationSkillMinAggregateOutputType | null
    _max: IntimidationSkillMaxAggregateOutputType | null
  }

  export type IntimidationSkillAvgAggregateOutputType = {
    value: number | null
  }

  export type IntimidationSkillSumAggregateOutputType = {
    value: number | null
  }

  export type IntimidationSkillMinAggregateOutputType = {
    id: string | null
    value: number | null
    mastery: boolean | null
    name: string | null
  }

  export type IntimidationSkillMaxAggregateOutputType = {
    id: string | null
    value: number | null
    mastery: boolean | null
    name: string | null
  }

  export type IntimidationSkillCountAggregateOutputType = {
    id: number
    value: number
    mastery: number
    name: number
    _all: number
  }


  export type IntimidationSkillAvgAggregateInputType = {
    value?: true
  }

  export type IntimidationSkillSumAggregateInputType = {
    value?: true
  }

  export type IntimidationSkillMinAggregateInputType = {
    id?: true
    value?: true
    mastery?: true
    name?: true
  }

  export type IntimidationSkillMaxAggregateInputType = {
    id?: true
    value?: true
    mastery?: true
    name?: true
  }

  export type IntimidationSkillCountAggregateInputType = {
    id?: true
    value?: true
    mastery?: true
    name?: true
    _all?: true
  }

  export type IntimidationSkillAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which IntimidationSkill to aggregate.
     */
    where?: IntimidationSkillWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IntimidationSkills to fetch.
     */
    orderBy?: IntimidationSkillOrderByWithRelationInput | IntimidationSkillOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: IntimidationSkillWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IntimidationSkills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IntimidationSkills.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned IntimidationSkills
    **/
    _count?: true | IntimidationSkillCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: IntimidationSkillAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: IntimidationSkillSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: IntimidationSkillMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: IntimidationSkillMaxAggregateInputType
  }

  export type GetIntimidationSkillAggregateType<T extends IntimidationSkillAggregateArgs> = {
        [P in keyof T & keyof AggregateIntimidationSkill]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateIntimidationSkill[P]>
      : GetScalarType<T[P], AggregateIntimidationSkill[P]>
  }




  export type IntimidationSkillGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: IntimidationSkillWhereInput
    orderBy?: IntimidationSkillOrderByWithAggregationInput | IntimidationSkillOrderByWithAggregationInput[]
    by: IntimidationSkillScalarFieldEnum[] | IntimidationSkillScalarFieldEnum
    having?: IntimidationSkillScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: IntimidationSkillCountAggregateInputType | true
    _avg?: IntimidationSkillAvgAggregateInputType
    _sum?: IntimidationSkillSumAggregateInputType
    _min?: IntimidationSkillMinAggregateInputType
    _max?: IntimidationSkillMaxAggregateInputType
  }

  export type IntimidationSkillGroupByOutputType = {
    id: string
    value: number | null
    mastery: boolean
    name: string
    _count: IntimidationSkillCountAggregateOutputType | null
    _avg: IntimidationSkillAvgAggregateOutputType | null
    _sum: IntimidationSkillSumAggregateOutputType | null
    _min: IntimidationSkillMinAggregateOutputType | null
    _max: IntimidationSkillMaxAggregateOutputType | null
  }

  type GetIntimidationSkillGroupByPayload<T extends IntimidationSkillGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<IntimidationSkillGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof IntimidationSkillGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], IntimidationSkillGroupByOutputType[P]>
            : GetScalarType<T[P], IntimidationSkillGroupByOutputType[P]>
        }
      >
    >


  export type IntimidationSkillSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    value?: boolean
    mastery?: boolean
    name?: boolean
    skill_list?: boolean | CharismaBasedSkillsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["intimidationSkill"]>

  export type IntimidationSkillSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    value?: boolean
    mastery?: boolean
    name?: boolean
    skill_list?: boolean | CharismaBasedSkillsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["intimidationSkill"]>

  export type IntimidationSkillSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    value?: boolean
    mastery?: boolean
    name?: boolean
    skill_list?: boolean | CharismaBasedSkillsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["intimidationSkill"]>

  export type IntimidationSkillSelectScalar = {
    id?: boolean
    value?: boolean
    mastery?: boolean
    name?: boolean
  }

  export type IntimidationSkillOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "value" | "mastery" | "name", ExtArgs["result"]["intimidationSkill"]>
  export type IntimidationSkillInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    skill_list?: boolean | CharismaBasedSkillsDefaultArgs<ExtArgs>
  }
  export type IntimidationSkillIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    skill_list?: boolean | CharismaBasedSkillsDefaultArgs<ExtArgs>
  }
  export type IntimidationSkillIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    skill_list?: boolean | CharismaBasedSkillsDefaultArgs<ExtArgs>
  }

  export type $IntimidationSkillPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "IntimidationSkill"
    objects: {
      skill_list: Prisma.$CharismaBasedSkillsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      value: number | null
      mastery: boolean
      name: string
    }, ExtArgs["result"]["intimidationSkill"]>
    composites: {}
  }

  type IntimidationSkillGetPayload<S extends boolean | null | undefined | IntimidationSkillDefaultArgs> = $Result.GetResult<Prisma.$IntimidationSkillPayload, S>

  type IntimidationSkillCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<IntimidationSkillFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: IntimidationSkillCountAggregateInputType | true
    }

  export interface IntimidationSkillDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['IntimidationSkill'], meta: { name: 'IntimidationSkill' } }
    /**
     * Find zero or one IntimidationSkill that matches the filter.
     * @param {IntimidationSkillFindUniqueArgs} args - Arguments to find a IntimidationSkill
     * @example
     * // Get one IntimidationSkill
     * const intimidationSkill = await prisma.intimidationSkill.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends IntimidationSkillFindUniqueArgs>(args: SelectSubset<T, IntimidationSkillFindUniqueArgs<ExtArgs>>): Prisma__IntimidationSkillClient<$Result.GetResult<Prisma.$IntimidationSkillPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one IntimidationSkill that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {IntimidationSkillFindUniqueOrThrowArgs} args - Arguments to find a IntimidationSkill
     * @example
     * // Get one IntimidationSkill
     * const intimidationSkill = await prisma.intimidationSkill.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends IntimidationSkillFindUniqueOrThrowArgs>(args: SelectSubset<T, IntimidationSkillFindUniqueOrThrowArgs<ExtArgs>>): Prisma__IntimidationSkillClient<$Result.GetResult<Prisma.$IntimidationSkillPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first IntimidationSkill that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IntimidationSkillFindFirstArgs} args - Arguments to find a IntimidationSkill
     * @example
     * // Get one IntimidationSkill
     * const intimidationSkill = await prisma.intimidationSkill.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends IntimidationSkillFindFirstArgs>(args?: SelectSubset<T, IntimidationSkillFindFirstArgs<ExtArgs>>): Prisma__IntimidationSkillClient<$Result.GetResult<Prisma.$IntimidationSkillPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first IntimidationSkill that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IntimidationSkillFindFirstOrThrowArgs} args - Arguments to find a IntimidationSkill
     * @example
     * // Get one IntimidationSkill
     * const intimidationSkill = await prisma.intimidationSkill.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends IntimidationSkillFindFirstOrThrowArgs>(args?: SelectSubset<T, IntimidationSkillFindFirstOrThrowArgs<ExtArgs>>): Prisma__IntimidationSkillClient<$Result.GetResult<Prisma.$IntimidationSkillPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more IntimidationSkills that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IntimidationSkillFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all IntimidationSkills
     * const intimidationSkills = await prisma.intimidationSkill.findMany()
     * 
     * // Get first 10 IntimidationSkills
     * const intimidationSkills = await prisma.intimidationSkill.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const intimidationSkillWithIdOnly = await prisma.intimidationSkill.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends IntimidationSkillFindManyArgs>(args?: SelectSubset<T, IntimidationSkillFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IntimidationSkillPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a IntimidationSkill.
     * @param {IntimidationSkillCreateArgs} args - Arguments to create a IntimidationSkill.
     * @example
     * // Create one IntimidationSkill
     * const IntimidationSkill = await prisma.intimidationSkill.create({
     *   data: {
     *     // ... data to create a IntimidationSkill
     *   }
     * })
     * 
     */
    create<T extends IntimidationSkillCreateArgs>(args: SelectSubset<T, IntimidationSkillCreateArgs<ExtArgs>>): Prisma__IntimidationSkillClient<$Result.GetResult<Prisma.$IntimidationSkillPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many IntimidationSkills.
     * @param {IntimidationSkillCreateManyArgs} args - Arguments to create many IntimidationSkills.
     * @example
     * // Create many IntimidationSkills
     * const intimidationSkill = await prisma.intimidationSkill.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends IntimidationSkillCreateManyArgs>(args?: SelectSubset<T, IntimidationSkillCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many IntimidationSkills and returns the data saved in the database.
     * @param {IntimidationSkillCreateManyAndReturnArgs} args - Arguments to create many IntimidationSkills.
     * @example
     * // Create many IntimidationSkills
     * const intimidationSkill = await prisma.intimidationSkill.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many IntimidationSkills and only return the `id`
     * const intimidationSkillWithIdOnly = await prisma.intimidationSkill.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends IntimidationSkillCreateManyAndReturnArgs>(args?: SelectSubset<T, IntimidationSkillCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IntimidationSkillPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a IntimidationSkill.
     * @param {IntimidationSkillDeleteArgs} args - Arguments to delete one IntimidationSkill.
     * @example
     * // Delete one IntimidationSkill
     * const IntimidationSkill = await prisma.intimidationSkill.delete({
     *   where: {
     *     // ... filter to delete one IntimidationSkill
     *   }
     * })
     * 
     */
    delete<T extends IntimidationSkillDeleteArgs>(args: SelectSubset<T, IntimidationSkillDeleteArgs<ExtArgs>>): Prisma__IntimidationSkillClient<$Result.GetResult<Prisma.$IntimidationSkillPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one IntimidationSkill.
     * @param {IntimidationSkillUpdateArgs} args - Arguments to update one IntimidationSkill.
     * @example
     * // Update one IntimidationSkill
     * const intimidationSkill = await prisma.intimidationSkill.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends IntimidationSkillUpdateArgs>(args: SelectSubset<T, IntimidationSkillUpdateArgs<ExtArgs>>): Prisma__IntimidationSkillClient<$Result.GetResult<Prisma.$IntimidationSkillPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more IntimidationSkills.
     * @param {IntimidationSkillDeleteManyArgs} args - Arguments to filter IntimidationSkills to delete.
     * @example
     * // Delete a few IntimidationSkills
     * const { count } = await prisma.intimidationSkill.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends IntimidationSkillDeleteManyArgs>(args?: SelectSubset<T, IntimidationSkillDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more IntimidationSkills.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IntimidationSkillUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many IntimidationSkills
     * const intimidationSkill = await prisma.intimidationSkill.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends IntimidationSkillUpdateManyArgs>(args: SelectSubset<T, IntimidationSkillUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more IntimidationSkills and returns the data updated in the database.
     * @param {IntimidationSkillUpdateManyAndReturnArgs} args - Arguments to update many IntimidationSkills.
     * @example
     * // Update many IntimidationSkills
     * const intimidationSkill = await prisma.intimidationSkill.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more IntimidationSkills and only return the `id`
     * const intimidationSkillWithIdOnly = await prisma.intimidationSkill.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends IntimidationSkillUpdateManyAndReturnArgs>(args: SelectSubset<T, IntimidationSkillUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IntimidationSkillPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one IntimidationSkill.
     * @param {IntimidationSkillUpsertArgs} args - Arguments to update or create a IntimidationSkill.
     * @example
     * // Update or create a IntimidationSkill
     * const intimidationSkill = await prisma.intimidationSkill.upsert({
     *   create: {
     *     // ... data to create a IntimidationSkill
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the IntimidationSkill we want to update
     *   }
     * })
     */
    upsert<T extends IntimidationSkillUpsertArgs>(args: SelectSubset<T, IntimidationSkillUpsertArgs<ExtArgs>>): Prisma__IntimidationSkillClient<$Result.GetResult<Prisma.$IntimidationSkillPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of IntimidationSkills.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IntimidationSkillCountArgs} args - Arguments to filter IntimidationSkills to count.
     * @example
     * // Count the number of IntimidationSkills
     * const count = await prisma.intimidationSkill.count({
     *   where: {
     *     // ... the filter for the IntimidationSkills we want to count
     *   }
     * })
    **/
    count<T extends IntimidationSkillCountArgs>(
      args?: Subset<T, IntimidationSkillCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], IntimidationSkillCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a IntimidationSkill.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IntimidationSkillAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends IntimidationSkillAggregateArgs>(args: Subset<T, IntimidationSkillAggregateArgs>): Prisma.PrismaPromise<GetIntimidationSkillAggregateType<T>>

    /**
     * Group by IntimidationSkill.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IntimidationSkillGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends IntimidationSkillGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: IntimidationSkillGroupByArgs['orderBy'] }
        : { orderBy?: IntimidationSkillGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, IntimidationSkillGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetIntimidationSkillGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the IntimidationSkill model
   */
  readonly fields: IntimidationSkillFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for IntimidationSkill.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__IntimidationSkillClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    skill_list<T extends CharismaBasedSkillsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CharismaBasedSkillsDefaultArgs<ExtArgs>>): Prisma__CharismaBasedSkillsClient<$Result.GetResult<Prisma.$CharismaBasedSkillsPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the IntimidationSkill model
   */ 
  interface IntimidationSkillFieldRefs {
    readonly id: FieldRef<"IntimidationSkill", 'String'>
    readonly value: FieldRef<"IntimidationSkill", 'Int'>
    readonly mastery: FieldRef<"IntimidationSkill", 'Boolean'>
    readonly name: FieldRef<"IntimidationSkill", 'String'>
  }
    

  // Custom InputTypes
  /**
   * IntimidationSkill findUnique
   */
  export type IntimidationSkillFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IntimidationSkill
     */
    select?: IntimidationSkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IntimidationSkill
     */
    omit?: IntimidationSkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IntimidationSkillInclude<ExtArgs> | null
    /**
     * Filter, which IntimidationSkill to fetch.
     */
    where: IntimidationSkillWhereUniqueInput
  }

  /**
   * IntimidationSkill findUniqueOrThrow
   */
  export type IntimidationSkillFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IntimidationSkill
     */
    select?: IntimidationSkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IntimidationSkill
     */
    omit?: IntimidationSkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IntimidationSkillInclude<ExtArgs> | null
    /**
     * Filter, which IntimidationSkill to fetch.
     */
    where: IntimidationSkillWhereUniqueInput
  }

  /**
   * IntimidationSkill findFirst
   */
  export type IntimidationSkillFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IntimidationSkill
     */
    select?: IntimidationSkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IntimidationSkill
     */
    omit?: IntimidationSkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IntimidationSkillInclude<ExtArgs> | null
    /**
     * Filter, which IntimidationSkill to fetch.
     */
    where?: IntimidationSkillWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IntimidationSkills to fetch.
     */
    orderBy?: IntimidationSkillOrderByWithRelationInput | IntimidationSkillOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for IntimidationSkills.
     */
    cursor?: IntimidationSkillWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IntimidationSkills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IntimidationSkills.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of IntimidationSkills.
     */
    distinct?: IntimidationSkillScalarFieldEnum | IntimidationSkillScalarFieldEnum[]
  }

  /**
   * IntimidationSkill findFirstOrThrow
   */
  export type IntimidationSkillFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IntimidationSkill
     */
    select?: IntimidationSkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IntimidationSkill
     */
    omit?: IntimidationSkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IntimidationSkillInclude<ExtArgs> | null
    /**
     * Filter, which IntimidationSkill to fetch.
     */
    where?: IntimidationSkillWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IntimidationSkills to fetch.
     */
    orderBy?: IntimidationSkillOrderByWithRelationInput | IntimidationSkillOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for IntimidationSkills.
     */
    cursor?: IntimidationSkillWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IntimidationSkills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IntimidationSkills.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of IntimidationSkills.
     */
    distinct?: IntimidationSkillScalarFieldEnum | IntimidationSkillScalarFieldEnum[]
  }

  /**
   * IntimidationSkill findMany
   */
  export type IntimidationSkillFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IntimidationSkill
     */
    select?: IntimidationSkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IntimidationSkill
     */
    omit?: IntimidationSkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IntimidationSkillInclude<ExtArgs> | null
    /**
     * Filter, which IntimidationSkills to fetch.
     */
    where?: IntimidationSkillWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IntimidationSkills to fetch.
     */
    orderBy?: IntimidationSkillOrderByWithRelationInput | IntimidationSkillOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing IntimidationSkills.
     */
    cursor?: IntimidationSkillWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IntimidationSkills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IntimidationSkills.
     */
    skip?: number
    distinct?: IntimidationSkillScalarFieldEnum | IntimidationSkillScalarFieldEnum[]
  }

  /**
   * IntimidationSkill create
   */
  export type IntimidationSkillCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IntimidationSkill
     */
    select?: IntimidationSkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IntimidationSkill
     */
    omit?: IntimidationSkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IntimidationSkillInclude<ExtArgs> | null
    /**
     * The data needed to create a IntimidationSkill.
     */
    data: XOR<IntimidationSkillCreateInput, IntimidationSkillUncheckedCreateInput>
  }

  /**
   * IntimidationSkill createMany
   */
  export type IntimidationSkillCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many IntimidationSkills.
     */
    data: IntimidationSkillCreateManyInput | IntimidationSkillCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * IntimidationSkill createManyAndReturn
   */
  export type IntimidationSkillCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IntimidationSkill
     */
    select?: IntimidationSkillSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the IntimidationSkill
     */
    omit?: IntimidationSkillOmit<ExtArgs> | null
    /**
     * The data used to create many IntimidationSkills.
     */
    data: IntimidationSkillCreateManyInput | IntimidationSkillCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IntimidationSkillIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * IntimidationSkill update
   */
  export type IntimidationSkillUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IntimidationSkill
     */
    select?: IntimidationSkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IntimidationSkill
     */
    omit?: IntimidationSkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IntimidationSkillInclude<ExtArgs> | null
    /**
     * The data needed to update a IntimidationSkill.
     */
    data: XOR<IntimidationSkillUpdateInput, IntimidationSkillUncheckedUpdateInput>
    /**
     * Choose, which IntimidationSkill to update.
     */
    where: IntimidationSkillWhereUniqueInput
  }

  /**
   * IntimidationSkill updateMany
   */
  export type IntimidationSkillUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update IntimidationSkills.
     */
    data: XOR<IntimidationSkillUpdateManyMutationInput, IntimidationSkillUncheckedUpdateManyInput>
    /**
     * Filter which IntimidationSkills to update
     */
    where?: IntimidationSkillWhereInput
    /**
     * Limit how many IntimidationSkills to update.
     */
    limit?: number
  }

  /**
   * IntimidationSkill updateManyAndReturn
   */
  export type IntimidationSkillUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IntimidationSkill
     */
    select?: IntimidationSkillSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the IntimidationSkill
     */
    omit?: IntimidationSkillOmit<ExtArgs> | null
    /**
     * The data used to update IntimidationSkills.
     */
    data: XOR<IntimidationSkillUpdateManyMutationInput, IntimidationSkillUncheckedUpdateManyInput>
    /**
     * Filter which IntimidationSkills to update
     */
    where?: IntimidationSkillWhereInput
    /**
     * Limit how many IntimidationSkills to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IntimidationSkillIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * IntimidationSkill upsert
   */
  export type IntimidationSkillUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IntimidationSkill
     */
    select?: IntimidationSkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IntimidationSkill
     */
    omit?: IntimidationSkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IntimidationSkillInclude<ExtArgs> | null
    /**
     * The filter to search for the IntimidationSkill to update in case it exists.
     */
    where: IntimidationSkillWhereUniqueInput
    /**
     * In case the IntimidationSkill found by the `where` argument doesn't exist, create a new IntimidationSkill with this data.
     */
    create: XOR<IntimidationSkillCreateInput, IntimidationSkillUncheckedCreateInput>
    /**
     * In case the IntimidationSkill was found with the provided `where` argument, update it with this data.
     */
    update: XOR<IntimidationSkillUpdateInput, IntimidationSkillUncheckedUpdateInput>
  }

  /**
   * IntimidationSkill delete
   */
  export type IntimidationSkillDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IntimidationSkill
     */
    select?: IntimidationSkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IntimidationSkill
     */
    omit?: IntimidationSkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IntimidationSkillInclude<ExtArgs> | null
    /**
     * Filter which IntimidationSkill to delete.
     */
    where: IntimidationSkillWhereUniqueInput
  }

  /**
   * IntimidationSkill deleteMany
   */
  export type IntimidationSkillDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which IntimidationSkills to delete
     */
    where?: IntimidationSkillWhereInput
    /**
     * Limit how many IntimidationSkills to delete.
     */
    limit?: number
  }

  /**
   * IntimidationSkill without action
   */
  export type IntimidationSkillDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IntimidationSkill
     */
    select?: IntimidationSkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IntimidationSkill
     */
    omit?: IntimidationSkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IntimidationSkillInclude<ExtArgs> | null
  }


  /**
   * Model PerformanceSkill
   */

  export type AggregatePerformanceSkill = {
    _count: PerformanceSkillCountAggregateOutputType | null
    _avg: PerformanceSkillAvgAggregateOutputType | null
    _sum: PerformanceSkillSumAggregateOutputType | null
    _min: PerformanceSkillMinAggregateOutputType | null
    _max: PerformanceSkillMaxAggregateOutputType | null
  }

  export type PerformanceSkillAvgAggregateOutputType = {
    value: number | null
  }

  export type PerformanceSkillSumAggregateOutputType = {
    value: number | null
  }

  export type PerformanceSkillMinAggregateOutputType = {
    id: string | null
    value: number | null
    mastery: boolean | null
    name: string | null
  }

  export type PerformanceSkillMaxAggregateOutputType = {
    id: string | null
    value: number | null
    mastery: boolean | null
    name: string | null
  }

  export type PerformanceSkillCountAggregateOutputType = {
    id: number
    value: number
    mastery: number
    name: number
    _all: number
  }


  export type PerformanceSkillAvgAggregateInputType = {
    value?: true
  }

  export type PerformanceSkillSumAggregateInputType = {
    value?: true
  }

  export type PerformanceSkillMinAggregateInputType = {
    id?: true
    value?: true
    mastery?: true
    name?: true
  }

  export type PerformanceSkillMaxAggregateInputType = {
    id?: true
    value?: true
    mastery?: true
    name?: true
  }

  export type PerformanceSkillCountAggregateInputType = {
    id?: true
    value?: true
    mastery?: true
    name?: true
    _all?: true
  }

  export type PerformanceSkillAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PerformanceSkill to aggregate.
     */
    where?: PerformanceSkillWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PerformanceSkills to fetch.
     */
    orderBy?: PerformanceSkillOrderByWithRelationInput | PerformanceSkillOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PerformanceSkillWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PerformanceSkills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PerformanceSkills.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PerformanceSkills
    **/
    _count?: true | PerformanceSkillCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PerformanceSkillAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PerformanceSkillSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PerformanceSkillMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PerformanceSkillMaxAggregateInputType
  }

  export type GetPerformanceSkillAggregateType<T extends PerformanceSkillAggregateArgs> = {
        [P in keyof T & keyof AggregatePerformanceSkill]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePerformanceSkill[P]>
      : GetScalarType<T[P], AggregatePerformanceSkill[P]>
  }




  export type PerformanceSkillGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PerformanceSkillWhereInput
    orderBy?: PerformanceSkillOrderByWithAggregationInput | PerformanceSkillOrderByWithAggregationInput[]
    by: PerformanceSkillScalarFieldEnum[] | PerformanceSkillScalarFieldEnum
    having?: PerformanceSkillScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PerformanceSkillCountAggregateInputType | true
    _avg?: PerformanceSkillAvgAggregateInputType
    _sum?: PerformanceSkillSumAggregateInputType
    _min?: PerformanceSkillMinAggregateInputType
    _max?: PerformanceSkillMaxAggregateInputType
  }

  export type PerformanceSkillGroupByOutputType = {
    id: string
    value: number | null
    mastery: boolean
    name: string
    _count: PerformanceSkillCountAggregateOutputType | null
    _avg: PerformanceSkillAvgAggregateOutputType | null
    _sum: PerformanceSkillSumAggregateOutputType | null
    _min: PerformanceSkillMinAggregateOutputType | null
    _max: PerformanceSkillMaxAggregateOutputType | null
  }

  type GetPerformanceSkillGroupByPayload<T extends PerformanceSkillGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PerformanceSkillGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PerformanceSkillGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PerformanceSkillGroupByOutputType[P]>
            : GetScalarType<T[P], PerformanceSkillGroupByOutputType[P]>
        }
      >
    >


  export type PerformanceSkillSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    value?: boolean
    mastery?: boolean
    name?: boolean
    skill_list?: boolean | CharismaBasedSkillsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["performanceSkill"]>

  export type PerformanceSkillSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    value?: boolean
    mastery?: boolean
    name?: boolean
    skill_list?: boolean | CharismaBasedSkillsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["performanceSkill"]>

  export type PerformanceSkillSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    value?: boolean
    mastery?: boolean
    name?: boolean
    skill_list?: boolean | CharismaBasedSkillsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["performanceSkill"]>

  export type PerformanceSkillSelectScalar = {
    id?: boolean
    value?: boolean
    mastery?: boolean
    name?: boolean
  }

  export type PerformanceSkillOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "value" | "mastery" | "name", ExtArgs["result"]["performanceSkill"]>
  export type PerformanceSkillInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    skill_list?: boolean | CharismaBasedSkillsDefaultArgs<ExtArgs>
  }
  export type PerformanceSkillIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    skill_list?: boolean | CharismaBasedSkillsDefaultArgs<ExtArgs>
  }
  export type PerformanceSkillIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    skill_list?: boolean | CharismaBasedSkillsDefaultArgs<ExtArgs>
  }

  export type $PerformanceSkillPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PerformanceSkill"
    objects: {
      skill_list: Prisma.$CharismaBasedSkillsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      value: number | null
      mastery: boolean
      name: string
    }, ExtArgs["result"]["performanceSkill"]>
    composites: {}
  }

  type PerformanceSkillGetPayload<S extends boolean | null | undefined | PerformanceSkillDefaultArgs> = $Result.GetResult<Prisma.$PerformanceSkillPayload, S>

  type PerformanceSkillCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PerformanceSkillFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PerformanceSkillCountAggregateInputType | true
    }

  export interface PerformanceSkillDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PerformanceSkill'], meta: { name: 'PerformanceSkill' } }
    /**
     * Find zero or one PerformanceSkill that matches the filter.
     * @param {PerformanceSkillFindUniqueArgs} args - Arguments to find a PerformanceSkill
     * @example
     * // Get one PerformanceSkill
     * const performanceSkill = await prisma.performanceSkill.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PerformanceSkillFindUniqueArgs>(args: SelectSubset<T, PerformanceSkillFindUniqueArgs<ExtArgs>>): Prisma__PerformanceSkillClient<$Result.GetResult<Prisma.$PerformanceSkillPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one PerformanceSkill that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PerformanceSkillFindUniqueOrThrowArgs} args - Arguments to find a PerformanceSkill
     * @example
     * // Get one PerformanceSkill
     * const performanceSkill = await prisma.performanceSkill.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PerformanceSkillFindUniqueOrThrowArgs>(args: SelectSubset<T, PerformanceSkillFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PerformanceSkillClient<$Result.GetResult<Prisma.$PerformanceSkillPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first PerformanceSkill that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PerformanceSkillFindFirstArgs} args - Arguments to find a PerformanceSkill
     * @example
     * // Get one PerformanceSkill
     * const performanceSkill = await prisma.performanceSkill.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PerformanceSkillFindFirstArgs>(args?: SelectSubset<T, PerformanceSkillFindFirstArgs<ExtArgs>>): Prisma__PerformanceSkillClient<$Result.GetResult<Prisma.$PerformanceSkillPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first PerformanceSkill that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PerformanceSkillFindFirstOrThrowArgs} args - Arguments to find a PerformanceSkill
     * @example
     * // Get one PerformanceSkill
     * const performanceSkill = await prisma.performanceSkill.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PerformanceSkillFindFirstOrThrowArgs>(args?: SelectSubset<T, PerformanceSkillFindFirstOrThrowArgs<ExtArgs>>): Prisma__PerformanceSkillClient<$Result.GetResult<Prisma.$PerformanceSkillPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more PerformanceSkills that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PerformanceSkillFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PerformanceSkills
     * const performanceSkills = await prisma.performanceSkill.findMany()
     * 
     * // Get first 10 PerformanceSkills
     * const performanceSkills = await prisma.performanceSkill.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const performanceSkillWithIdOnly = await prisma.performanceSkill.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PerformanceSkillFindManyArgs>(args?: SelectSubset<T, PerformanceSkillFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PerformanceSkillPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a PerformanceSkill.
     * @param {PerformanceSkillCreateArgs} args - Arguments to create a PerformanceSkill.
     * @example
     * // Create one PerformanceSkill
     * const PerformanceSkill = await prisma.performanceSkill.create({
     *   data: {
     *     // ... data to create a PerformanceSkill
     *   }
     * })
     * 
     */
    create<T extends PerformanceSkillCreateArgs>(args: SelectSubset<T, PerformanceSkillCreateArgs<ExtArgs>>): Prisma__PerformanceSkillClient<$Result.GetResult<Prisma.$PerformanceSkillPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many PerformanceSkills.
     * @param {PerformanceSkillCreateManyArgs} args - Arguments to create many PerformanceSkills.
     * @example
     * // Create many PerformanceSkills
     * const performanceSkill = await prisma.performanceSkill.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PerformanceSkillCreateManyArgs>(args?: SelectSubset<T, PerformanceSkillCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PerformanceSkills and returns the data saved in the database.
     * @param {PerformanceSkillCreateManyAndReturnArgs} args - Arguments to create many PerformanceSkills.
     * @example
     * // Create many PerformanceSkills
     * const performanceSkill = await prisma.performanceSkill.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PerformanceSkills and only return the `id`
     * const performanceSkillWithIdOnly = await prisma.performanceSkill.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PerformanceSkillCreateManyAndReturnArgs>(args?: SelectSubset<T, PerformanceSkillCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PerformanceSkillPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a PerformanceSkill.
     * @param {PerformanceSkillDeleteArgs} args - Arguments to delete one PerformanceSkill.
     * @example
     * // Delete one PerformanceSkill
     * const PerformanceSkill = await prisma.performanceSkill.delete({
     *   where: {
     *     // ... filter to delete one PerformanceSkill
     *   }
     * })
     * 
     */
    delete<T extends PerformanceSkillDeleteArgs>(args: SelectSubset<T, PerformanceSkillDeleteArgs<ExtArgs>>): Prisma__PerformanceSkillClient<$Result.GetResult<Prisma.$PerformanceSkillPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one PerformanceSkill.
     * @param {PerformanceSkillUpdateArgs} args - Arguments to update one PerformanceSkill.
     * @example
     * // Update one PerformanceSkill
     * const performanceSkill = await prisma.performanceSkill.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PerformanceSkillUpdateArgs>(args: SelectSubset<T, PerformanceSkillUpdateArgs<ExtArgs>>): Prisma__PerformanceSkillClient<$Result.GetResult<Prisma.$PerformanceSkillPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more PerformanceSkills.
     * @param {PerformanceSkillDeleteManyArgs} args - Arguments to filter PerformanceSkills to delete.
     * @example
     * // Delete a few PerformanceSkills
     * const { count } = await prisma.performanceSkill.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PerformanceSkillDeleteManyArgs>(args?: SelectSubset<T, PerformanceSkillDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PerformanceSkills.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PerformanceSkillUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PerformanceSkills
     * const performanceSkill = await prisma.performanceSkill.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PerformanceSkillUpdateManyArgs>(args: SelectSubset<T, PerformanceSkillUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PerformanceSkills and returns the data updated in the database.
     * @param {PerformanceSkillUpdateManyAndReturnArgs} args - Arguments to update many PerformanceSkills.
     * @example
     * // Update many PerformanceSkills
     * const performanceSkill = await prisma.performanceSkill.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PerformanceSkills and only return the `id`
     * const performanceSkillWithIdOnly = await prisma.performanceSkill.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PerformanceSkillUpdateManyAndReturnArgs>(args: SelectSubset<T, PerformanceSkillUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PerformanceSkillPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one PerformanceSkill.
     * @param {PerformanceSkillUpsertArgs} args - Arguments to update or create a PerformanceSkill.
     * @example
     * // Update or create a PerformanceSkill
     * const performanceSkill = await prisma.performanceSkill.upsert({
     *   create: {
     *     // ... data to create a PerformanceSkill
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PerformanceSkill we want to update
     *   }
     * })
     */
    upsert<T extends PerformanceSkillUpsertArgs>(args: SelectSubset<T, PerformanceSkillUpsertArgs<ExtArgs>>): Prisma__PerformanceSkillClient<$Result.GetResult<Prisma.$PerformanceSkillPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of PerformanceSkills.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PerformanceSkillCountArgs} args - Arguments to filter PerformanceSkills to count.
     * @example
     * // Count the number of PerformanceSkills
     * const count = await prisma.performanceSkill.count({
     *   where: {
     *     // ... the filter for the PerformanceSkills we want to count
     *   }
     * })
    **/
    count<T extends PerformanceSkillCountArgs>(
      args?: Subset<T, PerformanceSkillCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PerformanceSkillCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PerformanceSkill.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PerformanceSkillAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PerformanceSkillAggregateArgs>(args: Subset<T, PerformanceSkillAggregateArgs>): Prisma.PrismaPromise<GetPerformanceSkillAggregateType<T>>

    /**
     * Group by PerformanceSkill.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PerformanceSkillGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PerformanceSkillGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PerformanceSkillGroupByArgs['orderBy'] }
        : { orderBy?: PerformanceSkillGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PerformanceSkillGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPerformanceSkillGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PerformanceSkill model
   */
  readonly fields: PerformanceSkillFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PerformanceSkill.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PerformanceSkillClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    skill_list<T extends CharismaBasedSkillsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CharismaBasedSkillsDefaultArgs<ExtArgs>>): Prisma__CharismaBasedSkillsClient<$Result.GetResult<Prisma.$CharismaBasedSkillsPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PerformanceSkill model
   */ 
  interface PerformanceSkillFieldRefs {
    readonly id: FieldRef<"PerformanceSkill", 'String'>
    readonly value: FieldRef<"PerformanceSkill", 'Int'>
    readonly mastery: FieldRef<"PerformanceSkill", 'Boolean'>
    readonly name: FieldRef<"PerformanceSkill", 'String'>
  }
    

  // Custom InputTypes
  /**
   * PerformanceSkill findUnique
   */
  export type PerformanceSkillFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PerformanceSkill
     */
    select?: PerformanceSkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PerformanceSkill
     */
    omit?: PerformanceSkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PerformanceSkillInclude<ExtArgs> | null
    /**
     * Filter, which PerformanceSkill to fetch.
     */
    where: PerformanceSkillWhereUniqueInput
  }

  /**
   * PerformanceSkill findUniqueOrThrow
   */
  export type PerformanceSkillFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PerformanceSkill
     */
    select?: PerformanceSkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PerformanceSkill
     */
    omit?: PerformanceSkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PerformanceSkillInclude<ExtArgs> | null
    /**
     * Filter, which PerformanceSkill to fetch.
     */
    where: PerformanceSkillWhereUniqueInput
  }

  /**
   * PerformanceSkill findFirst
   */
  export type PerformanceSkillFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PerformanceSkill
     */
    select?: PerformanceSkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PerformanceSkill
     */
    omit?: PerformanceSkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PerformanceSkillInclude<ExtArgs> | null
    /**
     * Filter, which PerformanceSkill to fetch.
     */
    where?: PerformanceSkillWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PerformanceSkills to fetch.
     */
    orderBy?: PerformanceSkillOrderByWithRelationInput | PerformanceSkillOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PerformanceSkills.
     */
    cursor?: PerformanceSkillWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PerformanceSkills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PerformanceSkills.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PerformanceSkills.
     */
    distinct?: PerformanceSkillScalarFieldEnum | PerformanceSkillScalarFieldEnum[]
  }

  /**
   * PerformanceSkill findFirstOrThrow
   */
  export type PerformanceSkillFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PerformanceSkill
     */
    select?: PerformanceSkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PerformanceSkill
     */
    omit?: PerformanceSkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PerformanceSkillInclude<ExtArgs> | null
    /**
     * Filter, which PerformanceSkill to fetch.
     */
    where?: PerformanceSkillWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PerformanceSkills to fetch.
     */
    orderBy?: PerformanceSkillOrderByWithRelationInput | PerformanceSkillOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PerformanceSkills.
     */
    cursor?: PerformanceSkillWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PerformanceSkills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PerformanceSkills.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PerformanceSkills.
     */
    distinct?: PerformanceSkillScalarFieldEnum | PerformanceSkillScalarFieldEnum[]
  }

  /**
   * PerformanceSkill findMany
   */
  export type PerformanceSkillFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PerformanceSkill
     */
    select?: PerformanceSkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PerformanceSkill
     */
    omit?: PerformanceSkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PerformanceSkillInclude<ExtArgs> | null
    /**
     * Filter, which PerformanceSkills to fetch.
     */
    where?: PerformanceSkillWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PerformanceSkills to fetch.
     */
    orderBy?: PerformanceSkillOrderByWithRelationInput | PerformanceSkillOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PerformanceSkills.
     */
    cursor?: PerformanceSkillWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PerformanceSkills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PerformanceSkills.
     */
    skip?: number
    distinct?: PerformanceSkillScalarFieldEnum | PerformanceSkillScalarFieldEnum[]
  }

  /**
   * PerformanceSkill create
   */
  export type PerformanceSkillCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PerformanceSkill
     */
    select?: PerformanceSkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PerformanceSkill
     */
    omit?: PerformanceSkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PerformanceSkillInclude<ExtArgs> | null
    /**
     * The data needed to create a PerformanceSkill.
     */
    data: XOR<PerformanceSkillCreateInput, PerformanceSkillUncheckedCreateInput>
  }

  /**
   * PerformanceSkill createMany
   */
  export type PerformanceSkillCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PerformanceSkills.
     */
    data: PerformanceSkillCreateManyInput | PerformanceSkillCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PerformanceSkill createManyAndReturn
   */
  export type PerformanceSkillCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PerformanceSkill
     */
    select?: PerformanceSkillSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PerformanceSkill
     */
    omit?: PerformanceSkillOmit<ExtArgs> | null
    /**
     * The data used to create many PerformanceSkills.
     */
    data: PerformanceSkillCreateManyInput | PerformanceSkillCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PerformanceSkillIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PerformanceSkill update
   */
  export type PerformanceSkillUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PerformanceSkill
     */
    select?: PerformanceSkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PerformanceSkill
     */
    omit?: PerformanceSkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PerformanceSkillInclude<ExtArgs> | null
    /**
     * The data needed to update a PerformanceSkill.
     */
    data: XOR<PerformanceSkillUpdateInput, PerformanceSkillUncheckedUpdateInput>
    /**
     * Choose, which PerformanceSkill to update.
     */
    where: PerformanceSkillWhereUniqueInput
  }

  /**
   * PerformanceSkill updateMany
   */
  export type PerformanceSkillUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PerformanceSkills.
     */
    data: XOR<PerformanceSkillUpdateManyMutationInput, PerformanceSkillUncheckedUpdateManyInput>
    /**
     * Filter which PerformanceSkills to update
     */
    where?: PerformanceSkillWhereInput
    /**
     * Limit how many PerformanceSkills to update.
     */
    limit?: number
  }

  /**
   * PerformanceSkill updateManyAndReturn
   */
  export type PerformanceSkillUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PerformanceSkill
     */
    select?: PerformanceSkillSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PerformanceSkill
     */
    omit?: PerformanceSkillOmit<ExtArgs> | null
    /**
     * The data used to update PerformanceSkills.
     */
    data: XOR<PerformanceSkillUpdateManyMutationInput, PerformanceSkillUncheckedUpdateManyInput>
    /**
     * Filter which PerformanceSkills to update
     */
    where?: PerformanceSkillWhereInput
    /**
     * Limit how many PerformanceSkills to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PerformanceSkillIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PerformanceSkill upsert
   */
  export type PerformanceSkillUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PerformanceSkill
     */
    select?: PerformanceSkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PerformanceSkill
     */
    omit?: PerformanceSkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PerformanceSkillInclude<ExtArgs> | null
    /**
     * The filter to search for the PerformanceSkill to update in case it exists.
     */
    where: PerformanceSkillWhereUniqueInput
    /**
     * In case the PerformanceSkill found by the `where` argument doesn't exist, create a new PerformanceSkill with this data.
     */
    create: XOR<PerformanceSkillCreateInput, PerformanceSkillUncheckedCreateInput>
    /**
     * In case the PerformanceSkill was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PerformanceSkillUpdateInput, PerformanceSkillUncheckedUpdateInput>
  }

  /**
   * PerformanceSkill delete
   */
  export type PerformanceSkillDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PerformanceSkill
     */
    select?: PerformanceSkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PerformanceSkill
     */
    omit?: PerformanceSkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PerformanceSkillInclude<ExtArgs> | null
    /**
     * Filter which PerformanceSkill to delete.
     */
    where: PerformanceSkillWhereUniqueInput
  }

  /**
   * PerformanceSkill deleteMany
   */
  export type PerformanceSkillDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PerformanceSkills to delete
     */
    where?: PerformanceSkillWhereInput
    /**
     * Limit how many PerformanceSkills to delete.
     */
    limit?: number
  }

  /**
   * PerformanceSkill without action
   */
  export type PerformanceSkillDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PerformanceSkill
     */
    select?: PerformanceSkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PerformanceSkill
     */
    omit?: PerformanceSkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PerformanceSkillInclude<ExtArgs> | null
  }


  /**
   * Model PersuasionSkill
   */

  export type AggregatePersuasionSkill = {
    _count: PersuasionSkillCountAggregateOutputType | null
    _avg: PersuasionSkillAvgAggregateOutputType | null
    _sum: PersuasionSkillSumAggregateOutputType | null
    _min: PersuasionSkillMinAggregateOutputType | null
    _max: PersuasionSkillMaxAggregateOutputType | null
  }

  export type PersuasionSkillAvgAggregateOutputType = {
    value: number | null
  }

  export type PersuasionSkillSumAggregateOutputType = {
    value: number | null
  }

  export type PersuasionSkillMinAggregateOutputType = {
    id: string | null
    value: number | null
    mastery: boolean | null
    name: string | null
  }

  export type PersuasionSkillMaxAggregateOutputType = {
    id: string | null
    value: number | null
    mastery: boolean | null
    name: string | null
  }

  export type PersuasionSkillCountAggregateOutputType = {
    id: number
    value: number
    mastery: number
    name: number
    _all: number
  }


  export type PersuasionSkillAvgAggregateInputType = {
    value?: true
  }

  export type PersuasionSkillSumAggregateInputType = {
    value?: true
  }

  export type PersuasionSkillMinAggregateInputType = {
    id?: true
    value?: true
    mastery?: true
    name?: true
  }

  export type PersuasionSkillMaxAggregateInputType = {
    id?: true
    value?: true
    mastery?: true
    name?: true
  }

  export type PersuasionSkillCountAggregateInputType = {
    id?: true
    value?: true
    mastery?: true
    name?: true
    _all?: true
  }

  export type PersuasionSkillAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PersuasionSkill to aggregate.
     */
    where?: PersuasionSkillWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PersuasionSkills to fetch.
     */
    orderBy?: PersuasionSkillOrderByWithRelationInput | PersuasionSkillOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PersuasionSkillWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PersuasionSkills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PersuasionSkills.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PersuasionSkills
    **/
    _count?: true | PersuasionSkillCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PersuasionSkillAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PersuasionSkillSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PersuasionSkillMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PersuasionSkillMaxAggregateInputType
  }

  export type GetPersuasionSkillAggregateType<T extends PersuasionSkillAggregateArgs> = {
        [P in keyof T & keyof AggregatePersuasionSkill]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePersuasionSkill[P]>
      : GetScalarType<T[P], AggregatePersuasionSkill[P]>
  }




  export type PersuasionSkillGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PersuasionSkillWhereInput
    orderBy?: PersuasionSkillOrderByWithAggregationInput | PersuasionSkillOrderByWithAggregationInput[]
    by: PersuasionSkillScalarFieldEnum[] | PersuasionSkillScalarFieldEnum
    having?: PersuasionSkillScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PersuasionSkillCountAggregateInputType | true
    _avg?: PersuasionSkillAvgAggregateInputType
    _sum?: PersuasionSkillSumAggregateInputType
    _min?: PersuasionSkillMinAggregateInputType
    _max?: PersuasionSkillMaxAggregateInputType
  }

  export type PersuasionSkillGroupByOutputType = {
    id: string
    value: number | null
    mastery: boolean
    name: string
    _count: PersuasionSkillCountAggregateOutputType | null
    _avg: PersuasionSkillAvgAggregateOutputType | null
    _sum: PersuasionSkillSumAggregateOutputType | null
    _min: PersuasionSkillMinAggregateOutputType | null
    _max: PersuasionSkillMaxAggregateOutputType | null
  }

  type GetPersuasionSkillGroupByPayload<T extends PersuasionSkillGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PersuasionSkillGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PersuasionSkillGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PersuasionSkillGroupByOutputType[P]>
            : GetScalarType<T[P], PersuasionSkillGroupByOutputType[P]>
        }
      >
    >


  export type PersuasionSkillSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    value?: boolean
    mastery?: boolean
    name?: boolean
    skill_list?: boolean | CharismaBasedSkillsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["persuasionSkill"]>

  export type PersuasionSkillSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    value?: boolean
    mastery?: boolean
    name?: boolean
    skill_list?: boolean | CharismaBasedSkillsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["persuasionSkill"]>

  export type PersuasionSkillSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    value?: boolean
    mastery?: boolean
    name?: boolean
    skill_list?: boolean | CharismaBasedSkillsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["persuasionSkill"]>

  export type PersuasionSkillSelectScalar = {
    id?: boolean
    value?: boolean
    mastery?: boolean
    name?: boolean
  }

  export type PersuasionSkillOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "value" | "mastery" | "name", ExtArgs["result"]["persuasionSkill"]>
  export type PersuasionSkillInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    skill_list?: boolean | CharismaBasedSkillsDefaultArgs<ExtArgs>
  }
  export type PersuasionSkillIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    skill_list?: boolean | CharismaBasedSkillsDefaultArgs<ExtArgs>
  }
  export type PersuasionSkillIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    skill_list?: boolean | CharismaBasedSkillsDefaultArgs<ExtArgs>
  }

  export type $PersuasionSkillPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PersuasionSkill"
    objects: {
      skill_list: Prisma.$CharismaBasedSkillsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      value: number | null
      mastery: boolean
      name: string
    }, ExtArgs["result"]["persuasionSkill"]>
    composites: {}
  }

  type PersuasionSkillGetPayload<S extends boolean | null | undefined | PersuasionSkillDefaultArgs> = $Result.GetResult<Prisma.$PersuasionSkillPayload, S>

  type PersuasionSkillCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PersuasionSkillFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PersuasionSkillCountAggregateInputType | true
    }

  export interface PersuasionSkillDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PersuasionSkill'], meta: { name: 'PersuasionSkill' } }
    /**
     * Find zero or one PersuasionSkill that matches the filter.
     * @param {PersuasionSkillFindUniqueArgs} args - Arguments to find a PersuasionSkill
     * @example
     * // Get one PersuasionSkill
     * const persuasionSkill = await prisma.persuasionSkill.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PersuasionSkillFindUniqueArgs>(args: SelectSubset<T, PersuasionSkillFindUniqueArgs<ExtArgs>>): Prisma__PersuasionSkillClient<$Result.GetResult<Prisma.$PersuasionSkillPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one PersuasionSkill that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PersuasionSkillFindUniqueOrThrowArgs} args - Arguments to find a PersuasionSkill
     * @example
     * // Get one PersuasionSkill
     * const persuasionSkill = await prisma.persuasionSkill.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PersuasionSkillFindUniqueOrThrowArgs>(args: SelectSubset<T, PersuasionSkillFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PersuasionSkillClient<$Result.GetResult<Prisma.$PersuasionSkillPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first PersuasionSkill that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersuasionSkillFindFirstArgs} args - Arguments to find a PersuasionSkill
     * @example
     * // Get one PersuasionSkill
     * const persuasionSkill = await prisma.persuasionSkill.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PersuasionSkillFindFirstArgs>(args?: SelectSubset<T, PersuasionSkillFindFirstArgs<ExtArgs>>): Prisma__PersuasionSkillClient<$Result.GetResult<Prisma.$PersuasionSkillPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first PersuasionSkill that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersuasionSkillFindFirstOrThrowArgs} args - Arguments to find a PersuasionSkill
     * @example
     * // Get one PersuasionSkill
     * const persuasionSkill = await prisma.persuasionSkill.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PersuasionSkillFindFirstOrThrowArgs>(args?: SelectSubset<T, PersuasionSkillFindFirstOrThrowArgs<ExtArgs>>): Prisma__PersuasionSkillClient<$Result.GetResult<Prisma.$PersuasionSkillPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more PersuasionSkills that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersuasionSkillFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PersuasionSkills
     * const persuasionSkills = await prisma.persuasionSkill.findMany()
     * 
     * // Get first 10 PersuasionSkills
     * const persuasionSkills = await prisma.persuasionSkill.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const persuasionSkillWithIdOnly = await prisma.persuasionSkill.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PersuasionSkillFindManyArgs>(args?: SelectSubset<T, PersuasionSkillFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PersuasionSkillPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a PersuasionSkill.
     * @param {PersuasionSkillCreateArgs} args - Arguments to create a PersuasionSkill.
     * @example
     * // Create one PersuasionSkill
     * const PersuasionSkill = await prisma.persuasionSkill.create({
     *   data: {
     *     // ... data to create a PersuasionSkill
     *   }
     * })
     * 
     */
    create<T extends PersuasionSkillCreateArgs>(args: SelectSubset<T, PersuasionSkillCreateArgs<ExtArgs>>): Prisma__PersuasionSkillClient<$Result.GetResult<Prisma.$PersuasionSkillPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many PersuasionSkills.
     * @param {PersuasionSkillCreateManyArgs} args - Arguments to create many PersuasionSkills.
     * @example
     * // Create many PersuasionSkills
     * const persuasionSkill = await prisma.persuasionSkill.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PersuasionSkillCreateManyArgs>(args?: SelectSubset<T, PersuasionSkillCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PersuasionSkills and returns the data saved in the database.
     * @param {PersuasionSkillCreateManyAndReturnArgs} args - Arguments to create many PersuasionSkills.
     * @example
     * // Create many PersuasionSkills
     * const persuasionSkill = await prisma.persuasionSkill.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PersuasionSkills and only return the `id`
     * const persuasionSkillWithIdOnly = await prisma.persuasionSkill.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PersuasionSkillCreateManyAndReturnArgs>(args?: SelectSubset<T, PersuasionSkillCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PersuasionSkillPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a PersuasionSkill.
     * @param {PersuasionSkillDeleteArgs} args - Arguments to delete one PersuasionSkill.
     * @example
     * // Delete one PersuasionSkill
     * const PersuasionSkill = await prisma.persuasionSkill.delete({
     *   where: {
     *     // ... filter to delete one PersuasionSkill
     *   }
     * })
     * 
     */
    delete<T extends PersuasionSkillDeleteArgs>(args: SelectSubset<T, PersuasionSkillDeleteArgs<ExtArgs>>): Prisma__PersuasionSkillClient<$Result.GetResult<Prisma.$PersuasionSkillPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one PersuasionSkill.
     * @param {PersuasionSkillUpdateArgs} args - Arguments to update one PersuasionSkill.
     * @example
     * // Update one PersuasionSkill
     * const persuasionSkill = await prisma.persuasionSkill.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PersuasionSkillUpdateArgs>(args: SelectSubset<T, PersuasionSkillUpdateArgs<ExtArgs>>): Prisma__PersuasionSkillClient<$Result.GetResult<Prisma.$PersuasionSkillPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more PersuasionSkills.
     * @param {PersuasionSkillDeleteManyArgs} args - Arguments to filter PersuasionSkills to delete.
     * @example
     * // Delete a few PersuasionSkills
     * const { count } = await prisma.persuasionSkill.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PersuasionSkillDeleteManyArgs>(args?: SelectSubset<T, PersuasionSkillDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PersuasionSkills.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersuasionSkillUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PersuasionSkills
     * const persuasionSkill = await prisma.persuasionSkill.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PersuasionSkillUpdateManyArgs>(args: SelectSubset<T, PersuasionSkillUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PersuasionSkills and returns the data updated in the database.
     * @param {PersuasionSkillUpdateManyAndReturnArgs} args - Arguments to update many PersuasionSkills.
     * @example
     * // Update many PersuasionSkills
     * const persuasionSkill = await prisma.persuasionSkill.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PersuasionSkills and only return the `id`
     * const persuasionSkillWithIdOnly = await prisma.persuasionSkill.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PersuasionSkillUpdateManyAndReturnArgs>(args: SelectSubset<T, PersuasionSkillUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PersuasionSkillPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one PersuasionSkill.
     * @param {PersuasionSkillUpsertArgs} args - Arguments to update or create a PersuasionSkill.
     * @example
     * // Update or create a PersuasionSkill
     * const persuasionSkill = await prisma.persuasionSkill.upsert({
     *   create: {
     *     // ... data to create a PersuasionSkill
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PersuasionSkill we want to update
     *   }
     * })
     */
    upsert<T extends PersuasionSkillUpsertArgs>(args: SelectSubset<T, PersuasionSkillUpsertArgs<ExtArgs>>): Prisma__PersuasionSkillClient<$Result.GetResult<Prisma.$PersuasionSkillPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of PersuasionSkills.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersuasionSkillCountArgs} args - Arguments to filter PersuasionSkills to count.
     * @example
     * // Count the number of PersuasionSkills
     * const count = await prisma.persuasionSkill.count({
     *   where: {
     *     // ... the filter for the PersuasionSkills we want to count
     *   }
     * })
    **/
    count<T extends PersuasionSkillCountArgs>(
      args?: Subset<T, PersuasionSkillCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PersuasionSkillCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PersuasionSkill.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersuasionSkillAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PersuasionSkillAggregateArgs>(args: Subset<T, PersuasionSkillAggregateArgs>): Prisma.PrismaPromise<GetPersuasionSkillAggregateType<T>>

    /**
     * Group by PersuasionSkill.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersuasionSkillGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PersuasionSkillGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PersuasionSkillGroupByArgs['orderBy'] }
        : { orderBy?: PersuasionSkillGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PersuasionSkillGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPersuasionSkillGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PersuasionSkill model
   */
  readonly fields: PersuasionSkillFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PersuasionSkill.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PersuasionSkillClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    skill_list<T extends CharismaBasedSkillsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CharismaBasedSkillsDefaultArgs<ExtArgs>>): Prisma__CharismaBasedSkillsClient<$Result.GetResult<Prisma.$CharismaBasedSkillsPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PersuasionSkill model
   */ 
  interface PersuasionSkillFieldRefs {
    readonly id: FieldRef<"PersuasionSkill", 'String'>
    readonly value: FieldRef<"PersuasionSkill", 'Int'>
    readonly mastery: FieldRef<"PersuasionSkill", 'Boolean'>
    readonly name: FieldRef<"PersuasionSkill", 'String'>
  }
    

  // Custom InputTypes
  /**
   * PersuasionSkill findUnique
   */
  export type PersuasionSkillFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersuasionSkill
     */
    select?: PersuasionSkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PersuasionSkill
     */
    omit?: PersuasionSkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersuasionSkillInclude<ExtArgs> | null
    /**
     * Filter, which PersuasionSkill to fetch.
     */
    where: PersuasionSkillWhereUniqueInput
  }

  /**
   * PersuasionSkill findUniqueOrThrow
   */
  export type PersuasionSkillFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersuasionSkill
     */
    select?: PersuasionSkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PersuasionSkill
     */
    omit?: PersuasionSkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersuasionSkillInclude<ExtArgs> | null
    /**
     * Filter, which PersuasionSkill to fetch.
     */
    where: PersuasionSkillWhereUniqueInput
  }

  /**
   * PersuasionSkill findFirst
   */
  export type PersuasionSkillFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersuasionSkill
     */
    select?: PersuasionSkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PersuasionSkill
     */
    omit?: PersuasionSkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersuasionSkillInclude<ExtArgs> | null
    /**
     * Filter, which PersuasionSkill to fetch.
     */
    where?: PersuasionSkillWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PersuasionSkills to fetch.
     */
    orderBy?: PersuasionSkillOrderByWithRelationInput | PersuasionSkillOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PersuasionSkills.
     */
    cursor?: PersuasionSkillWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PersuasionSkills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PersuasionSkills.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PersuasionSkills.
     */
    distinct?: PersuasionSkillScalarFieldEnum | PersuasionSkillScalarFieldEnum[]
  }

  /**
   * PersuasionSkill findFirstOrThrow
   */
  export type PersuasionSkillFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersuasionSkill
     */
    select?: PersuasionSkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PersuasionSkill
     */
    omit?: PersuasionSkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersuasionSkillInclude<ExtArgs> | null
    /**
     * Filter, which PersuasionSkill to fetch.
     */
    where?: PersuasionSkillWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PersuasionSkills to fetch.
     */
    orderBy?: PersuasionSkillOrderByWithRelationInput | PersuasionSkillOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PersuasionSkills.
     */
    cursor?: PersuasionSkillWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PersuasionSkills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PersuasionSkills.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PersuasionSkills.
     */
    distinct?: PersuasionSkillScalarFieldEnum | PersuasionSkillScalarFieldEnum[]
  }

  /**
   * PersuasionSkill findMany
   */
  export type PersuasionSkillFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersuasionSkill
     */
    select?: PersuasionSkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PersuasionSkill
     */
    omit?: PersuasionSkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersuasionSkillInclude<ExtArgs> | null
    /**
     * Filter, which PersuasionSkills to fetch.
     */
    where?: PersuasionSkillWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PersuasionSkills to fetch.
     */
    orderBy?: PersuasionSkillOrderByWithRelationInput | PersuasionSkillOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PersuasionSkills.
     */
    cursor?: PersuasionSkillWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PersuasionSkills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PersuasionSkills.
     */
    skip?: number
    distinct?: PersuasionSkillScalarFieldEnum | PersuasionSkillScalarFieldEnum[]
  }

  /**
   * PersuasionSkill create
   */
  export type PersuasionSkillCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersuasionSkill
     */
    select?: PersuasionSkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PersuasionSkill
     */
    omit?: PersuasionSkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersuasionSkillInclude<ExtArgs> | null
    /**
     * The data needed to create a PersuasionSkill.
     */
    data: XOR<PersuasionSkillCreateInput, PersuasionSkillUncheckedCreateInput>
  }

  /**
   * PersuasionSkill createMany
   */
  export type PersuasionSkillCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PersuasionSkills.
     */
    data: PersuasionSkillCreateManyInput | PersuasionSkillCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PersuasionSkill createManyAndReturn
   */
  export type PersuasionSkillCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersuasionSkill
     */
    select?: PersuasionSkillSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PersuasionSkill
     */
    omit?: PersuasionSkillOmit<ExtArgs> | null
    /**
     * The data used to create many PersuasionSkills.
     */
    data: PersuasionSkillCreateManyInput | PersuasionSkillCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersuasionSkillIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PersuasionSkill update
   */
  export type PersuasionSkillUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersuasionSkill
     */
    select?: PersuasionSkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PersuasionSkill
     */
    omit?: PersuasionSkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersuasionSkillInclude<ExtArgs> | null
    /**
     * The data needed to update a PersuasionSkill.
     */
    data: XOR<PersuasionSkillUpdateInput, PersuasionSkillUncheckedUpdateInput>
    /**
     * Choose, which PersuasionSkill to update.
     */
    where: PersuasionSkillWhereUniqueInput
  }

  /**
   * PersuasionSkill updateMany
   */
  export type PersuasionSkillUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PersuasionSkills.
     */
    data: XOR<PersuasionSkillUpdateManyMutationInput, PersuasionSkillUncheckedUpdateManyInput>
    /**
     * Filter which PersuasionSkills to update
     */
    where?: PersuasionSkillWhereInput
    /**
     * Limit how many PersuasionSkills to update.
     */
    limit?: number
  }

  /**
   * PersuasionSkill updateManyAndReturn
   */
  export type PersuasionSkillUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersuasionSkill
     */
    select?: PersuasionSkillSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PersuasionSkill
     */
    omit?: PersuasionSkillOmit<ExtArgs> | null
    /**
     * The data used to update PersuasionSkills.
     */
    data: XOR<PersuasionSkillUpdateManyMutationInput, PersuasionSkillUncheckedUpdateManyInput>
    /**
     * Filter which PersuasionSkills to update
     */
    where?: PersuasionSkillWhereInput
    /**
     * Limit how many PersuasionSkills to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersuasionSkillIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PersuasionSkill upsert
   */
  export type PersuasionSkillUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersuasionSkill
     */
    select?: PersuasionSkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PersuasionSkill
     */
    omit?: PersuasionSkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersuasionSkillInclude<ExtArgs> | null
    /**
     * The filter to search for the PersuasionSkill to update in case it exists.
     */
    where: PersuasionSkillWhereUniqueInput
    /**
     * In case the PersuasionSkill found by the `where` argument doesn't exist, create a new PersuasionSkill with this data.
     */
    create: XOR<PersuasionSkillCreateInput, PersuasionSkillUncheckedCreateInput>
    /**
     * In case the PersuasionSkill was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PersuasionSkillUpdateInput, PersuasionSkillUncheckedUpdateInput>
  }

  /**
   * PersuasionSkill delete
   */
  export type PersuasionSkillDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersuasionSkill
     */
    select?: PersuasionSkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PersuasionSkill
     */
    omit?: PersuasionSkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersuasionSkillInclude<ExtArgs> | null
    /**
     * Filter which PersuasionSkill to delete.
     */
    where: PersuasionSkillWhereUniqueInput
  }

  /**
   * PersuasionSkill deleteMany
   */
  export type PersuasionSkillDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PersuasionSkills to delete
     */
    where?: PersuasionSkillWhereInput
    /**
     * Limit how many PersuasionSkills to delete.
     */
    limit?: number
  }

  /**
   * PersuasionSkill without action
   */
  export type PersuasionSkillDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersuasionSkill
     */
    select?: PersuasionSkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PersuasionSkill
     */
    omit?: PersuasionSkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersuasionSkillInclude<ExtArgs> | null
  }


  /**
   * Model Creature
   */

  export type AggregateCreature = {
    _count: CreatureCountAggregateOutputType | null
    _avg: CreatureAvgAggregateOutputType | null
    _sum: CreatureSumAggregateOutputType | null
    _min: CreatureMinAggregateOutputType | null
    _max: CreatureMaxAggregateOutputType | null
  }

  export type CreatureAvgAggregateOutputType = {
    race_id: number | null
    source_id: number | null
    alignment_id: number | null
    armor_class: number | null
    hit_points: number | null
    biomes_ids: number | null
    type_id: number | null
  }

  export type CreatureSumAggregateOutputType = {
    race_id: number | null
    source_id: number | null
    alignment_id: number | null
    armor_class: number | null
    hit_points: number | null
    biomes_ids: number[]
    type_id: number | null
  }

  export type CreatureMinAggregateOutputType = {
    id: string | null
    name: string | null
    creator_id: string | null
    image_uri: string | null
    description: string | null
    size: string | null
    race_id: number | null
    source_id: number | null
    alignment_id: number | null
    armor_class: number | null
    hit_points: number | null
    challenge_rating: string | null
    type_id: number | null
  }

  export type CreatureMaxAggregateOutputType = {
    id: string | null
    name: string | null
    creator_id: string | null
    image_uri: string | null
    description: string | null
    size: string | null
    race_id: number | null
    source_id: number | null
    alignment_id: number | null
    armor_class: number | null
    hit_points: number | null
    challenge_rating: string | null
    type_id: number | null
  }

  export type CreatureCountAggregateOutputType = {
    id: number
    name: number
    creator_id: number
    image_uri: number
    description: number
    size: number
    race_id: number
    source_id: number
    alignment_id: number
    armor_class: number
    hit_points: number
    challenge_rating: number
    biomes_ids: number
    type_id: number
    aSubTypes: number
    _all: number
  }


  export type CreatureAvgAggregateInputType = {
    race_id?: true
    source_id?: true
    alignment_id?: true
    armor_class?: true
    hit_points?: true
    biomes_ids?: true
    type_id?: true
  }

  export type CreatureSumAggregateInputType = {
    race_id?: true
    source_id?: true
    alignment_id?: true
    armor_class?: true
    hit_points?: true
    biomes_ids?: true
    type_id?: true
  }

  export type CreatureMinAggregateInputType = {
    id?: true
    name?: true
    creator_id?: true
    image_uri?: true
    description?: true
    size?: true
    race_id?: true
    source_id?: true
    alignment_id?: true
    armor_class?: true
    hit_points?: true
    challenge_rating?: true
    type_id?: true
  }

  export type CreatureMaxAggregateInputType = {
    id?: true
    name?: true
    creator_id?: true
    image_uri?: true
    description?: true
    size?: true
    race_id?: true
    source_id?: true
    alignment_id?: true
    armor_class?: true
    hit_points?: true
    challenge_rating?: true
    type_id?: true
  }

  export type CreatureCountAggregateInputType = {
    id?: true
    name?: true
    creator_id?: true
    image_uri?: true
    description?: true
    size?: true
    race_id?: true
    source_id?: true
    alignment_id?: true
    armor_class?: true
    hit_points?: true
    challenge_rating?: true
    biomes_ids?: true
    type_id?: true
    aSubTypes?: true
    _all?: true
  }

  export type CreatureAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Creature to aggregate.
     */
    where?: CreatureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Creatures to fetch.
     */
    orderBy?: CreatureOrderByWithRelationInput | CreatureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CreatureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Creatures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Creatures.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Creatures
    **/
    _count?: true | CreatureCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CreatureAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CreatureSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CreatureMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CreatureMaxAggregateInputType
  }

  export type GetCreatureAggregateType<T extends CreatureAggregateArgs> = {
        [P in keyof T & keyof AggregateCreature]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCreature[P]>
      : GetScalarType<T[P], AggregateCreature[P]>
  }




  export type CreatureGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CreatureWhereInput
    orderBy?: CreatureOrderByWithAggregationInput | CreatureOrderByWithAggregationInput[]
    by: CreatureScalarFieldEnum[] | CreatureScalarFieldEnum
    having?: CreatureScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CreatureCountAggregateInputType | true
    _avg?: CreatureAvgAggregateInputType
    _sum?: CreatureSumAggregateInputType
    _min?: CreatureMinAggregateInputType
    _max?: CreatureMaxAggregateInputType
  }

  export type CreatureGroupByOutputType = {
    id: string
    name: string
    creator_id: string | null
    image_uri: string | null
    description: string | null
    size: string | null
    race_id: number | null
    source_id: number | null
    alignment_id: number | null
    armor_class: number | null
    hit_points: number | null
    challenge_rating: string
    biomes_ids: number[]
    type_id: number | null
    aSubTypes: string[]
    _count: CreatureCountAggregateOutputType | null
    _avg: CreatureAvgAggregateOutputType | null
    _sum: CreatureSumAggregateOutputType | null
    _min: CreatureMinAggregateOutputType | null
    _max: CreatureMaxAggregateOutputType | null
  }

  type GetCreatureGroupByPayload<T extends CreatureGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CreatureGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CreatureGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CreatureGroupByOutputType[P]>
            : GetScalarType<T[P], CreatureGroupByOutputType[P]>
        }
      >
    >


  export type CreatureSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    creator_id?: boolean
    image_uri?: boolean
    description?: boolean
    size?: boolean
    race_id?: boolean
    source_id?: boolean
    alignment_id?: boolean
    armor_class?: boolean
    hit_points?: boolean
    challenge_rating?: boolean
    biomes_ids?: boolean
    type_id?: boolean
    aSubTypes?: boolean
    speed?: boolean | Creature$speedArgs<ExtArgs>
    stats?: boolean | Creature$statsArgs<ExtArgs>
    skills?: boolean | Creature$skillsArgs<ExtArgs>
    resistances?: boolean | Creature$resistancesArgs<ExtArgs>
    immunities?: boolean | Creature$immunitiesArgs<ExtArgs>
    vulnerabilities?: boolean | Creature$vulnerabilitiesArgs<ExtArgs>
    senses?: boolean | Creature$sensesArgs<ExtArgs>
    languages?: boolean | Creature$languagesArgs<ExtArgs>
    actions?: boolean | Creature$actionsArgs<ExtArgs>
    traits?: boolean | Creature$traitsArgs<ExtArgs>
    alignment_relation?: boolean | Creature$alignment_relationArgs<ExtArgs>
    race_relation?: boolean | Creature$race_relationArgs<ExtArgs>
    type_relation?: boolean | Creature$type_relationArgs<ExtArgs>
    size_relation?: boolean | Creature$size_relationArgs<ExtArgs>
    biome_relation?: boolean | Creature$biome_relationArgs<ExtArgs>
    source_relation?: boolean | Creature$source_relationArgs<ExtArgs>
    _count?: boolean | CreatureCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["creature"]>

  export type CreatureSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    creator_id?: boolean
    image_uri?: boolean
    description?: boolean
    size?: boolean
    race_id?: boolean
    source_id?: boolean
    alignment_id?: boolean
    armor_class?: boolean
    hit_points?: boolean
    challenge_rating?: boolean
    biomes_ids?: boolean
    type_id?: boolean
    aSubTypes?: boolean
    alignment_relation?: boolean | Creature$alignment_relationArgs<ExtArgs>
    race_relation?: boolean | Creature$race_relationArgs<ExtArgs>
    type_relation?: boolean | Creature$type_relationArgs<ExtArgs>
    size_relation?: boolean | Creature$size_relationArgs<ExtArgs>
    source_relation?: boolean | Creature$source_relationArgs<ExtArgs>
  }, ExtArgs["result"]["creature"]>

  export type CreatureSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    creator_id?: boolean
    image_uri?: boolean
    description?: boolean
    size?: boolean
    race_id?: boolean
    source_id?: boolean
    alignment_id?: boolean
    armor_class?: boolean
    hit_points?: boolean
    challenge_rating?: boolean
    biomes_ids?: boolean
    type_id?: boolean
    aSubTypes?: boolean
    alignment_relation?: boolean | Creature$alignment_relationArgs<ExtArgs>
    race_relation?: boolean | Creature$race_relationArgs<ExtArgs>
    type_relation?: boolean | Creature$type_relationArgs<ExtArgs>
    size_relation?: boolean | Creature$size_relationArgs<ExtArgs>
    source_relation?: boolean | Creature$source_relationArgs<ExtArgs>
  }, ExtArgs["result"]["creature"]>

  export type CreatureSelectScalar = {
    id?: boolean
    name?: boolean
    creator_id?: boolean
    image_uri?: boolean
    description?: boolean
    size?: boolean
    race_id?: boolean
    source_id?: boolean
    alignment_id?: boolean
    armor_class?: boolean
    hit_points?: boolean
    challenge_rating?: boolean
    biomes_ids?: boolean
    type_id?: boolean
    aSubTypes?: boolean
  }

  export type CreatureOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "creator_id" | "image_uri" | "description" | "size" | "race_id" | "source_id" | "alignment_id" | "armor_class" | "hit_points" | "challenge_rating" | "biomes_ids" | "type_id" | "aSubTypes", ExtArgs["result"]["creature"]>
  export type CreatureInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    speed?: boolean | Creature$speedArgs<ExtArgs>
    stats?: boolean | Creature$statsArgs<ExtArgs>
    skills?: boolean | Creature$skillsArgs<ExtArgs>
    resistances?: boolean | Creature$resistancesArgs<ExtArgs>
    immunities?: boolean | Creature$immunitiesArgs<ExtArgs>
    vulnerabilities?: boolean | Creature$vulnerabilitiesArgs<ExtArgs>
    senses?: boolean | Creature$sensesArgs<ExtArgs>
    languages?: boolean | Creature$languagesArgs<ExtArgs>
    actions?: boolean | Creature$actionsArgs<ExtArgs>
    traits?: boolean | Creature$traitsArgs<ExtArgs>
    alignment_relation?: boolean | Creature$alignment_relationArgs<ExtArgs>
    race_relation?: boolean | Creature$race_relationArgs<ExtArgs>
    type_relation?: boolean | Creature$type_relationArgs<ExtArgs>
    size_relation?: boolean | Creature$size_relationArgs<ExtArgs>
    biome_relation?: boolean | Creature$biome_relationArgs<ExtArgs>
    source_relation?: boolean | Creature$source_relationArgs<ExtArgs>
    _count?: boolean | CreatureCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CreatureIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    alignment_relation?: boolean | Creature$alignment_relationArgs<ExtArgs>
    race_relation?: boolean | Creature$race_relationArgs<ExtArgs>
    type_relation?: boolean | Creature$type_relationArgs<ExtArgs>
    size_relation?: boolean | Creature$size_relationArgs<ExtArgs>
    source_relation?: boolean | Creature$source_relationArgs<ExtArgs>
  }
  export type CreatureIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    alignment_relation?: boolean | Creature$alignment_relationArgs<ExtArgs>
    race_relation?: boolean | Creature$race_relationArgs<ExtArgs>
    type_relation?: boolean | Creature$type_relationArgs<ExtArgs>
    size_relation?: boolean | Creature$size_relationArgs<ExtArgs>
    source_relation?: boolean | Creature$source_relationArgs<ExtArgs>
  }

  export type $CreaturePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Creature"
    objects: {
      speed: Prisma.$Speed_statPayload<ExtArgs> | null
      stats: Prisma.$Creature_statsPayload<ExtArgs> | null
      skills: Prisma.$SkillsListPayload<ExtArgs> | null
      resistances: Prisma.$DamageTypePayload<ExtArgs>[]
      immunities: Prisma.$DamageTypePayload<ExtArgs>[]
      vulnerabilities: Prisma.$DamageTypePayload<ExtArgs>[]
      senses: Prisma.$SensesPayload<ExtArgs> | null
      languages: Prisma.$LanguagePayload<ExtArgs>[]
      actions: Prisma.$ActionPayload<ExtArgs>[]
      traits: Prisma.$TraitPayload<ExtArgs>[]
      alignment_relation: Prisma.$AlignmentPayload<ExtArgs> | null
      race_relation: Prisma.$CreatureRacePayload<ExtArgs> | null
      type_relation: Prisma.$TypePayload<ExtArgs> | null
      size_relation: Prisma.$SizePayload<ExtArgs> | null
      biome_relation: Prisma.$BiomePayload<ExtArgs>[]
      source_relation: Prisma.$SourcePayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      creator_id: string | null
      image_uri: string | null
      description: string | null
      size: string | null
      race_id: number | null
      source_id: number | null
      alignment_id: number | null
      armor_class: number | null
      hit_points: number | null
      challenge_rating: string
      biomes_ids: number[]
      type_id: number | null
      aSubTypes: string[]
    }, ExtArgs["result"]["creature"]>
    composites: {}
  }

  type CreatureGetPayload<S extends boolean | null | undefined | CreatureDefaultArgs> = $Result.GetResult<Prisma.$CreaturePayload, S>

  type CreatureCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CreatureFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CreatureCountAggregateInputType | true
    }

  export interface CreatureDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Creature'], meta: { name: 'Creature' } }
    /**
     * Find zero or one Creature that matches the filter.
     * @param {CreatureFindUniqueArgs} args - Arguments to find a Creature
     * @example
     * // Get one Creature
     * const creature = await prisma.creature.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CreatureFindUniqueArgs>(args: SelectSubset<T, CreatureFindUniqueArgs<ExtArgs>>): Prisma__CreatureClient<$Result.GetResult<Prisma.$CreaturePayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Creature that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CreatureFindUniqueOrThrowArgs} args - Arguments to find a Creature
     * @example
     * // Get one Creature
     * const creature = await prisma.creature.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CreatureFindUniqueOrThrowArgs>(args: SelectSubset<T, CreatureFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CreatureClient<$Result.GetResult<Prisma.$CreaturePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Creature that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreatureFindFirstArgs} args - Arguments to find a Creature
     * @example
     * // Get one Creature
     * const creature = await prisma.creature.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CreatureFindFirstArgs>(args?: SelectSubset<T, CreatureFindFirstArgs<ExtArgs>>): Prisma__CreatureClient<$Result.GetResult<Prisma.$CreaturePayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Creature that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreatureFindFirstOrThrowArgs} args - Arguments to find a Creature
     * @example
     * // Get one Creature
     * const creature = await prisma.creature.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CreatureFindFirstOrThrowArgs>(args?: SelectSubset<T, CreatureFindFirstOrThrowArgs<ExtArgs>>): Prisma__CreatureClient<$Result.GetResult<Prisma.$CreaturePayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Creatures that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreatureFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Creatures
     * const creatures = await prisma.creature.findMany()
     * 
     * // Get first 10 Creatures
     * const creatures = await prisma.creature.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const creatureWithIdOnly = await prisma.creature.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CreatureFindManyArgs>(args?: SelectSubset<T, CreatureFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CreaturePayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Creature.
     * @param {CreatureCreateArgs} args - Arguments to create a Creature.
     * @example
     * // Create one Creature
     * const Creature = await prisma.creature.create({
     *   data: {
     *     // ... data to create a Creature
     *   }
     * })
     * 
     */
    create<T extends CreatureCreateArgs>(args: SelectSubset<T, CreatureCreateArgs<ExtArgs>>): Prisma__CreatureClient<$Result.GetResult<Prisma.$CreaturePayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Creatures.
     * @param {CreatureCreateManyArgs} args - Arguments to create many Creatures.
     * @example
     * // Create many Creatures
     * const creature = await prisma.creature.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CreatureCreateManyArgs>(args?: SelectSubset<T, CreatureCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Creatures and returns the data saved in the database.
     * @param {CreatureCreateManyAndReturnArgs} args - Arguments to create many Creatures.
     * @example
     * // Create many Creatures
     * const creature = await prisma.creature.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Creatures and only return the `id`
     * const creatureWithIdOnly = await prisma.creature.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CreatureCreateManyAndReturnArgs>(args?: SelectSubset<T, CreatureCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CreaturePayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Creature.
     * @param {CreatureDeleteArgs} args - Arguments to delete one Creature.
     * @example
     * // Delete one Creature
     * const Creature = await prisma.creature.delete({
     *   where: {
     *     // ... filter to delete one Creature
     *   }
     * })
     * 
     */
    delete<T extends CreatureDeleteArgs>(args: SelectSubset<T, CreatureDeleteArgs<ExtArgs>>): Prisma__CreatureClient<$Result.GetResult<Prisma.$CreaturePayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Creature.
     * @param {CreatureUpdateArgs} args - Arguments to update one Creature.
     * @example
     * // Update one Creature
     * const creature = await prisma.creature.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CreatureUpdateArgs>(args: SelectSubset<T, CreatureUpdateArgs<ExtArgs>>): Prisma__CreatureClient<$Result.GetResult<Prisma.$CreaturePayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Creatures.
     * @param {CreatureDeleteManyArgs} args - Arguments to filter Creatures to delete.
     * @example
     * // Delete a few Creatures
     * const { count } = await prisma.creature.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CreatureDeleteManyArgs>(args?: SelectSubset<T, CreatureDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Creatures.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreatureUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Creatures
     * const creature = await prisma.creature.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CreatureUpdateManyArgs>(args: SelectSubset<T, CreatureUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Creatures and returns the data updated in the database.
     * @param {CreatureUpdateManyAndReturnArgs} args - Arguments to update many Creatures.
     * @example
     * // Update many Creatures
     * const creature = await prisma.creature.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Creatures and only return the `id`
     * const creatureWithIdOnly = await prisma.creature.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CreatureUpdateManyAndReturnArgs>(args: SelectSubset<T, CreatureUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CreaturePayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Creature.
     * @param {CreatureUpsertArgs} args - Arguments to update or create a Creature.
     * @example
     * // Update or create a Creature
     * const creature = await prisma.creature.upsert({
     *   create: {
     *     // ... data to create a Creature
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Creature we want to update
     *   }
     * })
     */
    upsert<T extends CreatureUpsertArgs>(args: SelectSubset<T, CreatureUpsertArgs<ExtArgs>>): Prisma__CreatureClient<$Result.GetResult<Prisma.$CreaturePayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Creatures.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreatureCountArgs} args - Arguments to filter Creatures to count.
     * @example
     * // Count the number of Creatures
     * const count = await prisma.creature.count({
     *   where: {
     *     // ... the filter for the Creatures we want to count
     *   }
     * })
    **/
    count<T extends CreatureCountArgs>(
      args?: Subset<T, CreatureCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CreatureCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Creature.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreatureAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CreatureAggregateArgs>(args: Subset<T, CreatureAggregateArgs>): Prisma.PrismaPromise<GetCreatureAggregateType<T>>

    /**
     * Group by Creature.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreatureGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CreatureGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CreatureGroupByArgs['orderBy'] }
        : { orderBy?: CreatureGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CreatureGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCreatureGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Creature model
   */
  readonly fields: CreatureFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Creature.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CreatureClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    speed<T extends Creature$speedArgs<ExtArgs> = {}>(args?: Subset<T, Creature$speedArgs<ExtArgs>>): Prisma__Speed_statClient<$Result.GetResult<Prisma.$Speed_statPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | null, null, ExtArgs, ClientOptions>
    stats<T extends Creature$statsArgs<ExtArgs> = {}>(args?: Subset<T, Creature$statsArgs<ExtArgs>>): Prisma__Creature_statsClient<$Result.GetResult<Prisma.$Creature_statsPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | null, null, ExtArgs, ClientOptions>
    skills<T extends Creature$skillsArgs<ExtArgs> = {}>(args?: Subset<T, Creature$skillsArgs<ExtArgs>>): Prisma__SkillsListClient<$Result.GetResult<Prisma.$SkillsListPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | null, null, ExtArgs, ClientOptions>
    resistances<T extends Creature$resistancesArgs<ExtArgs> = {}>(args?: Subset<T, Creature$resistancesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DamageTypePayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    immunities<T extends Creature$immunitiesArgs<ExtArgs> = {}>(args?: Subset<T, Creature$immunitiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DamageTypePayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    vulnerabilities<T extends Creature$vulnerabilitiesArgs<ExtArgs> = {}>(args?: Subset<T, Creature$vulnerabilitiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DamageTypePayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    senses<T extends Creature$sensesArgs<ExtArgs> = {}>(args?: Subset<T, Creature$sensesArgs<ExtArgs>>): Prisma__SensesClient<$Result.GetResult<Prisma.$SensesPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | null, null, ExtArgs, ClientOptions>
    languages<T extends Creature$languagesArgs<ExtArgs> = {}>(args?: Subset<T, Creature$languagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LanguagePayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    actions<T extends Creature$actionsArgs<ExtArgs> = {}>(args?: Subset<T, Creature$actionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActionPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    traits<T extends Creature$traitsArgs<ExtArgs> = {}>(args?: Subset<T, Creature$traitsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TraitPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    alignment_relation<T extends Creature$alignment_relationArgs<ExtArgs> = {}>(args?: Subset<T, Creature$alignment_relationArgs<ExtArgs>>): Prisma__AlignmentClient<$Result.GetResult<Prisma.$AlignmentPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | null, null, ExtArgs, ClientOptions>
    race_relation<T extends Creature$race_relationArgs<ExtArgs> = {}>(args?: Subset<T, Creature$race_relationArgs<ExtArgs>>): Prisma__CreatureRaceClient<$Result.GetResult<Prisma.$CreatureRacePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | null, null, ExtArgs, ClientOptions>
    type_relation<T extends Creature$type_relationArgs<ExtArgs> = {}>(args?: Subset<T, Creature$type_relationArgs<ExtArgs>>): Prisma__TypeClient<$Result.GetResult<Prisma.$TypePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | null, null, ExtArgs, ClientOptions>
    size_relation<T extends Creature$size_relationArgs<ExtArgs> = {}>(args?: Subset<T, Creature$size_relationArgs<ExtArgs>>): Prisma__SizeClient<$Result.GetResult<Prisma.$SizePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | null, null, ExtArgs, ClientOptions>
    biome_relation<T extends Creature$biome_relationArgs<ExtArgs> = {}>(args?: Subset<T, Creature$biome_relationArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BiomePayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    source_relation<T extends Creature$source_relationArgs<ExtArgs> = {}>(args?: Subset<T, Creature$source_relationArgs<ExtArgs>>): Prisma__SourceClient<$Result.GetResult<Prisma.$SourcePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | null, null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Creature model
   */ 
  interface CreatureFieldRefs {
    readonly id: FieldRef<"Creature", 'String'>
    readonly name: FieldRef<"Creature", 'String'>
    readonly creator_id: FieldRef<"Creature", 'String'>
    readonly image_uri: FieldRef<"Creature", 'String'>
    readonly description: FieldRef<"Creature", 'String'>
    readonly size: FieldRef<"Creature", 'String'>
    readonly race_id: FieldRef<"Creature", 'Int'>
    readonly source_id: FieldRef<"Creature", 'Int'>
    readonly alignment_id: FieldRef<"Creature", 'Int'>
    readonly armor_class: FieldRef<"Creature", 'Int'>
    readonly hit_points: FieldRef<"Creature", 'Int'>
    readonly challenge_rating: FieldRef<"Creature", 'String'>
    readonly biomes_ids: FieldRef<"Creature", 'Int[]'>
    readonly type_id: FieldRef<"Creature", 'Int'>
    readonly aSubTypes: FieldRef<"Creature", 'String[]'>
  }
    

  // Custom InputTypes
  /**
   * Creature findUnique
   */
  export type CreatureFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Creature
     */
    select?: CreatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Creature
     */
    omit?: CreatureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreatureInclude<ExtArgs> | null
    /**
     * Filter, which Creature to fetch.
     */
    where: CreatureWhereUniqueInput
  }

  /**
   * Creature findUniqueOrThrow
   */
  export type CreatureFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Creature
     */
    select?: CreatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Creature
     */
    omit?: CreatureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreatureInclude<ExtArgs> | null
    /**
     * Filter, which Creature to fetch.
     */
    where: CreatureWhereUniqueInput
  }

  /**
   * Creature findFirst
   */
  export type CreatureFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Creature
     */
    select?: CreatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Creature
     */
    omit?: CreatureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreatureInclude<ExtArgs> | null
    /**
     * Filter, which Creature to fetch.
     */
    where?: CreatureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Creatures to fetch.
     */
    orderBy?: CreatureOrderByWithRelationInput | CreatureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Creatures.
     */
    cursor?: CreatureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Creatures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Creatures.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Creatures.
     */
    distinct?: CreatureScalarFieldEnum | CreatureScalarFieldEnum[]
  }

  /**
   * Creature findFirstOrThrow
   */
  export type CreatureFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Creature
     */
    select?: CreatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Creature
     */
    omit?: CreatureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreatureInclude<ExtArgs> | null
    /**
     * Filter, which Creature to fetch.
     */
    where?: CreatureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Creatures to fetch.
     */
    orderBy?: CreatureOrderByWithRelationInput | CreatureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Creatures.
     */
    cursor?: CreatureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Creatures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Creatures.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Creatures.
     */
    distinct?: CreatureScalarFieldEnum | CreatureScalarFieldEnum[]
  }

  /**
   * Creature findMany
   */
  export type CreatureFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Creature
     */
    select?: CreatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Creature
     */
    omit?: CreatureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreatureInclude<ExtArgs> | null
    /**
     * Filter, which Creatures to fetch.
     */
    where?: CreatureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Creatures to fetch.
     */
    orderBy?: CreatureOrderByWithRelationInput | CreatureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Creatures.
     */
    cursor?: CreatureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Creatures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Creatures.
     */
    skip?: number
    distinct?: CreatureScalarFieldEnum | CreatureScalarFieldEnum[]
  }

  /**
   * Creature create
   */
  export type CreatureCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Creature
     */
    select?: CreatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Creature
     */
    omit?: CreatureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreatureInclude<ExtArgs> | null
    /**
     * The data needed to create a Creature.
     */
    data: XOR<CreatureCreateInput, CreatureUncheckedCreateInput>
  }

  /**
   * Creature createMany
   */
  export type CreatureCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Creatures.
     */
    data: CreatureCreateManyInput | CreatureCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Creature createManyAndReturn
   */
  export type CreatureCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Creature
     */
    select?: CreatureSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Creature
     */
    omit?: CreatureOmit<ExtArgs> | null
    /**
     * The data used to create many Creatures.
     */
    data: CreatureCreateManyInput | CreatureCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreatureIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Creature update
   */
  export type CreatureUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Creature
     */
    select?: CreatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Creature
     */
    omit?: CreatureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreatureInclude<ExtArgs> | null
    /**
     * The data needed to update a Creature.
     */
    data: XOR<CreatureUpdateInput, CreatureUncheckedUpdateInput>
    /**
     * Choose, which Creature to update.
     */
    where: CreatureWhereUniqueInput
  }

  /**
   * Creature updateMany
   */
  export type CreatureUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Creatures.
     */
    data: XOR<CreatureUpdateManyMutationInput, CreatureUncheckedUpdateManyInput>
    /**
     * Filter which Creatures to update
     */
    where?: CreatureWhereInput
    /**
     * Limit how many Creatures to update.
     */
    limit?: number
  }

  /**
   * Creature updateManyAndReturn
   */
  export type CreatureUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Creature
     */
    select?: CreatureSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Creature
     */
    omit?: CreatureOmit<ExtArgs> | null
    /**
     * The data used to update Creatures.
     */
    data: XOR<CreatureUpdateManyMutationInput, CreatureUncheckedUpdateManyInput>
    /**
     * Filter which Creatures to update
     */
    where?: CreatureWhereInput
    /**
     * Limit how many Creatures to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreatureIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Creature upsert
   */
  export type CreatureUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Creature
     */
    select?: CreatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Creature
     */
    omit?: CreatureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreatureInclude<ExtArgs> | null
    /**
     * The filter to search for the Creature to update in case it exists.
     */
    where: CreatureWhereUniqueInput
    /**
     * In case the Creature found by the `where` argument doesn't exist, create a new Creature with this data.
     */
    create: XOR<CreatureCreateInput, CreatureUncheckedCreateInput>
    /**
     * In case the Creature was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CreatureUpdateInput, CreatureUncheckedUpdateInput>
  }

  /**
   * Creature delete
   */
  export type CreatureDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Creature
     */
    select?: CreatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Creature
     */
    omit?: CreatureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreatureInclude<ExtArgs> | null
    /**
     * Filter which Creature to delete.
     */
    where: CreatureWhereUniqueInput
  }

  /**
   * Creature deleteMany
   */
  export type CreatureDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Creatures to delete
     */
    where?: CreatureWhereInput
    /**
     * Limit how many Creatures to delete.
     */
    limit?: number
  }

  /**
   * Creature.speed
   */
  export type Creature$speedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Speed_stat
     */
    select?: Speed_statSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Speed_stat
     */
    omit?: Speed_statOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Speed_statInclude<ExtArgs> | null
    where?: Speed_statWhereInput
  }

  /**
   * Creature.stats
   */
  export type Creature$statsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Creature_stats
     */
    select?: Creature_statsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Creature_stats
     */
    omit?: Creature_statsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Creature_statsInclude<ExtArgs> | null
    where?: Creature_statsWhereInput
  }

  /**
   * Creature.skills
   */
  export type Creature$skillsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SkillsList
     */
    select?: SkillsListSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SkillsList
     */
    omit?: SkillsListOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkillsListInclude<ExtArgs> | null
    where?: SkillsListWhereInput
  }

  /**
   * Creature.resistances
   */
  export type Creature$resistancesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DamageType
     */
    select?: DamageTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DamageType
     */
    omit?: DamageTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DamageTypeInclude<ExtArgs> | null
    where?: DamageTypeWhereInput
    orderBy?: DamageTypeOrderByWithRelationInput | DamageTypeOrderByWithRelationInput[]
    cursor?: DamageTypeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DamageTypeScalarFieldEnum | DamageTypeScalarFieldEnum[]
  }

  /**
   * Creature.immunities
   */
  export type Creature$immunitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DamageType
     */
    select?: DamageTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DamageType
     */
    omit?: DamageTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DamageTypeInclude<ExtArgs> | null
    where?: DamageTypeWhereInput
    orderBy?: DamageTypeOrderByWithRelationInput | DamageTypeOrderByWithRelationInput[]
    cursor?: DamageTypeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DamageTypeScalarFieldEnum | DamageTypeScalarFieldEnum[]
  }

  /**
   * Creature.vulnerabilities
   */
  export type Creature$vulnerabilitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DamageType
     */
    select?: DamageTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DamageType
     */
    omit?: DamageTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DamageTypeInclude<ExtArgs> | null
    where?: DamageTypeWhereInput
    orderBy?: DamageTypeOrderByWithRelationInput | DamageTypeOrderByWithRelationInput[]
    cursor?: DamageTypeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DamageTypeScalarFieldEnum | DamageTypeScalarFieldEnum[]
  }

  /**
   * Creature.senses
   */
  export type Creature$sensesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Senses
     */
    select?: SensesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Senses
     */
    omit?: SensesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SensesInclude<ExtArgs> | null
    where?: SensesWhereInput
  }

  /**
   * Creature.languages
   */
  export type Creature$languagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Language
     */
    select?: LanguageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Language
     */
    omit?: LanguageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LanguageInclude<ExtArgs> | null
    where?: LanguageWhereInput
    orderBy?: LanguageOrderByWithRelationInput | LanguageOrderByWithRelationInput[]
    cursor?: LanguageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LanguageScalarFieldEnum | LanguageScalarFieldEnum[]
  }

  /**
   * Creature.actions
   */
  export type Creature$actionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Action
     */
    select?: ActionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Action
     */
    omit?: ActionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActionInclude<ExtArgs> | null
    where?: ActionWhereInput
    orderBy?: ActionOrderByWithRelationInput | ActionOrderByWithRelationInput[]
    cursor?: ActionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ActionScalarFieldEnum | ActionScalarFieldEnum[]
  }

  /**
   * Creature.traits
   */
  export type Creature$traitsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Trait
     */
    select?: TraitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Trait
     */
    omit?: TraitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TraitInclude<ExtArgs> | null
    where?: TraitWhereInput
    orderBy?: TraitOrderByWithRelationInput | TraitOrderByWithRelationInput[]
    cursor?: TraitWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TraitScalarFieldEnum | TraitScalarFieldEnum[]
  }

  /**
   * Creature.alignment_relation
   */
  export type Creature$alignment_relationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alignment
     */
    select?: AlignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Alignment
     */
    omit?: AlignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlignmentInclude<ExtArgs> | null
    where?: AlignmentWhereInput
  }

  /**
   * Creature.race_relation
   */
  export type Creature$race_relationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreatureRace
     */
    select?: CreatureRaceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CreatureRace
     */
    omit?: CreatureRaceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreatureRaceInclude<ExtArgs> | null
    where?: CreatureRaceWhereInput
  }

  /**
   * Creature.type_relation
   */
  export type Creature$type_relationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Type
     */
    select?: TypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Type
     */
    omit?: TypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TypeInclude<ExtArgs> | null
    where?: TypeWhereInput
  }

  /**
   * Creature.size_relation
   */
  export type Creature$size_relationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Size
     */
    select?: SizeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Size
     */
    omit?: SizeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SizeInclude<ExtArgs> | null
    where?: SizeWhereInput
  }

  /**
   * Creature.biome_relation
   */
  export type Creature$biome_relationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Biome
     */
    select?: BiomeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Biome
     */
    omit?: BiomeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BiomeInclude<ExtArgs> | null
    where?: BiomeWhereInput
    orderBy?: BiomeOrderByWithRelationInput | BiomeOrderByWithRelationInput[]
    cursor?: BiomeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BiomeScalarFieldEnum | BiomeScalarFieldEnum[]
  }

  /**
   * Creature.source_relation
   */
  export type Creature$source_relationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Source
     */
    select?: SourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Source
     */
    omit?: SourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SourceInclude<ExtArgs> | null
    where?: SourceWhereInput
  }

  /**
   * Creature without action
   */
  export type CreatureDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Creature
     */
    select?: CreatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Creature
     */
    omit?: CreatureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreatureInclude<ExtArgs> | null
  }


  /**
   * Model Senses
   */

  export type AggregateSenses = {
    _count: SensesCountAggregateOutputType | null
    _avg: SensesAvgAggregateOutputType | null
    _sum: SensesSumAggregateOutputType | null
    _min: SensesMinAggregateOutputType | null
    _max: SensesMaxAggregateOutputType | null
  }

  export type SensesAvgAggregateOutputType = {
    passive_perception: number | null
  }

  export type SensesSumAggregateOutputType = {
    passive_perception: number | null
  }

  export type SensesMinAggregateOutputType = {
    creature_id: string | null
    passive_perception: number | null
  }

  export type SensesMaxAggregateOutputType = {
    creature_id: string | null
    passive_perception: number | null
  }

  export type SensesCountAggregateOutputType = {
    creature_id: number
    passive_perception: number
    _all: number
  }


  export type SensesAvgAggregateInputType = {
    passive_perception?: true
  }

  export type SensesSumAggregateInputType = {
    passive_perception?: true
  }

  export type SensesMinAggregateInputType = {
    creature_id?: true
    passive_perception?: true
  }

  export type SensesMaxAggregateInputType = {
    creature_id?: true
    passive_perception?: true
  }

  export type SensesCountAggregateInputType = {
    creature_id?: true
    passive_perception?: true
    _all?: true
  }

  export type SensesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Senses to aggregate.
     */
    where?: SensesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Senses to fetch.
     */
    orderBy?: SensesOrderByWithRelationInput | SensesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SensesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Senses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Senses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Senses
    **/
    _count?: true | SensesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SensesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SensesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SensesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SensesMaxAggregateInputType
  }

  export type GetSensesAggregateType<T extends SensesAggregateArgs> = {
        [P in keyof T & keyof AggregateSenses]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSenses[P]>
      : GetScalarType<T[P], AggregateSenses[P]>
  }




  export type SensesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SensesWhereInput
    orderBy?: SensesOrderByWithAggregationInput | SensesOrderByWithAggregationInput[]
    by: SensesScalarFieldEnum[] | SensesScalarFieldEnum
    having?: SensesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SensesCountAggregateInputType | true
    _avg?: SensesAvgAggregateInputType
    _sum?: SensesSumAggregateInputType
    _min?: SensesMinAggregateInputType
    _max?: SensesMaxAggregateInputType
  }

  export type SensesGroupByOutputType = {
    creature_id: string
    passive_perception: number | null
    _count: SensesCountAggregateOutputType | null
    _avg: SensesAvgAggregateOutputType | null
    _sum: SensesSumAggregateOutputType | null
    _min: SensesMinAggregateOutputType | null
    _max: SensesMaxAggregateOutputType | null
  }

  type GetSensesGroupByPayload<T extends SensesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SensesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SensesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SensesGroupByOutputType[P]>
            : GetScalarType<T[P], SensesGroupByOutputType[P]>
        }
      >
    >


  export type SensesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    creature_id?: boolean
    passive_perception?: boolean
    creature?: boolean | CreatureDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["senses"]>

  export type SensesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    creature_id?: boolean
    passive_perception?: boolean
    creature?: boolean | CreatureDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["senses"]>

  export type SensesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    creature_id?: boolean
    passive_perception?: boolean
    creature?: boolean | CreatureDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["senses"]>

  export type SensesSelectScalar = {
    creature_id?: boolean
    passive_perception?: boolean
  }

  export type SensesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"creature_id" | "passive_perception", ExtArgs["result"]["senses"]>
  export type SensesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creature?: boolean | CreatureDefaultArgs<ExtArgs>
  }
  export type SensesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creature?: boolean | CreatureDefaultArgs<ExtArgs>
  }
  export type SensesIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creature?: boolean | CreatureDefaultArgs<ExtArgs>
  }

  export type $SensesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Senses"
    objects: {
      creature: Prisma.$CreaturePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      creature_id: string
      passive_perception: number | null
    }, ExtArgs["result"]["senses"]>
    composites: {}
  }

  type SensesGetPayload<S extends boolean | null | undefined | SensesDefaultArgs> = $Result.GetResult<Prisma.$SensesPayload, S>

  type SensesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SensesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SensesCountAggregateInputType | true
    }

  export interface SensesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Senses'], meta: { name: 'Senses' } }
    /**
     * Find zero or one Senses that matches the filter.
     * @param {SensesFindUniqueArgs} args - Arguments to find a Senses
     * @example
     * // Get one Senses
     * const senses = await prisma.senses.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SensesFindUniqueArgs>(args: SelectSubset<T, SensesFindUniqueArgs<ExtArgs>>): Prisma__SensesClient<$Result.GetResult<Prisma.$SensesPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Senses that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SensesFindUniqueOrThrowArgs} args - Arguments to find a Senses
     * @example
     * // Get one Senses
     * const senses = await prisma.senses.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SensesFindUniqueOrThrowArgs>(args: SelectSubset<T, SensesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SensesClient<$Result.GetResult<Prisma.$SensesPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Senses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SensesFindFirstArgs} args - Arguments to find a Senses
     * @example
     * // Get one Senses
     * const senses = await prisma.senses.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SensesFindFirstArgs>(args?: SelectSubset<T, SensesFindFirstArgs<ExtArgs>>): Prisma__SensesClient<$Result.GetResult<Prisma.$SensesPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Senses that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SensesFindFirstOrThrowArgs} args - Arguments to find a Senses
     * @example
     * // Get one Senses
     * const senses = await prisma.senses.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SensesFindFirstOrThrowArgs>(args?: SelectSubset<T, SensesFindFirstOrThrowArgs<ExtArgs>>): Prisma__SensesClient<$Result.GetResult<Prisma.$SensesPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Senses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SensesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Senses
     * const senses = await prisma.senses.findMany()
     * 
     * // Get first 10 Senses
     * const senses = await prisma.senses.findMany({ take: 10 })
     * 
     * // Only select the `creature_id`
     * const sensesWithCreature_idOnly = await prisma.senses.findMany({ select: { creature_id: true } })
     * 
     */
    findMany<T extends SensesFindManyArgs>(args?: SelectSubset<T, SensesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SensesPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Senses.
     * @param {SensesCreateArgs} args - Arguments to create a Senses.
     * @example
     * // Create one Senses
     * const Senses = await prisma.senses.create({
     *   data: {
     *     // ... data to create a Senses
     *   }
     * })
     * 
     */
    create<T extends SensesCreateArgs>(args: SelectSubset<T, SensesCreateArgs<ExtArgs>>): Prisma__SensesClient<$Result.GetResult<Prisma.$SensesPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Senses.
     * @param {SensesCreateManyArgs} args - Arguments to create many Senses.
     * @example
     * // Create many Senses
     * const senses = await prisma.senses.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SensesCreateManyArgs>(args?: SelectSubset<T, SensesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Senses and returns the data saved in the database.
     * @param {SensesCreateManyAndReturnArgs} args - Arguments to create many Senses.
     * @example
     * // Create many Senses
     * const senses = await prisma.senses.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Senses and only return the `creature_id`
     * const sensesWithCreature_idOnly = await prisma.senses.createManyAndReturn({
     *   select: { creature_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SensesCreateManyAndReturnArgs>(args?: SelectSubset<T, SensesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SensesPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Senses.
     * @param {SensesDeleteArgs} args - Arguments to delete one Senses.
     * @example
     * // Delete one Senses
     * const Senses = await prisma.senses.delete({
     *   where: {
     *     // ... filter to delete one Senses
     *   }
     * })
     * 
     */
    delete<T extends SensesDeleteArgs>(args: SelectSubset<T, SensesDeleteArgs<ExtArgs>>): Prisma__SensesClient<$Result.GetResult<Prisma.$SensesPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Senses.
     * @param {SensesUpdateArgs} args - Arguments to update one Senses.
     * @example
     * // Update one Senses
     * const senses = await prisma.senses.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SensesUpdateArgs>(args: SelectSubset<T, SensesUpdateArgs<ExtArgs>>): Prisma__SensesClient<$Result.GetResult<Prisma.$SensesPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Senses.
     * @param {SensesDeleteManyArgs} args - Arguments to filter Senses to delete.
     * @example
     * // Delete a few Senses
     * const { count } = await prisma.senses.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SensesDeleteManyArgs>(args?: SelectSubset<T, SensesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Senses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SensesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Senses
     * const senses = await prisma.senses.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SensesUpdateManyArgs>(args: SelectSubset<T, SensesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Senses and returns the data updated in the database.
     * @param {SensesUpdateManyAndReturnArgs} args - Arguments to update many Senses.
     * @example
     * // Update many Senses
     * const senses = await prisma.senses.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Senses and only return the `creature_id`
     * const sensesWithCreature_idOnly = await prisma.senses.updateManyAndReturn({
     *   select: { creature_id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SensesUpdateManyAndReturnArgs>(args: SelectSubset<T, SensesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SensesPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Senses.
     * @param {SensesUpsertArgs} args - Arguments to update or create a Senses.
     * @example
     * // Update or create a Senses
     * const senses = await prisma.senses.upsert({
     *   create: {
     *     // ... data to create a Senses
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Senses we want to update
     *   }
     * })
     */
    upsert<T extends SensesUpsertArgs>(args: SelectSubset<T, SensesUpsertArgs<ExtArgs>>): Prisma__SensesClient<$Result.GetResult<Prisma.$SensesPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Senses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SensesCountArgs} args - Arguments to filter Senses to count.
     * @example
     * // Count the number of Senses
     * const count = await prisma.senses.count({
     *   where: {
     *     // ... the filter for the Senses we want to count
     *   }
     * })
    **/
    count<T extends SensesCountArgs>(
      args?: Subset<T, SensesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SensesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Senses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SensesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SensesAggregateArgs>(args: Subset<T, SensesAggregateArgs>): Prisma.PrismaPromise<GetSensesAggregateType<T>>

    /**
     * Group by Senses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SensesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SensesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SensesGroupByArgs['orderBy'] }
        : { orderBy?: SensesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SensesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSensesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Senses model
   */
  readonly fields: SensesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Senses.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SensesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    creature<T extends CreatureDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CreatureDefaultArgs<ExtArgs>>): Prisma__CreatureClient<$Result.GetResult<Prisma.$CreaturePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Senses model
   */ 
  interface SensesFieldRefs {
    readonly creature_id: FieldRef<"Senses", 'String'>
    readonly passive_perception: FieldRef<"Senses", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Senses findUnique
   */
  export type SensesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Senses
     */
    select?: SensesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Senses
     */
    omit?: SensesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SensesInclude<ExtArgs> | null
    /**
     * Filter, which Senses to fetch.
     */
    where: SensesWhereUniqueInput
  }

  /**
   * Senses findUniqueOrThrow
   */
  export type SensesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Senses
     */
    select?: SensesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Senses
     */
    omit?: SensesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SensesInclude<ExtArgs> | null
    /**
     * Filter, which Senses to fetch.
     */
    where: SensesWhereUniqueInput
  }

  /**
   * Senses findFirst
   */
  export type SensesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Senses
     */
    select?: SensesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Senses
     */
    omit?: SensesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SensesInclude<ExtArgs> | null
    /**
     * Filter, which Senses to fetch.
     */
    where?: SensesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Senses to fetch.
     */
    orderBy?: SensesOrderByWithRelationInput | SensesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Senses.
     */
    cursor?: SensesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Senses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Senses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Senses.
     */
    distinct?: SensesScalarFieldEnum | SensesScalarFieldEnum[]
  }

  /**
   * Senses findFirstOrThrow
   */
  export type SensesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Senses
     */
    select?: SensesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Senses
     */
    omit?: SensesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SensesInclude<ExtArgs> | null
    /**
     * Filter, which Senses to fetch.
     */
    where?: SensesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Senses to fetch.
     */
    orderBy?: SensesOrderByWithRelationInput | SensesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Senses.
     */
    cursor?: SensesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Senses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Senses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Senses.
     */
    distinct?: SensesScalarFieldEnum | SensesScalarFieldEnum[]
  }

  /**
   * Senses findMany
   */
  export type SensesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Senses
     */
    select?: SensesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Senses
     */
    omit?: SensesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SensesInclude<ExtArgs> | null
    /**
     * Filter, which Senses to fetch.
     */
    where?: SensesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Senses to fetch.
     */
    orderBy?: SensesOrderByWithRelationInput | SensesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Senses.
     */
    cursor?: SensesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Senses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Senses.
     */
    skip?: number
    distinct?: SensesScalarFieldEnum | SensesScalarFieldEnum[]
  }

  /**
   * Senses create
   */
  export type SensesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Senses
     */
    select?: SensesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Senses
     */
    omit?: SensesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SensesInclude<ExtArgs> | null
    /**
     * The data needed to create a Senses.
     */
    data: XOR<SensesCreateInput, SensesUncheckedCreateInput>
  }

  /**
   * Senses createMany
   */
  export type SensesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Senses.
     */
    data: SensesCreateManyInput | SensesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Senses createManyAndReturn
   */
  export type SensesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Senses
     */
    select?: SensesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Senses
     */
    omit?: SensesOmit<ExtArgs> | null
    /**
     * The data used to create many Senses.
     */
    data: SensesCreateManyInput | SensesCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SensesIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Senses update
   */
  export type SensesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Senses
     */
    select?: SensesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Senses
     */
    omit?: SensesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SensesInclude<ExtArgs> | null
    /**
     * The data needed to update a Senses.
     */
    data: XOR<SensesUpdateInput, SensesUncheckedUpdateInput>
    /**
     * Choose, which Senses to update.
     */
    where: SensesWhereUniqueInput
  }

  /**
   * Senses updateMany
   */
  export type SensesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Senses.
     */
    data: XOR<SensesUpdateManyMutationInput, SensesUncheckedUpdateManyInput>
    /**
     * Filter which Senses to update
     */
    where?: SensesWhereInput
    /**
     * Limit how many Senses to update.
     */
    limit?: number
  }

  /**
   * Senses updateManyAndReturn
   */
  export type SensesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Senses
     */
    select?: SensesSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Senses
     */
    omit?: SensesOmit<ExtArgs> | null
    /**
     * The data used to update Senses.
     */
    data: XOR<SensesUpdateManyMutationInput, SensesUncheckedUpdateManyInput>
    /**
     * Filter which Senses to update
     */
    where?: SensesWhereInput
    /**
     * Limit how many Senses to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SensesIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Senses upsert
   */
  export type SensesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Senses
     */
    select?: SensesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Senses
     */
    omit?: SensesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SensesInclude<ExtArgs> | null
    /**
     * The filter to search for the Senses to update in case it exists.
     */
    where: SensesWhereUniqueInput
    /**
     * In case the Senses found by the `where` argument doesn't exist, create a new Senses with this data.
     */
    create: XOR<SensesCreateInput, SensesUncheckedCreateInput>
    /**
     * In case the Senses was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SensesUpdateInput, SensesUncheckedUpdateInput>
  }

  /**
   * Senses delete
   */
  export type SensesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Senses
     */
    select?: SensesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Senses
     */
    omit?: SensesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SensesInclude<ExtArgs> | null
    /**
     * Filter which Senses to delete.
     */
    where: SensesWhereUniqueInput
  }

  /**
   * Senses deleteMany
   */
  export type SensesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Senses to delete
     */
    where?: SensesWhereInput
    /**
     * Limit how many Senses to delete.
     */
    limit?: number
  }

  /**
   * Senses without action
   */
  export type SensesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Senses
     */
    select?: SensesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Senses
     */
    omit?: SensesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SensesInclude<ExtArgs> | null
  }


  /**
   * Model Action
   */

  export type AggregateAction = {
    _count: ActionCountAggregateOutputType | null
    _avg: ActionAvgAggregateOutputType | null
    _sum: ActionSumAggregateOutputType | null
    _min: ActionMinAggregateOutputType | null
    _max: ActionMaxAggregateOutputType | null
  }

  export type ActionAvgAggregateOutputType = {
    id: number | null
  }

  export type ActionSumAggregateOutputType = {
    id: number | null
  }

  export type ActionMinAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
    attack: string | null
    is_template: boolean | null
  }

  export type ActionMaxAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
    attack: string | null
    is_template: boolean | null
  }

  export type ActionCountAggregateOutputType = {
    id: number
    name: number
    description: number
    attack: number
    is_template: number
    _all: number
  }


  export type ActionAvgAggregateInputType = {
    id?: true
  }

  export type ActionSumAggregateInputType = {
    id?: true
  }

  export type ActionMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    attack?: true
    is_template?: true
  }

  export type ActionMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    attack?: true
    is_template?: true
  }

  export type ActionCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    attack?: true
    is_template?: true
    _all?: true
  }

  export type ActionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Action to aggregate.
     */
    where?: ActionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Actions to fetch.
     */
    orderBy?: ActionOrderByWithRelationInput | ActionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ActionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Actions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Actions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Actions
    **/
    _count?: true | ActionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ActionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ActionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ActionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ActionMaxAggregateInputType
  }

  export type GetActionAggregateType<T extends ActionAggregateArgs> = {
        [P in keyof T & keyof AggregateAction]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAction[P]>
      : GetScalarType<T[P], AggregateAction[P]>
  }




  export type ActionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ActionWhereInput
    orderBy?: ActionOrderByWithAggregationInput | ActionOrderByWithAggregationInput[]
    by: ActionScalarFieldEnum[] | ActionScalarFieldEnum
    having?: ActionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ActionCountAggregateInputType | true
    _avg?: ActionAvgAggregateInputType
    _sum?: ActionSumAggregateInputType
    _min?: ActionMinAggregateInputType
    _max?: ActionMaxAggregateInputType
  }

  export type ActionGroupByOutputType = {
    id: number
    name: string
    description: string
    attack: string | null
    is_template: boolean | null
    _count: ActionCountAggregateOutputType | null
    _avg: ActionAvgAggregateOutputType | null
    _sum: ActionSumAggregateOutputType | null
    _min: ActionMinAggregateOutputType | null
    _max: ActionMaxAggregateOutputType | null
  }

  type GetActionGroupByPayload<T extends ActionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ActionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ActionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ActionGroupByOutputType[P]>
            : GetScalarType<T[P], ActionGroupByOutputType[P]>
        }
      >
    >


  export type ActionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    attack?: boolean
    is_template?: boolean
    creatures?: boolean | Action$creaturesArgs<ExtArgs>
    creatureTypes?: boolean | Action$creatureTypesArgs<ExtArgs>
    _count?: boolean | ActionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["action"]>

  export type ActionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    attack?: boolean
    is_template?: boolean
  }, ExtArgs["result"]["action"]>

  export type ActionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    attack?: boolean
    is_template?: boolean
  }, ExtArgs["result"]["action"]>

  export type ActionSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    attack?: boolean
    is_template?: boolean
  }

  export type ActionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "attack" | "is_template", ExtArgs["result"]["action"]>
  export type ActionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creatures?: boolean | Action$creaturesArgs<ExtArgs>
    creatureTypes?: boolean | Action$creatureTypesArgs<ExtArgs>
    _count?: boolean | ActionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ActionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type ActionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $ActionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Action"
    objects: {
      creatures: Prisma.$CreaturePayload<ExtArgs>[]
      creatureTypes: Prisma.$CreatureRacePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      description: string
      attack: string | null
      is_template: boolean | null
    }, ExtArgs["result"]["action"]>
    composites: {}
  }

  type ActionGetPayload<S extends boolean | null | undefined | ActionDefaultArgs> = $Result.GetResult<Prisma.$ActionPayload, S>

  type ActionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ActionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ActionCountAggregateInputType | true
    }

  export interface ActionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Action'], meta: { name: 'Action' } }
    /**
     * Find zero or one Action that matches the filter.
     * @param {ActionFindUniqueArgs} args - Arguments to find a Action
     * @example
     * // Get one Action
     * const action = await prisma.action.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ActionFindUniqueArgs>(args: SelectSubset<T, ActionFindUniqueArgs<ExtArgs>>): Prisma__ActionClient<$Result.GetResult<Prisma.$ActionPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Action that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ActionFindUniqueOrThrowArgs} args - Arguments to find a Action
     * @example
     * // Get one Action
     * const action = await prisma.action.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ActionFindUniqueOrThrowArgs>(args: SelectSubset<T, ActionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ActionClient<$Result.GetResult<Prisma.$ActionPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Action that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActionFindFirstArgs} args - Arguments to find a Action
     * @example
     * // Get one Action
     * const action = await prisma.action.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ActionFindFirstArgs>(args?: SelectSubset<T, ActionFindFirstArgs<ExtArgs>>): Prisma__ActionClient<$Result.GetResult<Prisma.$ActionPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Action that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActionFindFirstOrThrowArgs} args - Arguments to find a Action
     * @example
     * // Get one Action
     * const action = await prisma.action.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ActionFindFirstOrThrowArgs>(args?: SelectSubset<T, ActionFindFirstOrThrowArgs<ExtArgs>>): Prisma__ActionClient<$Result.GetResult<Prisma.$ActionPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Actions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Actions
     * const actions = await prisma.action.findMany()
     * 
     * // Get first 10 Actions
     * const actions = await prisma.action.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const actionWithIdOnly = await prisma.action.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ActionFindManyArgs>(args?: SelectSubset<T, ActionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActionPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Action.
     * @param {ActionCreateArgs} args - Arguments to create a Action.
     * @example
     * // Create one Action
     * const Action = await prisma.action.create({
     *   data: {
     *     // ... data to create a Action
     *   }
     * })
     * 
     */
    create<T extends ActionCreateArgs>(args: SelectSubset<T, ActionCreateArgs<ExtArgs>>): Prisma__ActionClient<$Result.GetResult<Prisma.$ActionPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Actions.
     * @param {ActionCreateManyArgs} args - Arguments to create many Actions.
     * @example
     * // Create many Actions
     * const action = await prisma.action.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ActionCreateManyArgs>(args?: SelectSubset<T, ActionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Actions and returns the data saved in the database.
     * @param {ActionCreateManyAndReturnArgs} args - Arguments to create many Actions.
     * @example
     * // Create many Actions
     * const action = await prisma.action.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Actions and only return the `id`
     * const actionWithIdOnly = await prisma.action.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ActionCreateManyAndReturnArgs>(args?: SelectSubset<T, ActionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActionPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Action.
     * @param {ActionDeleteArgs} args - Arguments to delete one Action.
     * @example
     * // Delete one Action
     * const Action = await prisma.action.delete({
     *   where: {
     *     // ... filter to delete one Action
     *   }
     * })
     * 
     */
    delete<T extends ActionDeleteArgs>(args: SelectSubset<T, ActionDeleteArgs<ExtArgs>>): Prisma__ActionClient<$Result.GetResult<Prisma.$ActionPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Action.
     * @param {ActionUpdateArgs} args - Arguments to update one Action.
     * @example
     * // Update one Action
     * const action = await prisma.action.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ActionUpdateArgs>(args: SelectSubset<T, ActionUpdateArgs<ExtArgs>>): Prisma__ActionClient<$Result.GetResult<Prisma.$ActionPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Actions.
     * @param {ActionDeleteManyArgs} args - Arguments to filter Actions to delete.
     * @example
     * // Delete a few Actions
     * const { count } = await prisma.action.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ActionDeleteManyArgs>(args?: SelectSubset<T, ActionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Actions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Actions
     * const action = await prisma.action.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ActionUpdateManyArgs>(args: SelectSubset<T, ActionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Actions and returns the data updated in the database.
     * @param {ActionUpdateManyAndReturnArgs} args - Arguments to update many Actions.
     * @example
     * // Update many Actions
     * const action = await prisma.action.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Actions and only return the `id`
     * const actionWithIdOnly = await prisma.action.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ActionUpdateManyAndReturnArgs>(args: SelectSubset<T, ActionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActionPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Action.
     * @param {ActionUpsertArgs} args - Arguments to update or create a Action.
     * @example
     * // Update or create a Action
     * const action = await prisma.action.upsert({
     *   create: {
     *     // ... data to create a Action
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Action we want to update
     *   }
     * })
     */
    upsert<T extends ActionUpsertArgs>(args: SelectSubset<T, ActionUpsertArgs<ExtArgs>>): Prisma__ActionClient<$Result.GetResult<Prisma.$ActionPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Actions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActionCountArgs} args - Arguments to filter Actions to count.
     * @example
     * // Count the number of Actions
     * const count = await prisma.action.count({
     *   where: {
     *     // ... the filter for the Actions we want to count
     *   }
     * })
    **/
    count<T extends ActionCountArgs>(
      args?: Subset<T, ActionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ActionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Action.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ActionAggregateArgs>(args: Subset<T, ActionAggregateArgs>): Prisma.PrismaPromise<GetActionAggregateType<T>>

    /**
     * Group by Action.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ActionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ActionGroupByArgs['orderBy'] }
        : { orderBy?: ActionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ActionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetActionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Action model
   */
  readonly fields: ActionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Action.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ActionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    creatures<T extends Action$creaturesArgs<ExtArgs> = {}>(args?: Subset<T, Action$creaturesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CreaturePayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    creatureTypes<T extends Action$creatureTypesArgs<ExtArgs> = {}>(args?: Subset<T, Action$creatureTypesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CreatureRacePayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Action model
   */ 
  interface ActionFieldRefs {
    readonly id: FieldRef<"Action", 'Int'>
    readonly name: FieldRef<"Action", 'String'>
    readonly description: FieldRef<"Action", 'String'>
    readonly attack: FieldRef<"Action", 'String'>
    readonly is_template: FieldRef<"Action", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * Action findUnique
   */
  export type ActionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Action
     */
    select?: ActionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Action
     */
    omit?: ActionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActionInclude<ExtArgs> | null
    /**
     * Filter, which Action to fetch.
     */
    where: ActionWhereUniqueInput
  }

  /**
   * Action findUniqueOrThrow
   */
  export type ActionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Action
     */
    select?: ActionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Action
     */
    omit?: ActionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActionInclude<ExtArgs> | null
    /**
     * Filter, which Action to fetch.
     */
    where: ActionWhereUniqueInput
  }

  /**
   * Action findFirst
   */
  export type ActionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Action
     */
    select?: ActionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Action
     */
    omit?: ActionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActionInclude<ExtArgs> | null
    /**
     * Filter, which Action to fetch.
     */
    where?: ActionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Actions to fetch.
     */
    orderBy?: ActionOrderByWithRelationInput | ActionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Actions.
     */
    cursor?: ActionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Actions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Actions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Actions.
     */
    distinct?: ActionScalarFieldEnum | ActionScalarFieldEnum[]
  }

  /**
   * Action findFirstOrThrow
   */
  export type ActionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Action
     */
    select?: ActionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Action
     */
    omit?: ActionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActionInclude<ExtArgs> | null
    /**
     * Filter, which Action to fetch.
     */
    where?: ActionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Actions to fetch.
     */
    orderBy?: ActionOrderByWithRelationInput | ActionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Actions.
     */
    cursor?: ActionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Actions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Actions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Actions.
     */
    distinct?: ActionScalarFieldEnum | ActionScalarFieldEnum[]
  }

  /**
   * Action findMany
   */
  export type ActionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Action
     */
    select?: ActionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Action
     */
    omit?: ActionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActionInclude<ExtArgs> | null
    /**
     * Filter, which Actions to fetch.
     */
    where?: ActionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Actions to fetch.
     */
    orderBy?: ActionOrderByWithRelationInput | ActionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Actions.
     */
    cursor?: ActionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Actions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Actions.
     */
    skip?: number
    distinct?: ActionScalarFieldEnum | ActionScalarFieldEnum[]
  }

  /**
   * Action create
   */
  export type ActionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Action
     */
    select?: ActionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Action
     */
    omit?: ActionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActionInclude<ExtArgs> | null
    /**
     * The data needed to create a Action.
     */
    data: XOR<ActionCreateInput, ActionUncheckedCreateInput>
  }

  /**
   * Action createMany
   */
  export type ActionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Actions.
     */
    data: ActionCreateManyInput | ActionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Action createManyAndReturn
   */
  export type ActionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Action
     */
    select?: ActionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Action
     */
    omit?: ActionOmit<ExtArgs> | null
    /**
     * The data used to create many Actions.
     */
    data: ActionCreateManyInput | ActionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Action update
   */
  export type ActionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Action
     */
    select?: ActionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Action
     */
    omit?: ActionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActionInclude<ExtArgs> | null
    /**
     * The data needed to update a Action.
     */
    data: XOR<ActionUpdateInput, ActionUncheckedUpdateInput>
    /**
     * Choose, which Action to update.
     */
    where: ActionWhereUniqueInput
  }

  /**
   * Action updateMany
   */
  export type ActionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Actions.
     */
    data: XOR<ActionUpdateManyMutationInput, ActionUncheckedUpdateManyInput>
    /**
     * Filter which Actions to update
     */
    where?: ActionWhereInput
    /**
     * Limit how many Actions to update.
     */
    limit?: number
  }

  /**
   * Action updateManyAndReturn
   */
  export type ActionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Action
     */
    select?: ActionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Action
     */
    omit?: ActionOmit<ExtArgs> | null
    /**
     * The data used to update Actions.
     */
    data: XOR<ActionUpdateManyMutationInput, ActionUncheckedUpdateManyInput>
    /**
     * Filter which Actions to update
     */
    where?: ActionWhereInput
    /**
     * Limit how many Actions to update.
     */
    limit?: number
  }

  /**
   * Action upsert
   */
  export type ActionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Action
     */
    select?: ActionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Action
     */
    omit?: ActionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActionInclude<ExtArgs> | null
    /**
     * The filter to search for the Action to update in case it exists.
     */
    where: ActionWhereUniqueInput
    /**
     * In case the Action found by the `where` argument doesn't exist, create a new Action with this data.
     */
    create: XOR<ActionCreateInput, ActionUncheckedCreateInput>
    /**
     * In case the Action was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ActionUpdateInput, ActionUncheckedUpdateInput>
  }

  /**
   * Action delete
   */
  export type ActionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Action
     */
    select?: ActionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Action
     */
    omit?: ActionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActionInclude<ExtArgs> | null
    /**
     * Filter which Action to delete.
     */
    where: ActionWhereUniqueInput
  }

  /**
   * Action deleteMany
   */
  export type ActionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Actions to delete
     */
    where?: ActionWhereInput
    /**
     * Limit how many Actions to delete.
     */
    limit?: number
  }

  /**
   * Action.creatures
   */
  export type Action$creaturesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Creature
     */
    select?: CreatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Creature
     */
    omit?: CreatureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreatureInclude<ExtArgs> | null
    where?: CreatureWhereInput
    orderBy?: CreatureOrderByWithRelationInput | CreatureOrderByWithRelationInput[]
    cursor?: CreatureWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CreatureScalarFieldEnum | CreatureScalarFieldEnum[]
  }

  /**
   * Action.creatureTypes
   */
  export type Action$creatureTypesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreatureRace
     */
    select?: CreatureRaceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CreatureRace
     */
    omit?: CreatureRaceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreatureRaceInclude<ExtArgs> | null
    where?: CreatureRaceWhereInput
    orderBy?: CreatureRaceOrderByWithRelationInput | CreatureRaceOrderByWithRelationInput[]
    cursor?: CreatureRaceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CreatureRaceScalarFieldEnum | CreatureRaceScalarFieldEnum[]
  }

  /**
   * Action without action
   */
  export type ActionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Action
     */
    select?: ActionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Action
     */
    omit?: ActionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActionInclude<ExtArgs> | null
  }


  /**
   * Model Trait
   */

  export type AggregateTrait = {
    _count: TraitCountAggregateOutputType | null
    _avg: TraitAvgAggregateOutputType | null
    _sum: TraitSumAggregateOutputType | null
    _min: TraitMinAggregateOutputType | null
    _max: TraitMaxAggregateOutputType | null
  }

  export type TraitAvgAggregateOutputType = {
    id: number | null
  }

  export type TraitSumAggregateOutputType = {
    id: number | null
  }

  export type TraitMinAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
    attack: string | null
    is_template: boolean | null
  }

  export type TraitMaxAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
    attack: string | null
    is_template: boolean | null
  }

  export type TraitCountAggregateOutputType = {
    id: number
    name: number
    description: number
    attack: number
    is_template: number
    _all: number
  }


  export type TraitAvgAggregateInputType = {
    id?: true
  }

  export type TraitSumAggregateInputType = {
    id?: true
  }

  export type TraitMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    attack?: true
    is_template?: true
  }

  export type TraitMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    attack?: true
    is_template?: true
  }

  export type TraitCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    attack?: true
    is_template?: true
    _all?: true
  }

  export type TraitAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Trait to aggregate.
     */
    where?: TraitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Traits to fetch.
     */
    orderBy?: TraitOrderByWithRelationInput | TraitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TraitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Traits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Traits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Traits
    **/
    _count?: true | TraitCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TraitAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TraitSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TraitMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TraitMaxAggregateInputType
  }

  export type GetTraitAggregateType<T extends TraitAggregateArgs> = {
        [P in keyof T & keyof AggregateTrait]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTrait[P]>
      : GetScalarType<T[P], AggregateTrait[P]>
  }




  export type TraitGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TraitWhereInput
    orderBy?: TraitOrderByWithAggregationInput | TraitOrderByWithAggregationInput[]
    by: TraitScalarFieldEnum[] | TraitScalarFieldEnum
    having?: TraitScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TraitCountAggregateInputType | true
    _avg?: TraitAvgAggregateInputType
    _sum?: TraitSumAggregateInputType
    _min?: TraitMinAggregateInputType
    _max?: TraitMaxAggregateInputType
  }

  export type TraitGroupByOutputType = {
    id: number
    name: string
    description: string
    attack: string | null
    is_template: boolean | null
    _count: TraitCountAggregateOutputType | null
    _avg: TraitAvgAggregateOutputType | null
    _sum: TraitSumAggregateOutputType | null
    _min: TraitMinAggregateOutputType | null
    _max: TraitMaxAggregateOutputType | null
  }

  type GetTraitGroupByPayload<T extends TraitGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TraitGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TraitGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TraitGroupByOutputType[P]>
            : GetScalarType<T[P], TraitGroupByOutputType[P]>
        }
      >
    >


  export type TraitSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    attack?: boolean
    is_template?: boolean
    cretures?: boolean | Trait$creturesArgs<ExtArgs>
    creatureTypes?: boolean | Trait$creatureTypesArgs<ExtArgs>
    _count?: boolean | TraitCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["trait"]>

  export type TraitSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    attack?: boolean
    is_template?: boolean
  }, ExtArgs["result"]["trait"]>

  export type TraitSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    attack?: boolean
    is_template?: boolean
  }, ExtArgs["result"]["trait"]>

  export type TraitSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    attack?: boolean
    is_template?: boolean
  }

  export type TraitOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "attack" | "is_template", ExtArgs["result"]["trait"]>
  export type TraitInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cretures?: boolean | Trait$creturesArgs<ExtArgs>
    creatureTypes?: boolean | Trait$creatureTypesArgs<ExtArgs>
    _count?: boolean | TraitCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TraitIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type TraitIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $TraitPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Trait"
    objects: {
      cretures: Prisma.$CreaturePayload<ExtArgs>[]
      creatureTypes: Prisma.$CreatureRacePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      description: string
      attack: string | null
      is_template: boolean | null
    }, ExtArgs["result"]["trait"]>
    composites: {}
  }

  type TraitGetPayload<S extends boolean | null | undefined | TraitDefaultArgs> = $Result.GetResult<Prisma.$TraitPayload, S>

  type TraitCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TraitFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TraitCountAggregateInputType | true
    }

  export interface TraitDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Trait'], meta: { name: 'Trait' } }
    /**
     * Find zero or one Trait that matches the filter.
     * @param {TraitFindUniqueArgs} args - Arguments to find a Trait
     * @example
     * // Get one Trait
     * const trait = await prisma.trait.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TraitFindUniqueArgs>(args: SelectSubset<T, TraitFindUniqueArgs<ExtArgs>>): Prisma__TraitClient<$Result.GetResult<Prisma.$TraitPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Trait that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TraitFindUniqueOrThrowArgs} args - Arguments to find a Trait
     * @example
     * // Get one Trait
     * const trait = await prisma.trait.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TraitFindUniqueOrThrowArgs>(args: SelectSubset<T, TraitFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TraitClient<$Result.GetResult<Prisma.$TraitPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Trait that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TraitFindFirstArgs} args - Arguments to find a Trait
     * @example
     * // Get one Trait
     * const trait = await prisma.trait.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TraitFindFirstArgs>(args?: SelectSubset<T, TraitFindFirstArgs<ExtArgs>>): Prisma__TraitClient<$Result.GetResult<Prisma.$TraitPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Trait that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TraitFindFirstOrThrowArgs} args - Arguments to find a Trait
     * @example
     * // Get one Trait
     * const trait = await prisma.trait.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TraitFindFirstOrThrowArgs>(args?: SelectSubset<T, TraitFindFirstOrThrowArgs<ExtArgs>>): Prisma__TraitClient<$Result.GetResult<Prisma.$TraitPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Traits that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TraitFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Traits
     * const traits = await prisma.trait.findMany()
     * 
     * // Get first 10 Traits
     * const traits = await prisma.trait.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const traitWithIdOnly = await prisma.trait.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TraitFindManyArgs>(args?: SelectSubset<T, TraitFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TraitPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Trait.
     * @param {TraitCreateArgs} args - Arguments to create a Trait.
     * @example
     * // Create one Trait
     * const Trait = await prisma.trait.create({
     *   data: {
     *     // ... data to create a Trait
     *   }
     * })
     * 
     */
    create<T extends TraitCreateArgs>(args: SelectSubset<T, TraitCreateArgs<ExtArgs>>): Prisma__TraitClient<$Result.GetResult<Prisma.$TraitPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Traits.
     * @param {TraitCreateManyArgs} args - Arguments to create many Traits.
     * @example
     * // Create many Traits
     * const trait = await prisma.trait.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TraitCreateManyArgs>(args?: SelectSubset<T, TraitCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Traits and returns the data saved in the database.
     * @param {TraitCreateManyAndReturnArgs} args - Arguments to create many Traits.
     * @example
     * // Create many Traits
     * const trait = await prisma.trait.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Traits and only return the `id`
     * const traitWithIdOnly = await prisma.trait.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TraitCreateManyAndReturnArgs>(args?: SelectSubset<T, TraitCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TraitPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Trait.
     * @param {TraitDeleteArgs} args - Arguments to delete one Trait.
     * @example
     * // Delete one Trait
     * const Trait = await prisma.trait.delete({
     *   where: {
     *     // ... filter to delete one Trait
     *   }
     * })
     * 
     */
    delete<T extends TraitDeleteArgs>(args: SelectSubset<T, TraitDeleteArgs<ExtArgs>>): Prisma__TraitClient<$Result.GetResult<Prisma.$TraitPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Trait.
     * @param {TraitUpdateArgs} args - Arguments to update one Trait.
     * @example
     * // Update one Trait
     * const trait = await prisma.trait.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TraitUpdateArgs>(args: SelectSubset<T, TraitUpdateArgs<ExtArgs>>): Prisma__TraitClient<$Result.GetResult<Prisma.$TraitPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Traits.
     * @param {TraitDeleteManyArgs} args - Arguments to filter Traits to delete.
     * @example
     * // Delete a few Traits
     * const { count } = await prisma.trait.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TraitDeleteManyArgs>(args?: SelectSubset<T, TraitDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Traits.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TraitUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Traits
     * const trait = await prisma.trait.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TraitUpdateManyArgs>(args: SelectSubset<T, TraitUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Traits and returns the data updated in the database.
     * @param {TraitUpdateManyAndReturnArgs} args - Arguments to update many Traits.
     * @example
     * // Update many Traits
     * const trait = await prisma.trait.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Traits and only return the `id`
     * const traitWithIdOnly = await prisma.trait.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TraitUpdateManyAndReturnArgs>(args: SelectSubset<T, TraitUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TraitPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Trait.
     * @param {TraitUpsertArgs} args - Arguments to update or create a Trait.
     * @example
     * // Update or create a Trait
     * const trait = await prisma.trait.upsert({
     *   create: {
     *     // ... data to create a Trait
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Trait we want to update
     *   }
     * })
     */
    upsert<T extends TraitUpsertArgs>(args: SelectSubset<T, TraitUpsertArgs<ExtArgs>>): Prisma__TraitClient<$Result.GetResult<Prisma.$TraitPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Traits.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TraitCountArgs} args - Arguments to filter Traits to count.
     * @example
     * // Count the number of Traits
     * const count = await prisma.trait.count({
     *   where: {
     *     // ... the filter for the Traits we want to count
     *   }
     * })
    **/
    count<T extends TraitCountArgs>(
      args?: Subset<T, TraitCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TraitCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Trait.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TraitAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TraitAggregateArgs>(args: Subset<T, TraitAggregateArgs>): Prisma.PrismaPromise<GetTraitAggregateType<T>>

    /**
     * Group by Trait.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TraitGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TraitGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TraitGroupByArgs['orderBy'] }
        : { orderBy?: TraitGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TraitGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTraitGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Trait model
   */
  readonly fields: TraitFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Trait.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TraitClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    cretures<T extends Trait$creturesArgs<ExtArgs> = {}>(args?: Subset<T, Trait$creturesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CreaturePayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    creatureTypes<T extends Trait$creatureTypesArgs<ExtArgs> = {}>(args?: Subset<T, Trait$creatureTypesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CreatureRacePayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Trait model
   */ 
  interface TraitFieldRefs {
    readonly id: FieldRef<"Trait", 'Int'>
    readonly name: FieldRef<"Trait", 'String'>
    readonly description: FieldRef<"Trait", 'String'>
    readonly attack: FieldRef<"Trait", 'String'>
    readonly is_template: FieldRef<"Trait", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * Trait findUnique
   */
  export type TraitFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Trait
     */
    select?: TraitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Trait
     */
    omit?: TraitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TraitInclude<ExtArgs> | null
    /**
     * Filter, which Trait to fetch.
     */
    where: TraitWhereUniqueInput
  }

  /**
   * Trait findUniqueOrThrow
   */
  export type TraitFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Trait
     */
    select?: TraitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Trait
     */
    omit?: TraitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TraitInclude<ExtArgs> | null
    /**
     * Filter, which Trait to fetch.
     */
    where: TraitWhereUniqueInput
  }

  /**
   * Trait findFirst
   */
  export type TraitFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Trait
     */
    select?: TraitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Trait
     */
    omit?: TraitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TraitInclude<ExtArgs> | null
    /**
     * Filter, which Trait to fetch.
     */
    where?: TraitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Traits to fetch.
     */
    orderBy?: TraitOrderByWithRelationInput | TraitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Traits.
     */
    cursor?: TraitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Traits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Traits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Traits.
     */
    distinct?: TraitScalarFieldEnum | TraitScalarFieldEnum[]
  }

  /**
   * Trait findFirstOrThrow
   */
  export type TraitFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Trait
     */
    select?: TraitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Trait
     */
    omit?: TraitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TraitInclude<ExtArgs> | null
    /**
     * Filter, which Trait to fetch.
     */
    where?: TraitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Traits to fetch.
     */
    orderBy?: TraitOrderByWithRelationInput | TraitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Traits.
     */
    cursor?: TraitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Traits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Traits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Traits.
     */
    distinct?: TraitScalarFieldEnum | TraitScalarFieldEnum[]
  }

  /**
   * Trait findMany
   */
  export type TraitFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Trait
     */
    select?: TraitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Trait
     */
    omit?: TraitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TraitInclude<ExtArgs> | null
    /**
     * Filter, which Traits to fetch.
     */
    where?: TraitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Traits to fetch.
     */
    orderBy?: TraitOrderByWithRelationInput | TraitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Traits.
     */
    cursor?: TraitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Traits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Traits.
     */
    skip?: number
    distinct?: TraitScalarFieldEnum | TraitScalarFieldEnum[]
  }

  /**
   * Trait create
   */
  export type TraitCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Trait
     */
    select?: TraitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Trait
     */
    omit?: TraitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TraitInclude<ExtArgs> | null
    /**
     * The data needed to create a Trait.
     */
    data: XOR<TraitCreateInput, TraitUncheckedCreateInput>
  }

  /**
   * Trait createMany
   */
  export type TraitCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Traits.
     */
    data: TraitCreateManyInput | TraitCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Trait createManyAndReturn
   */
  export type TraitCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Trait
     */
    select?: TraitSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Trait
     */
    omit?: TraitOmit<ExtArgs> | null
    /**
     * The data used to create many Traits.
     */
    data: TraitCreateManyInput | TraitCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Trait update
   */
  export type TraitUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Trait
     */
    select?: TraitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Trait
     */
    omit?: TraitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TraitInclude<ExtArgs> | null
    /**
     * The data needed to update a Trait.
     */
    data: XOR<TraitUpdateInput, TraitUncheckedUpdateInput>
    /**
     * Choose, which Trait to update.
     */
    where: TraitWhereUniqueInput
  }

  /**
   * Trait updateMany
   */
  export type TraitUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Traits.
     */
    data: XOR<TraitUpdateManyMutationInput, TraitUncheckedUpdateManyInput>
    /**
     * Filter which Traits to update
     */
    where?: TraitWhereInput
    /**
     * Limit how many Traits to update.
     */
    limit?: number
  }

  /**
   * Trait updateManyAndReturn
   */
  export type TraitUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Trait
     */
    select?: TraitSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Trait
     */
    omit?: TraitOmit<ExtArgs> | null
    /**
     * The data used to update Traits.
     */
    data: XOR<TraitUpdateManyMutationInput, TraitUncheckedUpdateManyInput>
    /**
     * Filter which Traits to update
     */
    where?: TraitWhereInput
    /**
     * Limit how many Traits to update.
     */
    limit?: number
  }

  /**
   * Trait upsert
   */
  export type TraitUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Trait
     */
    select?: TraitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Trait
     */
    omit?: TraitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TraitInclude<ExtArgs> | null
    /**
     * The filter to search for the Trait to update in case it exists.
     */
    where: TraitWhereUniqueInput
    /**
     * In case the Trait found by the `where` argument doesn't exist, create a new Trait with this data.
     */
    create: XOR<TraitCreateInput, TraitUncheckedCreateInput>
    /**
     * In case the Trait was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TraitUpdateInput, TraitUncheckedUpdateInput>
  }

  /**
   * Trait delete
   */
  export type TraitDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Trait
     */
    select?: TraitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Trait
     */
    omit?: TraitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TraitInclude<ExtArgs> | null
    /**
     * Filter which Trait to delete.
     */
    where: TraitWhereUniqueInput
  }

  /**
   * Trait deleteMany
   */
  export type TraitDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Traits to delete
     */
    where?: TraitWhereInput
    /**
     * Limit how many Traits to delete.
     */
    limit?: number
  }

  /**
   * Trait.cretures
   */
  export type Trait$creturesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Creature
     */
    select?: CreatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Creature
     */
    omit?: CreatureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreatureInclude<ExtArgs> | null
    where?: CreatureWhereInput
    orderBy?: CreatureOrderByWithRelationInput | CreatureOrderByWithRelationInput[]
    cursor?: CreatureWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CreatureScalarFieldEnum | CreatureScalarFieldEnum[]
  }

  /**
   * Trait.creatureTypes
   */
  export type Trait$creatureTypesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreatureRace
     */
    select?: CreatureRaceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CreatureRace
     */
    omit?: CreatureRaceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreatureRaceInclude<ExtArgs> | null
    where?: CreatureRaceWhereInput
    orderBy?: CreatureRaceOrderByWithRelationInput | CreatureRaceOrderByWithRelationInput[]
    cursor?: CreatureRaceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CreatureRaceScalarFieldEnum | CreatureRaceScalarFieldEnum[]
  }

  /**
   * Trait without action
   */
  export type TraitDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Trait
     */
    select?: TraitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Trait
     */
    omit?: TraitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TraitInclude<ExtArgs> | null
  }


  /**
   * Model CreatureRace
   */

  export type AggregateCreatureRace = {
    _count: CreatureRaceCountAggregateOutputType | null
    _avg: CreatureRaceAvgAggregateOutputType | null
    _sum: CreatureRaceSumAggregateOutputType | null
    _min: CreatureRaceMinAggregateOutputType | null
    _max: CreatureRaceMaxAggregateOutputType | null
  }

  export type CreatureRaceAvgAggregateOutputType = {
    id: number | null
  }

  export type CreatureRaceSumAggregateOutputType = {
    id: number | null
  }

  export type CreatureRaceMinAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
  }

  export type CreatureRaceMaxAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
  }

  export type CreatureRaceCountAggregateOutputType = {
    id: number
    name: number
    description: number
    _all: number
  }


  export type CreatureRaceAvgAggregateInputType = {
    id?: true
  }

  export type CreatureRaceSumAggregateInputType = {
    id?: true
  }

  export type CreatureRaceMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
  }

  export type CreatureRaceMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
  }

  export type CreatureRaceCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    _all?: true
  }

  export type CreatureRaceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CreatureRace to aggregate.
     */
    where?: CreatureRaceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CreatureRaces to fetch.
     */
    orderBy?: CreatureRaceOrderByWithRelationInput | CreatureRaceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CreatureRaceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CreatureRaces from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CreatureRaces.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CreatureRaces
    **/
    _count?: true | CreatureRaceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CreatureRaceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CreatureRaceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CreatureRaceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CreatureRaceMaxAggregateInputType
  }

  export type GetCreatureRaceAggregateType<T extends CreatureRaceAggregateArgs> = {
        [P in keyof T & keyof AggregateCreatureRace]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCreatureRace[P]>
      : GetScalarType<T[P], AggregateCreatureRace[P]>
  }




  export type CreatureRaceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CreatureRaceWhereInput
    orderBy?: CreatureRaceOrderByWithAggregationInput | CreatureRaceOrderByWithAggregationInput[]
    by: CreatureRaceScalarFieldEnum[] | CreatureRaceScalarFieldEnum
    having?: CreatureRaceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CreatureRaceCountAggregateInputType | true
    _avg?: CreatureRaceAvgAggregateInputType
    _sum?: CreatureRaceSumAggregateInputType
    _min?: CreatureRaceMinAggregateInputType
    _max?: CreatureRaceMaxAggregateInputType
  }

  export type CreatureRaceGroupByOutputType = {
    id: number
    name: string
    description: string
    _count: CreatureRaceCountAggregateOutputType | null
    _avg: CreatureRaceAvgAggregateOutputType | null
    _sum: CreatureRaceSumAggregateOutputType | null
    _min: CreatureRaceMinAggregateOutputType | null
    _max: CreatureRaceMaxAggregateOutputType | null
  }

  type GetCreatureRaceGroupByPayload<T extends CreatureRaceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CreatureRaceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CreatureRaceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CreatureRaceGroupByOutputType[P]>
            : GetScalarType<T[P], CreatureRaceGroupByOutputType[P]>
        }
      >
    >


  export type CreatureRaceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    traits?: boolean | CreatureRace$traitsArgs<ExtArgs>
    actions?: boolean | CreatureRace$actionsArgs<ExtArgs>
    creatures?: boolean | CreatureRace$creaturesArgs<ExtArgs>
    _count?: boolean | CreatureRaceCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["creatureRace"]>

  export type CreatureRaceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
  }, ExtArgs["result"]["creatureRace"]>

  export type CreatureRaceSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
  }, ExtArgs["result"]["creatureRace"]>

  export type CreatureRaceSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
  }

  export type CreatureRaceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description", ExtArgs["result"]["creatureRace"]>
  export type CreatureRaceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    traits?: boolean | CreatureRace$traitsArgs<ExtArgs>
    actions?: boolean | CreatureRace$actionsArgs<ExtArgs>
    creatures?: boolean | CreatureRace$creaturesArgs<ExtArgs>
    _count?: boolean | CreatureRaceCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CreatureRaceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type CreatureRaceIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $CreatureRacePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CreatureRace"
    objects: {
      traits: Prisma.$TraitPayload<ExtArgs>[]
      actions: Prisma.$ActionPayload<ExtArgs>[]
      creatures: Prisma.$CreaturePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      description: string
    }, ExtArgs["result"]["creatureRace"]>
    composites: {}
  }

  type CreatureRaceGetPayload<S extends boolean | null | undefined | CreatureRaceDefaultArgs> = $Result.GetResult<Prisma.$CreatureRacePayload, S>

  type CreatureRaceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CreatureRaceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CreatureRaceCountAggregateInputType | true
    }

  export interface CreatureRaceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CreatureRace'], meta: { name: 'CreatureRace' } }
    /**
     * Find zero or one CreatureRace that matches the filter.
     * @param {CreatureRaceFindUniqueArgs} args - Arguments to find a CreatureRace
     * @example
     * // Get one CreatureRace
     * const creatureRace = await prisma.creatureRace.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CreatureRaceFindUniqueArgs>(args: SelectSubset<T, CreatureRaceFindUniqueArgs<ExtArgs>>): Prisma__CreatureRaceClient<$Result.GetResult<Prisma.$CreatureRacePayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one CreatureRace that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CreatureRaceFindUniqueOrThrowArgs} args - Arguments to find a CreatureRace
     * @example
     * // Get one CreatureRace
     * const creatureRace = await prisma.creatureRace.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CreatureRaceFindUniqueOrThrowArgs>(args: SelectSubset<T, CreatureRaceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CreatureRaceClient<$Result.GetResult<Prisma.$CreatureRacePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first CreatureRace that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreatureRaceFindFirstArgs} args - Arguments to find a CreatureRace
     * @example
     * // Get one CreatureRace
     * const creatureRace = await prisma.creatureRace.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CreatureRaceFindFirstArgs>(args?: SelectSubset<T, CreatureRaceFindFirstArgs<ExtArgs>>): Prisma__CreatureRaceClient<$Result.GetResult<Prisma.$CreatureRacePayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first CreatureRace that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreatureRaceFindFirstOrThrowArgs} args - Arguments to find a CreatureRace
     * @example
     * // Get one CreatureRace
     * const creatureRace = await prisma.creatureRace.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CreatureRaceFindFirstOrThrowArgs>(args?: SelectSubset<T, CreatureRaceFindFirstOrThrowArgs<ExtArgs>>): Prisma__CreatureRaceClient<$Result.GetResult<Prisma.$CreatureRacePayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more CreatureRaces that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreatureRaceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CreatureRaces
     * const creatureRaces = await prisma.creatureRace.findMany()
     * 
     * // Get first 10 CreatureRaces
     * const creatureRaces = await prisma.creatureRace.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const creatureRaceWithIdOnly = await prisma.creatureRace.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CreatureRaceFindManyArgs>(args?: SelectSubset<T, CreatureRaceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CreatureRacePayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a CreatureRace.
     * @param {CreatureRaceCreateArgs} args - Arguments to create a CreatureRace.
     * @example
     * // Create one CreatureRace
     * const CreatureRace = await prisma.creatureRace.create({
     *   data: {
     *     // ... data to create a CreatureRace
     *   }
     * })
     * 
     */
    create<T extends CreatureRaceCreateArgs>(args: SelectSubset<T, CreatureRaceCreateArgs<ExtArgs>>): Prisma__CreatureRaceClient<$Result.GetResult<Prisma.$CreatureRacePayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many CreatureRaces.
     * @param {CreatureRaceCreateManyArgs} args - Arguments to create many CreatureRaces.
     * @example
     * // Create many CreatureRaces
     * const creatureRace = await prisma.creatureRace.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CreatureRaceCreateManyArgs>(args?: SelectSubset<T, CreatureRaceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CreatureRaces and returns the data saved in the database.
     * @param {CreatureRaceCreateManyAndReturnArgs} args - Arguments to create many CreatureRaces.
     * @example
     * // Create many CreatureRaces
     * const creatureRace = await prisma.creatureRace.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CreatureRaces and only return the `id`
     * const creatureRaceWithIdOnly = await prisma.creatureRace.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CreatureRaceCreateManyAndReturnArgs>(args?: SelectSubset<T, CreatureRaceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CreatureRacePayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a CreatureRace.
     * @param {CreatureRaceDeleteArgs} args - Arguments to delete one CreatureRace.
     * @example
     * // Delete one CreatureRace
     * const CreatureRace = await prisma.creatureRace.delete({
     *   where: {
     *     // ... filter to delete one CreatureRace
     *   }
     * })
     * 
     */
    delete<T extends CreatureRaceDeleteArgs>(args: SelectSubset<T, CreatureRaceDeleteArgs<ExtArgs>>): Prisma__CreatureRaceClient<$Result.GetResult<Prisma.$CreatureRacePayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one CreatureRace.
     * @param {CreatureRaceUpdateArgs} args - Arguments to update one CreatureRace.
     * @example
     * // Update one CreatureRace
     * const creatureRace = await prisma.creatureRace.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CreatureRaceUpdateArgs>(args: SelectSubset<T, CreatureRaceUpdateArgs<ExtArgs>>): Prisma__CreatureRaceClient<$Result.GetResult<Prisma.$CreatureRacePayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more CreatureRaces.
     * @param {CreatureRaceDeleteManyArgs} args - Arguments to filter CreatureRaces to delete.
     * @example
     * // Delete a few CreatureRaces
     * const { count } = await prisma.creatureRace.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CreatureRaceDeleteManyArgs>(args?: SelectSubset<T, CreatureRaceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CreatureRaces.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreatureRaceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CreatureRaces
     * const creatureRace = await prisma.creatureRace.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CreatureRaceUpdateManyArgs>(args: SelectSubset<T, CreatureRaceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CreatureRaces and returns the data updated in the database.
     * @param {CreatureRaceUpdateManyAndReturnArgs} args - Arguments to update many CreatureRaces.
     * @example
     * // Update many CreatureRaces
     * const creatureRace = await prisma.creatureRace.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CreatureRaces and only return the `id`
     * const creatureRaceWithIdOnly = await prisma.creatureRace.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CreatureRaceUpdateManyAndReturnArgs>(args: SelectSubset<T, CreatureRaceUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CreatureRacePayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one CreatureRace.
     * @param {CreatureRaceUpsertArgs} args - Arguments to update or create a CreatureRace.
     * @example
     * // Update or create a CreatureRace
     * const creatureRace = await prisma.creatureRace.upsert({
     *   create: {
     *     // ... data to create a CreatureRace
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CreatureRace we want to update
     *   }
     * })
     */
    upsert<T extends CreatureRaceUpsertArgs>(args: SelectSubset<T, CreatureRaceUpsertArgs<ExtArgs>>): Prisma__CreatureRaceClient<$Result.GetResult<Prisma.$CreatureRacePayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of CreatureRaces.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreatureRaceCountArgs} args - Arguments to filter CreatureRaces to count.
     * @example
     * // Count the number of CreatureRaces
     * const count = await prisma.creatureRace.count({
     *   where: {
     *     // ... the filter for the CreatureRaces we want to count
     *   }
     * })
    **/
    count<T extends CreatureRaceCountArgs>(
      args?: Subset<T, CreatureRaceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CreatureRaceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CreatureRace.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreatureRaceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CreatureRaceAggregateArgs>(args: Subset<T, CreatureRaceAggregateArgs>): Prisma.PrismaPromise<GetCreatureRaceAggregateType<T>>

    /**
     * Group by CreatureRace.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreatureRaceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CreatureRaceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CreatureRaceGroupByArgs['orderBy'] }
        : { orderBy?: CreatureRaceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CreatureRaceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCreatureRaceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CreatureRace model
   */
  readonly fields: CreatureRaceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CreatureRace.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CreatureRaceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    traits<T extends CreatureRace$traitsArgs<ExtArgs> = {}>(args?: Subset<T, CreatureRace$traitsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TraitPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    actions<T extends CreatureRace$actionsArgs<ExtArgs> = {}>(args?: Subset<T, CreatureRace$actionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActionPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    creatures<T extends CreatureRace$creaturesArgs<ExtArgs> = {}>(args?: Subset<T, CreatureRace$creaturesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CreaturePayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CreatureRace model
   */ 
  interface CreatureRaceFieldRefs {
    readonly id: FieldRef<"CreatureRace", 'Int'>
    readonly name: FieldRef<"CreatureRace", 'String'>
    readonly description: FieldRef<"CreatureRace", 'String'>
  }
    

  // Custom InputTypes
  /**
   * CreatureRace findUnique
   */
  export type CreatureRaceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreatureRace
     */
    select?: CreatureRaceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CreatureRace
     */
    omit?: CreatureRaceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreatureRaceInclude<ExtArgs> | null
    /**
     * Filter, which CreatureRace to fetch.
     */
    where: CreatureRaceWhereUniqueInput
  }

  /**
   * CreatureRace findUniqueOrThrow
   */
  export type CreatureRaceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreatureRace
     */
    select?: CreatureRaceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CreatureRace
     */
    omit?: CreatureRaceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreatureRaceInclude<ExtArgs> | null
    /**
     * Filter, which CreatureRace to fetch.
     */
    where: CreatureRaceWhereUniqueInput
  }

  /**
   * CreatureRace findFirst
   */
  export type CreatureRaceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreatureRace
     */
    select?: CreatureRaceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CreatureRace
     */
    omit?: CreatureRaceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreatureRaceInclude<ExtArgs> | null
    /**
     * Filter, which CreatureRace to fetch.
     */
    where?: CreatureRaceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CreatureRaces to fetch.
     */
    orderBy?: CreatureRaceOrderByWithRelationInput | CreatureRaceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CreatureRaces.
     */
    cursor?: CreatureRaceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CreatureRaces from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CreatureRaces.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CreatureRaces.
     */
    distinct?: CreatureRaceScalarFieldEnum | CreatureRaceScalarFieldEnum[]
  }

  /**
   * CreatureRace findFirstOrThrow
   */
  export type CreatureRaceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreatureRace
     */
    select?: CreatureRaceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CreatureRace
     */
    omit?: CreatureRaceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreatureRaceInclude<ExtArgs> | null
    /**
     * Filter, which CreatureRace to fetch.
     */
    where?: CreatureRaceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CreatureRaces to fetch.
     */
    orderBy?: CreatureRaceOrderByWithRelationInput | CreatureRaceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CreatureRaces.
     */
    cursor?: CreatureRaceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CreatureRaces from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CreatureRaces.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CreatureRaces.
     */
    distinct?: CreatureRaceScalarFieldEnum | CreatureRaceScalarFieldEnum[]
  }

  /**
   * CreatureRace findMany
   */
  export type CreatureRaceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreatureRace
     */
    select?: CreatureRaceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CreatureRace
     */
    omit?: CreatureRaceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreatureRaceInclude<ExtArgs> | null
    /**
     * Filter, which CreatureRaces to fetch.
     */
    where?: CreatureRaceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CreatureRaces to fetch.
     */
    orderBy?: CreatureRaceOrderByWithRelationInput | CreatureRaceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CreatureRaces.
     */
    cursor?: CreatureRaceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CreatureRaces from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CreatureRaces.
     */
    skip?: number
    distinct?: CreatureRaceScalarFieldEnum | CreatureRaceScalarFieldEnum[]
  }

  /**
   * CreatureRace create
   */
  export type CreatureRaceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreatureRace
     */
    select?: CreatureRaceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CreatureRace
     */
    omit?: CreatureRaceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreatureRaceInclude<ExtArgs> | null
    /**
     * The data needed to create a CreatureRace.
     */
    data: XOR<CreatureRaceCreateInput, CreatureRaceUncheckedCreateInput>
  }

  /**
   * CreatureRace createMany
   */
  export type CreatureRaceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CreatureRaces.
     */
    data: CreatureRaceCreateManyInput | CreatureRaceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CreatureRace createManyAndReturn
   */
  export type CreatureRaceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreatureRace
     */
    select?: CreatureRaceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CreatureRace
     */
    omit?: CreatureRaceOmit<ExtArgs> | null
    /**
     * The data used to create many CreatureRaces.
     */
    data: CreatureRaceCreateManyInput | CreatureRaceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CreatureRace update
   */
  export type CreatureRaceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreatureRace
     */
    select?: CreatureRaceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CreatureRace
     */
    omit?: CreatureRaceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreatureRaceInclude<ExtArgs> | null
    /**
     * The data needed to update a CreatureRace.
     */
    data: XOR<CreatureRaceUpdateInput, CreatureRaceUncheckedUpdateInput>
    /**
     * Choose, which CreatureRace to update.
     */
    where: CreatureRaceWhereUniqueInput
  }

  /**
   * CreatureRace updateMany
   */
  export type CreatureRaceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CreatureRaces.
     */
    data: XOR<CreatureRaceUpdateManyMutationInput, CreatureRaceUncheckedUpdateManyInput>
    /**
     * Filter which CreatureRaces to update
     */
    where?: CreatureRaceWhereInput
    /**
     * Limit how many CreatureRaces to update.
     */
    limit?: number
  }

  /**
   * CreatureRace updateManyAndReturn
   */
  export type CreatureRaceUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreatureRace
     */
    select?: CreatureRaceSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CreatureRace
     */
    omit?: CreatureRaceOmit<ExtArgs> | null
    /**
     * The data used to update CreatureRaces.
     */
    data: XOR<CreatureRaceUpdateManyMutationInput, CreatureRaceUncheckedUpdateManyInput>
    /**
     * Filter which CreatureRaces to update
     */
    where?: CreatureRaceWhereInput
    /**
     * Limit how many CreatureRaces to update.
     */
    limit?: number
  }

  /**
   * CreatureRace upsert
   */
  export type CreatureRaceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreatureRace
     */
    select?: CreatureRaceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CreatureRace
     */
    omit?: CreatureRaceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreatureRaceInclude<ExtArgs> | null
    /**
     * The filter to search for the CreatureRace to update in case it exists.
     */
    where: CreatureRaceWhereUniqueInput
    /**
     * In case the CreatureRace found by the `where` argument doesn't exist, create a new CreatureRace with this data.
     */
    create: XOR<CreatureRaceCreateInput, CreatureRaceUncheckedCreateInput>
    /**
     * In case the CreatureRace was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CreatureRaceUpdateInput, CreatureRaceUncheckedUpdateInput>
  }

  /**
   * CreatureRace delete
   */
  export type CreatureRaceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreatureRace
     */
    select?: CreatureRaceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CreatureRace
     */
    omit?: CreatureRaceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreatureRaceInclude<ExtArgs> | null
    /**
     * Filter which CreatureRace to delete.
     */
    where: CreatureRaceWhereUniqueInput
  }

  /**
   * CreatureRace deleteMany
   */
  export type CreatureRaceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CreatureRaces to delete
     */
    where?: CreatureRaceWhereInput
    /**
     * Limit how many CreatureRaces to delete.
     */
    limit?: number
  }

  /**
   * CreatureRace.traits
   */
  export type CreatureRace$traitsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Trait
     */
    select?: TraitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Trait
     */
    omit?: TraitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TraitInclude<ExtArgs> | null
    where?: TraitWhereInput
    orderBy?: TraitOrderByWithRelationInput | TraitOrderByWithRelationInput[]
    cursor?: TraitWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TraitScalarFieldEnum | TraitScalarFieldEnum[]
  }

  /**
   * CreatureRace.actions
   */
  export type CreatureRace$actionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Action
     */
    select?: ActionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Action
     */
    omit?: ActionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActionInclude<ExtArgs> | null
    where?: ActionWhereInput
    orderBy?: ActionOrderByWithRelationInput | ActionOrderByWithRelationInput[]
    cursor?: ActionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ActionScalarFieldEnum | ActionScalarFieldEnum[]
  }

  /**
   * CreatureRace.creatures
   */
  export type CreatureRace$creaturesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Creature
     */
    select?: CreatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Creature
     */
    omit?: CreatureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreatureInclude<ExtArgs> | null
    where?: CreatureWhereInput
    orderBy?: CreatureOrderByWithRelationInput | CreatureOrderByWithRelationInput[]
    cursor?: CreatureWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CreatureScalarFieldEnum | CreatureScalarFieldEnum[]
  }

  /**
   * CreatureRace without action
   */
  export type CreatureRaceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreatureRace
     */
    select?: CreatureRaceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CreatureRace
     */
    omit?: CreatureRaceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreatureRaceInclude<ExtArgs> | null
  }


  /**
   * Model GenrationRequest
   */

  export type AggregateGenrationRequest = {
    _count: GenrationRequestCountAggregateOutputType | null
    _avg: GenrationRequestAvgAggregateOutputType | null
    _sum: GenrationRequestSumAggregateOutputType | null
    _min: GenrationRequestMinAggregateOutputType | null
    _max: GenrationRequestMaxAggregateOutputType | null
  }

  export type GenrationRequestAvgAggregateOutputType = {
    id: number | null
  }

  export type GenrationRequestSumAggregateOutputType = {
    id: number | null
  }

  export type GenrationRequestMinAggregateOutputType = {
    id: number | null
    request: string | null
    danger: string | null
    name: string | null
  }

  export type GenrationRequestMaxAggregateOutputType = {
    id: number | null
    request: string | null
    danger: string | null
    name: string | null
  }

  export type GenrationRequestCountAggregateOutputType = {
    id: number
    request: number
    danger: number
    name: number
    _all: number
  }


  export type GenrationRequestAvgAggregateInputType = {
    id?: true
  }

  export type GenrationRequestSumAggregateInputType = {
    id?: true
  }

  export type GenrationRequestMinAggregateInputType = {
    id?: true
    request?: true
    danger?: true
    name?: true
  }

  export type GenrationRequestMaxAggregateInputType = {
    id?: true
    request?: true
    danger?: true
    name?: true
  }

  export type GenrationRequestCountAggregateInputType = {
    id?: true
    request?: true
    danger?: true
    name?: true
    _all?: true
  }

  export type GenrationRequestAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GenrationRequest to aggregate.
     */
    where?: GenrationRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GenrationRequests to fetch.
     */
    orderBy?: GenrationRequestOrderByWithRelationInput | GenrationRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: GenrationRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GenrationRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GenrationRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned GenrationRequests
    **/
    _count?: true | GenrationRequestCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: GenrationRequestAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: GenrationRequestSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GenrationRequestMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GenrationRequestMaxAggregateInputType
  }

  export type GetGenrationRequestAggregateType<T extends GenrationRequestAggregateArgs> = {
        [P in keyof T & keyof AggregateGenrationRequest]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGenrationRequest[P]>
      : GetScalarType<T[P], AggregateGenrationRequest[P]>
  }




  export type GenrationRequestGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GenrationRequestWhereInput
    orderBy?: GenrationRequestOrderByWithAggregationInput | GenrationRequestOrderByWithAggregationInput[]
    by: GenrationRequestScalarFieldEnum[] | GenrationRequestScalarFieldEnum
    having?: GenrationRequestScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GenrationRequestCountAggregateInputType | true
    _avg?: GenrationRequestAvgAggregateInputType
    _sum?: GenrationRequestSumAggregateInputType
    _min?: GenrationRequestMinAggregateInputType
    _max?: GenrationRequestMaxAggregateInputType
  }

  export type GenrationRequestGroupByOutputType = {
    id: number
    request: string
    danger: string
    name: string
    _count: GenrationRequestCountAggregateOutputType | null
    _avg: GenrationRequestAvgAggregateOutputType | null
    _sum: GenrationRequestSumAggregateOutputType | null
    _min: GenrationRequestMinAggregateOutputType | null
    _max: GenrationRequestMaxAggregateOutputType | null
  }

  type GetGenrationRequestGroupByPayload<T extends GenrationRequestGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GenrationRequestGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GenrationRequestGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GenrationRequestGroupByOutputType[P]>
            : GetScalarType<T[P], GenrationRequestGroupByOutputType[P]>
        }
      >
    >


  export type GenrationRequestSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    request?: boolean
    danger?: boolean
    name?: boolean
  }, ExtArgs["result"]["genrationRequest"]>

  export type GenrationRequestSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    request?: boolean
    danger?: boolean
    name?: boolean
  }, ExtArgs["result"]["genrationRequest"]>

  export type GenrationRequestSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    request?: boolean
    danger?: boolean
    name?: boolean
  }, ExtArgs["result"]["genrationRequest"]>

  export type GenrationRequestSelectScalar = {
    id?: boolean
    request?: boolean
    danger?: boolean
    name?: boolean
  }

  export type GenrationRequestOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "request" | "danger" | "name", ExtArgs["result"]["genrationRequest"]>

  export type $GenrationRequestPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "GenrationRequest"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      request: string
      danger: string
      name: string
    }, ExtArgs["result"]["genrationRequest"]>
    composites: {}
  }

  type GenrationRequestGetPayload<S extends boolean | null | undefined | GenrationRequestDefaultArgs> = $Result.GetResult<Prisma.$GenrationRequestPayload, S>

  type GenrationRequestCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<GenrationRequestFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: GenrationRequestCountAggregateInputType | true
    }

  export interface GenrationRequestDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['GenrationRequest'], meta: { name: 'GenrationRequest' } }
    /**
     * Find zero or one GenrationRequest that matches the filter.
     * @param {GenrationRequestFindUniqueArgs} args - Arguments to find a GenrationRequest
     * @example
     * // Get one GenrationRequest
     * const genrationRequest = await prisma.genrationRequest.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends GenrationRequestFindUniqueArgs>(args: SelectSubset<T, GenrationRequestFindUniqueArgs<ExtArgs>>): Prisma__GenrationRequestClient<$Result.GetResult<Prisma.$GenrationRequestPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one GenrationRequest that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {GenrationRequestFindUniqueOrThrowArgs} args - Arguments to find a GenrationRequest
     * @example
     * // Get one GenrationRequest
     * const genrationRequest = await prisma.genrationRequest.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends GenrationRequestFindUniqueOrThrowArgs>(args: SelectSubset<T, GenrationRequestFindUniqueOrThrowArgs<ExtArgs>>): Prisma__GenrationRequestClient<$Result.GetResult<Prisma.$GenrationRequestPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first GenrationRequest that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GenrationRequestFindFirstArgs} args - Arguments to find a GenrationRequest
     * @example
     * // Get one GenrationRequest
     * const genrationRequest = await prisma.genrationRequest.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends GenrationRequestFindFirstArgs>(args?: SelectSubset<T, GenrationRequestFindFirstArgs<ExtArgs>>): Prisma__GenrationRequestClient<$Result.GetResult<Prisma.$GenrationRequestPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first GenrationRequest that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GenrationRequestFindFirstOrThrowArgs} args - Arguments to find a GenrationRequest
     * @example
     * // Get one GenrationRequest
     * const genrationRequest = await prisma.genrationRequest.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends GenrationRequestFindFirstOrThrowArgs>(args?: SelectSubset<T, GenrationRequestFindFirstOrThrowArgs<ExtArgs>>): Prisma__GenrationRequestClient<$Result.GetResult<Prisma.$GenrationRequestPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more GenrationRequests that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GenrationRequestFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all GenrationRequests
     * const genrationRequests = await prisma.genrationRequest.findMany()
     * 
     * // Get first 10 GenrationRequests
     * const genrationRequests = await prisma.genrationRequest.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const genrationRequestWithIdOnly = await prisma.genrationRequest.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends GenrationRequestFindManyArgs>(args?: SelectSubset<T, GenrationRequestFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GenrationRequestPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a GenrationRequest.
     * @param {GenrationRequestCreateArgs} args - Arguments to create a GenrationRequest.
     * @example
     * // Create one GenrationRequest
     * const GenrationRequest = await prisma.genrationRequest.create({
     *   data: {
     *     // ... data to create a GenrationRequest
     *   }
     * })
     * 
     */
    create<T extends GenrationRequestCreateArgs>(args: SelectSubset<T, GenrationRequestCreateArgs<ExtArgs>>): Prisma__GenrationRequestClient<$Result.GetResult<Prisma.$GenrationRequestPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many GenrationRequests.
     * @param {GenrationRequestCreateManyArgs} args - Arguments to create many GenrationRequests.
     * @example
     * // Create many GenrationRequests
     * const genrationRequest = await prisma.genrationRequest.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends GenrationRequestCreateManyArgs>(args?: SelectSubset<T, GenrationRequestCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many GenrationRequests and returns the data saved in the database.
     * @param {GenrationRequestCreateManyAndReturnArgs} args - Arguments to create many GenrationRequests.
     * @example
     * // Create many GenrationRequests
     * const genrationRequest = await prisma.genrationRequest.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many GenrationRequests and only return the `id`
     * const genrationRequestWithIdOnly = await prisma.genrationRequest.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends GenrationRequestCreateManyAndReturnArgs>(args?: SelectSubset<T, GenrationRequestCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GenrationRequestPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a GenrationRequest.
     * @param {GenrationRequestDeleteArgs} args - Arguments to delete one GenrationRequest.
     * @example
     * // Delete one GenrationRequest
     * const GenrationRequest = await prisma.genrationRequest.delete({
     *   where: {
     *     // ... filter to delete one GenrationRequest
     *   }
     * })
     * 
     */
    delete<T extends GenrationRequestDeleteArgs>(args: SelectSubset<T, GenrationRequestDeleteArgs<ExtArgs>>): Prisma__GenrationRequestClient<$Result.GetResult<Prisma.$GenrationRequestPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one GenrationRequest.
     * @param {GenrationRequestUpdateArgs} args - Arguments to update one GenrationRequest.
     * @example
     * // Update one GenrationRequest
     * const genrationRequest = await prisma.genrationRequest.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends GenrationRequestUpdateArgs>(args: SelectSubset<T, GenrationRequestUpdateArgs<ExtArgs>>): Prisma__GenrationRequestClient<$Result.GetResult<Prisma.$GenrationRequestPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more GenrationRequests.
     * @param {GenrationRequestDeleteManyArgs} args - Arguments to filter GenrationRequests to delete.
     * @example
     * // Delete a few GenrationRequests
     * const { count } = await prisma.genrationRequest.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends GenrationRequestDeleteManyArgs>(args?: SelectSubset<T, GenrationRequestDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more GenrationRequests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GenrationRequestUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many GenrationRequests
     * const genrationRequest = await prisma.genrationRequest.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends GenrationRequestUpdateManyArgs>(args: SelectSubset<T, GenrationRequestUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more GenrationRequests and returns the data updated in the database.
     * @param {GenrationRequestUpdateManyAndReturnArgs} args - Arguments to update many GenrationRequests.
     * @example
     * // Update many GenrationRequests
     * const genrationRequest = await prisma.genrationRequest.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more GenrationRequests and only return the `id`
     * const genrationRequestWithIdOnly = await prisma.genrationRequest.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends GenrationRequestUpdateManyAndReturnArgs>(args: SelectSubset<T, GenrationRequestUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GenrationRequestPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one GenrationRequest.
     * @param {GenrationRequestUpsertArgs} args - Arguments to update or create a GenrationRequest.
     * @example
     * // Update or create a GenrationRequest
     * const genrationRequest = await prisma.genrationRequest.upsert({
     *   create: {
     *     // ... data to create a GenrationRequest
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the GenrationRequest we want to update
     *   }
     * })
     */
    upsert<T extends GenrationRequestUpsertArgs>(args: SelectSubset<T, GenrationRequestUpsertArgs<ExtArgs>>): Prisma__GenrationRequestClient<$Result.GetResult<Prisma.$GenrationRequestPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of GenrationRequests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GenrationRequestCountArgs} args - Arguments to filter GenrationRequests to count.
     * @example
     * // Count the number of GenrationRequests
     * const count = await prisma.genrationRequest.count({
     *   where: {
     *     // ... the filter for the GenrationRequests we want to count
     *   }
     * })
    **/
    count<T extends GenrationRequestCountArgs>(
      args?: Subset<T, GenrationRequestCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GenrationRequestCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a GenrationRequest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GenrationRequestAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GenrationRequestAggregateArgs>(args: Subset<T, GenrationRequestAggregateArgs>): Prisma.PrismaPromise<GetGenrationRequestAggregateType<T>>

    /**
     * Group by GenrationRequest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GenrationRequestGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GenrationRequestGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GenrationRequestGroupByArgs['orderBy'] }
        : { orderBy?: GenrationRequestGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GenrationRequestGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGenrationRequestGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the GenrationRequest model
   */
  readonly fields: GenrationRequestFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for GenrationRequest.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__GenrationRequestClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the GenrationRequest model
   */ 
  interface GenrationRequestFieldRefs {
    readonly id: FieldRef<"GenrationRequest", 'Int'>
    readonly request: FieldRef<"GenrationRequest", 'String'>
    readonly danger: FieldRef<"GenrationRequest", 'String'>
    readonly name: FieldRef<"GenrationRequest", 'String'>
  }
    

  // Custom InputTypes
  /**
   * GenrationRequest findUnique
   */
  export type GenrationRequestFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GenrationRequest
     */
    select?: GenrationRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GenrationRequest
     */
    omit?: GenrationRequestOmit<ExtArgs> | null
    /**
     * Filter, which GenrationRequest to fetch.
     */
    where: GenrationRequestWhereUniqueInput
  }

  /**
   * GenrationRequest findUniqueOrThrow
   */
  export type GenrationRequestFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GenrationRequest
     */
    select?: GenrationRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GenrationRequest
     */
    omit?: GenrationRequestOmit<ExtArgs> | null
    /**
     * Filter, which GenrationRequest to fetch.
     */
    where: GenrationRequestWhereUniqueInput
  }

  /**
   * GenrationRequest findFirst
   */
  export type GenrationRequestFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GenrationRequest
     */
    select?: GenrationRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GenrationRequest
     */
    omit?: GenrationRequestOmit<ExtArgs> | null
    /**
     * Filter, which GenrationRequest to fetch.
     */
    where?: GenrationRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GenrationRequests to fetch.
     */
    orderBy?: GenrationRequestOrderByWithRelationInput | GenrationRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GenrationRequests.
     */
    cursor?: GenrationRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GenrationRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GenrationRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GenrationRequests.
     */
    distinct?: GenrationRequestScalarFieldEnum | GenrationRequestScalarFieldEnum[]
  }

  /**
   * GenrationRequest findFirstOrThrow
   */
  export type GenrationRequestFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GenrationRequest
     */
    select?: GenrationRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GenrationRequest
     */
    omit?: GenrationRequestOmit<ExtArgs> | null
    /**
     * Filter, which GenrationRequest to fetch.
     */
    where?: GenrationRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GenrationRequests to fetch.
     */
    orderBy?: GenrationRequestOrderByWithRelationInput | GenrationRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GenrationRequests.
     */
    cursor?: GenrationRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GenrationRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GenrationRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GenrationRequests.
     */
    distinct?: GenrationRequestScalarFieldEnum | GenrationRequestScalarFieldEnum[]
  }

  /**
   * GenrationRequest findMany
   */
  export type GenrationRequestFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GenrationRequest
     */
    select?: GenrationRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GenrationRequest
     */
    omit?: GenrationRequestOmit<ExtArgs> | null
    /**
     * Filter, which GenrationRequests to fetch.
     */
    where?: GenrationRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GenrationRequests to fetch.
     */
    orderBy?: GenrationRequestOrderByWithRelationInput | GenrationRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing GenrationRequests.
     */
    cursor?: GenrationRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GenrationRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GenrationRequests.
     */
    skip?: number
    distinct?: GenrationRequestScalarFieldEnum | GenrationRequestScalarFieldEnum[]
  }

  /**
   * GenrationRequest create
   */
  export type GenrationRequestCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GenrationRequest
     */
    select?: GenrationRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GenrationRequest
     */
    omit?: GenrationRequestOmit<ExtArgs> | null
    /**
     * The data needed to create a GenrationRequest.
     */
    data: XOR<GenrationRequestCreateInput, GenrationRequestUncheckedCreateInput>
  }

  /**
   * GenrationRequest createMany
   */
  export type GenrationRequestCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many GenrationRequests.
     */
    data: GenrationRequestCreateManyInput | GenrationRequestCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * GenrationRequest createManyAndReturn
   */
  export type GenrationRequestCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GenrationRequest
     */
    select?: GenrationRequestSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the GenrationRequest
     */
    omit?: GenrationRequestOmit<ExtArgs> | null
    /**
     * The data used to create many GenrationRequests.
     */
    data: GenrationRequestCreateManyInput | GenrationRequestCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * GenrationRequest update
   */
  export type GenrationRequestUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GenrationRequest
     */
    select?: GenrationRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GenrationRequest
     */
    omit?: GenrationRequestOmit<ExtArgs> | null
    /**
     * The data needed to update a GenrationRequest.
     */
    data: XOR<GenrationRequestUpdateInput, GenrationRequestUncheckedUpdateInput>
    /**
     * Choose, which GenrationRequest to update.
     */
    where: GenrationRequestWhereUniqueInput
  }

  /**
   * GenrationRequest updateMany
   */
  export type GenrationRequestUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update GenrationRequests.
     */
    data: XOR<GenrationRequestUpdateManyMutationInput, GenrationRequestUncheckedUpdateManyInput>
    /**
     * Filter which GenrationRequests to update
     */
    where?: GenrationRequestWhereInput
    /**
     * Limit how many GenrationRequests to update.
     */
    limit?: number
  }

  /**
   * GenrationRequest updateManyAndReturn
   */
  export type GenrationRequestUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GenrationRequest
     */
    select?: GenrationRequestSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the GenrationRequest
     */
    omit?: GenrationRequestOmit<ExtArgs> | null
    /**
     * The data used to update GenrationRequests.
     */
    data: XOR<GenrationRequestUpdateManyMutationInput, GenrationRequestUncheckedUpdateManyInput>
    /**
     * Filter which GenrationRequests to update
     */
    where?: GenrationRequestWhereInput
    /**
     * Limit how many GenrationRequests to update.
     */
    limit?: number
  }

  /**
   * GenrationRequest upsert
   */
  export type GenrationRequestUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GenrationRequest
     */
    select?: GenrationRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GenrationRequest
     */
    omit?: GenrationRequestOmit<ExtArgs> | null
    /**
     * The filter to search for the GenrationRequest to update in case it exists.
     */
    where: GenrationRequestWhereUniqueInput
    /**
     * In case the GenrationRequest found by the `where` argument doesn't exist, create a new GenrationRequest with this data.
     */
    create: XOR<GenrationRequestCreateInput, GenrationRequestUncheckedCreateInput>
    /**
     * In case the GenrationRequest was found with the provided `where` argument, update it with this data.
     */
    update: XOR<GenrationRequestUpdateInput, GenrationRequestUncheckedUpdateInput>
  }

  /**
   * GenrationRequest delete
   */
  export type GenrationRequestDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GenrationRequest
     */
    select?: GenrationRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GenrationRequest
     */
    omit?: GenrationRequestOmit<ExtArgs> | null
    /**
     * Filter which GenrationRequest to delete.
     */
    where: GenrationRequestWhereUniqueInput
  }

  /**
   * GenrationRequest deleteMany
   */
  export type GenrationRequestDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GenrationRequests to delete
     */
    where?: GenrationRequestWhereInput
    /**
     * Limit how many GenrationRequests to delete.
     */
    limit?: number
  }

  /**
   * GenrationRequest without action
   */
  export type GenrationRequestDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GenrationRequest
     */
    select?: GenrationRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GenrationRequest
     */
    omit?: GenrationRequestOmit<ExtArgs> | null
  }


  /**
   * Model DamageType
   */

  export type AggregateDamageType = {
    _count: DamageTypeCountAggregateOutputType | null
    _min: DamageTypeMinAggregateOutputType | null
    _max: DamageTypeMaxAggregateOutputType | null
  }

  export type DamageTypeMinAggregateOutputType = {
    id: string | null
    name: string | null
  }

  export type DamageTypeMaxAggregateOutputType = {
    id: string | null
    name: string | null
  }

  export type DamageTypeCountAggregateOutputType = {
    id: number
    name: number
    _all: number
  }


  export type DamageTypeMinAggregateInputType = {
    id?: true
    name?: true
  }

  export type DamageTypeMaxAggregateInputType = {
    id?: true
    name?: true
  }

  export type DamageTypeCountAggregateInputType = {
    id?: true
    name?: true
    _all?: true
  }

  export type DamageTypeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DamageType to aggregate.
     */
    where?: DamageTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DamageTypes to fetch.
     */
    orderBy?: DamageTypeOrderByWithRelationInput | DamageTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DamageTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DamageTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DamageTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DamageTypes
    **/
    _count?: true | DamageTypeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DamageTypeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DamageTypeMaxAggregateInputType
  }

  export type GetDamageTypeAggregateType<T extends DamageTypeAggregateArgs> = {
        [P in keyof T & keyof AggregateDamageType]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDamageType[P]>
      : GetScalarType<T[P], AggregateDamageType[P]>
  }




  export type DamageTypeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DamageTypeWhereInput
    orderBy?: DamageTypeOrderByWithAggregationInput | DamageTypeOrderByWithAggregationInput[]
    by: DamageTypeScalarFieldEnum[] | DamageTypeScalarFieldEnum
    having?: DamageTypeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DamageTypeCountAggregateInputType | true
    _min?: DamageTypeMinAggregateInputType
    _max?: DamageTypeMaxAggregateInputType
  }

  export type DamageTypeGroupByOutputType = {
    id: string
    name: string
    _count: DamageTypeCountAggregateOutputType | null
    _min: DamageTypeMinAggregateOutputType | null
    _max: DamageTypeMaxAggregateOutputType | null
  }

  type GetDamageTypeGroupByPayload<T extends DamageTypeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DamageTypeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DamageTypeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DamageTypeGroupByOutputType[P]>
            : GetScalarType<T[P], DamageTypeGroupByOutputType[P]>
        }
      >
    >


  export type DamageTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    resistant_creatures?: boolean | DamageType$resistant_creaturesArgs<ExtArgs>
    immune_creatures?: boolean | DamageType$immune_creaturesArgs<ExtArgs>
    vunlerable_creatures?: boolean | DamageType$vunlerable_creaturesArgs<ExtArgs>
    _count?: boolean | DamageTypeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["damageType"]>

  export type DamageTypeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
  }, ExtArgs["result"]["damageType"]>

  export type DamageTypeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
  }, ExtArgs["result"]["damageType"]>

  export type DamageTypeSelectScalar = {
    id?: boolean
    name?: boolean
  }

  export type DamageTypeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name", ExtArgs["result"]["damageType"]>
  export type DamageTypeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    resistant_creatures?: boolean | DamageType$resistant_creaturesArgs<ExtArgs>
    immune_creatures?: boolean | DamageType$immune_creaturesArgs<ExtArgs>
    vunlerable_creatures?: boolean | DamageType$vunlerable_creaturesArgs<ExtArgs>
    _count?: boolean | DamageTypeCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type DamageTypeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type DamageTypeIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $DamageTypePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DamageType"
    objects: {
      resistant_creatures: Prisma.$CreaturePayload<ExtArgs>[]
      immune_creatures: Prisma.$CreaturePayload<ExtArgs>[]
      vunlerable_creatures: Prisma.$CreaturePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
    }, ExtArgs["result"]["damageType"]>
    composites: {}
  }

  type DamageTypeGetPayload<S extends boolean | null | undefined | DamageTypeDefaultArgs> = $Result.GetResult<Prisma.$DamageTypePayload, S>

  type DamageTypeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DamageTypeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DamageTypeCountAggregateInputType | true
    }

  export interface DamageTypeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DamageType'], meta: { name: 'DamageType' } }
    /**
     * Find zero or one DamageType that matches the filter.
     * @param {DamageTypeFindUniqueArgs} args - Arguments to find a DamageType
     * @example
     * // Get one DamageType
     * const damageType = await prisma.damageType.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DamageTypeFindUniqueArgs>(args: SelectSubset<T, DamageTypeFindUniqueArgs<ExtArgs>>): Prisma__DamageTypeClient<$Result.GetResult<Prisma.$DamageTypePayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one DamageType that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DamageTypeFindUniqueOrThrowArgs} args - Arguments to find a DamageType
     * @example
     * // Get one DamageType
     * const damageType = await prisma.damageType.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DamageTypeFindUniqueOrThrowArgs>(args: SelectSubset<T, DamageTypeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DamageTypeClient<$Result.GetResult<Prisma.$DamageTypePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first DamageType that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DamageTypeFindFirstArgs} args - Arguments to find a DamageType
     * @example
     * // Get one DamageType
     * const damageType = await prisma.damageType.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DamageTypeFindFirstArgs>(args?: SelectSubset<T, DamageTypeFindFirstArgs<ExtArgs>>): Prisma__DamageTypeClient<$Result.GetResult<Prisma.$DamageTypePayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first DamageType that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DamageTypeFindFirstOrThrowArgs} args - Arguments to find a DamageType
     * @example
     * // Get one DamageType
     * const damageType = await prisma.damageType.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DamageTypeFindFirstOrThrowArgs>(args?: SelectSubset<T, DamageTypeFindFirstOrThrowArgs<ExtArgs>>): Prisma__DamageTypeClient<$Result.GetResult<Prisma.$DamageTypePayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more DamageTypes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DamageTypeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DamageTypes
     * const damageTypes = await prisma.damageType.findMany()
     * 
     * // Get first 10 DamageTypes
     * const damageTypes = await prisma.damageType.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const damageTypeWithIdOnly = await prisma.damageType.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DamageTypeFindManyArgs>(args?: SelectSubset<T, DamageTypeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DamageTypePayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a DamageType.
     * @param {DamageTypeCreateArgs} args - Arguments to create a DamageType.
     * @example
     * // Create one DamageType
     * const DamageType = await prisma.damageType.create({
     *   data: {
     *     // ... data to create a DamageType
     *   }
     * })
     * 
     */
    create<T extends DamageTypeCreateArgs>(args: SelectSubset<T, DamageTypeCreateArgs<ExtArgs>>): Prisma__DamageTypeClient<$Result.GetResult<Prisma.$DamageTypePayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many DamageTypes.
     * @param {DamageTypeCreateManyArgs} args - Arguments to create many DamageTypes.
     * @example
     * // Create many DamageTypes
     * const damageType = await prisma.damageType.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DamageTypeCreateManyArgs>(args?: SelectSubset<T, DamageTypeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DamageTypes and returns the data saved in the database.
     * @param {DamageTypeCreateManyAndReturnArgs} args - Arguments to create many DamageTypes.
     * @example
     * // Create many DamageTypes
     * const damageType = await prisma.damageType.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DamageTypes and only return the `id`
     * const damageTypeWithIdOnly = await prisma.damageType.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DamageTypeCreateManyAndReturnArgs>(args?: SelectSubset<T, DamageTypeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DamageTypePayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a DamageType.
     * @param {DamageTypeDeleteArgs} args - Arguments to delete one DamageType.
     * @example
     * // Delete one DamageType
     * const DamageType = await prisma.damageType.delete({
     *   where: {
     *     // ... filter to delete one DamageType
     *   }
     * })
     * 
     */
    delete<T extends DamageTypeDeleteArgs>(args: SelectSubset<T, DamageTypeDeleteArgs<ExtArgs>>): Prisma__DamageTypeClient<$Result.GetResult<Prisma.$DamageTypePayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one DamageType.
     * @param {DamageTypeUpdateArgs} args - Arguments to update one DamageType.
     * @example
     * // Update one DamageType
     * const damageType = await prisma.damageType.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DamageTypeUpdateArgs>(args: SelectSubset<T, DamageTypeUpdateArgs<ExtArgs>>): Prisma__DamageTypeClient<$Result.GetResult<Prisma.$DamageTypePayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more DamageTypes.
     * @param {DamageTypeDeleteManyArgs} args - Arguments to filter DamageTypes to delete.
     * @example
     * // Delete a few DamageTypes
     * const { count } = await prisma.damageType.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DamageTypeDeleteManyArgs>(args?: SelectSubset<T, DamageTypeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DamageTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DamageTypeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DamageTypes
     * const damageType = await prisma.damageType.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DamageTypeUpdateManyArgs>(args: SelectSubset<T, DamageTypeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DamageTypes and returns the data updated in the database.
     * @param {DamageTypeUpdateManyAndReturnArgs} args - Arguments to update many DamageTypes.
     * @example
     * // Update many DamageTypes
     * const damageType = await prisma.damageType.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more DamageTypes and only return the `id`
     * const damageTypeWithIdOnly = await prisma.damageType.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DamageTypeUpdateManyAndReturnArgs>(args: SelectSubset<T, DamageTypeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DamageTypePayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one DamageType.
     * @param {DamageTypeUpsertArgs} args - Arguments to update or create a DamageType.
     * @example
     * // Update or create a DamageType
     * const damageType = await prisma.damageType.upsert({
     *   create: {
     *     // ... data to create a DamageType
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DamageType we want to update
     *   }
     * })
     */
    upsert<T extends DamageTypeUpsertArgs>(args: SelectSubset<T, DamageTypeUpsertArgs<ExtArgs>>): Prisma__DamageTypeClient<$Result.GetResult<Prisma.$DamageTypePayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of DamageTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DamageTypeCountArgs} args - Arguments to filter DamageTypes to count.
     * @example
     * // Count the number of DamageTypes
     * const count = await prisma.damageType.count({
     *   where: {
     *     // ... the filter for the DamageTypes we want to count
     *   }
     * })
    **/
    count<T extends DamageTypeCountArgs>(
      args?: Subset<T, DamageTypeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DamageTypeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DamageType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DamageTypeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DamageTypeAggregateArgs>(args: Subset<T, DamageTypeAggregateArgs>): Prisma.PrismaPromise<GetDamageTypeAggregateType<T>>

    /**
     * Group by DamageType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DamageTypeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DamageTypeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DamageTypeGroupByArgs['orderBy'] }
        : { orderBy?: DamageTypeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DamageTypeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDamageTypeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DamageType model
   */
  readonly fields: DamageTypeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DamageType.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DamageTypeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    resistant_creatures<T extends DamageType$resistant_creaturesArgs<ExtArgs> = {}>(args?: Subset<T, DamageType$resistant_creaturesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CreaturePayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    immune_creatures<T extends DamageType$immune_creaturesArgs<ExtArgs> = {}>(args?: Subset<T, DamageType$immune_creaturesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CreaturePayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    vunlerable_creatures<T extends DamageType$vunlerable_creaturesArgs<ExtArgs> = {}>(args?: Subset<T, DamageType$vunlerable_creaturesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CreaturePayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DamageType model
   */ 
  interface DamageTypeFieldRefs {
    readonly id: FieldRef<"DamageType", 'String'>
    readonly name: FieldRef<"DamageType", 'String'>
  }
    

  // Custom InputTypes
  /**
   * DamageType findUnique
   */
  export type DamageTypeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DamageType
     */
    select?: DamageTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DamageType
     */
    omit?: DamageTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DamageTypeInclude<ExtArgs> | null
    /**
     * Filter, which DamageType to fetch.
     */
    where: DamageTypeWhereUniqueInput
  }

  /**
   * DamageType findUniqueOrThrow
   */
  export type DamageTypeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DamageType
     */
    select?: DamageTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DamageType
     */
    omit?: DamageTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DamageTypeInclude<ExtArgs> | null
    /**
     * Filter, which DamageType to fetch.
     */
    where: DamageTypeWhereUniqueInput
  }

  /**
   * DamageType findFirst
   */
  export type DamageTypeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DamageType
     */
    select?: DamageTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DamageType
     */
    omit?: DamageTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DamageTypeInclude<ExtArgs> | null
    /**
     * Filter, which DamageType to fetch.
     */
    where?: DamageTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DamageTypes to fetch.
     */
    orderBy?: DamageTypeOrderByWithRelationInput | DamageTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DamageTypes.
     */
    cursor?: DamageTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DamageTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DamageTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DamageTypes.
     */
    distinct?: DamageTypeScalarFieldEnum | DamageTypeScalarFieldEnum[]
  }

  /**
   * DamageType findFirstOrThrow
   */
  export type DamageTypeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DamageType
     */
    select?: DamageTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DamageType
     */
    omit?: DamageTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DamageTypeInclude<ExtArgs> | null
    /**
     * Filter, which DamageType to fetch.
     */
    where?: DamageTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DamageTypes to fetch.
     */
    orderBy?: DamageTypeOrderByWithRelationInput | DamageTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DamageTypes.
     */
    cursor?: DamageTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DamageTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DamageTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DamageTypes.
     */
    distinct?: DamageTypeScalarFieldEnum | DamageTypeScalarFieldEnum[]
  }

  /**
   * DamageType findMany
   */
  export type DamageTypeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DamageType
     */
    select?: DamageTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DamageType
     */
    omit?: DamageTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DamageTypeInclude<ExtArgs> | null
    /**
     * Filter, which DamageTypes to fetch.
     */
    where?: DamageTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DamageTypes to fetch.
     */
    orderBy?: DamageTypeOrderByWithRelationInput | DamageTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DamageTypes.
     */
    cursor?: DamageTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DamageTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DamageTypes.
     */
    skip?: number
    distinct?: DamageTypeScalarFieldEnum | DamageTypeScalarFieldEnum[]
  }

  /**
   * DamageType create
   */
  export type DamageTypeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DamageType
     */
    select?: DamageTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DamageType
     */
    omit?: DamageTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DamageTypeInclude<ExtArgs> | null
    /**
     * The data needed to create a DamageType.
     */
    data: XOR<DamageTypeCreateInput, DamageTypeUncheckedCreateInput>
  }

  /**
   * DamageType createMany
   */
  export type DamageTypeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DamageTypes.
     */
    data: DamageTypeCreateManyInput | DamageTypeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DamageType createManyAndReturn
   */
  export type DamageTypeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DamageType
     */
    select?: DamageTypeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DamageType
     */
    omit?: DamageTypeOmit<ExtArgs> | null
    /**
     * The data used to create many DamageTypes.
     */
    data: DamageTypeCreateManyInput | DamageTypeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DamageType update
   */
  export type DamageTypeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DamageType
     */
    select?: DamageTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DamageType
     */
    omit?: DamageTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DamageTypeInclude<ExtArgs> | null
    /**
     * The data needed to update a DamageType.
     */
    data: XOR<DamageTypeUpdateInput, DamageTypeUncheckedUpdateInput>
    /**
     * Choose, which DamageType to update.
     */
    where: DamageTypeWhereUniqueInput
  }

  /**
   * DamageType updateMany
   */
  export type DamageTypeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DamageTypes.
     */
    data: XOR<DamageTypeUpdateManyMutationInput, DamageTypeUncheckedUpdateManyInput>
    /**
     * Filter which DamageTypes to update
     */
    where?: DamageTypeWhereInput
    /**
     * Limit how many DamageTypes to update.
     */
    limit?: number
  }

  /**
   * DamageType updateManyAndReturn
   */
  export type DamageTypeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DamageType
     */
    select?: DamageTypeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DamageType
     */
    omit?: DamageTypeOmit<ExtArgs> | null
    /**
     * The data used to update DamageTypes.
     */
    data: XOR<DamageTypeUpdateManyMutationInput, DamageTypeUncheckedUpdateManyInput>
    /**
     * Filter which DamageTypes to update
     */
    where?: DamageTypeWhereInput
    /**
     * Limit how many DamageTypes to update.
     */
    limit?: number
  }

  /**
   * DamageType upsert
   */
  export type DamageTypeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DamageType
     */
    select?: DamageTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DamageType
     */
    omit?: DamageTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DamageTypeInclude<ExtArgs> | null
    /**
     * The filter to search for the DamageType to update in case it exists.
     */
    where: DamageTypeWhereUniqueInput
    /**
     * In case the DamageType found by the `where` argument doesn't exist, create a new DamageType with this data.
     */
    create: XOR<DamageTypeCreateInput, DamageTypeUncheckedCreateInput>
    /**
     * In case the DamageType was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DamageTypeUpdateInput, DamageTypeUncheckedUpdateInput>
  }

  /**
   * DamageType delete
   */
  export type DamageTypeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DamageType
     */
    select?: DamageTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DamageType
     */
    omit?: DamageTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DamageTypeInclude<ExtArgs> | null
    /**
     * Filter which DamageType to delete.
     */
    where: DamageTypeWhereUniqueInput
  }

  /**
   * DamageType deleteMany
   */
  export type DamageTypeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DamageTypes to delete
     */
    where?: DamageTypeWhereInput
    /**
     * Limit how many DamageTypes to delete.
     */
    limit?: number
  }

  /**
   * DamageType.resistant_creatures
   */
  export type DamageType$resistant_creaturesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Creature
     */
    select?: CreatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Creature
     */
    omit?: CreatureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreatureInclude<ExtArgs> | null
    where?: CreatureWhereInput
    orderBy?: CreatureOrderByWithRelationInput | CreatureOrderByWithRelationInput[]
    cursor?: CreatureWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CreatureScalarFieldEnum | CreatureScalarFieldEnum[]
  }

  /**
   * DamageType.immune_creatures
   */
  export type DamageType$immune_creaturesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Creature
     */
    select?: CreatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Creature
     */
    omit?: CreatureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreatureInclude<ExtArgs> | null
    where?: CreatureWhereInput
    orderBy?: CreatureOrderByWithRelationInput | CreatureOrderByWithRelationInput[]
    cursor?: CreatureWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CreatureScalarFieldEnum | CreatureScalarFieldEnum[]
  }

  /**
   * DamageType.vunlerable_creatures
   */
  export type DamageType$vunlerable_creaturesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Creature
     */
    select?: CreatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Creature
     */
    omit?: CreatureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreatureInclude<ExtArgs> | null
    where?: CreatureWhereInput
    orderBy?: CreatureOrderByWithRelationInput | CreatureOrderByWithRelationInput[]
    cursor?: CreatureWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CreatureScalarFieldEnum | CreatureScalarFieldEnum[]
  }

  /**
   * DamageType without action
   */
  export type DamageTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DamageType
     */
    select?: DamageTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DamageType
     */
    omit?: DamageTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DamageTypeInclude<ExtArgs> | null
  }


  /**
   * Model ChallengeRating
   */

  export type AggregateChallengeRating = {
    _count: ChallengeRatingCountAggregateOutputType | null
    _min: ChallengeRatingMinAggregateOutputType | null
    _max: ChallengeRatingMaxAggregateOutputType | null
  }

  export type ChallengeRatingMinAggregateOutputType = {
    id: string | null
  }

  export type ChallengeRatingMaxAggregateOutputType = {
    id: string | null
  }

  export type ChallengeRatingCountAggregateOutputType = {
    id: number
    _all: number
  }


  export type ChallengeRatingMinAggregateInputType = {
    id?: true
  }

  export type ChallengeRatingMaxAggregateInputType = {
    id?: true
  }

  export type ChallengeRatingCountAggregateInputType = {
    id?: true
    _all?: true
  }

  export type ChallengeRatingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ChallengeRating to aggregate.
     */
    where?: ChallengeRatingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChallengeRatings to fetch.
     */
    orderBy?: ChallengeRatingOrderByWithRelationInput | ChallengeRatingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ChallengeRatingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChallengeRatings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChallengeRatings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ChallengeRatings
    **/
    _count?: true | ChallengeRatingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ChallengeRatingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ChallengeRatingMaxAggregateInputType
  }

  export type GetChallengeRatingAggregateType<T extends ChallengeRatingAggregateArgs> = {
        [P in keyof T & keyof AggregateChallengeRating]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateChallengeRating[P]>
      : GetScalarType<T[P], AggregateChallengeRating[P]>
  }




  export type ChallengeRatingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChallengeRatingWhereInput
    orderBy?: ChallengeRatingOrderByWithAggregationInput | ChallengeRatingOrderByWithAggregationInput[]
    by: ChallengeRatingScalarFieldEnum[] | ChallengeRatingScalarFieldEnum
    having?: ChallengeRatingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ChallengeRatingCountAggregateInputType | true
    _min?: ChallengeRatingMinAggregateInputType
    _max?: ChallengeRatingMaxAggregateInputType
  }

  export type ChallengeRatingGroupByOutputType = {
    id: string
    _count: ChallengeRatingCountAggregateOutputType | null
    _min: ChallengeRatingMinAggregateOutputType | null
    _max: ChallengeRatingMaxAggregateOutputType | null
  }

  type GetChallengeRatingGroupByPayload<T extends ChallengeRatingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ChallengeRatingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ChallengeRatingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ChallengeRatingGroupByOutputType[P]>
            : GetScalarType<T[P], ChallengeRatingGroupByOutputType[P]>
        }
      >
    >


  export type ChallengeRatingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
  }, ExtArgs["result"]["challengeRating"]>

  export type ChallengeRatingSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
  }, ExtArgs["result"]["challengeRating"]>

  export type ChallengeRatingSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
  }, ExtArgs["result"]["challengeRating"]>

  export type ChallengeRatingSelectScalar = {
    id?: boolean
  }

  export type ChallengeRatingOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id", ExtArgs["result"]["challengeRating"]>

  export type $ChallengeRatingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ChallengeRating"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
    }, ExtArgs["result"]["challengeRating"]>
    composites: {}
  }

  type ChallengeRatingGetPayload<S extends boolean | null | undefined | ChallengeRatingDefaultArgs> = $Result.GetResult<Prisma.$ChallengeRatingPayload, S>

  type ChallengeRatingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ChallengeRatingFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ChallengeRatingCountAggregateInputType | true
    }

  export interface ChallengeRatingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ChallengeRating'], meta: { name: 'ChallengeRating' } }
    /**
     * Find zero or one ChallengeRating that matches the filter.
     * @param {ChallengeRatingFindUniqueArgs} args - Arguments to find a ChallengeRating
     * @example
     * // Get one ChallengeRating
     * const challengeRating = await prisma.challengeRating.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ChallengeRatingFindUniqueArgs>(args: SelectSubset<T, ChallengeRatingFindUniqueArgs<ExtArgs>>): Prisma__ChallengeRatingClient<$Result.GetResult<Prisma.$ChallengeRatingPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one ChallengeRating that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ChallengeRatingFindUniqueOrThrowArgs} args - Arguments to find a ChallengeRating
     * @example
     * // Get one ChallengeRating
     * const challengeRating = await prisma.challengeRating.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ChallengeRatingFindUniqueOrThrowArgs>(args: SelectSubset<T, ChallengeRatingFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ChallengeRatingClient<$Result.GetResult<Prisma.$ChallengeRatingPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first ChallengeRating that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChallengeRatingFindFirstArgs} args - Arguments to find a ChallengeRating
     * @example
     * // Get one ChallengeRating
     * const challengeRating = await prisma.challengeRating.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ChallengeRatingFindFirstArgs>(args?: SelectSubset<T, ChallengeRatingFindFirstArgs<ExtArgs>>): Prisma__ChallengeRatingClient<$Result.GetResult<Prisma.$ChallengeRatingPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first ChallengeRating that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChallengeRatingFindFirstOrThrowArgs} args - Arguments to find a ChallengeRating
     * @example
     * // Get one ChallengeRating
     * const challengeRating = await prisma.challengeRating.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ChallengeRatingFindFirstOrThrowArgs>(args?: SelectSubset<T, ChallengeRatingFindFirstOrThrowArgs<ExtArgs>>): Prisma__ChallengeRatingClient<$Result.GetResult<Prisma.$ChallengeRatingPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more ChallengeRatings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChallengeRatingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ChallengeRatings
     * const challengeRatings = await prisma.challengeRating.findMany()
     * 
     * // Get first 10 ChallengeRatings
     * const challengeRatings = await prisma.challengeRating.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const challengeRatingWithIdOnly = await prisma.challengeRating.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ChallengeRatingFindManyArgs>(args?: SelectSubset<T, ChallengeRatingFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChallengeRatingPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a ChallengeRating.
     * @param {ChallengeRatingCreateArgs} args - Arguments to create a ChallengeRating.
     * @example
     * // Create one ChallengeRating
     * const ChallengeRating = await prisma.challengeRating.create({
     *   data: {
     *     // ... data to create a ChallengeRating
     *   }
     * })
     * 
     */
    create<T extends ChallengeRatingCreateArgs>(args: SelectSubset<T, ChallengeRatingCreateArgs<ExtArgs>>): Prisma__ChallengeRatingClient<$Result.GetResult<Prisma.$ChallengeRatingPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many ChallengeRatings.
     * @param {ChallengeRatingCreateManyArgs} args - Arguments to create many ChallengeRatings.
     * @example
     * // Create many ChallengeRatings
     * const challengeRating = await prisma.challengeRating.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ChallengeRatingCreateManyArgs>(args?: SelectSubset<T, ChallengeRatingCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ChallengeRatings and returns the data saved in the database.
     * @param {ChallengeRatingCreateManyAndReturnArgs} args - Arguments to create many ChallengeRatings.
     * @example
     * // Create many ChallengeRatings
     * const challengeRating = await prisma.challengeRating.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ChallengeRatings and only return the `id`
     * const challengeRatingWithIdOnly = await prisma.challengeRating.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ChallengeRatingCreateManyAndReturnArgs>(args?: SelectSubset<T, ChallengeRatingCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChallengeRatingPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a ChallengeRating.
     * @param {ChallengeRatingDeleteArgs} args - Arguments to delete one ChallengeRating.
     * @example
     * // Delete one ChallengeRating
     * const ChallengeRating = await prisma.challengeRating.delete({
     *   where: {
     *     // ... filter to delete one ChallengeRating
     *   }
     * })
     * 
     */
    delete<T extends ChallengeRatingDeleteArgs>(args: SelectSubset<T, ChallengeRatingDeleteArgs<ExtArgs>>): Prisma__ChallengeRatingClient<$Result.GetResult<Prisma.$ChallengeRatingPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one ChallengeRating.
     * @param {ChallengeRatingUpdateArgs} args - Arguments to update one ChallengeRating.
     * @example
     * // Update one ChallengeRating
     * const challengeRating = await prisma.challengeRating.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ChallengeRatingUpdateArgs>(args: SelectSubset<T, ChallengeRatingUpdateArgs<ExtArgs>>): Prisma__ChallengeRatingClient<$Result.GetResult<Prisma.$ChallengeRatingPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more ChallengeRatings.
     * @param {ChallengeRatingDeleteManyArgs} args - Arguments to filter ChallengeRatings to delete.
     * @example
     * // Delete a few ChallengeRatings
     * const { count } = await prisma.challengeRating.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ChallengeRatingDeleteManyArgs>(args?: SelectSubset<T, ChallengeRatingDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ChallengeRatings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChallengeRatingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ChallengeRatings
     * const challengeRating = await prisma.challengeRating.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ChallengeRatingUpdateManyArgs>(args: SelectSubset<T, ChallengeRatingUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ChallengeRatings and returns the data updated in the database.
     * @param {ChallengeRatingUpdateManyAndReturnArgs} args - Arguments to update many ChallengeRatings.
     * @example
     * // Update many ChallengeRatings
     * const challengeRating = await prisma.challengeRating.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ChallengeRatings and only return the `id`
     * const challengeRatingWithIdOnly = await prisma.challengeRating.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ChallengeRatingUpdateManyAndReturnArgs>(args: SelectSubset<T, ChallengeRatingUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChallengeRatingPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one ChallengeRating.
     * @param {ChallengeRatingUpsertArgs} args - Arguments to update or create a ChallengeRating.
     * @example
     * // Update or create a ChallengeRating
     * const challengeRating = await prisma.challengeRating.upsert({
     *   create: {
     *     // ... data to create a ChallengeRating
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ChallengeRating we want to update
     *   }
     * })
     */
    upsert<T extends ChallengeRatingUpsertArgs>(args: SelectSubset<T, ChallengeRatingUpsertArgs<ExtArgs>>): Prisma__ChallengeRatingClient<$Result.GetResult<Prisma.$ChallengeRatingPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of ChallengeRatings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChallengeRatingCountArgs} args - Arguments to filter ChallengeRatings to count.
     * @example
     * // Count the number of ChallengeRatings
     * const count = await prisma.challengeRating.count({
     *   where: {
     *     // ... the filter for the ChallengeRatings we want to count
     *   }
     * })
    **/
    count<T extends ChallengeRatingCountArgs>(
      args?: Subset<T, ChallengeRatingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ChallengeRatingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ChallengeRating.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChallengeRatingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ChallengeRatingAggregateArgs>(args: Subset<T, ChallengeRatingAggregateArgs>): Prisma.PrismaPromise<GetChallengeRatingAggregateType<T>>

    /**
     * Group by ChallengeRating.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChallengeRatingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ChallengeRatingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ChallengeRatingGroupByArgs['orderBy'] }
        : { orderBy?: ChallengeRatingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ChallengeRatingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetChallengeRatingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ChallengeRating model
   */
  readonly fields: ChallengeRatingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ChallengeRating.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ChallengeRatingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ChallengeRating model
   */ 
  interface ChallengeRatingFieldRefs {
    readonly id: FieldRef<"ChallengeRating", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ChallengeRating findUnique
   */
  export type ChallengeRatingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeRating
     */
    select?: ChallengeRatingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengeRating
     */
    omit?: ChallengeRatingOmit<ExtArgs> | null
    /**
     * Filter, which ChallengeRating to fetch.
     */
    where: ChallengeRatingWhereUniqueInput
  }

  /**
   * ChallengeRating findUniqueOrThrow
   */
  export type ChallengeRatingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeRating
     */
    select?: ChallengeRatingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengeRating
     */
    omit?: ChallengeRatingOmit<ExtArgs> | null
    /**
     * Filter, which ChallengeRating to fetch.
     */
    where: ChallengeRatingWhereUniqueInput
  }

  /**
   * ChallengeRating findFirst
   */
  export type ChallengeRatingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeRating
     */
    select?: ChallengeRatingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengeRating
     */
    omit?: ChallengeRatingOmit<ExtArgs> | null
    /**
     * Filter, which ChallengeRating to fetch.
     */
    where?: ChallengeRatingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChallengeRatings to fetch.
     */
    orderBy?: ChallengeRatingOrderByWithRelationInput | ChallengeRatingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ChallengeRatings.
     */
    cursor?: ChallengeRatingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChallengeRatings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChallengeRatings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ChallengeRatings.
     */
    distinct?: ChallengeRatingScalarFieldEnum | ChallengeRatingScalarFieldEnum[]
  }

  /**
   * ChallengeRating findFirstOrThrow
   */
  export type ChallengeRatingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeRating
     */
    select?: ChallengeRatingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengeRating
     */
    omit?: ChallengeRatingOmit<ExtArgs> | null
    /**
     * Filter, which ChallengeRating to fetch.
     */
    where?: ChallengeRatingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChallengeRatings to fetch.
     */
    orderBy?: ChallengeRatingOrderByWithRelationInput | ChallengeRatingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ChallengeRatings.
     */
    cursor?: ChallengeRatingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChallengeRatings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChallengeRatings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ChallengeRatings.
     */
    distinct?: ChallengeRatingScalarFieldEnum | ChallengeRatingScalarFieldEnum[]
  }

  /**
   * ChallengeRating findMany
   */
  export type ChallengeRatingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeRating
     */
    select?: ChallengeRatingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengeRating
     */
    omit?: ChallengeRatingOmit<ExtArgs> | null
    /**
     * Filter, which ChallengeRatings to fetch.
     */
    where?: ChallengeRatingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChallengeRatings to fetch.
     */
    orderBy?: ChallengeRatingOrderByWithRelationInput | ChallengeRatingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ChallengeRatings.
     */
    cursor?: ChallengeRatingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChallengeRatings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChallengeRatings.
     */
    skip?: number
    distinct?: ChallengeRatingScalarFieldEnum | ChallengeRatingScalarFieldEnum[]
  }

  /**
   * ChallengeRating create
   */
  export type ChallengeRatingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeRating
     */
    select?: ChallengeRatingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengeRating
     */
    omit?: ChallengeRatingOmit<ExtArgs> | null
    /**
     * The data needed to create a ChallengeRating.
     */
    data: XOR<ChallengeRatingCreateInput, ChallengeRatingUncheckedCreateInput>
  }

  /**
   * ChallengeRating createMany
   */
  export type ChallengeRatingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ChallengeRatings.
     */
    data: ChallengeRatingCreateManyInput | ChallengeRatingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ChallengeRating createManyAndReturn
   */
  export type ChallengeRatingCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeRating
     */
    select?: ChallengeRatingSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengeRating
     */
    omit?: ChallengeRatingOmit<ExtArgs> | null
    /**
     * The data used to create many ChallengeRatings.
     */
    data: ChallengeRatingCreateManyInput | ChallengeRatingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ChallengeRating update
   */
  export type ChallengeRatingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeRating
     */
    select?: ChallengeRatingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengeRating
     */
    omit?: ChallengeRatingOmit<ExtArgs> | null
    /**
     * The data needed to update a ChallengeRating.
     */
    data: XOR<ChallengeRatingUpdateInput, ChallengeRatingUncheckedUpdateInput>
    /**
     * Choose, which ChallengeRating to update.
     */
    where: ChallengeRatingWhereUniqueInput
  }

  /**
   * ChallengeRating updateMany
   */
  export type ChallengeRatingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ChallengeRatings.
     */
    data: XOR<ChallengeRatingUpdateManyMutationInput, ChallengeRatingUncheckedUpdateManyInput>
    /**
     * Filter which ChallengeRatings to update
     */
    where?: ChallengeRatingWhereInput
    /**
     * Limit how many ChallengeRatings to update.
     */
    limit?: number
  }

  /**
   * ChallengeRating updateManyAndReturn
   */
  export type ChallengeRatingUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeRating
     */
    select?: ChallengeRatingSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengeRating
     */
    omit?: ChallengeRatingOmit<ExtArgs> | null
    /**
     * The data used to update ChallengeRatings.
     */
    data: XOR<ChallengeRatingUpdateManyMutationInput, ChallengeRatingUncheckedUpdateManyInput>
    /**
     * Filter which ChallengeRatings to update
     */
    where?: ChallengeRatingWhereInput
    /**
     * Limit how many ChallengeRatings to update.
     */
    limit?: number
  }

  /**
   * ChallengeRating upsert
   */
  export type ChallengeRatingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeRating
     */
    select?: ChallengeRatingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengeRating
     */
    omit?: ChallengeRatingOmit<ExtArgs> | null
    /**
     * The filter to search for the ChallengeRating to update in case it exists.
     */
    where: ChallengeRatingWhereUniqueInput
    /**
     * In case the ChallengeRating found by the `where` argument doesn't exist, create a new ChallengeRating with this data.
     */
    create: XOR<ChallengeRatingCreateInput, ChallengeRatingUncheckedCreateInput>
    /**
     * In case the ChallengeRating was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ChallengeRatingUpdateInput, ChallengeRatingUncheckedUpdateInput>
  }

  /**
   * ChallengeRating delete
   */
  export type ChallengeRatingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeRating
     */
    select?: ChallengeRatingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengeRating
     */
    omit?: ChallengeRatingOmit<ExtArgs> | null
    /**
     * Filter which ChallengeRating to delete.
     */
    where: ChallengeRatingWhereUniqueInput
  }

  /**
   * ChallengeRating deleteMany
   */
  export type ChallengeRatingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ChallengeRatings to delete
     */
    where?: ChallengeRatingWhereInput
    /**
     * Limit how many ChallengeRatings to delete.
     */
    limit?: number
  }

  /**
   * ChallengeRating without action
   */
  export type ChallengeRatingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeRating
     */
    select?: ChallengeRatingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChallengeRating
     */
    omit?: ChallengeRatingOmit<ExtArgs> | null
  }


  /**
   * Model GPTMessageHistory
   */

  export type AggregateGPTMessageHistory = {
    _count: GPTMessageHistoryCountAggregateOutputType | null
    _min: GPTMessageHistoryMinAggregateOutputType | null
    _max: GPTMessageHistoryMaxAggregateOutputType | null
  }

  export type GPTMessageHistoryMinAggregateOutputType = {
    id: string | null
    type: string | null
  }

  export type GPTMessageHistoryMaxAggregateOutputType = {
    id: string | null
    type: string | null
  }

  export type GPTMessageHistoryCountAggregateOutputType = {
    id: number
    type: number
    _all: number
  }


  export type GPTMessageHistoryMinAggregateInputType = {
    id?: true
    type?: true
  }

  export type GPTMessageHistoryMaxAggregateInputType = {
    id?: true
    type?: true
  }

  export type GPTMessageHistoryCountAggregateInputType = {
    id?: true
    type?: true
    _all?: true
  }

  export type GPTMessageHistoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GPTMessageHistory to aggregate.
     */
    where?: GPTMessageHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GPTMessageHistories to fetch.
     */
    orderBy?: GPTMessageHistoryOrderByWithRelationInput | GPTMessageHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: GPTMessageHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GPTMessageHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GPTMessageHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned GPTMessageHistories
    **/
    _count?: true | GPTMessageHistoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GPTMessageHistoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GPTMessageHistoryMaxAggregateInputType
  }

  export type GetGPTMessageHistoryAggregateType<T extends GPTMessageHistoryAggregateArgs> = {
        [P in keyof T & keyof AggregateGPTMessageHistory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGPTMessageHistory[P]>
      : GetScalarType<T[P], AggregateGPTMessageHistory[P]>
  }




  export type GPTMessageHistoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GPTMessageHistoryWhereInput
    orderBy?: GPTMessageHistoryOrderByWithAggregationInput | GPTMessageHistoryOrderByWithAggregationInput[]
    by: GPTMessageHistoryScalarFieldEnum[] | GPTMessageHistoryScalarFieldEnum
    having?: GPTMessageHistoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GPTMessageHistoryCountAggregateInputType | true
    _min?: GPTMessageHistoryMinAggregateInputType
    _max?: GPTMessageHistoryMaxAggregateInputType
  }

  export type GPTMessageHistoryGroupByOutputType = {
    id: string
    type: string
    _count: GPTMessageHistoryCountAggregateOutputType | null
    _min: GPTMessageHistoryMinAggregateOutputType | null
    _max: GPTMessageHistoryMaxAggregateOutputType | null
  }

  type GetGPTMessageHistoryGroupByPayload<T extends GPTMessageHistoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GPTMessageHistoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GPTMessageHistoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GPTMessageHistoryGroupByOutputType[P]>
            : GetScalarType<T[P], GPTMessageHistoryGroupByOutputType[P]>
        }
      >
    >


  export type GPTMessageHistorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    messages?: boolean | GPTMessageHistory$messagesArgs<ExtArgs>
    _count?: boolean | GPTMessageHistoryCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["gPTMessageHistory"]>

  export type GPTMessageHistorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
  }, ExtArgs["result"]["gPTMessageHistory"]>

  export type GPTMessageHistorySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
  }, ExtArgs["result"]["gPTMessageHistory"]>

  export type GPTMessageHistorySelectScalar = {
    id?: boolean
    type?: boolean
  }

  export type GPTMessageHistoryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "type", ExtArgs["result"]["gPTMessageHistory"]>
  export type GPTMessageHistoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    messages?: boolean | GPTMessageHistory$messagesArgs<ExtArgs>
    _count?: boolean | GPTMessageHistoryCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type GPTMessageHistoryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type GPTMessageHistoryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $GPTMessageHistoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "GPTMessageHistory"
    objects: {
      messages: Prisma.$GPTMessagePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      type: string
    }, ExtArgs["result"]["gPTMessageHistory"]>
    composites: {}
  }

  type GPTMessageHistoryGetPayload<S extends boolean | null | undefined | GPTMessageHistoryDefaultArgs> = $Result.GetResult<Prisma.$GPTMessageHistoryPayload, S>

  type GPTMessageHistoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<GPTMessageHistoryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: GPTMessageHistoryCountAggregateInputType | true
    }

  export interface GPTMessageHistoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['GPTMessageHistory'], meta: { name: 'GPTMessageHistory' } }
    /**
     * Find zero or one GPTMessageHistory that matches the filter.
     * @param {GPTMessageHistoryFindUniqueArgs} args - Arguments to find a GPTMessageHistory
     * @example
     * // Get one GPTMessageHistory
     * const gPTMessageHistory = await prisma.gPTMessageHistory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends GPTMessageHistoryFindUniqueArgs>(args: SelectSubset<T, GPTMessageHistoryFindUniqueArgs<ExtArgs>>): Prisma__GPTMessageHistoryClient<$Result.GetResult<Prisma.$GPTMessageHistoryPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one GPTMessageHistory that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {GPTMessageHistoryFindUniqueOrThrowArgs} args - Arguments to find a GPTMessageHistory
     * @example
     * // Get one GPTMessageHistory
     * const gPTMessageHistory = await prisma.gPTMessageHistory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends GPTMessageHistoryFindUniqueOrThrowArgs>(args: SelectSubset<T, GPTMessageHistoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__GPTMessageHistoryClient<$Result.GetResult<Prisma.$GPTMessageHistoryPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first GPTMessageHistory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GPTMessageHistoryFindFirstArgs} args - Arguments to find a GPTMessageHistory
     * @example
     * // Get one GPTMessageHistory
     * const gPTMessageHistory = await prisma.gPTMessageHistory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends GPTMessageHistoryFindFirstArgs>(args?: SelectSubset<T, GPTMessageHistoryFindFirstArgs<ExtArgs>>): Prisma__GPTMessageHistoryClient<$Result.GetResult<Prisma.$GPTMessageHistoryPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first GPTMessageHistory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GPTMessageHistoryFindFirstOrThrowArgs} args - Arguments to find a GPTMessageHistory
     * @example
     * // Get one GPTMessageHistory
     * const gPTMessageHistory = await prisma.gPTMessageHistory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends GPTMessageHistoryFindFirstOrThrowArgs>(args?: SelectSubset<T, GPTMessageHistoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__GPTMessageHistoryClient<$Result.GetResult<Prisma.$GPTMessageHistoryPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more GPTMessageHistories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GPTMessageHistoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all GPTMessageHistories
     * const gPTMessageHistories = await prisma.gPTMessageHistory.findMany()
     * 
     * // Get first 10 GPTMessageHistories
     * const gPTMessageHistories = await prisma.gPTMessageHistory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const gPTMessageHistoryWithIdOnly = await prisma.gPTMessageHistory.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends GPTMessageHistoryFindManyArgs>(args?: SelectSubset<T, GPTMessageHistoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GPTMessageHistoryPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a GPTMessageHistory.
     * @param {GPTMessageHistoryCreateArgs} args - Arguments to create a GPTMessageHistory.
     * @example
     * // Create one GPTMessageHistory
     * const GPTMessageHistory = await prisma.gPTMessageHistory.create({
     *   data: {
     *     // ... data to create a GPTMessageHistory
     *   }
     * })
     * 
     */
    create<T extends GPTMessageHistoryCreateArgs>(args: SelectSubset<T, GPTMessageHistoryCreateArgs<ExtArgs>>): Prisma__GPTMessageHistoryClient<$Result.GetResult<Prisma.$GPTMessageHistoryPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many GPTMessageHistories.
     * @param {GPTMessageHistoryCreateManyArgs} args - Arguments to create many GPTMessageHistories.
     * @example
     * // Create many GPTMessageHistories
     * const gPTMessageHistory = await prisma.gPTMessageHistory.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends GPTMessageHistoryCreateManyArgs>(args?: SelectSubset<T, GPTMessageHistoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many GPTMessageHistories and returns the data saved in the database.
     * @param {GPTMessageHistoryCreateManyAndReturnArgs} args - Arguments to create many GPTMessageHistories.
     * @example
     * // Create many GPTMessageHistories
     * const gPTMessageHistory = await prisma.gPTMessageHistory.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many GPTMessageHistories and only return the `id`
     * const gPTMessageHistoryWithIdOnly = await prisma.gPTMessageHistory.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends GPTMessageHistoryCreateManyAndReturnArgs>(args?: SelectSubset<T, GPTMessageHistoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GPTMessageHistoryPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a GPTMessageHistory.
     * @param {GPTMessageHistoryDeleteArgs} args - Arguments to delete one GPTMessageHistory.
     * @example
     * // Delete one GPTMessageHistory
     * const GPTMessageHistory = await prisma.gPTMessageHistory.delete({
     *   where: {
     *     // ... filter to delete one GPTMessageHistory
     *   }
     * })
     * 
     */
    delete<T extends GPTMessageHistoryDeleteArgs>(args: SelectSubset<T, GPTMessageHistoryDeleteArgs<ExtArgs>>): Prisma__GPTMessageHistoryClient<$Result.GetResult<Prisma.$GPTMessageHistoryPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one GPTMessageHistory.
     * @param {GPTMessageHistoryUpdateArgs} args - Arguments to update one GPTMessageHistory.
     * @example
     * // Update one GPTMessageHistory
     * const gPTMessageHistory = await prisma.gPTMessageHistory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends GPTMessageHistoryUpdateArgs>(args: SelectSubset<T, GPTMessageHistoryUpdateArgs<ExtArgs>>): Prisma__GPTMessageHistoryClient<$Result.GetResult<Prisma.$GPTMessageHistoryPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more GPTMessageHistories.
     * @param {GPTMessageHistoryDeleteManyArgs} args - Arguments to filter GPTMessageHistories to delete.
     * @example
     * // Delete a few GPTMessageHistories
     * const { count } = await prisma.gPTMessageHistory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends GPTMessageHistoryDeleteManyArgs>(args?: SelectSubset<T, GPTMessageHistoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more GPTMessageHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GPTMessageHistoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many GPTMessageHistories
     * const gPTMessageHistory = await prisma.gPTMessageHistory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends GPTMessageHistoryUpdateManyArgs>(args: SelectSubset<T, GPTMessageHistoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more GPTMessageHistories and returns the data updated in the database.
     * @param {GPTMessageHistoryUpdateManyAndReturnArgs} args - Arguments to update many GPTMessageHistories.
     * @example
     * // Update many GPTMessageHistories
     * const gPTMessageHistory = await prisma.gPTMessageHistory.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more GPTMessageHistories and only return the `id`
     * const gPTMessageHistoryWithIdOnly = await prisma.gPTMessageHistory.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends GPTMessageHistoryUpdateManyAndReturnArgs>(args: SelectSubset<T, GPTMessageHistoryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GPTMessageHistoryPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one GPTMessageHistory.
     * @param {GPTMessageHistoryUpsertArgs} args - Arguments to update or create a GPTMessageHistory.
     * @example
     * // Update or create a GPTMessageHistory
     * const gPTMessageHistory = await prisma.gPTMessageHistory.upsert({
     *   create: {
     *     // ... data to create a GPTMessageHistory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the GPTMessageHistory we want to update
     *   }
     * })
     */
    upsert<T extends GPTMessageHistoryUpsertArgs>(args: SelectSubset<T, GPTMessageHistoryUpsertArgs<ExtArgs>>): Prisma__GPTMessageHistoryClient<$Result.GetResult<Prisma.$GPTMessageHistoryPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of GPTMessageHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GPTMessageHistoryCountArgs} args - Arguments to filter GPTMessageHistories to count.
     * @example
     * // Count the number of GPTMessageHistories
     * const count = await prisma.gPTMessageHistory.count({
     *   where: {
     *     // ... the filter for the GPTMessageHistories we want to count
     *   }
     * })
    **/
    count<T extends GPTMessageHistoryCountArgs>(
      args?: Subset<T, GPTMessageHistoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GPTMessageHistoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a GPTMessageHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GPTMessageHistoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GPTMessageHistoryAggregateArgs>(args: Subset<T, GPTMessageHistoryAggregateArgs>): Prisma.PrismaPromise<GetGPTMessageHistoryAggregateType<T>>

    /**
     * Group by GPTMessageHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GPTMessageHistoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GPTMessageHistoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GPTMessageHistoryGroupByArgs['orderBy'] }
        : { orderBy?: GPTMessageHistoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GPTMessageHistoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGPTMessageHistoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the GPTMessageHistory model
   */
  readonly fields: GPTMessageHistoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for GPTMessageHistory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__GPTMessageHistoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    messages<T extends GPTMessageHistory$messagesArgs<ExtArgs> = {}>(args?: Subset<T, GPTMessageHistory$messagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GPTMessagePayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the GPTMessageHistory model
   */ 
  interface GPTMessageHistoryFieldRefs {
    readonly id: FieldRef<"GPTMessageHistory", 'String'>
    readonly type: FieldRef<"GPTMessageHistory", 'String'>
  }
    

  // Custom InputTypes
  /**
   * GPTMessageHistory findUnique
   */
  export type GPTMessageHistoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GPTMessageHistory
     */
    select?: GPTMessageHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the GPTMessageHistory
     */
    omit?: GPTMessageHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GPTMessageHistoryInclude<ExtArgs> | null
    /**
     * Filter, which GPTMessageHistory to fetch.
     */
    where: GPTMessageHistoryWhereUniqueInput
  }

  /**
   * GPTMessageHistory findUniqueOrThrow
   */
  export type GPTMessageHistoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GPTMessageHistory
     */
    select?: GPTMessageHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the GPTMessageHistory
     */
    omit?: GPTMessageHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GPTMessageHistoryInclude<ExtArgs> | null
    /**
     * Filter, which GPTMessageHistory to fetch.
     */
    where: GPTMessageHistoryWhereUniqueInput
  }

  /**
   * GPTMessageHistory findFirst
   */
  export type GPTMessageHistoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GPTMessageHistory
     */
    select?: GPTMessageHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the GPTMessageHistory
     */
    omit?: GPTMessageHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GPTMessageHistoryInclude<ExtArgs> | null
    /**
     * Filter, which GPTMessageHistory to fetch.
     */
    where?: GPTMessageHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GPTMessageHistories to fetch.
     */
    orderBy?: GPTMessageHistoryOrderByWithRelationInput | GPTMessageHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GPTMessageHistories.
     */
    cursor?: GPTMessageHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GPTMessageHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GPTMessageHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GPTMessageHistories.
     */
    distinct?: GPTMessageHistoryScalarFieldEnum | GPTMessageHistoryScalarFieldEnum[]
  }

  /**
   * GPTMessageHistory findFirstOrThrow
   */
  export type GPTMessageHistoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GPTMessageHistory
     */
    select?: GPTMessageHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the GPTMessageHistory
     */
    omit?: GPTMessageHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GPTMessageHistoryInclude<ExtArgs> | null
    /**
     * Filter, which GPTMessageHistory to fetch.
     */
    where?: GPTMessageHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GPTMessageHistories to fetch.
     */
    orderBy?: GPTMessageHistoryOrderByWithRelationInput | GPTMessageHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GPTMessageHistories.
     */
    cursor?: GPTMessageHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GPTMessageHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GPTMessageHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GPTMessageHistories.
     */
    distinct?: GPTMessageHistoryScalarFieldEnum | GPTMessageHistoryScalarFieldEnum[]
  }

  /**
   * GPTMessageHistory findMany
   */
  export type GPTMessageHistoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GPTMessageHistory
     */
    select?: GPTMessageHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the GPTMessageHistory
     */
    omit?: GPTMessageHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GPTMessageHistoryInclude<ExtArgs> | null
    /**
     * Filter, which GPTMessageHistories to fetch.
     */
    where?: GPTMessageHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GPTMessageHistories to fetch.
     */
    orderBy?: GPTMessageHistoryOrderByWithRelationInput | GPTMessageHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing GPTMessageHistories.
     */
    cursor?: GPTMessageHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GPTMessageHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GPTMessageHistories.
     */
    skip?: number
    distinct?: GPTMessageHistoryScalarFieldEnum | GPTMessageHistoryScalarFieldEnum[]
  }

  /**
   * GPTMessageHistory create
   */
  export type GPTMessageHistoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GPTMessageHistory
     */
    select?: GPTMessageHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the GPTMessageHistory
     */
    omit?: GPTMessageHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GPTMessageHistoryInclude<ExtArgs> | null
    /**
     * The data needed to create a GPTMessageHistory.
     */
    data: XOR<GPTMessageHistoryCreateInput, GPTMessageHistoryUncheckedCreateInput>
  }

  /**
   * GPTMessageHistory createMany
   */
  export type GPTMessageHistoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many GPTMessageHistories.
     */
    data: GPTMessageHistoryCreateManyInput | GPTMessageHistoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * GPTMessageHistory createManyAndReturn
   */
  export type GPTMessageHistoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GPTMessageHistory
     */
    select?: GPTMessageHistorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the GPTMessageHistory
     */
    omit?: GPTMessageHistoryOmit<ExtArgs> | null
    /**
     * The data used to create many GPTMessageHistories.
     */
    data: GPTMessageHistoryCreateManyInput | GPTMessageHistoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * GPTMessageHistory update
   */
  export type GPTMessageHistoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GPTMessageHistory
     */
    select?: GPTMessageHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the GPTMessageHistory
     */
    omit?: GPTMessageHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GPTMessageHistoryInclude<ExtArgs> | null
    /**
     * The data needed to update a GPTMessageHistory.
     */
    data: XOR<GPTMessageHistoryUpdateInput, GPTMessageHistoryUncheckedUpdateInput>
    /**
     * Choose, which GPTMessageHistory to update.
     */
    where: GPTMessageHistoryWhereUniqueInput
  }

  /**
   * GPTMessageHistory updateMany
   */
  export type GPTMessageHistoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update GPTMessageHistories.
     */
    data: XOR<GPTMessageHistoryUpdateManyMutationInput, GPTMessageHistoryUncheckedUpdateManyInput>
    /**
     * Filter which GPTMessageHistories to update
     */
    where?: GPTMessageHistoryWhereInput
    /**
     * Limit how many GPTMessageHistories to update.
     */
    limit?: number
  }

  /**
   * GPTMessageHistory updateManyAndReturn
   */
  export type GPTMessageHistoryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GPTMessageHistory
     */
    select?: GPTMessageHistorySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the GPTMessageHistory
     */
    omit?: GPTMessageHistoryOmit<ExtArgs> | null
    /**
     * The data used to update GPTMessageHistories.
     */
    data: XOR<GPTMessageHistoryUpdateManyMutationInput, GPTMessageHistoryUncheckedUpdateManyInput>
    /**
     * Filter which GPTMessageHistories to update
     */
    where?: GPTMessageHistoryWhereInput
    /**
     * Limit how many GPTMessageHistories to update.
     */
    limit?: number
  }

  /**
   * GPTMessageHistory upsert
   */
  export type GPTMessageHistoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GPTMessageHistory
     */
    select?: GPTMessageHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the GPTMessageHistory
     */
    omit?: GPTMessageHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GPTMessageHistoryInclude<ExtArgs> | null
    /**
     * The filter to search for the GPTMessageHistory to update in case it exists.
     */
    where: GPTMessageHistoryWhereUniqueInput
    /**
     * In case the GPTMessageHistory found by the `where` argument doesn't exist, create a new GPTMessageHistory with this data.
     */
    create: XOR<GPTMessageHistoryCreateInput, GPTMessageHistoryUncheckedCreateInput>
    /**
     * In case the GPTMessageHistory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<GPTMessageHistoryUpdateInput, GPTMessageHistoryUncheckedUpdateInput>
  }

  /**
   * GPTMessageHistory delete
   */
  export type GPTMessageHistoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GPTMessageHistory
     */
    select?: GPTMessageHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the GPTMessageHistory
     */
    omit?: GPTMessageHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GPTMessageHistoryInclude<ExtArgs> | null
    /**
     * Filter which GPTMessageHistory to delete.
     */
    where: GPTMessageHistoryWhereUniqueInput
  }

  /**
   * GPTMessageHistory deleteMany
   */
  export type GPTMessageHistoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GPTMessageHistories to delete
     */
    where?: GPTMessageHistoryWhereInput
    /**
     * Limit how many GPTMessageHistories to delete.
     */
    limit?: number
  }

  /**
   * GPTMessageHistory.messages
   */
  export type GPTMessageHistory$messagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GPTMessage
     */
    select?: GPTMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GPTMessage
     */
    omit?: GPTMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GPTMessageInclude<ExtArgs> | null
    where?: GPTMessageWhereInput
    orderBy?: GPTMessageOrderByWithRelationInput | GPTMessageOrderByWithRelationInput[]
    cursor?: GPTMessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GPTMessageScalarFieldEnum | GPTMessageScalarFieldEnum[]
  }

  /**
   * GPTMessageHistory without action
   */
  export type GPTMessageHistoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GPTMessageHistory
     */
    select?: GPTMessageHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the GPTMessageHistory
     */
    omit?: GPTMessageHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GPTMessageHistoryInclude<ExtArgs> | null
  }


  /**
   * Model GPTMessage
   */

  export type AggregateGPTMessage = {
    _count: GPTMessageCountAggregateOutputType | null
    _avg: GPTMessageAvgAggregateOutputType | null
    _sum: GPTMessageSumAggregateOutputType | null
    _min: GPTMessageMinAggregateOutputType | null
    _max: GPTMessageMaxAggregateOutputType | null
  }

  export type GPTMessageAvgAggregateOutputType = {
    number: number | null
  }

  export type GPTMessageSumAggregateOutputType = {
    number: number | null
  }

  export type GPTMessageMinAggregateOutputType = {
    number: number | null
    message_history_id: string | null
    text: string | null
    role: string | null
  }

  export type GPTMessageMaxAggregateOutputType = {
    number: number | null
    message_history_id: string | null
    text: string | null
    role: string | null
  }

  export type GPTMessageCountAggregateOutputType = {
    number: number
    message_history_id: number
    text: number
    role: number
    _all: number
  }


  export type GPTMessageAvgAggregateInputType = {
    number?: true
  }

  export type GPTMessageSumAggregateInputType = {
    number?: true
  }

  export type GPTMessageMinAggregateInputType = {
    number?: true
    message_history_id?: true
    text?: true
    role?: true
  }

  export type GPTMessageMaxAggregateInputType = {
    number?: true
    message_history_id?: true
    text?: true
    role?: true
  }

  export type GPTMessageCountAggregateInputType = {
    number?: true
    message_history_id?: true
    text?: true
    role?: true
    _all?: true
  }

  export type GPTMessageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GPTMessage to aggregate.
     */
    where?: GPTMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GPTMessages to fetch.
     */
    orderBy?: GPTMessageOrderByWithRelationInput | GPTMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: GPTMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GPTMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GPTMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned GPTMessages
    **/
    _count?: true | GPTMessageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: GPTMessageAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: GPTMessageSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GPTMessageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GPTMessageMaxAggregateInputType
  }

  export type GetGPTMessageAggregateType<T extends GPTMessageAggregateArgs> = {
        [P in keyof T & keyof AggregateGPTMessage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGPTMessage[P]>
      : GetScalarType<T[P], AggregateGPTMessage[P]>
  }




  export type GPTMessageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GPTMessageWhereInput
    orderBy?: GPTMessageOrderByWithAggregationInput | GPTMessageOrderByWithAggregationInput[]
    by: GPTMessageScalarFieldEnum[] | GPTMessageScalarFieldEnum
    having?: GPTMessageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GPTMessageCountAggregateInputType | true
    _avg?: GPTMessageAvgAggregateInputType
    _sum?: GPTMessageSumAggregateInputType
    _min?: GPTMessageMinAggregateInputType
    _max?: GPTMessageMaxAggregateInputType
  }

  export type GPTMessageGroupByOutputType = {
    number: number
    message_history_id: string
    text: string
    role: string
    _count: GPTMessageCountAggregateOutputType | null
    _avg: GPTMessageAvgAggregateOutputType | null
    _sum: GPTMessageSumAggregateOutputType | null
    _min: GPTMessageMinAggregateOutputType | null
    _max: GPTMessageMaxAggregateOutputType | null
  }

  type GetGPTMessageGroupByPayload<T extends GPTMessageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GPTMessageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GPTMessageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GPTMessageGroupByOutputType[P]>
            : GetScalarType<T[P], GPTMessageGroupByOutputType[P]>
        }
      >
    >


  export type GPTMessageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    number?: boolean
    message_history_id?: boolean
    text?: boolean
    role?: boolean
    message_history?: boolean | GPTMessageHistoryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["gPTMessage"]>

  export type GPTMessageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    number?: boolean
    message_history_id?: boolean
    text?: boolean
    role?: boolean
    message_history?: boolean | GPTMessageHistoryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["gPTMessage"]>

  export type GPTMessageSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    number?: boolean
    message_history_id?: boolean
    text?: boolean
    role?: boolean
    message_history?: boolean | GPTMessageHistoryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["gPTMessage"]>

  export type GPTMessageSelectScalar = {
    number?: boolean
    message_history_id?: boolean
    text?: boolean
    role?: boolean
  }

  export type GPTMessageOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"number" | "message_history_id" | "text" | "role", ExtArgs["result"]["gPTMessage"]>
  export type GPTMessageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    message_history?: boolean | GPTMessageHistoryDefaultArgs<ExtArgs>
  }
  export type GPTMessageIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    message_history?: boolean | GPTMessageHistoryDefaultArgs<ExtArgs>
  }
  export type GPTMessageIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    message_history?: boolean | GPTMessageHistoryDefaultArgs<ExtArgs>
  }

  export type $GPTMessagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "GPTMessage"
    objects: {
      message_history: Prisma.$GPTMessageHistoryPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      number: number
      message_history_id: string
      text: string
      role: string
    }, ExtArgs["result"]["gPTMessage"]>
    composites: {}
  }

  type GPTMessageGetPayload<S extends boolean | null | undefined | GPTMessageDefaultArgs> = $Result.GetResult<Prisma.$GPTMessagePayload, S>

  type GPTMessageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<GPTMessageFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: GPTMessageCountAggregateInputType | true
    }

  export interface GPTMessageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['GPTMessage'], meta: { name: 'GPTMessage' } }
    /**
     * Find zero or one GPTMessage that matches the filter.
     * @param {GPTMessageFindUniqueArgs} args - Arguments to find a GPTMessage
     * @example
     * // Get one GPTMessage
     * const gPTMessage = await prisma.gPTMessage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends GPTMessageFindUniqueArgs>(args: SelectSubset<T, GPTMessageFindUniqueArgs<ExtArgs>>): Prisma__GPTMessageClient<$Result.GetResult<Prisma.$GPTMessagePayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one GPTMessage that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {GPTMessageFindUniqueOrThrowArgs} args - Arguments to find a GPTMessage
     * @example
     * // Get one GPTMessage
     * const gPTMessage = await prisma.gPTMessage.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends GPTMessageFindUniqueOrThrowArgs>(args: SelectSubset<T, GPTMessageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__GPTMessageClient<$Result.GetResult<Prisma.$GPTMessagePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first GPTMessage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GPTMessageFindFirstArgs} args - Arguments to find a GPTMessage
     * @example
     * // Get one GPTMessage
     * const gPTMessage = await prisma.gPTMessage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends GPTMessageFindFirstArgs>(args?: SelectSubset<T, GPTMessageFindFirstArgs<ExtArgs>>): Prisma__GPTMessageClient<$Result.GetResult<Prisma.$GPTMessagePayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first GPTMessage that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GPTMessageFindFirstOrThrowArgs} args - Arguments to find a GPTMessage
     * @example
     * // Get one GPTMessage
     * const gPTMessage = await prisma.gPTMessage.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends GPTMessageFindFirstOrThrowArgs>(args?: SelectSubset<T, GPTMessageFindFirstOrThrowArgs<ExtArgs>>): Prisma__GPTMessageClient<$Result.GetResult<Prisma.$GPTMessagePayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more GPTMessages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GPTMessageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all GPTMessages
     * const gPTMessages = await prisma.gPTMessage.findMany()
     * 
     * // Get first 10 GPTMessages
     * const gPTMessages = await prisma.gPTMessage.findMany({ take: 10 })
     * 
     * // Only select the `number`
     * const gPTMessageWithNumberOnly = await prisma.gPTMessage.findMany({ select: { number: true } })
     * 
     */
    findMany<T extends GPTMessageFindManyArgs>(args?: SelectSubset<T, GPTMessageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GPTMessagePayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a GPTMessage.
     * @param {GPTMessageCreateArgs} args - Arguments to create a GPTMessage.
     * @example
     * // Create one GPTMessage
     * const GPTMessage = await prisma.gPTMessage.create({
     *   data: {
     *     // ... data to create a GPTMessage
     *   }
     * })
     * 
     */
    create<T extends GPTMessageCreateArgs>(args: SelectSubset<T, GPTMessageCreateArgs<ExtArgs>>): Prisma__GPTMessageClient<$Result.GetResult<Prisma.$GPTMessagePayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many GPTMessages.
     * @param {GPTMessageCreateManyArgs} args - Arguments to create many GPTMessages.
     * @example
     * // Create many GPTMessages
     * const gPTMessage = await prisma.gPTMessage.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends GPTMessageCreateManyArgs>(args?: SelectSubset<T, GPTMessageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many GPTMessages and returns the data saved in the database.
     * @param {GPTMessageCreateManyAndReturnArgs} args - Arguments to create many GPTMessages.
     * @example
     * // Create many GPTMessages
     * const gPTMessage = await prisma.gPTMessage.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many GPTMessages and only return the `number`
     * const gPTMessageWithNumberOnly = await prisma.gPTMessage.createManyAndReturn({
     *   select: { number: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends GPTMessageCreateManyAndReturnArgs>(args?: SelectSubset<T, GPTMessageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GPTMessagePayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a GPTMessage.
     * @param {GPTMessageDeleteArgs} args - Arguments to delete one GPTMessage.
     * @example
     * // Delete one GPTMessage
     * const GPTMessage = await prisma.gPTMessage.delete({
     *   where: {
     *     // ... filter to delete one GPTMessage
     *   }
     * })
     * 
     */
    delete<T extends GPTMessageDeleteArgs>(args: SelectSubset<T, GPTMessageDeleteArgs<ExtArgs>>): Prisma__GPTMessageClient<$Result.GetResult<Prisma.$GPTMessagePayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one GPTMessage.
     * @param {GPTMessageUpdateArgs} args - Arguments to update one GPTMessage.
     * @example
     * // Update one GPTMessage
     * const gPTMessage = await prisma.gPTMessage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends GPTMessageUpdateArgs>(args: SelectSubset<T, GPTMessageUpdateArgs<ExtArgs>>): Prisma__GPTMessageClient<$Result.GetResult<Prisma.$GPTMessagePayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more GPTMessages.
     * @param {GPTMessageDeleteManyArgs} args - Arguments to filter GPTMessages to delete.
     * @example
     * // Delete a few GPTMessages
     * const { count } = await prisma.gPTMessage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends GPTMessageDeleteManyArgs>(args?: SelectSubset<T, GPTMessageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more GPTMessages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GPTMessageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many GPTMessages
     * const gPTMessage = await prisma.gPTMessage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends GPTMessageUpdateManyArgs>(args: SelectSubset<T, GPTMessageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more GPTMessages and returns the data updated in the database.
     * @param {GPTMessageUpdateManyAndReturnArgs} args - Arguments to update many GPTMessages.
     * @example
     * // Update many GPTMessages
     * const gPTMessage = await prisma.gPTMessage.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more GPTMessages and only return the `number`
     * const gPTMessageWithNumberOnly = await prisma.gPTMessage.updateManyAndReturn({
     *   select: { number: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends GPTMessageUpdateManyAndReturnArgs>(args: SelectSubset<T, GPTMessageUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GPTMessagePayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one GPTMessage.
     * @param {GPTMessageUpsertArgs} args - Arguments to update or create a GPTMessage.
     * @example
     * // Update or create a GPTMessage
     * const gPTMessage = await prisma.gPTMessage.upsert({
     *   create: {
     *     // ... data to create a GPTMessage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the GPTMessage we want to update
     *   }
     * })
     */
    upsert<T extends GPTMessageUpsertArgs>(args: SelectSubset<T, GPTMessageUpsertArgs<ExtArgs>>): Prisma__GPTMessageClient<$Result.GetResult<Prisma.$GPTMessagePayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of GPTMessages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GPTMessageCountArgs} args - Arguments to filter GPTMessages to count.
     * @example
     * // Count the number of GPTMessages
     * const count = await prisma.gPTMessage.count({
     *   where: {
     *     // ... the filter for the GPTMessages we want to count
     *   }
     * })
    **/
    count<T extends GPTMessageCountArgs>(
      args?: Subset<T, GPTMessageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GPTMessageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a GPTMessage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GPTMessageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GPTMessageAggregateArgs>(args: Subset<T, GPTMessageAggregateArgs>): Prisma.PrismaPromise<GetGPTMessageAggregateType<T>>

    /**
     * Group by GPTMessage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GPTMessageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GPTMessageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GPTMessageGroupByArgs['orderBy'] }
        : { orderBy?: GPTMessageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GPTMessageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGPTMessageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the GPTMessage model
   */
  readonly fields: GPTMessageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for GPTMessage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__GPTMessageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    message_history<T extends GPTMessageHistoryDefaultArgs<ExtArgs> = {}>(args?: Subset<T, GPTMessageHistoryDefaultArgs<ExtArgs>>): Prisma__GPTMessageHistoryClient<$Result.GetResult<Prisma.$GPTMessageHistoryPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the GPTMessage model
   */ 
  interface GPTMessageFieldRefs {
    readonly number: FieldRef<"GPTMessage", 'Int'>
    readonly message_history_id: FieldRef<"GPTMessage", 'String'>
    readonly text: FieldRef<"GPTMessage", 'String'>
    readonly role: FieldRef<"GPTMessage", 'String'>
  }
    

  // Custom InputTypes
  /**
   * GPTMessage findUnique
   */
  export type GPTMessageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GPTMessage
     */
    select?: GPTMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GPTMessage
     */
    omit?: GPTMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GPTMessageInclude<ExtArgs> | null
    /**
     * Filter, which GPTMessage to fetch.
     */
    where: GPTMessageWhereUniqueInput
  }

  /**
   * GPTMessage findUniqueOrThrow
   */
  export type GPTMessageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GPTMessage
     */
    select?: GPTMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GPTMessage
     */
    omit?: GPTMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GPTMessageInclude<ExtArgs> | null
    /**
     * Filter, which GPTMessage to fetch.
     */
    where: GPTMessageWhereUniqueInput
  }

  /**
   * GPTMessage findFirst
   */
  export type GPTMessageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GPTMessage
     */
    select?: GPTMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GPTMessage
     */
    omit?: GPTMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GPTMessageInclude<ExtArgs> | null
    /**
     * Filter, which GPTMessage to fetch.
     */
    where?: GPTMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GPTMessages to fetch.
     */
    orderBy?: GPTMessageOrderByWithRelationInput | GPTMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GPTMessages.
     */
    cursor?: GPTMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GPTMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GPTMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GPTMessages.
     */
    distinct?: GPTMessageScalarFieldEnum | GPTMessageScalarFieldEnum[]
  }

  /**
   * GPTMessage findFirstOrThrow
   */
  export type GPTMessageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GPTMessage
     */
    select?: GPTMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GPTMessage
     */
    omit?: GPTMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GPTMessageInclude<ExtArgs> | null
    /**
     * Filter, which GPTMessage to fetch.
     */
    where?: GPTMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GPTMessages to fetch.
     */
    orderBy?: GPTMessageOrderByWithRelationInput | GPTMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GPTMessages.
     */
    cursor?: GPTMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GPTMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GPTMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GPTMessages.
     */
    distinct?: GPTMessageScalarFieldEnum | GPTMessageScalarFieldEnum[]
  }

  /**
   * GPTMessage findMany
   */
  export type GPTMessageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GPTMessage
     */
    select?: GPTMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GPTMessage
     */
    omit?: GPTMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GPTMessageInclude<ExtArgs> | null
    /**
     * Filter, which GPTMessages to fetch.
     */
    where?: GPTMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GPTMessages to fetch.
     */
    orderBy?: GPTMessageOrderByWithRelationInput | GPTMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing GPTMessages.
     */
    cursor?: GPTMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GPTMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GPTMessages.
     */
    skip?: number
    distinct?: GPTMessageScalarFieldEnum | GPTMessageScalarFieldEnum[]
  }

  /**
   * GPTMessage create
   */
  export type GPTMessageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GPTMessage
     */
    select?: GPTMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GPTMessage
     */
    omit?: GPTMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GPTMessageInclude<ExtArgs> | null
    /**
     * The data needed to create a GPTMessage.
     */
    data: XOR<GPTMessageCreateInput, GPTMessageUncheckedCreateInput>
  }

  /**
   * GPTMessage createMany
   */
  export type GPTMessageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many GPTMessages.
     */
    data: GPTMessageCreateManyInput | GPTMessageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * GPTMessage createManyAndReturn
   */
  export type GPTMessageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GPTMessage
     */
    select?: GPTMessageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the GPTMessage
     */
    omit?: GPTMessageOmit<ExtArgs> | null
    /**
     * The data used to create many GPTMessages.
     */
    data: GPTMessageCreateManyInput | GPTMessageCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GPTMessageIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * GPTMessage update
   */
  export type GPTMessageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GPTMessage
     */
    select?: GPTMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GPTMessage
     */
    omit?: GPTMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GPTMessageInclude<ExtArgs> | null
    /**
     * The data needed to update a GPTMessage.
     */
    data: XOR<GPTMessageUpdateInput, GPTMessageUncheckedUpdateInput>
    /**
     * Choose, which GPTMessage to update.
     */
    where: GPTMessageWhereUniqueInput
  }

  /**
   * GPTMessage updateMany
   */
  export type GPTMessageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update GPTMessages.
     */
    data: XOR<GPTMessageUpdateManyMutationInput, GPTMessageUncheckedUpdateManyInput>
    /**
     * Filter which GPTMessages to update
     */
    where?: GPTMessageWhereInput
    /**
     * Limit how many GPTMessages to update.
     */
    limit?: number
  }

  /**
   * GPTMessage updateManyAndReturn
   */
  export type GPTMessageUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GPTMessage
     */
    select?: GPTMessageSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the GPTMessage
     */
    omit?: GPTMessageOmit<ExtArgs> | null
    /**
     * The data used to update GPTMessages.
     */
    data: XOR<GPTMessageUpdateManyMutationInput, GPTMessageUncheckedUpdateManyInput>
    /**
     * Filter which GPTMessages to update
     */
    where?: GPTMessageWhereInput
    /**
     * Limit how many GPTMessages to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GPTMessageIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * GPTMessage upsert
   */
  export type GPTMessageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GPTMessage
     */
    select?: GPTMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GPTMessage
     */
    omit?: GPTMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GPTMessageInclude<ExtArgs> | null
    /**
     * The filter to search for the GPTMessage to update in case it exists.
     */
    where: GPTMessageWhereUniqueInput
    /**
     * In case the GPTMessage found by the `where` argument doesn't exist, create a new GPTMessage with this data.
     */
    create: XOR<GPTMessageCreateInput, GPTMessageUncheckedCreateInput>
    /**
     * In case the GPTMessage was found with the provided `where` argument, update it with this data.
     */
    update: XOR<GPTMessageUpdateInput, GPTMessageUncheckedUpdateInput>
  }

  /**
   * GPTMessage delete
   */
  export type GPTMessageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GPTMessage
     */
    select?: GPTMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GPTMessage
     */
    omit?: GPTMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GPTMessageInclude<ExtArgs> | null
    /**
     * Filter which GPTMessage to delete.
     */
    where: GPTMessageWhereUniqueInput
  }

  /**
   * GPTMessage deleteMany
   */
  export type GPTMessageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GPTMessages to delete
     */
    where?: GPTMessageWhereInput
    /**
     * Limit how many GPTMessages to delete.
     */
    limit?: number
  }

  /**
   * GPTMessage without action
   */
  export type GPTMessageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GPTMessage
     */
    select?: GPTMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GPTMessage
     */
    omit?: GPTMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GPTMessageInclude<ExtArgs> | null
  }


  /**
   * Model Adventure
   */

  export type AggregateAdventure = {
    _count: AdventureCountAggregateOutputType | null
    _avg: AdventureAvgAggregateOutputType | null
    _sum: AdventureSumAggregateOutputType | null
    _min: AdventureMinAggregateOutputType | null
    _max: AdventureMaxAggregateOutputType | null
  }

  export type AdventureAvgAggregateOutputType = {
    planned_parties: number | null
  }

  export type AdventureSumAggregateOutputType = {
    planned_parties: number | null
  }

  export type AdventureMinAggregateOutputType = {
    id: string | null
    title: string | null
    planned_parties: number | null
    genre_id: string | null
    creator_id: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type AdventureMaxAggregateOutputType = {
    id: string | null
    title: string | null
    planned_parties: number | null
    genre_id: string | null
    creator_id: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type AdventureCountAggregateOutputType = {
    id: number
    title: number
    planned_parties: number
    genre_id: number
    creator_id: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type AdventureAvgAggregateInputType = {
    planned_parties?: true
  }

  export type AdventureSumAggregateInputType = {
    planned_parties?: true
  }

  export type AdventureMinAggregateInputType = {
    id?: true
    title?: true
    planned_parties?: true
    genre_id?: true
    creator_id?: true
    created_at?: true
    updated_at?: true
  }

  export type AdventureMaxAggregateInputType = {
    id?: true
    title?: true
    planned_parties?: true
    genre_id?: true
    creator_id?: true
    created_at?: true
    updated_at?: true
  }

  export type AdventureCountAggregateInputType = {
    id?: true
    title?: true
    planned_parties?: true
    genre_id?: true
    creator_id?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type AdventureAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Adventure to aggregate.
     */
    where?: AdventureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Adventures to fetch.
     */
    orderBy?: AdventureOrderByWithRelationInput | AdventureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AdventureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Adventures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Adventures.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Adventures
    **/
    _count?: true | AdventureCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AdventureAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AdventureSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AdventureMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AdventureMaxAggregateInputType
  }

  export type GetAdventureAggregateType<T extends AdventureAggregateArgs> = {
        [P in keyof T & keyof AggregateAdventure]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAdventure[P]>
      : GetScalarType<T[P], AggregateAdventure[P]>
  }




  export type AdventureGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdventureWhereInput
    orderBy?: AdventureOrderByWithAggregationInput | AdventureOrderByWithAggregationInput[]
    by: AdventureScalarFieldEnum[] | AdventureScalarFieldEnum
    having?: AdventureScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AdventureCountAggregateInputType | true
    _avg?: AdventureAvgAggregateInputType
    _sum?: AdventureSumAggregateInputType
    _min?: AdventureMinAggregateInputType
    _max?: AdventureMaxAggregateInputType
  }

  export type AdventureGroupByOutputType = {
    id: string
    title: string
    planned_parties: number
    genre_id: string
    creator_id: string
    created_at: Date
    updated_at: Date
    _count: AdventureCountAggregateOutputType | null
    _avg: AdventureAvgAggregateOutputType | null
    _sum: AdventureSumAggregateOutputType | null
    _min: AdventureMinAggregateOutputType | null
    _max: AdventureMaxAggregateOutputType | null
  }

  type GetAdventureGroupByPayload<T extends AdventureGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AdventureGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AdventureGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AdventureGroupByOutputType[P]>
            : GetScalarType<T[P], AdventureGroupByOutputType[P]>
        }
      >
    >


  export type AdventureSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    planned_parties?: boolean
    genre_id?: boolean
    creator_id?: boolean
    created_at?: boolean
    updated_at?: boolean
    genre?: boolean | GenreDefaultArgs<ExtArgs>
    keywords?: boolean | Adventure$keywordsArgs<ExtArgs>
    _count?: boolean | AdventureCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["adventure"]>

  export type AdventureSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    planned_parties?: boolean
    genre_id?: boolean
    creator_id?: boolean
    created_at?: boolean
    updated_at?: boolean
    genre?: boolean | GenreDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["adventure"]>

  export type AdventureSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    planned_parties?: boolean
    genre_id?: boolean
    creator_id?: boolean
    created_at?: boolean
    updated_at?: boolean
    genre?: boolean | GenreDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["adventure"]>

  export type AdventureSelectScalar = {
    id?: boolean
    title?: boolean
    planned_parties?: boolean
    genre_id?: boolean
    creator_id?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type AdventureOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "planned_parties" | "genre_id" | "creator_id" | "created_at" | "updated_at", ExtArgs["result"]["adventure"]>
  export type AdventureInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    genre?: boolean | GenreDefaultArgs<ExtArgs>
    keywords?: boolean | Adventure$keywordsArgs<ExtArgs>
    _count?: boolean | AdventureCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type AdventureIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    genre?: boolean | GenreDefaultArgs<ExtArgs>
  }
  export type AdventureIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    genre?: boolean | GenreDefaultArgs<ExtArgs>
  }

  export type $AdventurePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Adventure"
    objects: {
      genre: Prisma.$GenrePayload<ExtArgs>
      keywords: Prisma.$AdventureKeywordPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      planned_parties: number
      genre_id: string
      creator_id: string
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["adventure"]>
    composites: {}
  }

  type AdventureGetPayload<S extends boolean | null | undefined | AdventureDefaultArgs> = $Result.GetResult<Prisma.$AdventurePayload, S>

  type AdventureCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AdventureFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AdventureCountAggregateInputType | true
    }

  export interface AdventureDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Adventure'], meta: { name: 'Adventure' } }
    /**
     * Find zero or one Adventure that matches the filter.
     * @param {AdventureFindUniqueArgs} args - Arguments to find a Adventure
     * @example
     * // Get one Adventure
     * const adventure = await prisma.adventure.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AdventureFindUniqueArgs>(args: SelectSubset<T, AdventureFindUniqueArgs<ExtArgs>>): Prisma__AdventureClient<$Result.GetResult<Prisma.$AdventurePayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Adventure that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AdventureFindUniqueOrThrowArgs} args - Arguments to find a Adventure
     * @example
     * // Get one Adventure
     * const adventure = await prisma.adventure.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AdventureFindUniqueOrThrowArgs>(args: SelectSubset<T, AdventureFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AdventureClient<$Result.GetResult<Prisma.$AdventurePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Adventure that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdventureFindFirstArgs} args - Arguments to find a Adventure
     * @example
     * // Get one Adventure
     * const adventure = await prisma.adventure.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AdventureFindFirstArgs>(args?: SelectSubset<T, AdventureFindFirstArgs<ExtArgs>>): Prisma__AdventureClient<$Result.GetResult<Prisma.$AdventurePayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Adventure that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdventureFindFirstOrThrowArgs} args - Arguments to find a Adventure
     * @example
     * // Get one Adventure
     * const adventure = await prisma.adventure.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AdventureFindFirstOrThrowArgs>(args?: SelectSubset<T, AdventureFindFirstOrThrowArgs<ExtArgs>>): Prisma__AdventureClient<$Result.GetResult<Prisma.$AdventurePayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Adventures that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdventureFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Adventures
     * const adventures = await prisma.adventure.findMany()
     * 
     * // Get first 10 Adventures
     * const adventures = await prisma.adventure.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const adventureWithIdOnly = await prisma.adventure.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AdventureFindManyArgs>(args?: SelectSubset<T, AdventureFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdventurePayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Adventure.
     * @param {AdventureCreateArgs} args - Arguments to create a Adventure.
     * @example
     * // Create one Adventure
     * const Adventure = await prisma.adventure.create({
     *   data: {
     *     // ... data to create a Adventure
     *   }
     * })
     * 
     */
    create<T extends AdventureCreateArgs>(args: SelectSubset<T, AdventureCreateArgs<ExtArgs>>): Prisma__AdventureClient<$Result.GetResult<Prisma.$AdventurePayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Adventures.
     * @param {AdventureCreateManyArgs} args - Arguments to create many Adventures.
     * @example
     * // Create many Adventures
     * const adventure = await prisma.adventure.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AdventureCreateManyArgs>(args?: SelectSubset<T, AdventureCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Adventures and returns the data saved in the database.
     * @param {AdventureCreateManyAndReturnArgs} args - Arguments to create many Adventures.
     * @example
     * // Create many Adventures
     * const adventure = await prisma.adventure.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Adventures and only return the `id`
     * const adventureWithIdOnly = await prisma.adventure.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AdventureCreateManyAndReturnArgs>(args?: SelectSubset<T, AdventureCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdventurePayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Adventure.
     * @param {AdventureDeleteArgs} args - Arguments to delete one Adventure.
     * @example
     * // Delete one Adventure
     * const Adventure = await prisma.adventure.delete({
     *   where: {
     *     // ... filter to delete one Adventure
     *   }
     * })
     * 
     */
    delete<T extends AdventureDeleteArgs>(args: SelectSubset<T, AdventureDeleteArgs<ExtArgs>>): Prisma__AdventureClient<$Result.GetResult<Prisma.$AdventurePayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Adventure.
     * @param {AdventureUpdateArgs} args - Arguments to update one Adventure.
     * @example
     * // Update one Adventure
     * const adventure = await prisma.adventure.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AdventureUpdateArgs>(args: SelectSubset<T, AdventureUpdateArgs<ExtArgs>>): Prisma__AdventureClient<$Result.GetResult<Prisma.$AdventurePayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Adventures.
     * @param {AdventureDeleteManyArgs} args - Arguments to filter Adventures to delete.
     * @example
     * // Delete a few Adventures
     * const { count } = await prisma.adventure.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AdventureDeleteManyArgs>(args?: SelectSubset<T, AdventureDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Adventures.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdventureUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Adventures
     * const adventure = await prisma.adventure.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AdventureUpdateManyArgs>(args: SelectSubset<T, AdventureUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Adventures and returns the data updated in the database.
     * @param {AdventureUpdateManyAndReturnArgs} args - Arguments to update many Adventures.
     * @example
     * // Update many Adventures
     * const adventure = await prisma.adventure.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Adventures and only return the `id`
     * const adventureWithIdOnly = await prisma.adventure.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AdventureUpdateManyAndReturnArgs>(args: SelectSubset<T, AdventureUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdventurePayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Adventure.
     * @param {AdventureUpsertArgs} args - Arguments to update or create a Adventure.
     * @example
     * // Update or create a Adventure
     * const adventure = await prisma.adventure.upsert({
     *   create: {
     *     // ... data to create a Adventure
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Adventure we want to update
     *   }
     * })
     */
    upsert<T extends AdventureUpsertArgs>(args: SelectSubset<T, AdventureUpsertArgs<ExtArgs>>): Prisma__AdventureClient<$Result.GetResult<Prisma.$AdventurePayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Adventures.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdventureCountArgs} args - Arguments to filter Adventures to count.
     * @example
     * // Count the number of Adventures
     * const count = await prisma.adventure.count({
     *   where: {
     *     // ... the filter for the Adventures we want to count
     *   }
     * })
    **/
    count<T extends AdventureCountArgs>(
      args?: Subset<T, AdventureCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AdventureCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Adventure.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdventureAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AdventureAggregateArgs>(args: Subset<T, AdventureAggregateArgs>): Prisma.PrismaPromise<GetAdventureAggregateType<T>>

    /**
     * Group by Adventure.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdventureGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AdventureGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AdventureGroupByArgs['orderBy'] }
        : { orderBy?: AdventureGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AdventureGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAdventureGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Adventure model
   */
  readonly fields: AdventureFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Adventure.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AdventureClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    genre<T extends GenreDefaultArgs<ExtArgs> = {}>(args?: Subset<T, GenreDefaultArgs<ExtArgs>>): Prisma__GenreClient<$Result.GetResult<Prisma.$GenrePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    keywords<T extends Adventure$keywordsArgs<ExtArgs> = {}>(args?: Subset<T, Adventure$keywordsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdventureKeywordPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Adventure model
   */ 
  interface AdventureFieldRefs {
    readonly id: FieldRef<"Adventure", 'String'>
    readonly title: FieldRef<"Adventure", 'String'>
    readonly planned_parties: FieldRef<"Adventure", 'Int'>
    readonly genre_id: FieldRef<"Adventure", 'String'>
    readonly creator_id: FieldRef<"Adventure", 'String'>
    readonly created_at: FieldRef<"Adventure", 'DateTime'>
    readonly updated_at: FieldRef<"Adventure", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Adventure findUnique
   */
  export type AdventureFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Adventure
     */
    select?: AdventureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Adventure
     */
    omit?: AdventureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdventureInclude<ExtArgs> | null
    /**
     * Filter, which Adventure to fetch.
     */
    where: AdventureWhereUniqueInput
  }

  /**
   * Adventure findUniqueOrThrow
   */
  export type AdventureFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Adventure
     */
    select?: AdventureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Adventure
     */
    omit?: AdventureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdventureInclude<ExtArgs> | null
    /**
     * Filter, which Adventure to fetch.
     */
    where: AdventureWhereUniqueInput
  }

  /**
   * Adventure findFirst
   */
  export type AdventureFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Adventure
     */
    select?: AdventureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Adventure
     */
    omit?: AdventureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdventureInclude<ExtArgs> | null
    /**
     * Filter, which Adventure to fetch.
     */
    where?: AdventureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Adventures to fetch.
     */
    orderBy?: AdventureOrderByWithRelationInput | AdventureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Adventures.
     */
    cursor?: AdventureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Adventures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Adventures.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Adventures.
     */
    distinct?: AdventureScalarFieldEnum | AdventureScalarFieldEnum[]
  }

  /**
   * Adventure findFirstOrThrow
   */
  export type AdventureFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Adventure
     */
    select?: AdventureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Adventure
     */
    omit?: AdventureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdventureInclude<ExtArgs> | null
    /**
     * Filter, which Adventure to fetch.
     */
    where?: AdventureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Adventures to fetch.
     */
    orderBy?: AdventureOrderByWithRelationInput | AdventureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Adventures.
     */
    cursor?: AdventureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Adventures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Adventures.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Adventures.
     */
    distinct?: AdventureScalarFieldEnum | AdventureScalarFieldEnum[]
  }

  /**
   * Adventure findMany
   */
  export type AdventureFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Adventure
     */
    select?: AdventureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Adventure
     */
    omit?: AdventureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdventureInclude<ExtArgs> | null
    /**
     * Filter, which Adventures to fetch.
     */
    where?: AdventureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Adventures to fetch.
     */
    orderBy?: AdventureOrderByWithRelationInput | AdventureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Adventures.
     */
    cursor?: AdventureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Adventures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Adventures.
     */
    skip?: number
    distinct?: AdventureScalarFieldEnum | AdventureScalarFieldEnum[]
  }

  /**
   * Adventure create
   */
  export type AdventureCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Adventure
     */
    select?: AdventureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Adventure
     */
    omit?: AdventureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdventureInclude<ExtArgs> | null
    /**
     * The data needed to create a Adventure.
     */
    data: XOR<AdventureCreateInput, AdventureUncheckedCreateInput>
  }

  /**
   * Adventure createMany
   */
  export type AdventureCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Adventures.
     */
    data: AdventureCreateManyInput | AdventureCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Adventure createManyAndReturn
   */
  export type AdventureCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Adventure
     */
    select?: AdventureSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Adventure
     */
    omit?: AdventureOmit<ExtArgs> | null
    /**
     * The data used to create many Adventures.
     */
    data: AdventureCreateManyInput | AdventureCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdventureIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Adventure update
   */
  export type AdventureUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Adventure
     */
    select?: AdventureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Adventure
     */
    omit?: AdventureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdventureInclude<ExtArgs> | null
    /**
     * The data needed to update a Adventure.
     */
    data: XOR<AdventureUpdateInput, AdventureUncheckedUpdateInput>
    /**
     * Choose, which Adventure to update.
     */
    where: AdventureWhereUniqueInput
  }

  /**
   * Adventure updateMany
   */
  export type AdventureUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Adventures.
     */
    data: XOR<AdventureUpdateManyMutationInput, AdventureUncheckedUpdateManyInput>
    /**
     * Filter which Adventures to update
     */
    where?: AdventureWhereInput
    /**
     * Limit how many Adventures to update.
     */
    limit?: number
  }

  /**
   * Adventure updateManyAndReturn
   */
  export type AdventureUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Adventure
     */
    select?: AdventureSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Adventure
     */
    omit?: AdventureOmit<ExtArgs> | null
    /**
     * The data used to update Adventures.
     */
    data: XOR<AdventureUpdateManyMutationInput, AdventureUncheckedUpdateManyInput>
    /**
     * Filter which Adventures to update
     */
    where?: AdventureWhereInput
    /**
     * Limit how many Adventures to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdventureIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Adventure upsert
   */
  export type AdventureUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Adventure
     */
    select?: AdventureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Adventure
     */
    omit?: AdventureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdventureInclude<ExtArgs> | null
    /**
     * The filter to search for the Adventure to update in case it exists.
     */
    where: AdventureWhereUniqueInput
    /**
     * In case the Adventure found by the `where` argument doesn't exist, create a new Adventure with this data.
     */
    create: XOR<AdventureCreateInput, AdventureUncheckedCreateInput>
    /**
     * In case the Adventure was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AdventureUpdateInput, AdventureUncheckedUpdateInput>
  }

  /**
   * Adventure delete
   */
  export type AdventureDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Adventure
     */
    select?: AdventureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Adventure
     */
    omit?: AdventureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdventureInclude<ExtArgs> | null
    /**
     * Filter which Adventure to delete.
     */
    where: AdventureWhereUniqueInput
  }

  /**
   * Adventure deleteMany
   */
  export type AdventureDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Adventures to delete
     */
    where?: AdventureWhereInput
    /**
     * Limit how many Adventures to delete.
     */
    limit?: number
  }

  /**
   * Adventure.keywords
   */
  export type Adventure$keywordsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdventureKeyword
     */
    select?: AdventureKeywordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdventureKeyword
     */
    omit?: AdventureKeywordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdventureKeywordInclude<ExtArgs> | null
    where?: AdventureKeywordWhereInput
    orderBy?: AdventureKeywordOrderByWithRelationInput | AdventureKeywordOrderByWithRelationInput[]
    cursor?: AdventureKeywordWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AdventureKeywordScalarFieldEnum | AdventureKeywordScalarFieldEnum[]
  }

  /**
   * Adventure without action
   */
  export type AdventureDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Adventure
     */
    select?: AdventureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Adventure
     */
    omit?: AdventureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdventureInclude<ExtArgs> | null
  }


  /**
   * Model Genre
   */

  export type AggregateGenre = {
    _count: GenreCountAggregateOutputType | null
    _min: GenreMinAggregateOutputType | null
    _max: GenreMaxAggregateOutputType | null
  }

  export type GenreMinAggregateOutputType = {
    id: string | null
    name: string | null
  }

  export type GenreMaxAggregateOutputType = {
    id: string | null
    name: string | null
  }

  export type GenreCountAggregateOutputType = {
    id: number
    name: number
    _all: number
  }


  export type GenreMinAggregateInputType = {
    id?: true
    name?: true
  }

  export type GenreMaxAggregateInputType = {
    id?: true
    name?: true
  }

  export type GenreCountAggregateInputType = {
    id?: true
    name?: true
    _all?: true
  }

  export type GenreAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Genre to aggregate.
     */
    where?: GenreWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Genres to fetch.
     */
    orderBy?: GenreOrderByWithRelationInput | GenreOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: GenreWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Genres from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Genres.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Genres
    **/
    _count?: true | GenreCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GenreMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GenreMaxAggregateInputType
  }

  export type GetGenreAggregateType<T extends GenreAggregateArgs> = {
        [P in keyof T & keyof AggregateGenre]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGenre[P]>
      : GetScalarType<T[P], AggregateGenre[P]>
  }




  export type GenreGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GenreWhereInput
    orderBy?: GenreOrderByWithAggregationInput | GenreOrderByWithAggregationInput[]
    by: GenreScalarFieldEnum[] | GenreScalarFieldEnum
    having?: GenreScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GenreCountAggregateInputType | true
    _min?: GenreMinAggregateInputType
    _max?: GenreMaxAggregateInputType
  }

  export type GenreGroupByOutputType = {
    id: string
    name: string
    _count: GenreCountAggregateOutputType | null
    _min: GenreMinAggregateOutputType | null
    _max: GenreMaxAggregateOutputType | null
  }

  type GetGenreGroupByPayload<T extends GenreGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GenreGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GenreGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GenreGroupByOutputType[P]>
            : GetScalarType<T[P], GenreGroupByOutputType[P]>
        }
      >
    >


  export type GenreSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    keywords?: boolean | Genre$keywordsArgs<ExtArgs>
    adventures?: boolean | Genre$adventuresArgs<ExtArgs>
    _count?: boolean | GenreCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["genre"]>

  export type GenreSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
  }, ExtArgs["result"]["genre"]>

  export type GenreSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
  }, ExtArgs["result"]["genre"]>

  export type GenreSelectScalar = {
    id?: boolean
    name?: boolean
  }

  export type GenreOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name", ExtArgs["result"]["genre"]>
  export type GenreInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    keywords?: boolean | Genre$keywordsArgs<ExtArgs>
    adventures?: boolean | Genre$adventuresArgs<ExtArgs>
    _count?: boolean | GenreCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type GenreIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type GenreIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $GenrePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Genre"
    objects: {
      keywords: Prisma.$KeywordPayload<ExtArgs>[]
      adventures: Prisma.$AdventurePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
    }, ExtArgs["result"]["genre"]>
    composites: {}
  }

  type GenreGetPayload<S extends boolean | null | undefined | GenreDefaultArgs> = $Result.GetResult<Prisma.$GenrePayload, S>

  type GenreCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<GenreFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: GenreCountAggregateInputType | true
    }

  export interface GenreDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Genre'], meta: { name: 'Genre' } }
    /**
     * Find zero or one Genre that matches the filter.
     * @param {GenreFindUniqueArgs} args - Arguments to find a Genre
     * @example
     * // Get one Genre
     * const genre = await prisma.genre.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends GenreFindUniqueArgs>(args: SelectSubset<T, GenreFindUniqueArgs<ExtArgs>>): Prisma__GenreClient<$Result.GetResult<Prisma.$GenrePayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Genre that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {GenreFindUniqueOrThrowArgs} args - Arguments to find a Genre
     * @example
     * // Get one Genre
     * const genre = await prisma.genre.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends GenreFindUniqueOrThrowArgs>(args: SelectSubset<T, GenreFindUniqueOrThrowArgs<ExtArgs>>): Prisma__GenreClient<$Result.GetResult<Prisma.$GenrePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Genre that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GenreFindFirstArgs} args - Arguments to find a Genre
     * @example
     * // Get one Genre
     * const genre = await prisma.genre.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends GenreFindFirstArgs>(args?: SelectSubset<T, GenreFindFirstArgs<ExtArgs>>): Prisma__GenreClient<$Result.GetResult<Prisma.$GenrePayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Genre that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GenreFindFirstOrThrowArgs} args - Arguments to find a Genre
     * @example
     * // Get one Genre
     * const genre = await prisma.genre.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends GenreFindFirstOrThrowArgs>(args?: SelectSubset<T, GenreFindFirstOrThrowArgs<ExtArgs>>): Prisma__GenreClient<$Result.GetResult<Prisma.$GenrePayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Genres that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GenreFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Genres
     * const genres = await prisma.genre.findMany()
     * 
     * // Get first 10 Genres
     * const genres = await prisma.genre.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const genreWithIdOnly = await prisma.genre.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends GenreFindManyArgs>(args?: SelectSubset<T, GenreFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GenrePayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Genre.
     * @param {GenreCreateArgs} args - Arguments to create a Genre.
     * @example
     * // Create one Genre
     * const Genre = await prisma.genre.create({
     *   data: {
     *     // ... data to create a Genre
     *   }
     * })
     * 
     */
    create<T extends GenreCreateArgs>(args: SelectSubset<T, GenreCreateArgs<ExtArgs>>): Prisma__GenreClient<$Result.GetResult<Prisma.$GenrePayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Genres.
     * @param {GenreCreateManyArgs} args - Arguments to create many Genres.
     * @example
     * // Create many Genres
     * const genre = await prisma.genre.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends GenreCreateManyArgs>(args?: SelectSubset<T, GenreCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Genres and returns the data saved in the database.
     * @param {GenreCreateManyAndReturnArgs} args - Arguments to create many Genres.
     * @example
     * // Create many Genres
     * const genre = await prisma.genre.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Genres and only return the `id`
     * const genreWithIdOnly = await prisma.genre.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends GenreCreateManyAndReturnArgs>(args?: SelectSubset<T, GenreCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GenrePayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Genre.
     * @param {GenreDeleteArgs} args - Arguments to delete one Genre.
     * @example
     * // Delete one Genre
     * const Genre = await prisma.genre.delete({
     *   where: {
     *     // ... filter to delete one Genre
     *   }
     * })
     * 
     */
    delete<T extends GenreDeleteArgs>(args: SelectSubset<T, GenreDeleteArgs<ExtArgs>>): Prisma__GenreClient<$Result.GetResult<Prisma.$GenrePayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Genre.
     * @param {GenreUpdateArgs} args - Arguments to update one Genre.
     * @example
     * // Update one Genre
     * const genre = await prisma.genre.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends GenreUpdateArgs>(args: SelectSubset<T, GenreUpdateArgs<ExtArgs>>): Prisma__GenreClient<$Result.GetResult<Prisma.$GenrePayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Genres.
     * @param {GenreDeleteManyArgs} args - Arguments to filter Genres to delete.
     * @example
     * // Delete a few Genres
     * const { count } = await prisma.genre.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends GenreDeleteManyArgs>(args?: SelectSubset<T, GenreDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Genres.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GenreUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Genres
     * const genre = await prisma.genre.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends GenreUpdateManyArgs>(args: SelectSubset<T, GenreUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Genres and returns the data updated in the database.
     * @param {GenreUpdateManyAndReturnArgs} args - Arguments to update many Genres.
     * @example
     * // Update many Genres
     * const genre = await prisma.genre.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Genres and only return the `id`
     * const genreWithIdOnly = await prisma.genre.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends GenreUpdateManyAndReturnArgs>(args: SelectSubset<T, GenreUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GenrePayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Genre.
     * @param {GenreUpsertArgs} args - Arguments to update or create a Genre.
     * @example
     * // Update or create a Genre
     * const genre = await prisma.genre.upsert({
     *   create: {
     *     // ... data to create a Genre
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Genre we want to update
     *   }
     * })
     */
    upsert<T extends GenreUpsertArgs>(args: SelectSubset<T, GenreUpsertArgs<ExtArgs>>): Prisma__GenreClient<$Result.GetResult<Prisma.$GenrePayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Genres.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GenreCountArgs} args - Arguments to filter Genres to count.
     * @example
     * // Count the number of Genres
     * const count = await prisma.genre.count({
     *   where: {
     *     // ... the filter for the Genres we want to count
     *   }
     * })
    **/
    count<T extends GenreCountArgs>(
      args?: Subset<T, GenreCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GenreCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Genre.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GenreAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GenreAggregateArgs>(args: Subset<T, GenreAggregateArgs>): Prisma.PrismaPromise<GetGenreAggregateType<T>>

    /**
     * Group by Genre.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GenreGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GenreGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GenreGroupByArgs['orderBy'] }
        : { orderBy?: GenreGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GenreGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGenreGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Genre model
   */
  readonly fields: GenreFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Genre.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__GenreClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    keywords<T extends Genre$keywordsArgs<ExtArgs> = {}>(args?: Subset<T, Genre$keywordsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$KeywordPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    adventures<T extends Genre$adventuresArgs<ExtArgs> = {}>(args?: Subset<T, Genre$adventuresArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdventurePayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Genre model
   */ 
  interface GenreFieldRefs {
    readonly id: FieldRef<"Genre", 'String'>
    readonly name: FieldRef<"Genre", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Genre findUnique
   */
  export type GenreFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Genre
     */
    select?: GenreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Genre
     */
    omit?: GenreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GenreInclude<ExtArgs> | null
    /**
     * Filter, which Genre to fetch.
     */
    where: GenreWhereUniqueInput
  }

  /**
   * Genre findUniqueOrThrow
   */
  export type GenreFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Genre
     */
    select?: GenreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Genre
     */
    omit?: GenreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GenreInclude<ExtArgs> | null
    /**
     * Filter, which Genre to fetch.
     */
    where: GenreWhereUniqueInput
  }

  /**
   * Genre findFirst
   */
  export type GenreFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Genre
     */
    select?: GenreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Genre
     */
    omit?: GenreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GenreInclude<ExtArgs> | null
    /**
     * Filter, which Genre to fetch.
     */
    where?: GenreWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Genres to fetch.
     */
    orderBy?: GenreOrderByWithRelationInput | GenreOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Genres.
     */
    cursor?: GenreWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Genres from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Genres.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Genres.
     */
    distinct?: GenreScalarFieldEnum | GenreScalarFieldEnum[]
  }

  /**
   * Genre findFirstOrThrow
   */
  export type GenreFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Genre
     */
    select?: GenreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Genre
     */
    omit?: GenreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GenreInclude<ExtArgs> | null
    /**
     * Filter, which Genre to fetch.
     */
    where?: GenreWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Genres to fetch.
     */
    orderBy?: GenreOrderByWithRelationInput | GenreOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Genres.
     */
    cursor?: GenreWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Genres from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Genres.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Genres.
     */
    distinct?: GenreScalarFieldEnum | GenreScalarFieldEnum[]
  }

  /**
   * Genre findMany
   */
  export type GenreFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Genre
     */
    select?: GenreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Genre
     */
    omit?: GenreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GenreInclude<ExtArgs> | null
    /**
     * Filter, which Genres to fetch.
     */
    where?: GenreWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Genres to fetch.
     */
    orderBy?: GenreOrderByWithRelationInput | GenreOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Genres.
     */
    cursor?: GenreWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Genres from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Genres.
     */
    skip?: number
    distinct?: GenreScalarFieldEnum | GenreScalarFieldEnum[]
  }

  /**
   * Genre create
   */
  export type GenreCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Genre
     */
    select?: GenreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Genre
     */
    omit?: GenreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GenreInclude<ExtArgs> | null
    /**
     * The data needed to create a Genre.
     */
    data: XOR<GenreCreateInput, GenreUncheckedCreateInput>
  }

  /**
   * Genre createMany
   */
  export type GenreCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Genres.
     */
    data: GenreCreateManyInput | GenreCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Genre createManyAndReturn
   */
  export type GenreCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Genre
     */
    select?: GenreSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Genre
     */
    omit?: GenreOmit<ExtArgs> | null
    /**
     * The data used to create many Genres.
     */
    data: GenreCreateManyInput | GenreCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Genre update
   */
  export type GenreUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Genre
     */
    select?: GenreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Genre
     */
    omit?: GenreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GenreInclude<ExtArgs> | null
    /**
     * The data needed to update a Genre.
     */
    data: XOR<GenreUpdateInput, GenreUncheckedUpdateInput>
    /**
     * Choose, which Genre to update.
     */
    where: GenreWhereUniqueInput
  }

  /**
   * Genre updateMany
   */
  export type GenreUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Genres.
     */
    data: XOR<GenreUpdateManyMutationInput, GenreUncheckedUpdateManyInput>
    /**
     * Filter which Genres to update
     */
    where?: GenreWhereInput
    /**
     * Limit how many Genres to update.
     */
    limit?: number
  }

  /**
   * Genre updateManyAndReturn
   */
  export type GenreUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Genre
     */
    select?: GenreSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Genre
     */
    omit?: GenreOmit<ExtArgs> | null
    /**
     * The data used to update Genres.
     */
    data: XOR<GenreUpdateManyMutationInput, GenreUncheckedUpdateManyInput>
    /**
     * Filter which Genres to update
     */
    where?: GenreWhereInput
    /**
     * Limit how many Genres to update.
     */
    limit?: number
  }

  /**
   * Genre upsert
   */
  export type GenreUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Genre
     */
    select?: GenreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Genre
     */
    omit?: GenreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GenreInclude<ExtArgs> | null
    /**
     * The filter to search for the Genre to update in case it exists.
     */
    where: GenreWhereUniqueInput
    /**
     * In case the Genre found by the `where` argument doesn't exist, create a new Genre with this data.
     */
    create: XOR<GenreCreateInput, GenreUncheckedCreateInput>
    /**
     * In case the Genre was found with the provided `where` argument, update it with this data.
     */
    update: XOR<GenreUpdateInput, GenreUncheckedUpdateInput>
  }

  /**
   * Genre delete
   */
  export type GenreDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Genre
     */
    select?: GenreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Genre
     */
    omit?: GenreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GenreInclude<ExtArgs> | null
    /**
     * Filter which Genre to delete.
     */
    where: GenreWhereUniqueInput
  }

  /**
   * Genre deleteMany
   */
  export type GenreDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Genres to delete
     */
    where?: GenreWhereInput
    /**
     * Limit how many Genres to delete.
     */
    limit?: number
  }

  /**
   * Genre.keywords
   */
  export type Genre$keywordsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Keyword
     */
    select?: KeywordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Keyword
     */
    omit?: KeywordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KeywordInclude<ExtArgs> | null
    where?: KeywordWhereInput
    orderBy?: KeywordOrderByWithRelationInput | KeywordOrderByWithRelationInput[]
    cursor?: KeywordWhereUniqueInput
    take?: number
    skip?: number
    distinct?: KeywordScalarFieldEnum | KeywordScalarFieldEnum[]
  }

  /**
   * Genre.adventures
   */
  export type Genre$adventuresArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Adventure
     */
    select?: AdventureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Adventure
     */
    omit?: AdventureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdventureInclude<ExtArgs> | null
    where?: AdventureWhereInput
    orderBy?: AdventureOrderByWithRelationInput | AdventureOrderByWithRelationInput[]
    cursor?: AdventureWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AdventureScalarFieldEnum | AdventureScalarFieldEnum[]
  }

  /**
   * Genre without action
   */
  export type GenreDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Genre
     */
    select?: GenreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Genre
     */
    omit?: GenreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GenreInclude<ExtArgs> | null
  }


  /**
   * Model Keyword
   */

  export type AggregateKeyword = {
    _count: KeywordCountAggregateOutputType | null
    _min: KeywordMinAggregateOutputType | null
    _max: KeywordMaxAggregateOutputType | null
  }

  export type KeywordMinAggregateOutputType = {
    id: string | null
    name: string | null
    genre_id: string | null
  }

  export type KeywordMaxAggregateOutputType = {
    id: string | null
    name: string | null
    genre_id: string | null
  }

  export type KeywordCountAggregateOutputType = {
    id: number
    name: number
    genre_id: number
    _all: number
  }


  export type KeywordMinAggregateInputType = {
    id?: true
    name?: true
    genre_id?: true
  }

  export type KeywordMaxAggregateInputType = {
    id?: true
    name?: true
    genre_id?: true
  }

  export type KeywordCountAggregateInputType = {
    id?: true
    name?: true
    genre_id?: true
    _all?: true
  }

  export type KeywordAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Keyword to aggregate.
     */
    where?: KeywordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Keywords to fetch.
     */
    orderBy?: KeywordOrderByWithRelationInput | KeywordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: KeywordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Keywords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Keywords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Keywords
    **/
    _count?: true | KeywordCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: KeywordMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: KeywordMaxAggregateInputType
  }

  export type GetKeywordAggregateType<T extends KeywordAggregateArgs> = {
        [P in keyof T & keyof AggregateKeyword]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateKeyword[P]>
      : GetScalarType<T[P], AggregateKeyword[P]>
  }




  export type KeywordGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: KeywordWhereInput
    orderBy?: KeywordOrderByWithAggregationInput | KeywordOrderByWithAggregationInput[]
    by: KeywordScalarFieldEnum[] | KeywordScalarFieldEnum
    having?: KeywordScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: KeywordCountAggregateInputType | true
    _min?: KeywordMinAggregateInputType
    _max?: KeywordMaxAggregateInputType
  }

  export type KeywordGroupByOutputType = {
    id: string
    name: string
    genre_id: string
    _count: KeywordCountAggregateOutputType | null
    _min: KeywordMinAggregateOutputType | null
    _max: KeywordMaxAggregateOutputType | null
  }

  type GetKeywordGroupByPayload<T extends KeywordGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<KeywordGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof KeywordGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], KeywordGroupByOutputType[P]>
            : GetScalarType<T[P], KeywordGroupByOutputType[P]>
        }
      >
    >


  export type KeywordSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    genre_id?: boolean
    genre?: boolean | GenreDefaultArgs<ExtArgs>
    adventures?: boolean | Keyword$adventuresArgs<ExtArgs>
    _count?: boolean | KeywordCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["keyword"]>

  export type KeywordSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    genre_id?: boolean
    genre?: boolean | GenreDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["keyword"]>

  export type KeywordSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    genre_id?: boolean
    genre?: boolean | GenreDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["keyword"]>

  export type KeywordSelectScalar = {
    id?: boolean
    name?: boolean
    genre_id?: boolean
  }

  export type KeywordOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "genre_id", ExtArgs["result"]["keyword"]>
  export type KeywordInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    genre?: boolean | GenreDefaultArgs<ExtArgs>
    adventures?: boolean | Keyword$adventuresArgs<ExtArgs>
    _count?: boolean | KeywordCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type KeywordIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    genre?: boolean | GenreDefaultArgs<ExtArgs>
  }
  export type KeywordIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    genre?: boolean | GenreDefaultArgs<ExtArgs>
  }

  export type $KeywordPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Keyword"
    objects: {
      genre: Prisma.$GenrePayload<ExtArgs>
      adventures: Prisma.$AdventureKeywordPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      genre_id: string
    }, ExtArgs["result"]["keyword"]>
    composites: {}
  }

  type KeywordGetPayload<S extends boolean | null | undefined | KeywordDefaultArgs> = $Result.GetResult<Prisma.$KeywordPayload, S>

  type KeywordCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<KeywordFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: KeywordCountAggregateInputType | true
    }

  export interface KeywordDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Keyword'], meta: { name: 'Keyword' } }
    /**
     * Find zero or one Keyword that matches the filter.
     * @param {KeywordFindUniqueArgs} args - Arguments to find a Keyword
     * @example
     * // Get one Keyword
     * const keyword = await prisma.keyword.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends KeywordFindUniqueArgs>(args: SelectSubset<T, KeywordFindUniqueArgs<ExtArgs>>): Prisma__KeywordClient<$Result.GetResult<Prisma.$KeywordPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Keyword that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {KeywordFindUniqueOrThrowArgs} args - Arguments to find a Keyword
     * @example
     * // Get one Keyword
     * const keyword = await prisma.keyword.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends KeywordFindUniqueOrThrowArgs>(args: SelectSubset<T, KeywordFindUniqueOrThrowArgs<ExtArgs>>): Prisma__KeywordClient<$Result.GetResult<Prisma.$KeywordPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Keyword that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KeywordFindFirstArgs} args - Arguments to find a Keyword
     * @example
     * // Get one Keyword
     * const keyword = await prisma.keyword.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends KeywordFindFirstArgs>(args?: SelectSubset<T, KeywordFindFirstArgs<ExtArgs>>): Prisma__KeywordClient<$Result.GetResult<Prisma.$KeywordPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Keyword that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KeywordFindFirstOrThrowArgs} args - Arguments to find a Keyword
     * @example
     * // Get one Keyword
     * const keyword = await prisma.keyword.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends KeywordFindFirstOrThrowArgs>(args?: SelectSubset<T, KeywordFindFirstOrThrowArgs<ExtArgs>>): Prisma__KeywordClient<$Result.GetResult<Prisma.$KeywordPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Keywords that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KeywordFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Keywords
     * const keywords = await prisma.keyword.findMany()
     * 
     * // Get first 10 Keywords
     * const keywords = await prisma.keyword.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const keywordWithIdOnly = await prisma.keyword.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends KeywordFindManyArgs>(args?: SelectSubset<T, KeywordFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$KeywordPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Keyword.
     * @param {KeywordCreateArgs} args - Arguments to create a Keyword.
     * @example
     * // Create one Keyword
     * const Keyword = await prisma.keyword.create({
     *   data: {
     *     // ... data to create a Keyword
     *   }
     * })
     * 
     */
    create<T extends KeywordCreateArgs>(args: SelectSubset<T, KeywordCreateArgs<ExtArgs>>): Prisma__KeywordClient<$Result.GetResult<Prisma.$KeywordPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Keywords.
     * @param {KeywordCreateManyArgs} args - Arguments to create many Keywords.
     * @example
     * // Create many Keywords
     * const keyword = await prisma.keyword.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends KeywordCreateManyArgs>(args?: SelectSubset<T, KeywordCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Keywords and returns the data saved in the database.
     * @param {KeywordCreateManyAndReturnArgs} args - Arguments to create many Keywords.
     * @example
     * // Create many Keywords
     * const keyword = await prisma.keyword.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Keywords and only return the `id`
     * const keywordWithIdOnly = await prisma.keyword.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends KeywordCreateManyAndReturnArgs>(args?: SelectSubset<T, KeywordCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$KeywordPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Keyword.
     * @param {KeywordDeleteArgs} args - Arguments to delete one Keyword.
     * @example
     * // Delete one Keyword
     * const Keyword = await prisma.keyword.delete({
     *   where: {
     *     // ... filter to delete one Keyword
     *   }
     * })
     * 
     */
    delete<T extends KeywordDeleteArgs>(args: SelectSubset<T, KeywordDeleteArgs<ExtArgs>>): Prisma__KeywordClient<$Result.GetResult<Prisma.$KeywordPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Keyword.
     * @param {KeywordUpdateArgs} args - Arguments to update one Keyword.
     * @example
     * // Update one Keyword
     * const keyword = await prisma.keyword.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends KeywordUpdateArgs>(args: SelectSubset<T, KeywordUpdateArgs<ExtArgs>>): Prisma__KeywordClient<$Result.GetResult<Prisma.$KeywordPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Keywords.
     * @param {KeywordDeleteManyArgs} args - Arguments to filter Keywords to delete.
     * @example
     * // Delete a few Keywords
     * const { count } = await prisma.keyword.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends KeywordDeleteManyArgs>(args?: SelectSubset<T, KeywordDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Keywords.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KeywordUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Keywords
     * const keyword = await prisma.keyword.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends KeywordUpdateManyArgs>(args: SelectSubset<T, KeywordUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Keywords and returns the data updated in the database.
     * @param {KeywordUpdateManyAndReturnArgs} args - Arguments to update many Keywords.
     * @example
     * // Update many Keywords
     * const keyword = await prisma.keyword.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Keywords and only return the `id`
     * const keywordWithIdOnly = await prisma.keyword.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends KeywordUpdateManyAndReturnArgs>(args: SelectSubset<T, KeywordUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$KeywordPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Keyword.
     * @param {KeywordUpsertArgs} args - Arguments to update or create a Keyword.
     * @example
     * // Update or create a Keyword
     * const keyword = await prisma.keyword.upsert({
     *   create: {
     *     // ... data to create a Keyword
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Keyword we want to update
     *   }
     * })
     */
    upsert<T extends KeywordUpsertArgs>(args: SelectSubset<T, KeywordUpsertArgs<ExtArgs>>): Prisma__KeywordClient<$Result.GetResult<Prisma.$KeywordPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Keywords.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KeywordCountArgs} args - Arguments to filter Keywords to count.
     * @example
     * // Count the number of Keywords
     * const count = await prisma.keyword.count({
     *   where: {
     *     // ... the filter for the Keywords we want to count
     *   }
     * })
    **/
    count<T extends KeywordCountArgs>(
      args?: Subset<T, KeywordCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], KeywordCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Keyword.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KeywordAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends KeywordAggregateArgs>(args: Subset<T, KeywordAggregateArgs>): Prisma.PrismaPromise<GetKeywordAggregateType<T>>

    /**
     * Group by Keyword.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KeywordGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends KeywordGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: KeywordGroupByArgs['orderBy'] }
        : { orderBy?: KeywordGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, KeywordGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetKeywordGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Keyword model
   */
  readonly fields: KeywordFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Keyword.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__KeywordClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    genre<T extends GenreDefaultArgs<ExtArgs> = {}>(args?: Subset<T, GenreDefaultArgs<ExtArgs>>): Prisma__GenreClient<$Result.GetResult<Prisma.$GenrePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    adventures<T extends Keyword$adventuresArgs<ExtArgs> = {}>(args?: Subset<T, Keyword$adventuresArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdventureKeywordPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Keyword model
   */ 
  interface KeywordFieldRefs {
    readonly id: FieldRef<"Keyword", 'String'>
    readonly name: FieldRef<"Keyword", 'String'>
    readonly genre_id: FieldRef<"Keyword", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Keyword findUnique
   */
  export type KeywordFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Keyword
     */
    select?: KeywordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Keyword
     */
    omit?: KeywordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KeywordInclude<ExtArgs> | null
    /**
     * Filter, which Keyword to fetch.
     */
    where: KeywordWhereUniqueInput
  }

  /**
   * Keyword findUniqueOrThrow
   */
  export type KeywordFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Keyword
     */
    select?: KeywordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Keyword
     */
    omit?: KeywordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KeywordInclude<ExtArgs> | null
    /**
     * Filter, which Keyword to fetch.
     */
    where: KeywordWhereUniqueInput
  }

  /**
   * Keyword findFirst
   */
  export type KeywordFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Keyword
     */
    select?: KeywordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Keyword
     */
    omit?: KeywordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KeywordInclude<ExtArgs> | null
    /**
     * Filter, which Keyword to fetch.
     */
    where?: KeywordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Keywords to fetch.
     */
    orderBy?: KeywordOrderByWithRelationInput | KeywordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Keywords.
     */
    cursor?: KeywordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Keywords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Keywords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Keywords.
     */
    distinct?: KeywordScalarFieldEnum | KeywordScalarFieldEnum[]
  }

  /**
   * Keyword findFirstOrThrow
   */
  export type KeywordFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Keyword
     */
    select?: KeywordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Keyword
     */
    omit?: KeywordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KeywordInclude<ExtArgs> | null
    /**
     * Filter, which Keyword to fetch.
     */
    where?: KeywordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Keywords to fetch.
     */
    orderBy?: KeywordOrderByWithRelationInput | KeywordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Keywords.
     */
    cursor?: KeywordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Keywords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Keywords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Keywords.
     */
    distinct?: KeywordScalarFieldEnum | KeywordScalarFieldEnum[]
  }

  /**
   * Keyword findMany
   */
  export type KeywordFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Keyword
     */
    select?: KeywordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Keyword
     */
    omit?: KeywordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KeywordInclude<ExtArgs> | null
    /**
     * Filter, which Keywords to fetch.
     */
    where?: KeywordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Keywords to fetch.
     */
    orderBy?: KeywordOrderByWithRelationInput | KeywordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Keywords.
     */
    cursor?: KeywordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Keywords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Keywords.
     */
    skip?: number
    distinct?: KeywordScalarFieldEnum | KeywordScalarFieldEnum[]
  }

  /**
   * Keyword create
   */
  export type KeywordCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Keyword
     */
    select?: KeywordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Keyword
     */
    omit?: KeywordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KeywordInclude<ExtArgs> | null
    /**
     * The data needed to create a Keyword.
     */
    data: XOR<KeywordCreateInput, KeywordUncheckedCreateInput>
  }

  /**
   * Keyword createMany
   */
  export type KeywordCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Keywords.
     */
    data: KeywordCreateManyInput | KeywordCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Keyword createManyAndReturn
   */
  export type KeywordCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Keyword
     */
    select?: KeywordSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Keyword
     */
    omit?: KeywordOmit<ExtArgs> | null
    /**
     * The data used to create many Keywords.
     */
    data: KeywordCreateManyInput | KeywordCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KeywordIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Keyword update
   */
  export type KeywordUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Keyword
     */
    select?: KeywordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Keyword
     */
    omit?: KeywordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KeywordInclude<ExtArgs> | null
    /**
     * The data needed to update a Keyword.
     */
    data: XOR<KeywordUpdateInput, KeywordUncheckedUpdateInput>
    /**
     * Choose, which Keyword to update.
     */
    where: KeywordWhereUniqueInput
  }

  /**
   * Keyword updateMany
   */
  export type KeywordUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Keywords.
     */
    data: XOR<KeywordUpdateManyMutationInput, KeywordUncheckedUpdateManyInput>
    /**
     * Filter which Keywords to update
     */
    where?: KeywordWhereInput
    /**
     * Limit how many Keywords to update.
     */
    limit?: number
  }

  /**
   * Keyword updateManyAndReturn
   */
  export type KeywordUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Keyword
     */
    select?: KeywordSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Keyword
     */
    omit?: KeywordOmit<ExtArgs> | null
    /**
     * The data used to update Keywords.
     */
    data: XOR<KeywordUpdateManyMutationInput, KeywordUncheckedUpdateManyInput>
    /**
     * Filter which Keywords to update
     */
    where?: KeywordWhereInput
    /**
     * Limit how many Keywords to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KeywordIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Keyword upsert
   */
  export type KeywordUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Keyword
     */
    select?: KeywordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Keyword
     */
    omit?: KeywordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KeywordInclude<ExtArgs> | null
    /**
     * The filter to search for the Keyword to update in case it exists.
     */
    where: KeywordWhereUniqueInput
    /**
     * In case the Keyword found by the `where` argument doesn't exist, create a new Keyword with this data.
     */
    create: XOR<KeywordCreateInput, KeywordUncheckedCreateInput>
    /**
     * In case the Keyword was found with the provided `where` argument, update it with this data.
     */
    update: XOR<KeywordUpdateInput, KeywordUncheckedUpdateInput>
  }

  /**
   * Keyword delete
   */
  export type KeywordDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Keyword
     */
    select?: KeywordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Keyword
     */
    omit?: KeywordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KeywordInclude<ExtArgs> | null
    /**
     * Filter which Keyword to delete.
     */
    where: KeywordWhereUniqueInput
  }

  /**
   * Keyword deleteMany
   */
  export type KeywordDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Keywords to delete
     */
    where?: KeywordWhereInput
    /**
     * Limit how many Keywords to delete.
     */
    limit?: number
  }

  /**
   * Keyword.adventures
   */
  export type Keyword$adventuresArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdventureKeyword
     */
    select?: AdventureKeywordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdventureKeyword
     */
    omit?: AdventureKeywordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdventureKeywordInclude<ExtArgs> | null
    where?: AdventureKeywordWhereInput
    orderBy?: AdventureKeywordOrderByWithRelationInput | AdventureKeywordOrderByWithRelationInput[]
    cursor?: AdventureKeywordWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AdventureKeywordScalarFieldEnum | AdventureKeywordScalarFieldEnum[]
  }

  /**
   * Keyword without action
   */
  export type KeywordDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Keyword
     */
    select?: KeywordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Keyword
     */
    omit?: KeywordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KeywordInclude<ExtArgs> | null
  }


  /**
   * Model AdventureKeyword
   */

  export type AggregateAdventureKeyword = {
    _count: AdventureKeywordCountAggregateOutputType | null
    _min: AdventureKeywordMinAggregateOutputType | null
    _max: AdventureKeywordMaxAggregateOutputType | null
  }

  export type AdventureKeywordMinAggregateOutputType = {
    adventure_id: string | null
    keyword_id: string | null
  }

  export type AdventureKeywordMaxAggregateOutputType = {
    adventure_id: string | null
    keyword_id: string | null
  }

  export type AdventureKeywordCountAggregateOutputType = {
    adventure_id: number
    keyword_id: number
    _all: number
  }


  export type AdventureKeywordMinAggregateInputType = {
    adventure_id?: true
    keyword_id?: true
  }

  export type AdventureKeywordMaxAggregateInputType = {
    adventure_id?: true
    keyword_id?: true
  }

  export type AdventureKeywordCountAggregateInputType = {
    adventure_id?: true
    keyword_id?: true
    _all?: true
  }

  export type AdventureKeywordAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AdventureKeyword to aggregate.
     */
    where?: AdventureKeywordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdventureKeywords to fetch.
     */
    orderBy?: AdventureKeywordOrderByWithRelationInput | AdventureKeywordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AdventureKeywordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdventureKeywords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdventureKeywords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AdventureKeywords
    **/
    _count?: true | AdventureKeywordCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AdventureKeywordMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AdventureKeywordMaxAggregateInputType
  }

  export type GetAdventureKeywordAggregateType<T extends AdventureKeywordAggregateArgs> = {
        [P in keyof T & keyof AggregateAdventureKeyword]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAdventureKeyword[P]>
      : GetScalarType<T[P], AggregateAdventureKeyword[P]>
  }




  export type AdventureKeywordGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdventureKeywordWhereInput
    orderBy?: AdventureKeywordOrderByWithAggregationInput | AdventureKeywordOrderByWithAggregationInput[]
    by: AdventureKeywordScalarFieldEnum[] | AdventureKeywordScalarFieldEnum
    having?: AdventureKeywordScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AdventureKeywordCountAggregateInputType | true
    _min?: AdventureKeywordMinAggregateInputType
    _max?: AdventureKeywordMaxAggregateInputType
  }

  export type AdventureKeywordGroupByOutputType = {
    adventure_id: string
    keyword_id: string
    _count: AdventureKeywordCountAggregateOutputType | null
    _min: AdventureKeywordMinAggregateOutputType | null
    _max: AdventureKeywordMaxAggregateOutputType | null
  }

  type GetAdventureKeywordGroupByPayload<T extends AdventureKeywordGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AdventureKeywordGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AdventureKeywordGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AdventureKeywordGroupByOutputType[P]>
            : GetScalarType<T[P], AdventureKeywordGroupByOutputType[P]>
        }
      >
    >


  export type AdventureKeywordSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    adventure_id?: boolean
    keyword_id?: boolean
    adventure?: boolean | AdventureDefaultArgs<ExtArgs>
    keyword?: boolean | KeywordDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["adventureKeyword"]>

  export type AdventureKeywordSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    adventure_id?: boolean
    keyword_id?: boolean
    adventure?: boolean | AdventureDefaultArgs<ExtArgs>
    keyword?: boolean | KeywordDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["adventureKeyword"]>

  export type AdventureKeywordSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    adventure_id?: boolean
    keyword_id?: boolean
    adventure?: boolean | AdventureDefaultArgs<ExtArgs>
    keyword?: boolean | KeywordDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["adventureKeyword"]>

  export type AdventureKeywordSelectScalar = {
    adventure_id?: boolean
    keyword_id?: boolean
  }

  export type AdventureKeywordOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"adventure_id" | "keyword_id", ExtArgs["result"]["adventureKeyword"]>
  export type AdventureKeywordInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    adventure?: boolean | AdventureDefaultArgs<ExtArgs>
    keyword?: boolean | KeywordDefaultArgs<ExtArgs>
  }
  export type AdventureKeywordIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    adventure?: boolean | AdventureDefaultArgs<ExtArgs>
    keyword?: boolean | KeywordDefaultArgs<ExtArgs>
  }
  export type AdventureKeywordIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    adventure?: boolean | AdventureDefaultArgs<ExtArgs>
    keyword?: boolean | KeywordDefaultArgs<ExtArgs>
  }

  export type $AdventureKeywordPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AdventureKeyword"
    objects: {
      adventure: Prisma.$AdventurePayload<ExtArgs>
      keyword: Prisma.$KeywordPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      adventure_id: string
      keyword_id: string
    }, ExtArgs["result"]["adventureKeyword"]>
    composites: {}
  }

  type AdventureKeywordGetPayload<S extends boolean | null | undefined | AdventureKeywordDefaultArgs> = $Result.GetResult<Prisma.$AdventureKeywordPayload, S>

  type AdventureKeywordCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AdventureKeywordFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AdventureKeywordCountAggregateInputType | true
    }

  export interface AdventureKeywordDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AdventureKeyword'], meta: { name: 'AdventureKeyword' } }
    /**
     * Find zero or one AdventureKeyword that matches the filter.
     * @param {AdventureKeywordFindUniqueArgs} args - Arguments to find a AdventureKeyword
     * @example
     * // Get one AdventureKeyword
     * const adventureKeyword = await prisma.adventureKeyword.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AdventureKeywordFindUniqueArgs>(args: SelectSubset<T, AdventureKeywordFindUniqueArgs<ExtArgs>>): Prisma__AdventureKeywordClient<$Result.GetResult<Prisma.$AdventureKeywordPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one AdventureKeyword that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AdventureKeywordFindUniqueOrThrowArgs} args - Arguments to find a AdventureKeyword
     * @example
     * // Get one AdventureKeyword
     * const adventureKeyword = await prisma.adventureKeyword.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AdventureKeywordFindUniqueOrThrowArgs>(args: SelectSubset<T, AdventureKeywordFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AdventureKeywordClient<$Result.GetResult<Prisma.$AdventureKeywordPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first AdventureKeyword that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdventureKeywordFindFirstArgs} args - Arguments to find a AdventureKeyword
     * @example
     * // Get one AdventureKeyword
     * const adventureKeyword = await prisma.adventureKeyword.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AdventureKeywordFindFirstArgs>(args?: SelectSubset<T, AdventureKeywordFindFirstArgs<ExtArgs>>): Prisma__AdventureKeywordClient<$Result.GetResult<Prisma.$AdventureKeywordPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first AdventureKeyword that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdventureKeywordFindFirstOrThrowArgs} args - Arguments to find a AdventureKeyword
     * @example
     * // Get one AdventureKeyword
     * const adventureKeyword = await prisma.adventureKeyword.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AdventureKeywordFindFirstOrThrowArgs>(args?: SelectSubset<T, AdventureKeywordFindFirstOrThrowArgs<ExtArgs>>): Prisma__AdventureKeywordClient<$Result.GetResult<Prisma.$AdventureKeywordPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more AdventureKeywords that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdventureKeywordFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AdventureKeywords
     * const adventureKeywords = await prisma.adventureKeyword.findMany()
     * 
     * // Get first 10 AdventureKeywords
     * const adventureKeywords = await prisma.adventureKeyword.findMany({ take: 10 })
     * 
     * // Only select the `adventure_id`
     * const adventureKeywordWithAdventure_idOnly = await prisma.adventureKeyword.findMany({ select: { adventure_id: true } })
     * 
     */
    findMany<T extends AdventureKeywordFindManyArgs>(args?: SelectSubset<T, AdventureKeywordFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdventureKeywordPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a AdventureKeyword.
     * @param {AdventureKeywordCreateArgs} args - Arguments to create a AdventureKeyword.
     * @example
     * // Create one AdventureKeyword
     * const AdventureKeyword = await prisma.adventureKeyword.create({
     *   data: {
     *     // ... data to create a AdventureKeyword
     *   }
     * })
     * 
     */
    create<T extends AdventureKeywordCreateArgs>(args: SelectSubset<T, AdventureKeywordCreateArgs<ExtArgs>>): Prisma__AdventureKeywordClient<$Result.GetResult<Prisma.$AdventureKeywordPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many AdventureKeywords.
     * @param {AdventureKeywordCreateManyArgs} args - Arguments to create many AdventureKeywords.
     * @example
     * // Create many AdventureKeywords
     * const adventureKeyword = await prisma.adventureKeyword.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AdventureKeywordCreateManyArgs>(args?: SelectSubset<T, AdventureKeywordCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AdventureKeywords and returns the data saved in the database.
     * @param {AdventureKeywordCreateManyAndReturnArgs} args - Arguments to create many AdventureKeywords.
     * @example
     * // Create many AdventureKeywords
     * const adventureKeyword = await prisma.adventureKeyword.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AdventureKeywords and only return the `adventure_id`
     * const adventureKeywordWithAdventure_idOnly = await prisma.adventureKeyword.createManyAndReturn({
     *   select: { adventure_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AdventureKeywordCreateManyAndReturnArgs>(args?: SelectSubset<T, AdventureKeywordCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdventureKeywordPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a AdventureKeyword.
     * @param {AdventureKeywordDeleteArgs} args - Arguments to delete one AdventureKeyword.
     * @example
     * // Delete one AdventureKeyword
     * const AdventureKeyword = await prisma.adventureKeyword.delete({
     *   where: {
     *     // ... filter to delete one AdventureKeyword
     *   }
     * })
     * 
     */
    delete<T extends AdventureKeywordDeleteArgs>(args: SelectSubset<T, AdventureKeywordDeleteArgs<ExtArgs>>): Prisma__AdventureKeywordClient<$Result.GetResult<Prisma.$AdventureKeywordPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one AdventureKeyword.
     * @param {AdventureKeywordUpdateArgs} args - Arguments to update one AdventureKeyword.
     * @example
     * // Update one AdventureKeyword
     * const adventureKeyword = await prisma.adventureKeyword.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AdventureKeywordUpdateArgs>(args: SelectSubset<T, AdventureKeywordUpdateArgs<ExtArgs>>): Prisma__AdventureKeywordClient<$Result.GetResult<Prisma.$AdventureKeywordPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more AdventureKeywords.
     * @param {AdventureKeywordDeleteManyArgs} args - Arguments to filter AdventureKeywords to delete.
     * @example
     * // Delete a few AdventureKeywords
     * const { count } = await prisma.adventureKeyword.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AdventureKeywordDeleteManyArgs>(args?: SelectSubset<T, AdventureKeywordDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AdventureKeywords.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdventureKeywordUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AdventureKeywords
     * const adventureKeyword = await prisma.adventureKeyword.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AdventureKeywordUpdateManyArgs>(args: SelectSubset<T, AdventureKeywordUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AdventureKeywords and returns the data updated in the database.
     * @param {AdventureKeywordUpdateManyAndReturnArgs} args - Arguments to update many AdventureKeywords.
     * @example
     * // Update many AdventureKeywords
     * const adventureKeyword = await prisma.adventureKeyword.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AdventureKeywords and only return the `adventure_id`
     * const adventureKeywordWithAdventure_idOnly = await prisma.adventureKeyword.updateManyAndReturn({
     *   select: { adventure_id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AdventureKeywordUpdateManyAndReturnArgs>(args: SelectSubset<T, AdventureKeywordUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdventureKeywordPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one AdventureKeyword.
     * @param {AdventureKeywordUpsertArgs} args - Arguments to update or create a AdventureKeyword.
     * @example
     * // Update or create a AdventureKeyword
     * const adventureKeyword = await prisma.adventureKeyword.upsert({
     *   create: {
     *     // ... data to create a AdventureKeyword
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AdventureKeyword we want to update
     *   }
     * })
     */
    upsert<T extends AdventureKeywordUpsertArgs>(args: SelectSubset<T, AdventureKeywordUpsertArgs<ExtArgs>>): Prisma__AdventureKeywordClient<$Result.GetResult<Prisma.$AdventureKeywordPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of AdventureKeywords.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdventureKeywordCountArgs} args - Arguments to filter AdventureKeywords to count.
     * @example
     * // Count the number of AdventureKeywords
     * const count = await prisma.adventureKeyword.count({
     *   where: {
     *     // ... the filter for the AdventureKeywords we want to count
     *   }
     * })
    **/
    count<T extends AdventureKeywordCountArgs>(
      args?: Subset<T, AdventureKeywordCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AdventureKeywordCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AdventureKeyword.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdventureKeywordAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AdventureKeywordAggregateArgs>(args: Subset<T, AdventureKeywordAggregateArgs>): Prisma.PrismaPromise<GetAdventureKeywordAggregateType<T>>

    /**
     * Group by AdventureKeyword.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdventureKeywordGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AdventureKeywordGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AdventureKeywordGroupByArgs['orderBy'] }
        : { orderBy?: AdventureKeywordGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AdventureKeywordGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAdventureKeywordGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AdventureKeyword model
   */
  readonly fields: AdventureKeywordFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AdventureKeyword.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AdventureKeywordClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    adventure<T extends AdventureDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AdventureDefaultArgs<ExtArgs>>): Prisma__AdventureClient<$Result.GetResult<Prisma.$AdventurePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    keyword<T extends KeywordDefaultArgs<ExtArgs> = {}>(args?: Subset<T, KeywordDefaultArgs<ExtArgs>>): Prisma__KeywordClient<$Result.GetResult<Prisma.$KeywordPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AdventureKeyword model
   */ 
  interface AdventureKeywordFieldRefs {
    readonly adventure_id: FieldRef<"AdventureKeyword", 'String'>
    readonly keyword_id: FieldRef<"AdventureKeyword", 'String'>
  }
    

  // Custom InputTypes
  /**
   * AdventureKeyword findUnique
   */
  export type AdventureKeywordFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdventureKeyword
     */
    select?: AdventureKeywordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdventureKeyword
     */
    omit?: AdventureKeywordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdventureKeywordInclude<ExtArgs> | null
    /**
     * Filter, which AdventureKeyword to fetch.
     */
    where: AdventureKeywordWhereUniqueInput
  }

  /**
   * AdventureKeyword findUniqueOrThrow
   */
  export type AdventureKeywordFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdventureKeyword
     */
    select?: AdventureKeywordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdventureKeyword
     */
    omit?: AdventureKeywordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdventureKeywordInclude<ExtArgs> | null
    /**
     * Filter, which AdventureKeyword to fetch.
     */
    where: AdventureKeywordWhereUniqueInput
  }

  /**
   * AdventureKeyword findFirst
   */
  export type AdventureKeywordFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdventureKeyword
     */
    select?: AdventureKeywordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdventureKeyword
     */
    omit?: AdventureKeywordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdventureKeywordInclude<ExtArgs> | null
    /**
     * Filter, which AdventureKeyword to fetch.
     */
    where?: AdventureKeywordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdventureKeywords to fetch.
     */
    orderBy?: AdventureKeywordOrderByWithRelationInput | AdventureKeywordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AdventureKeywords.
     */
    cursor?: AdventureKeywordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdventureKeywords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdventureKeywords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AdventureKeywords.
     */
    distinct?: AdventureKeywordScalarFieldEnum | AdventureKeywordScalarFieldEnum[]
  }

  /**
   * AdventureKeyword findFirstOrThrow
   */
  export type AdventureKeywordFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdventureKeyword
     */
    select?: AdventureKeywordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdventureKeyword
     */
    omit?: AdventureKeywordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdventureKeywordInclude<ExtArgs> | null
    /**
     * Filter, which AdventureKeyword to fetch.
     */
    where?: AdventureKeywordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdventureKeywords to fetch.
     */
    orderBy?: AdventureKeywordOrderByWithRelationInput | AdventureKeywordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AdventureKeywords.
     */
    cursor?: AdventureKeywordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdventureKeywords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdventureKeywords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AdventureKeywords.
     */
    distinct?: AdventureKeywordScalarFieldEnum | AdventureKeywordScalarFieldEnum[]
  }

  /**
   * AdventureKeyword findMany
   */
  export type AdventureKeywordFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdventureKeyword
     */
    select?: AdventureKeywordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdventureKeyword
     */
    omit?: AdventureKeywordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdventureKeywordInclude<ExtArgs> | null
    /**
     * Filter, which AdventureKeywords to fetch.
     */
    where?: AdventureKeywordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdventureKeywords to fetch.
     */
    orderBy?: AdventureKeywordOrderByWithRelationInput | AdventureKeywordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AdventureKeywords.
     */
    cursor?: AdventureKeywordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdventureKeywords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdventureKeywords.
     */
    skip?: number
    distinct?: AdventureKeywordScalarFieldEnum | AdventureKeywordScalarFieldEnum[]
  }

  /**
   * AdventureKeyword create
   */
  export type AdventureKeywordCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdventureKeyword
     */
    select?: AdventureKeywordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdventureKeyword
     */
    omit?: AdventureKeywordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdventureKeywordInclude<ExtArgs> | null
    /**
     * The data needed to create a AdventureKeyword.
     */
    data: XOR<AdventureKeywordCreateInput, AdventureKeywordUncheckedCreateInput>
  }

  /**
   * AdventureKeyword createMany
   */
  export type AdventureKeywordCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AdventureKeywords.
     */
    data: AdventureKeywordCreateManyInput | AdventureKeywordCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AdventureKeyword createManyAndReturn
   */
  export type AdventureKeywordCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdventureKeyword
     */
    select?: AdventureKeywordSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AdventureKeyword
     */
    omit?: AdventureKeywordOmit<ExtArgs> | null
    /**
     * The data used to create many AdventureKeywords.
     */
    data: AdventureKeywordCreateManyInput | AdventureKeywordCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdventureKeywordIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AdventureKeyword update
   */
  export type AdventureKeywordUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdventureKeyword
     */
    select?: AdventureKeywordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdventureKeyword
     */
    omit?: AdventureKeywordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdventureKeywordInclude<ExtArgs> | null
    /**
     * The data needed to update a AdventureKeyword.
     */
    data: XOR<AdventureKeywordUpdateInput, AdventureKeywordUncheckedUpdateInput>
    /**
     * Choose, which AdventureKeyword to update.
     */
    where: AdventureKeywordWhereUniqueInput
  }

  /**
   * AdventureKeyword updateMany
   */
  export type AdventureKeywordUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AdventureKeywords.
     */
    data: XOR<AdventureKeywordUpdateManyMutationInput, AdventureKeywordUncheckedUpdateManyInput>
    /**
     * Filter which AdventureKeywords to update
     */
    where?: AdventureKeywordWhereInput
    /**
     * Limit how many AdventureKeywords to update.
     */
    limit?: number
  }

  /**
   * AdventureKeyword updateManyAndReturn
   */
  export type AdventureKeywordUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdventureKeyword
     */
    select?: AdventureKeywordSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AdventureKeyword
     */
    omit?: AdventureKeywordOmit<ExtArgs> | null
    /**
     * The data used to update AdventureKeywords.
     */
    data: XOR<AdventureKeywordUpdateManyMutationInput, AdventureKeywordUncheckedUpdateManyInput>
    /**
     * Filter which AdventureKeywords to update
     */
    where?: AdventureKeywordWhereInput
    /**
     * Limit how many AdventureKeywords to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdventureKeywordIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AdventureKeyword upsert
   */
  export type AdventureKeywordUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdventureKeyword
     */
    select?: AdventureKeywordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdventureKeyword
     */
    omit?: AdventureKeywordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdventureKeywordInclude<ExtArgs> | null
    /**
     * The filter to search for the AdventureKeyword to update in case it exists.
     */
    where: AdventureKeywordWhereUniqueInput
    /**
     * In case the AdventureKeyword found by the `where` argument doesn't exist, create a new AdventureKeyword with this data.
     */
    create: XOR<AdventureKeywordCreateInput, AdventureKeywordUncheckedCreateInput>
    /**
     * In case the AdventureKeyword was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AdventureKeywordUpdateInput, AdventureKeywordUncheckedUpdateInput>
  }

  /**
   * AdventureKeyword delete
   */
  export type AdventureKeywordDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdventureKeyword
     */
    select?: AdventureKeywordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdventureKeyword
     */
    omit?: AdventureKeywordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdventureKeywordInclude<ExtArgs> | null
    /**
     * Filter which AdventureKeyword to delete.
     */
    where: AdventureKeywordWhereUniqueInput
  }

  /**
   * AdventureKeyword deleteMany
   */
  export type AdventureKeywordDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AdventureKeywords to delete
     */
    where?: AdventureKeywordWhereInput
    /**
     * Limit how many AdventureKeywords to delete.
     */
    limit?: number
  }

  /**
   * AdventureKeyword without action
   */
  export type AdventureKeywordDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdventureKeyword
     */
    select?: AdventureKeywordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdventureKeyword
     */
    omit?: AdventureKeywordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdventureKeywordInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const SizeScalarFieldEnum: {
    id: 'id',
    name: 'name'
  };

  export type SizeScalarFieldEnum = (typeof SizeScalarFieldEnum)[keyof typeof SizeScalarFieldEnum]


  export const SourceScalarFieldEnum: {
    id: 'id',
    shortName: 'shortName',
    name: 'name'
  };

  export type SourceScalarFieldEnum = (typeof SourceScalarFieldEnum)[keyof typeof SourceScalarFieldEnum]


  export const LanguageScalarFieldEnum: {
    id: 'id',
    name: 'name'
  };

  export type LanguageScalarFieldEnum = (typeof LanguageScalarFieldEnum)[keyof typeof LanguageScalarFieldEnum]


  export const BiomeScalarFieldEnum: {
    id: 'id',
    key: 'key',
    name: 'name'
  };

  export type BiomeScalarFieldEnum = (typeof BiomeScalarFieldEnum)[keyof typeof BiomeScalarFieldEnum]


  export const TypeScalarFieldEnum: {
    id: 'id',
    name: 'name'
  };

  export type TypeScalarFieldEnum = (typeof TypeScalarFieldEnum)[keyof typeof TypeScalarFieldEnum]


  export const AlignmentScalarFieldEnum: {
    id: 'id',
    name: 'name'
  };

  export type AlignmentScalarFieldEnum = (typeof AlignmentScalarFieldEnum)[keyof typeof AlignmentScalarFieldEnum]


  export const Speed_statScalarFieldEnum: {
    id: 'id',
    walk: 'walk',
    fly: 'fly',
    swim: 'swim',
    burrow: 'burrow',
    climb: 'climb'
  };

  export type Speed_statScalarFieldEnum = (typeof Speed_statScalarFieldEnum)[keyof typeof Speed_statScalarFieldEnum]


  export const Creature_statsScalarFieldEnum: {
    id: 'id'
  };

  export type Creature_statsScalarFieldEnum = (typeof Creature_statsScalarFieldEnum)[keyof typeof Creature_statsScalarFieldEnum]


  export const Strength_stat_detailsScalarFieldEnum: {
    statblock_id: 'statblock_id',
    value: 'value',
    mastery: 'mastery'
  };

  export type Strength_stat_detailsScalarFieldEnum = (typeof Strength_stat_detailsScalarFieldEnum)[keyof typeof Strength_stat_detailsScalarFieldEnum]


  export const Dexterity_stat_detailsScalarFieldEnum: {
    statblock_id: 'statblock_id',
    value: 'value',
    mastery: 'mastery'
  };

  export type Dexterity_stat_detailsScalarFieldEnum = (typeof Dexterity_stat_detailsScalarFieldEnum)[keyof typeof Dexterity_stat_detailsScalarFieldEnum]


  export const Constitution_stat_detailsScalarFieldEnum: {
    statblock_id: 'statblock_id',
    value: 'value',
    mastery: 'mastery'
  };

  export type Constitution_stat_detailsScalarFieldEnum = (typeof Constitution_stat_detailsScalarFieldEnum)[keyof typeof Constitution_stat_detailsScalarFieldEnum]


  export const Intelligence_stat_detailsScalarFieldEnum: {
    statblock_id: 'statblock_id',
    value: 'value',
    mastery: 'mastery'
  };

  export type Intelligence_stat_detailsScalarFieldEnum = (typeof Intelligence_stat_detailsScalarFieldEnum)[keyof typeof Intelligence_stat_detailsScalarFieldEnum]


  export const Wisdom_stat_detailsScalarFieldEnum: {
    statblock_id: 'statblock_id',
    value: 'value',
    mastery: 'mastery'
  };

  export type Wisdom_stat_detailsScalarFieldEnum = (typeof Wisdom_stat_detailsScalarFieldEnum)[keyof typeof Wisdom_stat_detailsScalarFieldEnum]


  export const Charisma_stat_detailsScalarFieldEnum: {
    statblock_id: 'statblock_id',
    value: 'value',
    mastery: 'mastery'
  };

  export type Charisma_stat_detailsScalarFieldEnum = (typeof Charisma_stat_detailsScalarFieldEnum)[keyof typeof Charisma_stat_detailsScalarFieldEnum]


  export const SkillsListScalarFieldEnum: {
    id: 'id'
  };

  export type SkillsListScalarFieldEnum = (typeof SkillsListScalarFieldEnum)[keyof typeof SkillsListScalarFieldEnum]


  export const StrengthBasedSkillsScalarFieldEnum: {
    id: 'id'
  };

  export type StrengthBasedSkillsScalarFieldEnum = (typeof StrengthBasedSkillsScalarFieldEnum)[keyof typeof StrengthBasedSkillsScalarFieldEnum]


  export const DexterityBasedSkillsScalarFieldEnum: {
    id: 'id'
  };

  export type DexterityBasedSkillsScalarFieldEnum = (typeof DexterityBasedSkillsScalarFieldEnum)[keyof typeof DexterityBasedSkillsScalarFieldEnum]


  export const IntellengenceBasedSkillsScalarFieldEnum: {
    id: 'id'
  };

  export type IntellengenceBasedSkillsScalarFieldEnum = (typeof IntellengenceBasedSkillsScalarFieldEnum)[keyof typeof IntellengenceBasedSkillsScalarFieldEnum]


  export const WisdomBasedSkillsScalarFieldEnum: {
    id: 'id'
  };

  export type WisdomBasedSkillsScalarFieldEnum = (typeof WisdomBasedSkillsScalarFieldEnum)[keyof typeof WisdomBasedSkillsScalarFieldEnum]


  export const CharismaBasedSkillsScalarFieldEnum: {
    id: 'id'
  };

  export type CharismaBasedSkillsScalarFieldEnum = (typeof CharismaBasedSkillsScalarFieldEnum)[keyof typeof CharismaBasedSkillsScalarFieldEnum]


  export const AthleticsSkillScalarFieldEnum: {
    id: 'id',
    value: 'value',
    mastery: 'mastery',
    name: 'name'
  };

  export type AthleticsSkillScalarFieldEnum = (typeof AthleticsSkillScalarFieldEnum)[keyof typeof AthleticsSkillScalarFieldEnum]


  export const AcrobaticsSkillScalarFieldEnum: {
    id: 'id',
    value: 'value',
    mastery: 'mastery',
    name: 'name'
  };

  export type AcrobaticsSkillScalarFieldEnum = (typeof AcrobaticsSkillScalarFieldEnum)[keyof typeof AcrobaticsSkillScalarFieldEnum]


  export const SleightOfHandSkillScalarFieldEnum: {
    id: 'id',
    value: 'value',
    mastery: 'mastery',
    name: 'name'
  };

  export type SleightOfHandSkillScalarFieldEnum = (typeof SleightOfHandSkillScalarFieldEnum)[keyof typeof SleightOfHandSkillScalarFieldEnum]


  export const StealthSkillScalarFieldEnum: {
    id: 'id',
    value: 'value',
    mastery: 'mastery',
    name: 'name'
  };

  export type StealthSkillScalarFieldEnum = (typeof StealthSkillScalarFieldEnum)[keyof typeof StealthSkillScalarFieldEnum]


  export const ArcanaSkillScalarFieldEnum: {
    id: 'id',
    value: 'value',
    mastery: 'mastery',
    name: 'name'
  };

  export type ArcanaSkillScalarFieldEnum = (typeof ArcanaSkillScalarFieldEnum)[keyof typeof ArcanaSkillScalarFieldEnum]


  export const HistorySkillScalarFieldEnum: {
    id: 'id',
    value: 'value',
    mastery: 'mastery',
    name: 'name'
  };

  export type HistorySkillScalarFieldEnum = (typeof HistorySkillScalarFieldEnum)[keyof typeof HistorySkillScalarFieldEnum]


  export const InvestigationSkillScalarFieldEnum: {
    id: 'id',
    value: 'value',
    mastery: 'mastery',
    name: 'name'
  };

  export type InvestigationSkillScalarFieldEnum = (typeof InvestigationSkillScalarFieldEnum)[keyof typeof InvestigationSkillScalarFieldEnum]


  export const NatureSkillScalarFieldEnum: {
    id: 'id',
    value: 'value',
    mastery: 'mastery',
    name: 'name'
  };

  export type NatureSkillScalarFieldEnum = (typeof NatureSkillScalarFieldEnum)[keyof typeof NatureSkillScalarFieldEnum]


  export const ReligionSkillScalarFieldEnum: {
    id: 'id',
    value: 'value',
    mastery: 'mastery',
    name: 'name'
  };

  export type ReligionSkillScalarFieldEnum = (typeof ReligionSkillScalarFieldEnum)[keyof typeof ReligionSkillScalarFieldEnum]


  export const AnimalHandlingSkillScalarFieldEnum: {
    id: 'id',
    value: 'value',
    mastery: 'mastery',
    name: 'name'
  };

  export type AnimalHandlingSkillScalarFieldEnum = (typeof AnimalHandlingSkillScalarFieldEnum)[keyof typeof AnimalHandlingSkillScalarFieldEnum]


  export const InsightSkillScalarFieldEnum: {
    id: 'id',
    value: 'value',
    mastery: 'mastery',
    name: 'name'
  };

  export type InsightSkillScalarFieldEnum = (typeof InsightSkillScalarFieldEnum)[keyof typeof InsightSkillScalarFieldEnum]


  export const MedicineSkillScalarFieldEnum: {
    id: 'id',
    value: 'value',
    mastery: 'mastery',
    name: 'name'
  };

  export type MedicineSkillScalarFieldEnum = (typeof MedicineSkillScalarFieldEnum)[keyof typeof MedicineSkillScalarFieldEnum]


  export const PerceptionSkillScalarFieldEnum: {
    id: 'id',
    value: 'value',
    mastery: 'mastery',
    name: 'name'
  };

  export type PerceptionSkillScalarFieldEnum = (typeof PerceptionSkillScalarFieldEnum)[keyof typeof PerceptionSkillScalarFieldEnum]


  export const SurvivalSkillScalarFieldEnum: {
    id: 'id',
    value: 'value',
    mastery: 'mastery',
    name: 'name'
  };

  export type SurvivalSkillScalarFieldEnum = (typeof SurvivalSkillScalarFieldEnum)[keyof typeof SurvivalSkillScalarFieldEnum]


  export const DeceptionSkillScalarFieldEnum: {
    id: 'id',
    value: 'value',
    mastery: 'mastery',
    name: 'name'
  };

  export type DeceptionSkillScalarFieldEnum = (typeof DeceptionSkillScalarFieldEnum)[keyof typeof DeceptionSkillScalarFieldEnum]


  export const IntimidationSkillScalarFieldEnum: {
    id: 'id',
    value: 'value',
    mastery: 'mastery',
    name: 'name'
  };

  export type IntimidationSkillScalarFieldEnum = (typeof IntimidationSkillScalarFieldEnum)[keyof typeof IntimidationSkillScalarFieldEnum]


  export const PerformanceSkillScalarFieldEnum: {
    id: 'id',
    value: 'value',
    mastery: 'mastery',
    name: 'name'
  };

  export type PerformanceSkillScalarFieldEnum = (typeof PerformanceSkillScalarFieldEnum)[keyof typeof PerformanceSkillScalarFieldEnum]


  export const PersuasionSkillScalarFieldEnum: {
    id: 'id',
    value: 'value',
    mastery: 'mastery',
    name: 'name'
  };

  export type PersuasionSkillScalarFieldEnum = (typeof PersuasionSkillScalarFieldEnum)[keyof typeof PersuasionSkillScalarFieldEnum]


  export const CreatureScalarFieldEnum: {
    id: 'id',
    name: 'name',
    creator_id: 'creator_id',
    image_uri: 'image_uri',
    description: 'description',
    size: 'size',
    race_id: 'race_id',
    source_id: 'source_id',
    alignment_id: 'alignment_id',
    armor_class: 'armor_class',
    hit_points: 'hit_points',
    challenge_rating: 'challenge_rating',
    biomes_ids: 'biomes_ids',
    type_id: 'type_id',
    aSubTypes: 'aSubTypes'
  };

  export type CreatureScalarFieldEnum = (typeof CreatureScalarFieldEnum)[keyof typeof CreatureScalarFieldEnum]


  export const SensesScalarFieldEnum: {
    creature_id: 'creature_id',
    passive_perception: 'passive_perception'
  };

  export type SensesScalarFieldEnum = (typeof SensesScalarFieldEnum)[keyof typeof SensesScalarFieldEnum]


  export const ActionScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    attack: 'attack',
    is_template: 'is_template'
  };

  export type ActionScalarFieldEnum = (typeof ActionScalarFieldEnum)[keyof typeof ActionScalarFieldEnum]


  export const TraitScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    attack: 'attack',
    is_template: 'is_template'
  };

  export type TraitScalarFieldEnum = (typeof TraitScalarFieldEnum)[keyof typeof TraitScalarFieldEnum]


  export const CreatureRaceScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description'
  };

  export type CreatureRaceScalarFieldEnum = (typeof CreatureRaceScalarFieldEnum)[keyof typeof CreatureRaceScalarFieldEnum]


  export const GenrationRequestScalarFieldEnum: {
    id: 'id',
    request: 'request',
    danger: 'danger',
    name: 'name'
  };

  export type GenrationRequestScalarFieldEnum = (typeof GenrationRequestScalarFieldEnum)[keyof typeof GenrationRequestScalarFieldEnum]


  export const DamageTypeScalarFieldEnum: {
    id: 'id',
    name: 'name'
  };

  export type DamageTypeScalarFieldEnum = (typeof DamageTypeScalarFieldEnum)[keyof typeof DamageTypeScalarFieldEnum]


  export const ChallengeRatingScalarFieldEnum: {
    id: 'id'
  };

  export type ChallengeRatingScalarFieldEnum = (typeof ChallengeRatingScalarFieldEnum)[keyof typeof ChallengeRatingScalarFieldEnum]


  export const GPTMessageHistoryScalarFieldEnum: {
    id: 'id',
    type: 'type'
  };

  export type GPTMessageHistoryScalarFieldEnum = (typeof GPTMessageHistoryScalarFieldEnum)[keyof typeof GPTMessageHistoryScalarFieldEnum]


  export const GPTMessageScalarFieldEnum: {
    number: 'number',
    message_history_id: 'message_history_id',
    text: 'text',
    role: 'role'
  };

  export type GPTMessageScalarFieldEnum = (typeof GPTMessageScalarFieldEnum)[keyof typeof GPTMessageScalarFieldEnum]


  export const AdventureScalarFieldEnum: {
    id: 'id',
    title: 'title',
    planned_parties: 'planned_parties',
    genre_id: 'genre_id',
    creator_id: 'creator_id',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type AdventureScalarFieldEnum = (typeof AdventureScalarFieldEnum)[keyof typeof AdventureScalarFieldEnum]


  export const GenreScalarFieldEnum: {
    id: 'id',
    name: 'name'
  };

  export type GenreScalarFieldEnum = (typeof GenreScalarFieldEnum)[keyof typeof GenreScalarFieldEnum]


  export const KeywordScalarFieldEnum: {
    id: 'id',
    name: 'name',
    genre_id: 'genre_id'
  };

  export type KeywordScalarFieldEnum = (typeof KeywordScalarFieldEnum)[keyof typeof KeywordScalarFieldEnum]


  export const AdventureKeywordScalarFieldEnum: {
    adventure_id: 'adventure_id',
    keyword_id: 'keyword_id'
  };

  export type AdventureKeywordScalarFieldEnum = (typeof AdventureKeywordScalarFieldEnum)[keyof typeof AdventureKeywordScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type SizeWhereInput = {
    AND?: SizeWhereInput | SizeWhereInput[]
    OR?: SizeWhereInput[]
    NOT?: SizeWhereInput | SizeWhereInput[]
    id?: StringFilter<"Size"> | string
    name?: StringFilter<"Size"> | string
    creature?: CreatureListRelationFilter
  }

  export type SizeOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    creature?: CreatureOrderByRelationAggregateInput
  }

  export type SizeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    AND?: SizeWhereInput | SizeWhereInput[]
    OR?: SizeWhereInput[]
    NOT?: SizeWhereInput | SizeWhereInput[]
    creature?: CreatureListRelationFilter
  }, "id" | "name">

  export type SizeOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    _count?: SizeCountOrderByAggregateInput
    _max?: SizeMaxOrderByAggregateInput
    _min?: SizeMinOrderByAggregateInput
  }

  export type SizeScalarWhereWithAggregatesInput = {
    AND?: SizeScalarWhereWithAggregatesInput | SizeScalarWhereWithAggregatesInput[]
    OR?: SizeScalarWhereWithAggregatesInput[]
    NOT?: SizeScalarWhereWithAggregatesInput | SizeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Size"> | string
    name?: StringWithAggregatesFilter<"Size"> | string
  }

  export type SourceWhereInput = {
    AND?: SourceWhereInput | SourceWhereInput[]
    OR?: SourceWhereInput[]
    NOT?: SourceWhereInput | SourceWhereInput[]
    id?: IntFilter<"Source"> | number
    shortName?: StringFilter<"Source"> | string
    name?: StringFilter<"Source"> | string
    creatures?: CreatureListRelationFilter
  }

  export type SourceOrderByWithRelationInput = {
    id?: SortOrder
    shortName?: SortOrder
    name?: SortOrder
    creatures?: CreatureOrderByRelationAggregateInput
  }

  export type SourceWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    shortName?: string
    AND?: SourceWhereInput | SourceWhereInput[]
    OR?: SourceWhereInput[]
    NOT?: SourceWhereInput | SourceWhereInput[]
    name?: StringFilter<"Source"> | string
    creatures?: CreatureListRelationFilter
  }, "id" | "shortName">

  export type SourceOrderByWithAggregationInput = {
    id?: SortOrder
    shortName?: SortOrder
    name?: SortOrder
    _count?: SourceCountOrderByAggregateInput
    _avg?: SourceAvgOrderByAggregateInput
    _max?: SourceMaxOrderByAggregateInput
    _min?: SourceMinOrderByAggregateInput
    _sum?: SourceSumOrderByAggregateInput
  }

  export type SourceScalarWhereWithAggregatesInput = {
    AND?: SourceScalarWhereWithAggregatesInput | SourceScalarWhereWithAggregatesInput[]
    OR?: SourceScalarWhereWithAggregatesInput[]
    NOT?: SourceScalarWhereWithAggregatesInput | SourceScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Source"> | number
    shortName?: StringWithAggregatesFilter<"Source"> | string
    name?: StringWithAggregatesFilter<"Source"> | string
  }

  export type LanguageWhereInput = {
    AND?: LanguageWhereInput | LanguageWhereInput[]
    OR?: LanguageWhereInput[]
    NOT?: LanguageWhereInput | LanguageWhereInput[]
    id?: IntFilter<"Language"> | number
    name?: StringFilter<"Language"> | string
    creatures?: CreatureListRelationFilter
  }

  export type LanguageOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    creatures?: CreatureOrderByRelationAggregateInput
  }

  export type LanguageWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    name?: string
    AND?: LanguageWhereInput | LanguageWhereInput[]
    OR?: LanguageWhereInput[]
    NOT?: LanguageWhereInput | LanguageWhereInput[]
    creatures?: CreatureListRelationFilter
  }, "id" | "name">

  export type LanguageOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    _count?: LanguageCountOrderByAggregateInput
    _avg?: LanguageAvgOrderByAggregateInput
    _max?: LanguageMaxOrderByAggregateInput
    _min?: LanguageMinOrderByAggregateInput
    _sum?: LanguageSumOrderByAggregateInput
  }

  export type LanguageScalarWhereWithAggregatesInput = {
    AND?: LanguageScalarWhereWithAggregatesInput | LanguageScalarWhereWithAggregatesInput[]
    OR?: LanguageScalarWhereWithAggregatesInput[]
    NOT?: LanguageScalarWhereWithAggregatesInput | LanguageScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Language"> | number
    name?: StringWithAggregatesFilter<"Language"> | string
  }

  export type BiomeWhereInput = {
    AND?: BiomeWhereInput | BiomeWhereInput[]
    OR?: BiomeWhereInput[]
    NOT?: BiomeWhereInput | BiomeWhereInput[]
    id?: IntFilter<"Biome"> | number
    key?: StringFilter<"Biome"> | string
    name?: StringFilter<"Biome"> | string
    creatures?: CreatureListRelationFilter
  }

  export type BiomeOrderByWithRelationInput = {
    id?: SortOrder
    key?: SortOrder
    name?: SortOrder
    creatures?: CreatureOrderByRelationAggregateInput
  }

  export type BiomeWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    key?: string
    name?: string
    AND?: BiomeWhereInput | BiomeWhereInput[]
    OR?: BiomeWhereInput[]
    NOT?: BiomeWhereInput | BiomeWhereInput[]
    creatures?: CreatureListRelationFilter
  }, "id" | "key" | "name">

  export type BiomeOrderByWithAggregationInput = {
    id?: SortOrder
    key?: SortOrder
    name?: SortOrder
    _count?: BiomeCountOrderByAggregateInput
    _avg?: BiomeAvgOrderByAggregateInput
    _max?: BiomeMaxOrderByAggregateInput
    _min?: BiomeMinOrderByAggregateInput
    _sum?: BiomeSumOrderByAggregateInput
  }

  export type BiomeScalarWhereWithAggregatesInput = {
    AND?: BiomeScalarWhereWithAggregatesInput | BiomeScalarWhereWithAggregatesInput[]
    OR?: BiomeScalarWhereWithAggregatesInput[]
    NOT?: BiomeScalarWhereWithAggregatesInput | BiomeScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Biome"> | number
    key?: StringWithAggregatesFilter<"Biome"> | string
    name?: StringWithAggregatesFilter<"Biome"> | string
  }

  export type TypeWhereInput = {
    AND?: TypeWhereInput | TypeWhereInput[]
    OR?: TypeWhereInput[]
    NOT?: TypeWhereInput | TypeWhereInput[]
    id?: IntFilter<"Type"> | number
    name?: StringFilter<"Type"> | string
    creatures?: CreatureListRelationFilter
  }

  export type TypeOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    creatures?: CreatureOrderByRelationAggregateInput
  }

  export type TypeWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    name?: string
    AND?: TypeWhereInput | TypeWhereInput[]
    OR?: TypeWhereInput[]
    NOT?: TypeWhereInput | TypeWhereInput[]
    creatures?: CreatureListRelationFilter
  }, "id" | "name">

  export type TypeOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    _count?: TypeCountOrderByAggregateInput
    _avg?: TypeAvgOrderByAggregateInput
    _max?: TypeMaxOrderByAggregateInput
    _min?: TypeMinOrderByAggregateInput
    _sum?: TypeSumOrderByAggregateInput
  }

  export type TypeScalarWhereWithAggregatesInput = {
    AND?: TypeScalarWhereWithAggregatesInput | TypeScalarWhereWithAggregatesInput[]
    OR?: TypeScalarWhereWithAggregatesInput[]
    NOT?: TypeScalarWhereWithAggregatesInput | TypeScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Type"> | number
    name?: StringWithAggregatesFilter<"Type"> | string
  }

  export type AlignmentWhereInput = {
    AND?: AlignmentWhereInput | AlignmentWhereInput[]
    OR?: AlignmentWhereInput[]
    NOT?: AlignmentWhereInput | AlignmentWhereInput[]
    id?: IntFilter<"Alignment"> | number
    name?: StringFilter<"Alignment"> | string
    creatures?: CreatureListRelationFilter
  }

  export type AlignmentOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    creatures?: CreatureOrderByRelationAggregateInput
  }

  export type AlignmentWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    name?: string
    AND?: AlignmentWhereInput | AlignmentWhereInput[]
    OR?: AlignmentWhereInput[]
    NOT?: AlignmentWhereInput | AlignmentWhereInput[]
    creatures?: CreatureListRelationFilter
  }, "id" | "name">

  export type AlignmentOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    _count?: AlignmentCountOrderByAggregateInput
    _avg?: AlignmentAvgOrderByAggregateInput
    _max?: AlignmentMaxOrderByAggregateInput
    _min?: AlignmentMinOrderByAggregateInput
    _sum?: AlignmentSumOrderByAggregateInput
  }

  export type AlignmentScalarWhereWithAggregatesInput = {
    AND?: AlignmentScalarWhereWithAggregatesInput | AlignmentScalarWhereWithAggregatesInput[]
    OR?: AlignmentScalarWhereWithAggregatesInput[]
    NOT?: AlignmentScalarWhereWithAggregatesInput | AlignmentScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Alignment"> | number
    name?: StringWithAggregatesFilter<"Alignment"> | string
  }

  export type Speed_statWhereInput = {
    AND?: Speed_statWhereInput | Speed_statWhereInput[]
    OR?: Speed_statWhereInput[]
    NOT?: Speed_statWhereInput | Speed_statWhereInput[]
    id?: StringFilter<"Speed_stat"> | string
    walk?: IntNullableFilter<"Speed_stat"> | number | null
    fly?: IntNullableFilter<"Speed_stat"> | number | null
    swim?: IntNullableFilter<"Speed_stat"> | number | null
    burrow?: IntNullableFilter<"Speed_stat"> | number | null
    climb?: IntNullableFilter<"Speed_stat"> | number | null
    id_relation?: XOR<CreatureScalarRelationFilter, CreatureWhereInput>
  }

  export type Speed_statOrderByWithRelationInput = {
    id?: SortOrder
    walk?: SortOrderInput | SortOrder
    fly?: SortOrderInput | SortOrder
    swim?: SortOrderInput | SortOrder
    burrow?: SortOrderInput | SortOrder
    climb?: SortOrderInput | SortOrder
    id_relation?: CreatureOrderByWithRelationInput
  }

  export type Speed_statWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: Speed_statWhereInput | Speed_statWhereInput[]
    OR?: Speed_statWhereInput[]
    NOT?: Speed_statWhereInput | Speed_statWhereInput[]
    walk?: IntNullableFilter<"Speed_stat"> | number | null
    fly?: IntNullableFilter<"Speed_stat"> | number | null
    swim?: IntNullableFilter<"Speed_stat"> | number | null
    burrow?: IntNullableFilter<"Speed_stat"> | number | null
    climb?: IntNullableFilter<"Speed_stat"> | number | null
    id_relation?: XOR<CreatureScalarRelationFilter, CreatureWhereInput>
  }, "id">

  export type Speed_statOrderByWithAggregationInput = {
    id?: SortOrder
    walk?: SortOrderInput | SortOrder
    fly?: SortOrderInput | SortOrder
    swim?: SortOrderInput | SortOrder
    burrow?: SortOrderInput | SortOrder
    climb?: SortOrderInput | SortOrder
    _count?: Speed_statCountOrderByAggregateInput
    _avg?: Speed_statAvgOrderByAggregateInput
    _max?: Speed_statMaxOrderByAggregateInput
    _min?: Speed_statMinOrderByAggregateInput
    _sum?: Speed_statSumOrderByAggregateInput
  }

  export type Speed_statScalarWhereWithAggregatesInput = {
    AND?: Speed_statScalarWhereWithAggregatesInput | Speed_statScalarWhereWithAggregatesInput[]
    OR?: Speed_statScalarWhereWithAggregatesInput[]
    NOT?: Speed_statScalarWhereWithAggregatesInput | Speed_statScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Speed_stat"> | string
    walk?: IntNullableWithAggregatesFilter<"Speed_stat"> | number | null
    fly?: IntNullableWithAggregatesFilter<"Speed_stat"> | number | null
    swim?: IntNullableWithAggregatesFilter<"Speed_stat"> | number | null
    burrow?: IntNullableWithAggregatesFilter<"Speed_stat"> | number | null
    climb?: IntNullableWithAggregatesFilter<"Speed_stat"> | number | null
  }

  export type Creature_statsWhereInput = {
    AND?: Creature_statsWhereInput | Creature_statsWhereInput[]
    OR?: Creature_statsWhereInput[]
    NOT?: Creature_statsWhereInput | Creature_statsWhereInput[]
    id?: StringFilter<"Creature_stats"> | string
    strength?: XOR<Strength_stat_detailsNullableScalarRelationFilter, Strength_stat_detailsWhereInput> | null
    dexterity?: XOR<Dexterity_stat_detailsNullableScalarRelationFilter, Dexterity_stat_detailsWhereInput> | null
    constitution?: XOR<Constitution_stat_detailsNullableScalarRelationFilter, Constitution_stat_detailsWhereInput> | null
    intelligence?: XOR<Intelligence_stat_detailsNullableScalarRelationFilter, Intelligence_stat_detailsWhereInput> | null
    wisdom?: XOR<Wisdom_stat_detailsNullableScalarRelationFilter, Wisdom_stat_detailsWhereInput> | null
    charisma?: XOR<Charisma_stat_detailsNullableScalarRelationFilter, Charisma_stat_detailsWhereInput> | null
    id_relation?: XOR<CreatureScalarRelationFilter, CreatureWhereInput>
  }

  export type Creature_statsOrderByWithRelationInput = {
    id?: SortOrder
    strength?: Strength_stat_detailsOrderByWithRelationInput
    dexterity?: Dexterity_stat_detailsOrderByWithRelationInput
    constitution?: Constitution_stat_detailsOrderByWithRelationInput
    intelligence?: Intelligence_stat_detailsOrderByWithRelationInput
    wisdom?: Wisdom_stat_detailsOrderByWithRelationInput
    charisma?: Charisma_stat_detailsOrderByWithRelationInput
    id_relation?: CreatureOrderByWithRelationInput
  }

  export type Creature_statsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: Creature_statsWhereInput | Creature_statsWhereInput[]
    OR?: Creature_statsWhereInput[]
    NOT?: Creature_statsWhereInput | Creature_statsWhereInput[]
    strength?: XOR<Strength_stat_detailsNullableScalarRelationFilter, Strength_stat_detailsWhereInput> | null
    dexterity?: XOR<Dexterity_stat_detailsNullableScalarRelationFilter, Dexterity_stat_detailsWhereInput> | null
    constitution?: XOR<Constitution_stat_detailsNullableScalarRelationFilter, Constitution_stat_detailsWhereInput> | null
    intelligence?: XOR<Intelligence_stat_detailsNullableScalarRelationFilter, Intelligence_stat_detailsWhereInput> | null
    wisdom?: XOR<Wisdom_stat_detailsNullableScalarRelationFilter, Wisdom_stat_detailsWhereInput> | null
    charisma?: XOR<Charisma_stat_detailsNullableScalarRelationFilter, Charisma_stat_detailsWhereInput> | null
    id_relation?: XOR<CreatureScalarRelationFilter, CreatureWhereInput>
  }, "id">

  export type Creature_statsOrderByWithAggregationInput = {
    id?: SortOrder
    _count?: Creature_statsCountOrderByAggregateInput
    _max?: Creature_statsMaxOrderByAggregateInput
    _min?: Creature_statsMinOrderByAggregateInput
  }

  export type Creature_statsScalarWhereWithAggregatesInput = {
    AND?: Creature_statsScalarWhereWithAggregatesInput | Creature_statsScalarWhereWithAggregatesInput[]
    OR?: Creature_statsScalarWhereWithAggregatesInput[]
    NOT?: Creature_statsScalarWhereWithAggregatesInput | Creature_statsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Creature_stats"> | string
  }

  export type Strength_stat_detailsWhereInput = {
    AND?: Strength_stat_detailsWhereInput | Strength_stat_detailsWhereInput[]
    OR?: Strength_stat_detailsWhereInput[]
    NOT?: Strength_stat_detailsWhereInput | Strength_stat_detailsWhereInput[]
    statblock_id?: StringFilter<"Strength_stat_details"> | string
    value?: IntFilter<"Strength_stat_details"> | number
    mastery?: BoolFilter<"Strength_stat_details"> | boolean
    creature_stat?: XOR<Creature_statsScalarRelationFilter, Creature_statsWhereInput>
  }

  export type Strength_stat_detailsOrderByWithRelationInput = {
    statblock_id?: SortOrder
    value?: SortOrder
    mastery?: SortOrder
    creature_stat?: Creature_statsOrderByWithRelationInput
  }

  export type Strength_stat_detailsWhereUniqueInput = Prisma.AtLeast<{
    statblock_id?: string
    AND?: Strength_stat_detailsWhereInput | Strength_stat_detailsWhereInput[]
    OR?: Strength_stat_detailsWhereInput[]
    NOT?: Strength_stat_detailsWhereInput | Strength_stat_detailsWhereInput[]
    value?: IntFilter<"Strength_stat_details"> | number
    mastery?: BoolFilter<"Strength_stat_details"> | boolean
    creature_stat?: XOR<Creature_statsScalarRelationFilter, Creature_statsWhereInput>
  }, "statblock_id">

  export type Strength_stat_detailsOrderByWithAggregationInput = {
    statblock_id?: SortOrder
    value?: SortOrder
    mastery?: SortOrder
    _count?: Strength_stat_detailsCountOrderByAggregateInput
    _avg?: Strength_stat_detailsAvgOrderByAggregateInput
    _max?: Strength_stat_detailsMaxOrderByAggregateInput
    _min?: Strength_stat_detailsMinOrderByAggregateInput
    _sum?: Strength_stat_detailsSumOrderByAggregateInput
  }

  export type Strength_stat_detailsScalarWhereWithAggregatesInput = {
    AND?: Strength_stat_detailsScalarWhereWithAggregatesInput | Strength_stat_detailsScalarWhereWithAggregatesInput[]
    OR?: Strength_stat_detailsScalarWhereWithAggregatesInput[]
    NOT?: Strength_stat_detailsScalarWhereWithAggregatesInput | Strength_stat_detailsScalarWhereWithAggregatesInput[]
    statblock_id?: StringWithAggregatesFilter<"Strength_stat_details"> | string
    value?: IntWithAggregatesFilter<"Strength_stat_details"> | number
    mastery?: BoolWithAggregatesFilter<"Strength_stat_details"> | boolean
  }

  export type Dexterity_stat_detailsWhereInput = {
    AND?: Dexterity_stat_detailsWhereInput | Dexterity_stat_detailsWhereInput[]
    OR?: Dexterity_stat_detailsWhereInput[]
    NOT?: Dexterity_stat_detailsWhereInput | Dexterity_stat_detailsWhereInput[]
    statblock_id?: StringFilter<"Dexterity_stat_details"> | string
    value?: IntFilter<"Dexterity_stat_details"> | number
    mastery?: BoolFilter<"Dexterity_stat_details"> | boolean
    creature_stat?: XOR<Creature_statsScalarRelationFilter, Creature_statsWhereInput>
  }

  export type Dexterity_stat_detailsOrderByWithRelationInput = {
    statblock_id?: SortOrder
    value?: SortOrder
    mastery?: SortOrder
    creature_stat?: Creature_statsOrderByWithRelationInput
  }

  export type Dexterity_stat_detailsWhereUniqueInput = Prisma.AtLeast<{
    statblock_id?: string
    AND?: Dexterity_stat_detailsWhereInput | Dexterity_stat_detailsWhereInput[]
    OR?: Dexterity_stat_detailsWhereInput[]
    NOT?: Dexterity_stat_detailsWhereInput | Dexterity_stat_detailsWhereInput[]
    value?: IntFilter<"Dexterity_stat_details"> | number
    mastery?: BoolFilter<"Dexterity_stat_details"> | boolean
    creature_stat?: XOR<Creature_statsScalarRelationFilter, Creature_statsWhereInput>
  }, "statblock_id">

  export type Dexterity_stat_detailsOrderByWithAggregationInput = {
    statblock_id?: SortOrder
    value?: SortOrder
    mastery?: SortOrder
    _count?: Dexterity_stat_detailsCountOrderByAggregateInput
    _avg?: Dexterity_stat_detailsAvgOrderByAggregateInput
    _max?: Dexterity_stat_detailsMaxOrderByAggregateInput
    _min?: Dexterity_stat_detailsMinOrderByAggregateInput
    _sum?: Dexterity_stat_detailsSumOrderByAggregateInput
  }

  export type Dexterity_stat_detailsScalarWhereWithAggregatesInput = {
    AND?: Dexterity_stat_detailsScalarWhereWithAggregatesInput | Dexterity_stat_detailsScalarWhereWithAggregatesInput[]
    OR?: Dexterity_stat_detailsScalarWhereWithAggregatesInput[]
    NOT?: Dexterity_stat_detailsScalarWhereWithAggregatesInput | Dexterity_stat_detailsScalarWhereWithAggregatesInput[]
    statblock_id?: StringWithAggregatesFilter<"Dexterity_stat_details"> | string
    value?: IntWithAggregatesFilter<"Dexterity_stat_details"> | number
    mastery?: BoolWithAggregatesFilter<"Dexterity_stat_details"> | boolean
  }

  export type Constitution_stat_detailsWhereInput = {
    AND?: Constitution_stat_detailsWhereInput | Constitution_stat_detailsWhereInput[]
    OR?: Constitution_stat_detailsWhereInput[]
    NOT?: Constitution_stat_detailsWhereInput | Constitution_stat_detailsWhereInput[]
    statblock_id?: StringFilter<"Constitution_stat_details"> | string
    value?: IntFilter<"Constitution_stat_details"> | number
    mastery?: BoolFilter<"Constitution_stat_details"> | boolean
    creature_stat?: XOR<Creature_statsScalarRelationFilter, Creature_statsWhereInput>
  }

  export type Constitution_stat_detailsOrderByWithRelationInput = {
    statblock_id?: SortOrder
    value?: SortOrder
    mastery?: SortOrder
    creature_stat?: Creature_statsOrderByWithRelationInput
  }

  export type Constitution_stat_detailsWhereUniqueInput = Prisma.AtLeast<{
    statblock_id?: string
    AND?: Constitution_stat_detailsWhereInput | Constitution_stat_detailsWhereInput[]
    OR?: Constitution_stat_detailsWhereInput[]
    NOT?: Constitution_stat_detailsWhereInput | Constitution_stat_detailsWhereInput[]
    value?: IntFilter<"Constitution_stat_details"> | number
    mastery?: BoolFilter<"Constitution_stat_details"> | boolean
    creature_stat?: XOR<Creature_statsScalarRelationFilter, Creature_statsWhereInput>
  }, "statblock_id">

  export type Constitution_stat_detailsOrderByWithAggregationInput = {
    statblock_id?: SortOrder
    value?: SortOrder
    mastery?: SortOrder
    _count?: Constitution_stat_detailsCountOrderByAggregateInput
    _avg?: Constitution_stat_detailsAvgOrderByAggregateInput
    _max?: Constitution_stat_detailsMaxOrderByAggregateInput
    _min?: Constitution_stat_detailsMinOrderByAggregateInput
    _sum?: Constitution_stat_detailsSumOrderByAggregateInput
  }

  export type Constitution_stat_detailsScalarWhereWithAggregatesInput = {
    AND?: Constitution_stat_detailsScalarWhereWithAggregatesInput | Constitution_stat_detailsScalarWhereWithAggregatesInput[]
    OR?: Constitution_stat_detailsScalarWhereWithAggregatesInput[]
    NOT?: Constitution_stat_detailsScalarWhereWithAggregatesInput | Constitution_stat_detailsScalarWhereWithAggregatesInput[]
    statblock_id?: StringWithAggregatesFilter<"Constitution_stat_details"> | string
    value?: IntWithAggregatesFilter<"Constitution_stat_details"> | number
    mastery?: BoolWithAggregatesFilter<"Constitution_stat_details"> | boolean
  }

  export type Intelligence_stat_detailsWhereInput = {
    AND?: Intelligence_stat_detailsWhereInput | Intelligence_stat_detailsWhereInput[]
    OR?: Intelligence_stat_detailsWhereInput[]
    NOT?: Intelligence_stat_detailsWhereInput | Intelligence_stat_detailsWhereInput[]
    statblock_id?: StringFilter<"Intelligence_stat_details"> | string
    value?: IntFilter<"Intelligence_stat_details"> | number
    mastery?: BoolFilter<"Intelligence_stat_details"> | boolean
    creature_stat?: XOR<Creature_statsScalarRelationFilter, Creature_statsWhereInput>
  }

  export type Intelligence_stat_detailsOrderByWithRelationInput = {
    statblock_id?: SortOrder
    value?: SortOrder
    mastery?: SortOrder
    creature_stat?: Creature_statsOrderByWithRelationInput
  }

  export type Intelligence_stat_detailsWhereUniqueInput = Prisma.AtLeast<{
    statblock_id?: string
    AND?: Intelligence_stat_detailsWhereInput | Intelligence_stat_detailsWhereInput[]
    OR?: Intelligence_stat_detailsWhereInput[]
    NOT?: Intelligence_stat_detailsWhereInput | Intelligence_stat_detailsWhereInput[]
    value?: IntFilter<"Intelligence_stat_details"> | number
    mastery?: BoolFilter<"Intelligence_stat_details"> | boolean
    creature_stat?: XOR<Creature_statsScalarRelationFilter, Creature_statsWhereInput>
  }, "statblock_id">

  export type Intelligence_stat_detailsOrderByWithAggregationInput = {
    statblock_id?: SortOrder
    value?: SortOrder
    mastery?: SortOrder
    _count?: Intelligence_stat_detailsCountOrderByAggregateInput
    _avg?: Intelligence_stat_detailsAvgOrderByAggregateInput
    _max?: Intelligence_stat_detailsMaxOrderByAggregateInput
    _min?: Intelligence_stat_detailsMinOrderByAggregateInput
    _sum?: Intelligence_stat_detailsSumOrderByAggregateInput
  }

  export type Intelligence_stat_detailsScalarWhereWithAggregatesInput = {
    AND?: Intelligence_stat_detailsScalarWhereWithAggregatesInput | Intelligence_stat_detailsScalarWhereWithAggregatesInput[]
    OR?: Intelligence_stat_detailsScalarWhereWithAggregatesInput[]
    NOT?: Intelligence_stat_detailsScalarWhereWithAggregatesInput | Intelligence_stat_detailsScalarWhereWithAggregatesInput[]
    statblock_id?: StringWithAggregatesFilter<"Intelligence_stat_details"> | string
    value?: IntWithAggregatesFilter<"Intelligence_stat_details"> | number
    mastery?: BoolWithAggregatesFilter<"Intelligence_stat_details"> | boolean
  }

  export type Wisdom_stat_detailsWhereInput = {
    AND?: Wisdom_stat_detailsWhereInput | Wisdom_stat_detailsWhereInput[]
    OR?: Wisdom_stat_detailsWhereInput[]
    NOT?: Wisdom_stat_detailsWhereInput | Wisdom_stat_detailsWhereInput[]
    statblock_id?: StringFilter<"Wisdom_stat_details"> | string
    value?: IntFilter<"Wisdom_stat_details"> | number
    mastery?: BoolFilter<"Wisdom_stat_details"> | boolean
    creature_stat?: XOR<Creature_statsScalarRelationFilter, Creature_statsWhereInput>
  }

  export type Wisdom_stat_detailsOrderByWithRelationInput = {
    statblock_id?: SortOrder
    value?: SortOrder
    mastery?: SortOrder
    creature_stat?: Creature_statsOrderByWithRelationInput
  }

  export type Wisdom_stat_detailsWhereUniqueInput = Prisma.AtLeast<{
    statblock_id?: string
    AND?: Wisdom_stat_detailsWhereInput | Wisdom_stat_detailsWhereInput[]
    OR?: Wisdom_stat_detailsWhereInput[]
    NOT?: Wisdom_stat_detailsWhereInput | Wisdom_stat_detailsWhereInput[]
    value?: IntFilter<"Wisdom_stat_details"> | number
    mastery?: BoolFilter<"Wisdom_stat_details"> | boolean
    creature_stat?: XOR<Creature_statsScalarRelationFilter, Creature_statsWhereInput>
  }, "statblock_id">

  export type Wisdom_stat_detailsOrderByWithAggregationInput = {
    statblock_id?: SortOrder
    value?: SortOrder
    mastery?: SortOrder
    _count?: Wisdom_stat_detailsCountOrderByAggregateInput
    _avg?: Wisdom_stat_detailsAvgOrderByAggregateInput
    _max?: Wisdom_stat_detailsMaxOrderByAggregateInput
    _min?: Wisdom_stat_detailsMinOrderByAggregateInput
    _sum?: Wisdom_stat_detailsSumOrderByAggregateInput
  }

  export type Wisdom_stat_detailsScalarWhereWithAggregatesInput = {
    AND?: Wisdom_stat_detailsScalarWhereWithAggregatesInput | Wisdom_stat_detailsScalarWhereWithAggregatesInput[]
    OR?: Wisdom_stat_detailsScalarWhereWithAggregatesInput[]
    NOT?: Wisdom_stat_detailsScalarWhereWithAggregatesInput | Wisdom_stat_detailsScalarWhereWithAggregatesInput[]
    statblock_id?: StringWithAggregatesFilter<"Wisdom_stat_details"> | string
    value?: IntWithAggregatesFilter<"Wisdom_stat_details"> | number
    mastery?: BoolWithAggregatesFilter<"Wisdom_stat_details"> | boolean
  }

  export type Charisma_stat_detailsWhereInput = {
    AND?: Charisma_stat_detailsWhereInput | Charisma_stat_detailsWhereInput[]
    OR?: Charisma_stat_detailsWhereInput[]
    NOT?: Charisma_stat_detailsWhereInput | Charisma_stat_detailsWhereInput[]
    statblock_id?: StringFilter<"Charisma_stat_details"> | string
    value?: IntFilter<"Charisma_stat_details"> | number
    mastery?: BoolFilter<"Charisma_stat_details"> | boolean
    creature_stat?: XOR<Creature_statsScalarRelationFilter, Creature_statsWhereInput>
  }

  export type Charisma_stat_detailsOrderByWithRelationInput = {
    statblock_id?: SortOrder
    value?: SortOrder
    mastery?: SortOrder
    creature_stat?: Creature_statsOrderByWithRelationInput
  }

  export type Charisma_stat_detailsWhereUniqueInput = Prisma.AtLeast<{
    statblock_id?: string
    AND?: Charisma_stat_detailsWhereInput | Charisma_stat_detailsWhereInput[]
    OR?: Charisma_stat_detailsWhereInput[]
    NOT?: Charisma_stat_detailsWhereInput | Charisma_stat_detailsWhereInput[]
    value?: IntFilter<"Charisma_stat_details"> | number
    mastery?: BoolFilter<"Charisma_stat_details"> | boolean
    creature_stat?: XOR<Creature_statsScalarRelationFilter, Creature_statsWhereInput>
  }, "statblock_id">

  export type Charisma_stat_detailsOrderByWithAggregationInput = {
    statblock_id?: SortOrder
    value?: SortOrder
    mastery?: SortOrder
    _count?: Charisma_stat_detailsCountOrderByAggregateInput
    _avg?: Charisma_stat_detailsAvgOrderByAggregateInput
    _max?: Charisma_stat_detailsMaxOrderByAggregateInput
    _min?: Charisma_stat_detailsMinOrderByAggregateInput
    _sum?: Charisma_stat_detailsSumOrderByAggregateInput
  }

  export type Charisma_stat_detailsScalarWhereWithAggregatesInput = {
    AND?: Charisma_stat_detailsScalarWhereWithAggregatesInput | Charisma_stat_detailsScalarWhereWithAggregatesInput[]
    OR?: Charisma_stat_detailsScalarWhereWithAggregatesInput[]
    NOT?: Charisma_stat_detailsScalarWhereWithAggregatesInput | Charisma_stat_detailsScalarWhereWithAggregatesInput[]
    statblock_id?: StringWithAggregatesFilter<"Charisma_stat_details"> | string
    value?: IntWithAggregatesFilter<"Charisma_stat_details"> | number
    mastery?: BoolWithAggregatesFilter<"Charisma_stat_details"> | boolean
  }

  export type SkillsListWhereInput = {
    AND?: SkillsListWhereInput | SkillsListWhereInput[]
    OR?: SkillsListWhereInput[]
    NOT?: SkillsListWhereInput | SkillsListWhereInput[]
    id?: StringFilter<"SkillsList"> | string
    strength?: XOR<StrengthBasedSkillsNullableScalarRelationFilter, StrengthBasedSkillsWhereInput> | null
    dexterity?: XOR<DexterityBasedSkillsNullableScalarRelationFilter, DexterityBasedSkillsWhereInput> | null
    intelligence?: XOR<IntellengenceBasedSkillsNullableScalarRelationFilter, IntellengenceBasedSkillsWhereInput> | null
    wisdom?: XOR<WisdomBasedSkillsNullableScalarRelationFilter, WisdomBasedSkillsWhereInput> | null
    charisma?: XOR<CharismaBasedSkillsNullableScalarRelationFilter, CharismaBasedSkillsWhereInput> | null
    id_relation?: XOR<CreatureScalarRelationFilter, CreatureWhereInput>
  }

  export type SkillsListOrderByWithRelationInput = {
    id?: SortOrder
    strength?: StrengthBasedSkillsOrderByWithRelationInput
    dexterity?: DexterityBasedSkillsOrderByWithRelationInput
    intelligence?: IntellengenceBasedSkillsOrderByWithRelationInput
    wisdom?: WisdomBasedSkillsOrderByWithRelationInput
    charisma?: CharismaBasedSkillsOrderByWithRelationInput
    id_relation?: CreatureOrderByWithRelationInput
  }

  export type SkillsListWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SkillsListWhereInput | SkillsListWhereInput[]
    OR?: SkillsListWhereInput[]
    NOT?: SkillsListWhereInput | SkillsListWhereInput[]
    strength?: XOR<StrengthBasedSkillsNullableScalarRelationFilter, StrengthBasedSkillsWhereInput> | null
    dexterity?: XOR<DexterityBasedSkillsNullableScalarRelationFilter, DexterityBasedSkillsWhereInput> | null
    intelligence?: XOR<IntellengenceBasedSkillsNullableScalarRelationFilter, IntellengenceBasedSkillsWhereInput> | null
    wisdom?: XOR<WisdomBasedSkillsNullableScalarRelationFilter, WisdomBasedSkillsWhereInput> | null
    charisma?: XOR<CharismaBasedSkillsNullableScalarRelationFilter, CharismaBasedSkillsWhereInput> | null
    id_relation?: XOR<CreatureScalarRelationFilter, CreatureWhereInput>
  }, "id">

  export type SkillsListOrderByWithAggregationInput = {
    id?: SortOrder
    _count?: SkillsListCountOrderByAggregateInput
    _max?: SkillsListMaxOrderByAggregateInput
    _min?: SkillsListMinOrderByAggregateInput
  }

  export type SkillsListScalarWhereWithAggregatesInput = {
    AND?: SkillsListScalarWhereWithAggregatesInput | SkillsListScalarWhereWithAggregatesInput[]
    OR?: SkillsListScalarWhereWithAggregatesInput[]
    NOT?: SkillsListScalarWhereWithAggregatesInput | SkillsListScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SkillsList"> | string
  }

  export type StrengthBasedSkillsWhereInput = {
    AND?: StrengthBasedSkillsWhereInput | StrengthBasedSkillsWhereInput[]
    OR?: StrengthBasedSkillsWhereInput[]
    NOT?: StrengthBasedSkillsWhereInput | StrengthBasedSkillsWhereInput[]
    id?: StringFilter<"StrengthBasedSkills"> | string
    athletics?: XOR<AthleticsSkillNullableScalarRelationFilter, AthleticsSkillWhereInput> | null
    skills_list_relation?: XOR<SkillsListScalarRelationFilter, SkillsListWhereInput>
  }

  export type StrengthBasedSkillsOrderByWithRelationInput = {
    id?: SortOrder
    athletics?: AthleticsSkillOrderByWithRelationInput
    skills_list_relation?: SkillsListOrderByWithRelationInput
  }

  export type StrengthBasedSkillsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: StrengthBasedSkillsWhereInput | StrengthBasedSkillsWhereInput[]
    OR?: StrengthBasedSkillsWhereInput[]
    NOT?: StrengthBasedSkillsWhereInput | StrengthBasedSkillsWhereInput[]
    athletics?: XOR<AthleticsSkillNullableScalarRelationFilter, AthleticsSkillWhereInput> | null
    skills_list_relation?: XOR<SkillsListScalarRelationFilter, SkillsListWhereInput>
  }, "id">

  export type StrengthBasedSkillsOrderByWithAggregationInput = {
    id?: SortOrder
    _count?: StrengthBasedSkillsCountOrderByAggregateInput
    _max?: StrengthBasedSkillsMaxOrderByAggregateInput
    _min?: StrengthBasedSkillsMinOrderByAggregateInput
  }

  export type StrengthBasedSkillsScalarWhereWithAggregatesInput = {
    AND?: StrengthBasedSkillsScalarWhereWithAggregatesInput | StrengthBasedSkillsScalarWhereWithAggregatesInput[]
    OR?: StrengthBasedSkillsScalarWhereWithAggregatesInput[]
    NOT?: StrengthBasedSkillsScalarWhereWithAggregatesInput | StrengthBasedSkillsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"StrengthBasedSkills"> | string
  }

  export type DexterityBasedSkillsWhereInput = {
    AND?: DexterityBasedSkillsWhereInput | DexterityBasedSkillsWhereInput[]
    OR?: DexterityBasedSkillsWhereInput[]
    NOT?: DexterityBasedSkillsWhereInput | DexterityBasedSkillsWhereInput[]
    id?: StringFilter<"DexterityBasedSkills"> | string
    acrobatics?: XOR<AcrobaticsSkillNullableScalarRelationFilter, AcrobaticsSkillWhereInput> | null
    sleight_of_hand?: XOR<SleightOfHandSkillNullableScalarRelationFilter, SleightOfHandSkillWhereInput> | null
    stealth?: XOR<StealthSkillNullableScalarRelationFilter, StealthSkillWhereInput> | null
    skills_list_relation?: XOR<SkillsListScalarRelationFilter, SkillsListWhereInput>
  }

  export type DexterityBasedSkillsOrderByWithRelationInput = {
    id?: SortOrder
    acrobatics?: AcrobaticsSkillOrderByWithRelationInput
    sleight_of_hand?: SleightOfHandSkillOrderByWithRelationInput
    stealth?: StealthSkillOrderByWithRelationInput
    skills_list_relation?: SkillsListOrderByWithRelationInput
  }

  export type DexterityBasedSkillsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: DexterityBasedSkillsWhereInput | DexterityBasedSkillsWhereInput[]
    OR?: DexterityBasedSkillsWhereInput[]
    NOT?: DexterityBasedSkillsWhereInput | DexterityBasedSkillsWhereInput[]
    acrobatics?: XOR<AcrobaticsSkillNullableScalarRelationFilter, AcrobaticsSkillWhereInput> | null
    sleight_of_hand?: XOR<SleightOfHandSkillNullableScalarRelationFilter, SleightOfHandSkillWhereInput> | null
    stealth?: XOR<StealthSkillNullableScalarRelationFilter, StealthSkillWhereInput> | null
    skills_list_relation?: XOR<SkillsListScalarRelationFilter, SkillsListWhereInput>
  }, "id">

  export type DexterityBasedSkillsOrderByWithAggregationInput = {
    id?: SortOrder
    _count?: DexterityBasedSkillsCountOrderByAggregateInput
    _max?: DexterityBasedSkillsMaxOrderByAggregateInput
    _min?: DexterityBasedSkillsMinOrderByAggregateInput
  }

  export type DexterityBasedSkillsScalarWhereWithAggregatesInput = {
    AND?: DexterityBasedSkillsScalarWhereWithAggregatesInput | DexterityBasedSkillsScalarWhereWithAggregatesInput[]
    OR?: DexterityBasedSkillsScalarWhereWithAggregatesInput[]
    NOT?: DexterityBasedSkillsScalarWhereWithAggregatesInput | DexterityBasedSkillsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"DexterityBasedSkills"> | string
  }

  export type IntellengenceBasedSkillsWhereInput = {
    AND?: IntellengenceBasedSkillsWhereInput | IntellengenceBasedSkillsWhereInput[]
    OR?: IntellengenceBasedSkillsWhereInput[]
    NOT?: IntellengenceBasedSkillsWhereInput | IntellengenceBasedSkillsWhereInput[]
    id?: StringFilter<"IntellengenceBasedSkills"> | string
    arcana?: XOR<ArcanaSkillNullableScalarRelationFilter, ArcanaSkillWhereInput> | null
    history?: XOR<HistorySkillNullableScalarRelationFilter, HistorySkillWhereInput> | null
    investigation?: XOR<InvestigationSkillNullableScalarRelationFilter, InvestigationSkillWhereInput> | null
    nature?: XOR<NatureSkillNullableScalarRelationFilter, NatureSkillWhereInput> | null
    religion?: XOR<ReligionSkillNullableScalarRelationFilter, ReligionSkillWhereInput> | null
    skills_list_relation?: XOR<SkillsListScalarRelationFilter, SkillsListWhereInput>
  }

  export type IntellengenceBasedSkillsOrderByWithRelationInput = {
    id?: SortOrder
    arcana?: ArcanaSkillOrderByWithRelationInput
    history?: HistorySkillOrderByWithRelationInput
    investigation?: InvestigationSkillOrderByWithRelationInput
    nature?: NatureSkillOrderByWithRelationInput
    religion?: ReligionSkillOrderByWithRelationInput
    skills_list_relation?: SkillsListOrderByWithRelationInput
  }

  export type IntellengenceBasedSkillsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: IntellengenceBasedSkillsWhereInput | IntellengenceBasedSkillsWhereInput[]
    OR?: IntellengenceBasedSkillsWhereInput[]
    NOT?: IntellengenceBasedSkillsWhereInput | IntellengenceBasedSkillsWhereInput[]
    arcana?: XOR<ArcanaSkillNullableScalarRelationFilter, ArcanaSkillWhereInput> | null
    history?: XOR<HistorySkillNullableScalarRelationFilter, HistorySkillWhereInput> | null
    investigation?: XOR<InvestigationSkillNullableScalarRelationFilter, InvestigationSkillWhereInput> | null
    nature?: XOR<NatureSkillNullableScalarRelationFilter, NatureSkillWhereInput> | null
    religion?: XOR<ReligionSkillNullableScalarRelationFilter, ReligionSkillWhereInput> | null
    skills_list_relation?: XOR<SkillsListScalarRelationFilter, SkillsListWhereInput>
  }, "id">

  export type IntellengenceBasedSkillsOrderByWithAggregationInput = {
    id?: SortOrder
    _count?: IntellengenceBasedSkillsCountOrderByAggregateInput
    _max?: IntellengenceBasedSkillsMaxOrderByAggregateInput
    _min?: IntellengenceBasedSkillsMinOrderByAggregateInput
  }

  export type IntellengenceBasedSkillsScalarWhereWithAggregatesInput = {
    AND?: IntellengenceBasedSkillsScalarWhereWithAggregatesInput | IntellengenceBasedSkillsScalarWhereWithAggregatesInput[]
    OR?: IntellengenceBasedSkillsScalarWhereWithAggregatesInput[]
    NOT?: IntellengenceBasedSkillsScalarWhereWithAggregatesInput | IntellengenceBasedSkillsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"IntellengenceBasedSkills"> | string
  }

  export type WisdomBasedSkillsWhereInput = {
    AND?: WisdomBasedSkillsWhereInput | WisdomBasedSkillsWhereInput[]
    OR?: WisdomBasedSkillsWhereInput[]
    NOT?: WisdomBasedSkillsWhereInput | WisdomBasedSkillsWhereInput[]
    id?: StringFilter<"WisdomBasedSkills"> | string
    animal_handling?: XOR<AnimalHandlingSkillNullableScalarRelationFilter, AnimalHandlingSkillWhereInput> | null
    insight?: XOR<InsightSkillNullableScalarRelationFilter, InsightSkillWhereInput> | null
    medicine?: XOR<MedicineSkillNullableScalarRelationFilter, MedicineSkillWhereInput> | null
    perception?: XOR<PerceptionSkillNullableScalarRelationFilter, PerceptionSkillWhereInput> | null
    survival?: XOR<SurvivalSkillNullableScalarRelationFilter, SurvivalSkillWhereInput> | null
    skills_list_relation?: XOR<SkillsListScalarRelationFilter, SkillsListWhereInput>
  }

  export type WisdomBasedSkillsOrderByWithRelationInput = {
    id?: SortOrder
    animal_handling?: AnimalHandlingSkillOrderByWithRelationInput
    insight?: InsightSkillOrderByWithRelationInput
    medicine?: MedicineSkillOrderByWithRelationInput
    perception?: PerceptionSkillOrderByWithRelationInput
    survival?: SurvivalSkillOrderByWithRelationInput
    skills_list_relation?: SkillsListOrderByWithRelationInput
  }

  export type WisdomBasedSkillsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: WisdomBasedSkillsWhereInput | WisdomBasedSkillsWhereInput[]
    OR?: WisdomBasedSkillsWhereInput[]
    NOT?: WisdomBasedSkillsWhereInput | WisdomBasedSkillsWhereInput[]
    animal_handling?: XOR<AnimalHandlingSkillNullableScalarRelationFilter, AnimalHandlingSkillWhereInput> | null
    insight?: XOR<InsightSkillNullableScalarRelationFilter, InsightSkillWhereInput> | null
    medicine?: XOR<MedicineSkillNullableScalarRelationFilter, MedicineSkillWhereInput> | null
    perception?: XOR<PerceptionSkillNullableScalarRelationFilter, PerceptionSkillWhereInput> | null
    survival?: XOR<SurvivalSkillNullableScalarRelationFilter, SurvivalSkillWhereInput> | null
    skills_list_relation?: XOR<SkillsListScalarRelationFilter, SkillsListWhereInput>
  }, "id">

  export type WisdomBasedSkillsOrderByWithAggregationInput = {
    id?: SortOrder
    _count?: WisdomBasedSkillsCountOrderByAggregateInput
    _max?: WisdomBasedSkillsMaxOrderByAggregateInput
    _min?: WisdomBasedSkillsMinOrderByAggregateInput
  }

  export type WisdomBasedSkillsScalarWhereWithAggregatesInput = {
    AND?: WisdomBasedSkillsScalarWhereWithAggregatesInput | WisdomBasedSkillsScalarWhereWithAggregatesInput[]
    OR?: WisdomBasedSkillsScalarWhereWithAggregatesInput[]
    NOT?: WisdomBasedSkillsScalarWhereWithAggregatesInput | WisdomBasedSkillsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"WisdomBasedSkills"> | string
  }

  export type CharismaBasedSkillsWhereInput = {
    AND?: CharismaBasedSkillsWhereInput | CharismaBasedSkillsWhereInput[]
    OR?: CharismaBasedSkillsWhereInput[]
    NOT?: CharismaBasedSkillsWhereInput | CharismaBasedSkillsWhereInput[]
    id?: StringFilter<"CharismaBasedSkills"> | string
    deception?: XOR<DeceptionSkillNullableScalarRelationFilter, DeceptionSkillWhereInput> | null
    intimidation?: XOR<IntimidationSkillNullableScalarRelationFilter, IntimidationSkillWhereInput> | null
    performance?: XOR<PerformanceSkillNullableScalarRelationFilter, PerformanceSkillWhereInput> | null
    persuasion?: XOR<PersuasionSkillNullableScalarRelationFilter, PersuasionSkillWhereInput> | null
    skills_list_relation?: XOR<SkillsListScalarRelationFilter, SkillsListWhereInput>
  }

  export type CharismaBasedSkillsOrderByWithRelationInput = {
    id?: SortOrder
    deception?: DeceptionSkillOrderByWithRelationInput
    intimidation?: IntimidationSkillOrderByWithRelationInput
    performance?: PerformanceSkillOrderByWithRelationInput
    persuasion?: PersuasionSkillOrderByWithRelationInput
    skills_list_relation?: SkillsListOrderByWithRelationInput
  }

  export type CharismaBasedSkillsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CharismaBasedSkillsWhereInput | CharismaBasedSkillsWhereInput[]
    OR?: CharismaBasedSkillsWhereInput[]
    NOT?: CharismaBasedSkillsWhereInput | CharismaBasedSkillsWhereInput[]
    deception?: XOR<DeceptionSkillNullableScalarRelationFilter, DeceptionSkillWhereInput> | null
    intimidation?: XOR<IntimidationSkillNullableScalarRelationFilter, IntimidationSkillWhereInput> | null
    performance?: XOR<PerformanceSkillNullableScalarRelationFilter, PerformanceSkillWhereInput> | null
    persuasion?: XOR<PersuasionSkillNullableScalarRelationFilter, PersuasionSkillWhereInput> | null
    skills_list_relation?: XOR<SkillsListScalarRelationFilter, SkillsListWhereInput>
  }, "id">

  export type CharismaBasedSkillsOrderByWithAggregationInput = {
    id?: SortOrder
    _count?: CharismaBasedSkillsCountOrderByAggregateInput
    _max?: CharismaBasedSkillsMaxOrderByAggregateInput
    _min?: CharismaBasedSkillsMinOrderByAggregateInput
  }

  export type CharismaBasedSkillsScalarWhereWithAggregatesInput = {
    AND?: CharismaBasedSkillsScalarWhereWithAggregatesInput | CharismaBasedSkillsScalarWhereWithAggregatesInput[]
    OR?: CharismaBasedSkillsScalarWhereWithAggregatesInput[]
    NOT?: CharismaBasedSkillsScalarWhereWithAggregatesInput | CharismaBasedSkillsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CharismaBasedSkills"> | string
  }

  export type AthleticsSkillWhereInput = {
    AND?: AthleticsSkillWhereInput | AthleticsSkillWhereInput[]
    OR?: AthleticsSkillWhereInput[]
    NOT?: AthleticsSkillWhereInput | AthleticsSkillWhereInput[]
    id?: StringFilter<"AthleticsSkill"> | string
    value?: IntNullableFilter<"AthleticsSkill"> | number | null
    mastery?: BoolFilter<"AthleticsSkill"> | boolean
    name?: StringFilter<"AthleticsSkill"> | string
    skill_list?: XOR<StrengthBasedSkillsScalarRelationFilter, StrengthBasedSkillsWhereInput>
  }

  export type AthleticsSkillOrderByWithRelationInput = {
    id?: SortOrder
    value?: SortOrderInput | SortOrder
    mastery?: SortOrder
    name?: SortOrder
    skill_list?: StrengthBasedSkillsOrderByWithRelationInput
  }

  export type AthleticsSkillWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AthleticsSkillWhereInput | AthleticsSkillWhereInput[]
    OR?: AthleticsSkillWhereInput[]
    NOT?: AthleticsSkillWhereInput | AthleticsSkillWhereInput[]
    value?: IntNullableFilter<"AthleticsSkill"> | number | null
    mastery?: BoolFilter<"AthleticsSkill"> | boolean
    name?: StringFilter<"AthleticsSkill"> | string
    skill_list?: XOR<StrengthBasedSkillsScalarRelationFilter, StrengthBasedSkillsWhereInput>
  }, "id">

  export type AthleticsSkillOrderByWithAggregationInput = {
    id?: SortOrder
    value?: SortOrderInput | SortOrder
    mastery?: SortOrder
    name?: SortOrder
    _count?: AthleticsSkillCountOrderByAggregateInput
    _avg?: AthleticsSkillAvgOrderByAggregateInput
    _max?: AthleticsSkillMaxOrderByAggregateInput
    _min?: AthleticsSkillMinOrderByAggregateInput
    _sum?: AthleticsSkillSumOrderByAggregateInput
  }

  export type AthleticsSkillScalarWhereWithAggregatesInput = {
    AND?: AthleticsSkillScalarWhereWithAggregatesInput | AthleticsSkillScalarWhereWithAggregatesInput[]
    OR?: AthleticsSkillScalarWhereWithAggregatesInput[]
    NOT?: AthleticsSkillScalarWhereWithAggregatesInput | AthleticsSkillScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AthleticsSkill"> | string
    value?: IntNullableWithAggregatesFilter<"AthleticsSkill"> | number | null
    mastery?: BoolWithAggregatesFilter<"AthleticsSkill"> | boolean
    name?: StringWithAggregatesFilter<"AthleticsSkill"> | string
  }

  export type AcrobaticsSkillWhereInput = {
    AND?: AcrobaticsSkillWhereInput | AcrobaticsSkillWhereInput[]
    OR?: AcrobaticsSkillWhereInput[]
    NOT?: AcrobaticsSkillWhereInput | AcrobaticsSkillWhereInput[]
    id?: StringFilter<"AcrobaticsSkill"> | string
    value?: IntNullableFilter<"AcrobaticsSkill"> | number | null
    mastery?: BoolFilter<"AcrobaticsSkill"> | boolean
    name?: StringFilter<"AcrobaticsSkill"> | string
    skill_list?: XOR<DexterityBasedSkillsScalarRelationFilter, DexterityBasedSkillsWhereInput>
  }

  export type AcrobaticsSkillOrderByWithRelationInput = {
    id?: SortOrder
    value?: SortOrderInput | SortOrder
    mastery?: SortOrder
    name?: SortOrder
    skill_list?: DexterityBasedSkillsOrderByWithRelationInput
  }

  export type AcrobaticsSkillWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AcrobaticsSkillWhereInput | AcrobaticsSkillWhereInput[]
    OR?: AcrobaticsSkillWhereInput[]
    NOT?: AcrobaticsSkillWhereInput | AcrobaticsSkillWhereInput[]
    value?: IntNullableFilter<"AcrobaticsSkill"> | number | null
    mastery?: BoolFilter<"AcrobaticsSkill"> | boolean
    name?: StringFilter<"AcrobaticsSkill"> | string
    skill_list?: XOR<DexterityBasedSkillsScalarRelationFilter, DexterityBasedSkillsWhereInput>
  }, "id">

  export type AcrobaticsSkillOrderByWithAggregationInput = {
    id?: SortOrder
    value?: SortOrderInput | SortOrder
    mastery?: SortOrder
    name?: SortOrder
    _count?: AcrobaticsSkillCountOrderByAggregateInput
    _avg?: AcrobaticsSkillAvgOrderByAggregateInput
    _max?: AcrobaticsSkillMaxOrderByAggregateInput
    _min?: AcrobaticsSkillMinOrderByAggregateInput
    _sum?: AcrobaticsSkillSumOrderByAggregateInput
  }

  export type AcrobaticsSkillScalarWhereWithAggregatesInput = {
    AND?: AcrobaticsSkillScalarWhereWithAggregatesInput | AcrobaticsSkillScalarWhereWithAggregatesInput[]
    OR?: AcrobaticsSkillScalarWhereWithAggregatesInput[]
    NOT?: AcrobaticsSkillScalarWhereWithAggregatesInput | AcrobaticsSkillScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AcrobaticsSkill"> | string
    value?: IntNullableWithAggregatesFilter<"AcrobaticsSkill"> | number | null
    mastery?: BoolWithAggregatesFilter<"AcrobaticsSkill"> | boolean
    name?: StringWithAggregatesFilter<"AcrobaticsSkill"> | string
  }

  export type SleightOfHandSkillWhereInput = {
    AND?: SleightOfHandSkillWhereInput | SleightOfHandSkillWhereInput[]
    OR?: SleightOfHandSkillWhereInput[]
    NOT?: SleightOfHandSkillWhereInput | SleightOfHandSkillWhereInput[]
    id?: StringFilter<"SleightOfHandSkill"> | string
    value?: IntNullableFilter<"SleightOfHandSkill"> | number | null
    mastery?: BoolFilter<"SleightOfHandSkill"> | boolean
    name?: StringFilter<"SleightOfHandSkill"> | string
    skill_list?: XOR<DexterityBasedSkillsScalarRelationFilter, DexterityBasedSkillsWhereInput>
  }

  export type SleightOfHandSkillOrderByWithRelationInput = {
    id?: SortOrder
    value?: SortOrderInput | SortOrder
    mastery?: SortOrder
    name?: SortOrder
    skill_list?: DexterityBasedSkillsOrderByWithRelationInput
  }

  export type SleightOfHandSkillWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SleightOfHandSkillWhereInput | SleightOfHandSkillWhereInput[]
    OR?: SleightOfHandSkillWhereInput[]
    NOT?: SleightOfHandSkillWhereInput | SleightOfHandSkillWhereInput[]
    value?: IntNullableFilter<"SleightOfHandSkill"> | number | null
    mastery?: BoolFilter<"SleightOfHandSkill"> | boolean
    name?: StringFilter<"SleightOfHandSkill"> | string
    skill_list?: XOR<DexterityBasedSkillsScalarRelationFilter, DexterityBasedSkillsWhereInput>
  }, "id">

  export type SleightOfHandSkillOrderByWithAggregationInput = {
    id?: SortOrder
    value?: SortOrderInput | SortOrder
    mastery?: SortOrder
    name?: SortOrder
    _count?: SleightOfHandSkillCountOrderByAggregateInput
    _avg?: SleightOfHandSkillAvgOrderByAggregateInput
    _max?: SleightOfHandSkillMaxOrderByAggregateInput
    _min?: SleightOfHandSkillMinOrderByAggregateInput
    _sum?: SleightOfHandSkillSumOrderByAggregateInput
  }

  export type SleightOfHandSkillScalarWhereWithAggregatesInput = {
    AND?: SleightOfHandSkillScalarWhereWithAggregatesInput | SleightOfHandSkillScalarWhereWithAggregatesInput[]
    OR?: SleightOfHandSkillScalarWhereWithAggregatesInput[]
    NOT?: SleightOfHandSkillScalarWhereWithAggregatesInput | SleightOfHandSkillScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SleightOfHandSkill"> | string
    value?: IntNullableWithAggregatesFilter<"SleightOfHandSkill"> | number | null
    mastery?: BoolWithAggregatesFilter<"SleightOfHandSkill"> | boolean
    name?: StringWithAggregatesFilter<"SleightOfHandSkill"> | string
  }

  export type StealthSkillWhereInput = {
    AND?: StealthSkillWhereInput | StealthSkillWhereInput[]
    OR?: StealthSkillWhereInput[]
    NOT?: StealthSkillWhereInput | StealthSkillWhereInput[]
    id?: StringFilter<"StealthSkill"> | string
    value?: IntNullableFilter<"StealthSkill"> | number | null
    mastery?: BoolFilter<"StealthSkill"> | boolean
    name?: StringFilter<"StealthSkill"> | string
    skill_list?: XOR<DexterityBasedSkillsScalarRelationFilter, DexterityBasedSkillsWhereInput>
  }

  export type StealthSkillOrderByWithRelationInput = {
    id?: SortOrder
    value?: SortOrderInput | SortOrder
    mastery?: SortOrder
    name?: SortOrder
    skill_list?: DexterityBasedSkillsOrderByWithRelationInput
  }

  export type StealthSkillWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: StealthSkillWhereInput | StealthSkillWhereInput[]
    OR?: StealthSkillWhereInput[]
    NOT?: StealthSkillWhereInput | StealthSkillWhereInput[]
    value?: IntNullableFilter<"StealthSkill"> | number | null
    mastery?: BoolFilter<"StealthSkill"> | boolean
    name?: StringFilter<"StealthSkill"> | string
    skill_list?: XOR<DexterityBasedSkillsScalarRelationFilter, DexterityBasedSkillsWhereInput>
  }, "id">

  export type StealthSkillOrderByWithAggregationInput = {
    id?: SortOrder
    value?: SortOrderInput | SortOrder
    mastery?: SortOrder
    name?: SortOrder
    _count?: StealthSkillCountOrderByAggregateInput
    _avg?: StealthSkillAvgOrderByAggregateInput
    _max?: StealthSkillMaxOrderByAggregateInput
    _min?: StealthSkillMinOrderByAggregateInput
    _sum?: StealthSkillSumOrderByAggregateInput
  }

  export type StealthSkillScalarWhereWithAggregatesInput = {
    AND?: StealthSkillScalarWhereWithAggregatesInput | StealthSkillScalarWhereWithAggregatesInput[]
    OR?: StealthSkillScalarWhereWithAggregatesInput[]
    NOT?: StealthSkillScalarWhereWithAggregatesInput | StealthSkillScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"StealthSkill"> | string
    value?: IntNullableWithAggregatesFilter<"StealthSkill"> | number | null
    mastery?: BoolWithAggregatesFilter<"StealthSkill"> | boolean
    name?: StringWithAggregatesFilter<"StealthSkill"> | string
  }

  export type ArcanaSkillWhereInput = {
    AND?: ArcanaSkillWhereInput | ArcanaSkillWhereInput[]
    OR?: ArcanaSkillWhereInput[]
    NOT?: ArcanaSkillWhereInput | ArcanaSkillWhereInput[]
    id?: StringFilter<"ArcanaSkill"> | string
    value?: IntNullableFilter<"ArcanaSkill"> | number | null
    mastery?: BoolFilter<"ArcanaSkill"> | boolean
    name?: StringFilter<"ArcanaSkill"> | string
    skill_list?: XOR<IntellengenceBasedSkillsScalarRelationFilter, IntellengenceBasedSkillsWhereInput>
  }

  export type ArcanaSkillOrderByWithRelationInput = {
    id?: SortOrder
    value?: SortOrderInput | SortOrder
    mastery?: SortOrder
    name?: SortOrder
    skill_list?: IntellengenceBasedSkillsOrderByWithRelationInput
  }

  export type ArcanaSkillWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ArcanaSkillWhereInput | ArcanaSkillWhereInput[]
    OR?: ArcanaSkillWhereInput[]
    NOT?: ArcanaSkillWhereInput | ArcanaSkillWhereInput[]
    value?: IntNullableFilter<"ArcanaSkill"> | number | null
    mastery?: BoolFilter<"ArcanaSkill"> | boolean
    name?: StringFilter<"ArcanaSkill"> | string
    skill_list?: XOR<IntellengenceBasedSkillsScalarRelationFilter, IntellengenceBasedSkillsWhereInput>
  }, "id">

  export type ArcanaSkillOrderByWithAggregationInput = {
    id?: SortOrder
    value?: SortOrderInput | SortOrder
    mastery?: SortOrder
    name?: SortOrder
    _count?: ArcanaSkillCountOrderByAggregateInput
    _avg?: ArcanaSkillAvgOrderByAggregateInput
    _max?: ArcanaSkillMaxOrderByAggregateInput
    _min?: ArcanaSkillMinOrderByAggregateInput
    _sum?: ArcanaSkillSumOrderByAggregateInput
  }

  export type ArcanaSkillScalarWhereWithAggregatesInput = {
    AND?: ArcanaSkillScalarWhereWithAggregatesInput | ArcanaSkillScalarWhereWithAggregatesInput[]
    OR?: ArcanaSkillScalarWhereWithAggregatesInput[]
    NOT?: ArcanaSkillScalarWhereWithAggregatesInput | ArcanaSkillScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ArcanaSkill"> | string
    value?: IntNullableWithAggregatesFilter<"ArcanaSkill"> | number | null
    mastery?: BoolWithAggregatesFilter<"ArcanaSkill"> | boolean
    name?: StringWithAggregatesFilter<"ArcanaSkill"> | string
  }

  export type HistorySkillWhereInput = {
    AND?: HistorySkillWhereInput | HistorySkillWhereInput[]
    OR?: HistorySkillWhereInput[]
    NOT?: HistorySkillWhereInput | HistorySkillWhereInput[]
    id?: StringFilter<"HistorySkill"> | string
    value?: IntNullableFilter<"HistorySkill"> | number | null
    mastery?: BoolFilter<"HistorySkill"> | boolean
    name?: StringFilter<"HistorySkill"> | string
    skill_list?: XOR<IntellengenceBasedSkillsScalarRelationFilter, IntellengenceBasedSkillsWhereInput>
  }

  export type HistorySkillOrderByWithRelationInput = {
    id?: SortOrder
    value?: SortOrderInput | SortOrder
    mastery?: SortOrder
    name?: SortOrder
    skill_list?: IntellengenceBasedSkillsOrderByWithRelationInput
  }

  export type HistorySkillWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: HistorySkillWhereInput | HistorySkillWhereInput[]
    OR?: HistorySkillWhereInput[]
    NOT?: HistorySkillWhereInput | HistorySkillWhereInput[]
    value?: IntNullableFilter<"HistorySkill"> | number | null
    mastery?: BoolFilter<"HistorySkill"> | boolean
    name?: StringFilter<"HistorySkill"> | string
    skill_list?: XOR<IntellengenceBasedSkillsScalarRelationFilter, IntellengenceBasedSkillsWhereInput>
  }, "id">

  export type HistorySkillOrderByWithAggregationInput = {
    id?: SortOrder
    value?: SortOrderInput | SortOrder
    mastery?: SortOrder
    name?: SortOrder
    _count?: HistorySkillCountOrderByAggregateInput
    _avg?: HistorySkillAvgOrderByAggregateInput
    _max?: HistorySkillMaxOrderByAggregateInput
    _min?: HistorySkillMinOrderByAggregateInput
    _sum?: HistorySkillSumOrderByAggregateInput
  }

  export type HistorySkillScalarWhereWithAggregatesInput = {
    AND?: HistorySkillScalarWhereWithAggregatesInput | HistorySkillScalarWhereWithAggregatesInput[]
    OR?: HistorySkillScalarWhereWithAggregatesInput[]
    NOT?: HistorySkillScalarWhereWithAggregatesInput | HistorySkillScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"HistorySkill"> | string
    value?: IntNullableWithAggregatesFilter<"HistorySkill"> | number | null
    mastery?: BoolWithAggregatesFilter<"HistorySkill"> | boolean
    name?: StringWithAggregatesFilter<"HistorySkill"> | string
  }

  export type InvestigationSkillWhereInput = {
    AND?: InvestigationSkillWhereInput | InvestigationSkillWhereInput[]
    OR?: InvestigationSkillWhereInput[]
    NOT?: InvestigationSkillWhereInput | InvestigationSkillWhereInput[]
    id?: StringFilter<"InvestigationSkill"> | string
    value?: IntNullableFilter<"InvestigationSkill"> | number | null
    mastery?: BoolFilter<"InvestigationSkill"> | boolean
    name?: StringFilter<"InvestigationSkill"> | string
    skill_list?: XOR<IntellengenceBasedSkillsScalarRelationFilter, IntellengenceBasedSkillsWhereInput>
  }

  export type InvestigationSkillOrderByWithRelationInput = {
    id?: SortOrder
    value?: SortOrderInput | SortOrder
    mastery?: SortOrder
    name?: SortOrder
    skill_list?: IntellengenceBasedSkillsOrderByWithRelationInput
  }

  export type InvestigationSkillWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: InvestigationSkillWhereInput | InvestigationSkillWhereInput[]
    OR?: InvestigationSkillWhereInput[]
    NOT?: InvestigationSkillWhereInput | InvestigationSkillWhereInput[]
    value?: IntNullableFilter<"InvestigationSkill"> | number | null
    mastery?: BoolFilter<"InvestigationSkill"> | boolean
    name?: StringFilter<"InvestigationSkill"> | string
    skill_list?: XOR<IntellengenceBasedSkillsScalarRelationFilter, IntellengenceBasedSkillsWhereInput>
  }, "id">

  export type InvestigationSkillOrderByWithAggregationInput = {
    id?: SortOrder
    value?: SortOrderInput | SortOrder
    mastery?: SortOrder
    name?: SortOrder
    _count?: InvestigationSkillCountOrderByAggregateInput
    _avg?: InvestigationSkillAvgOrderByAggregateInput
    _max?: InvestigationSkillMaxOrderByAggregateInput
    _min?: InvestigationSkillMinOrderByAggregateInput
    _sum?: InvestigationSkillSumOrderByAggregateInput
  }

  export type InvestigationSkillScalarWhereWithAggregatesInput = {
    AND?: InvestigationSkillScalarWhereWithAggregatesInput | InvestigationSkillScalarWhereWithAggregatesInput[]
    OR?: InvestigationSkillScalarWhereWithAggregatesInput[]
    NOT?: InvestigationSkillScalarWhereWithAggregatesInput | InvestigationSkillScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"InvestigationSkill"> | string
    value?: IntNullableWithAggregatesFilter<"InvestigationSkill"> | number | null
    mastery?: BoolWithAggregatesFilter<"InvestigationSkill"> | boolean
    name?: StringWithAggregatesFilter<"InvestigationSkill"> | string
  }

  export type NatureSkillWhereInput = {
    AND?: NatureSkillWhereInput | NatureSkillWhereInput[]
    OR?: NatureSkillWhereInput[]
    NOT?: NatureSkillWhereInput | NatureSkillWhereInput[]
    id?: StringFilter<"NatureSkill"> | string
    value?: IntNullableFilter<"NatureSkill"> | number | null
    mastery?: BoolFilter<"NatureSkill"> | boolean
    name?: StringFilter<"NatureSkill"> | string
    skill_list?: XOR<IntellengenceBasedSkillsScalarRelationFilter, IntellengenceBasedSkillsWhereInput>
  }

  export type NatureSkillOrderByWithRelationInput = {
    id?: SortOrder
    value?: SortOrderInput | SortOrder
    mastery?: SortOrder
    name?: SortOrder
    skill_list?: IntellengenceBasedSkillsOrderByWithRelationInput
  }

  export type NatureSkillWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: NatureSkillWhereInput | NatureSkillWhereInput[]
    OR?: NatureSkillWhereInput[]
    NOT?: NatureSkillWhereInput | NatureSkillWhereInput[]
    value?: IntNullableFilter<"NatureSkill"> | number | null
    mastery?: BoolFilter<"NatureSkill"> | boolean
    name?: StringFilter<"NatureSkill"> | string
    skill_list?: XOR<IntellengenceBasedSkillsScalarRelationFilter, IntellengenceBasedSkillsWhereInput>
  }, "id">

  export type NatureSkillOrderByWithAggregationInput = {
    id?: SortOrder
    value?: SortOrderInput | SortOrder
    mastery?: SortOrder
    name?: SortOrder
    _count?: NatureSkillCountOrderByAggregateInput
    _avg?: NatureSkillAvgOrderByAggregateInput
    _max?: NatureSkillMaxOrderByAggregateInput
    _min?: NatureSkillMinOrderByAggregateInput
    _sum?: NatureSkillSumOrderByAggregateInput
  }

  export type NatureSkillScalarWhereWithAggregatesInput = {
    AND?: NatureSkillScalarWhereWithAggregatesInput | NatureSkillScalarWhereWithAggregatesInput[]
    OR?: NatureSkillScalarWhereWithAggregatesInput[]
    NOT?: NatureSkillScalarWhereWithAggregatesInput | NatureSkillScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"NatureSkill"> | string
    value?: IntNullableWithAggregatesFilter<"NatureSkill"> | number | null
    mastery?: BoolWithAggregatesFilter<"NatureSkill"> | boolean
    name?: StringWithAggregatesFilter<"NatureSkill"> | string
  }

  export type ReligionSkillWhereInput = {
    AND?: ReligionSkillWhereInput | ReligionSkillWhereInput[]
    OR?: ReligionSkillWhereInput[]
    NOT?: ReligionSkillWhereInput | ReligionSkillWhereInput[]
    id?: StringFilter<"ReligionSkill"> | string
    value?: IntNullableFilter<"ReligionSkill"> | number | null
    mastery?: BoolFilter<"ReligionSkill"> | boolean
    name?: StringFilter<"ReligionSkill"> | string
    skill_list?: XOR<IntellengenceBasedSkillsScalarRelationFilter, IntellengenceBasedSkillsWhereInput>
  }

  export type ReligionSkillOrderByWithRelationInput = {
    id?: SortOrder
    value?: SortOrderInput | SortOrder
    mastery?: SortOrder
    name?: SortOrder
    skill_list?: IntellengenceBasedSkillsOrderByWithRelationInput
  }

  export type ReligionSkillWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ReligionSkillWhereInput | ReligionSkillWhereInput[]
    OR?: ReligionSkillWhereInput[]
    NOT?: ReligionSkillWhereInput | ReligionSkillWhereInput[]
    value?: IntNullableFilter<"ReligionSkill"> | number | null
    mastery?: BoolFilter<"ReligionSkill"> | boolean
    name?: StringFilter<"ReligionSkill"> | string
    skill_list?: XOR<IntellengenceBasedSkillsScalarRelationFilter, IntellengenceBasedSkillsWhereInput>
  }, "id">

  export type ReligionSkillOrderByWithAggregationInput = {
    id?: SortOrder
    value?: SortOrderInput | SortOrder
    mastery?: SortOrder
    name?: SortOrder
    _count?: ReligionSkillCountOrderByAggregateInput
    _avg?: ReligionSkillAvgOrderByAggregateInput
    _max?: ReligionSkillMaxOrderByAggregateInput
    _min?: ReligionSkillMinOrderByAggregateInput
    _sum?: ReligionSkillSumOrderByAggregateInput
  }

  export type ReligionSkillScalarWhereWithAggregatesInput = {
    AND?: ReligionSkillScalarWhereWithAggregatesInput | ReligionSkillScalarWhereWithAggregatesInput[]
    OR?: ReligionSkillScalarWhereWithAggregatesInput[]
    NOT?: ReligionSkillScalarWhereWithAggregatesInput | ReligionSkillScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ReligionSkill"> | string
    value?: IntNullableWithAggregatesFilter<"ReligionSkill"> | number | null
    mastery?: BoolWithAggregatesFilter<"ReligionSkill"> | boolean
    name?: StringWithAggregatesFilter<"ReligionSkill"> | string
  }

  export type AnimalHandlingSkillWhereInput = {
    AND?: AnimalHandlingSkillWhereInput | AnimalHandlingSkillWhereInput[]
    OR?: AnimalHandlingSkillWhereInput[]
    NOT?: AnimalHandlingSkillWhereInput | AnimalHandlingSkillWhereInput[]
    id?: StringFilter<"AnimalHandlingSkill"> | string
    value?: IntNullableFilter<"AnimalHandlingSkill"> | number | null
    mastery?: BoolFilter<"AnimalHandlingSkill"> | boolean
    name?: StringFilter<"AnimalHandlingSkill"> | string
    skill_list?: XOR<WisdomBasedSkillsScalarRelationFilter, WisdomBasedSkillsWhereInput>
  }

  export type AnimalHandlingSkillOrderByWithRelationInput = {
    id?: SortOrder
    value?: SortOrderInput | SortOrder
    mastery?: SortOrder
    name?: SortOrder
    skill_list?: WisdomBasedSkillsOrderByWithRelationInput
  }

  export type AnimalHandlingSkillWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AnimalHandlingSkillWhereInput | AnimalHandlingSkillWhereInput[]
    OR?: AnimalHandlingSkillWhereInput[]
    NOT?: AnimalHandlingSkillWhereInput | AnimalHandlingSkillWhereInput[]
    value?: IntNullableFilter<"AnimalHandlingSkill"> | number | null
    mastery?: BoolFilter<"AnimalHandlingSkill"> | boolean
    name?: StringFilter<"AnimalHandlingSkill"> | string
    skill_list?: XOR<WisdomBasedSkillsScalarRelationFilter, WisdomBasedSkillsWhereInput>
  }, "id">

  export type AnimalHandlingSkillOrderByWithAggregationInput = {
    id?: SortOrder
    value?: SortOrderInput | SortOrder
    mastery?: SortOrder
    name?: SortOrder
    _count?: AnimalHandlingSkillCountOrderByAggregateInput
    _avg?: AnimalHandlingSkillAvgOrderByAggregateInput
    _max?: AnimalHandlingSkillMaxOrderByAggregateInput
    _min?: AnimalHandlingSkillMinOrderByAggregateInput
    _sum?: AnimalHandlingSkillSumOrderByAggregateInput
  }

  export type AnimalHandlingSkillScalarWhereWithAggregatesInput = {
    AND?: AnimalHandlingSkillScalarWhereWithAggregatesInput | AnimalHandlingSkillScalarWhereWithAggregatesInput[]
    OR?: AnimalHandlingSkillScalarWhereWithAggregatesInput[]
    NOT?: AnimalHandlingSkillScalarWhereWithAggregatesInput | AnimalHandlingSkillScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AnimalHandlingSkill"> | string
    value?: IntNullableWithAggregatesFilter<"AnimalHandlingSkill"> | number | null
    mastery?: BoolWithAggregatesFilter<"AnimalHandlingSkill"> | boolean
    name?: StringWithAggregatesFilter<"AnimalHandlingSkill"> | string
  }

  export type InsightSkillWhereInput = {
    AND?: InsightSkillWhereInput | InsightSkillWhereInput[]
    OR?: InsightSkillWhereInput[]
    NOT?: InsightSkillWhereInput | InsightSkillWhereInput[]
    id?: StringFilter<"InsightSkill"> | string
    value?: IntNullableFilter<"InsightSkill"> | number | null
    mastery?: BoolFilter<"InsightSkill"> | boolean
    name?: StringFilter<"InsightSkill"> | string
    skill_list?: XOR<WisdomBasedSkillsScalarRelationFilter, WisdomBasedSkillsWhereInput>
  }

  export type InsightSkillOrderByWithRelationInput = {
    id?: SortOrder
    value?: SortOrderInput | SortOrder
    mastery?: SortOrder
    name?: SortOrder
    skill_list?: WisdomBasedSkillsOrderByWithRelationInput
  }

  export type InsightSkillWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: InsightSkillWhereInput | InsightSkillWhereInput[]
    OR?: InsightSkillWhereInput[]
    NOT?: InsightSkillWhereInput | InsightSkillWhereInput[]
    value?: IntNullableFilter<"InsightSkill"> | number | null
    mastery?: BoolFilter<"InsightSkill"> | boolean
    name?: StringFilter<"InsightSkill"> | string
    skill_list?: XOR<WisdomBasedSkillsScalarRelationFilter, WisdomBasedSkillsWhereInput>
  }, "id">

  export type InsightSkillOrderByWithAggregationInput = {
    id?: SortOrder
    value?: SortOrderInput | SortOrder
    mastery?: SortOrder
    name?: SortOrder
    _count?: InsightSkillCountOrderByAggregateInput
    _avg?: InsightSkillAvgOrderByAggregateInput
    _max?: InsightSkillMaxOrderByAggregateInput
    _min?: InsightSkillMinOrderByAggregateInput
    _sum?: InsightSkillSumOrderByAggregateInput
  }

  export type InsightSkillScalarWhereWithAggregatesInput = {
    AND?: InsightSkillScalarWhereWithAggregatesInput | InsightSkillScalarWhereWithAggregatesInput[]
    OR?: InsightSkillScalarWhereWithAggregatesInput[]
    NOT?: InsightSkillScalarWhereWithAggregatesInput | InsightSkillScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"InsightSkill"> | string
    value?: IntNullableWithAggregatesFilter<"InsightSkill"> | number | null
    mastery?: BoolWithAggregatesFilter<"InsightSkill"> | boolean
    name?: StringWithAggregatesFilter<"InsightSkill"> | string
  }

  export type MedicineSkillWhereInput = {
    AND?: MedicineSkillWhereInput | MedicineSkillWhereInput[]
    OR?: MedicineSkillWhereInput[]
    NOT?: MedicineSkillWhereInput | MedicineSkillWhereInput[]
    id?: StringFilter<"MedicineSkill"> | string
    value?: IntNullableFilter<"MedicineSkill"> | number | null
    mastery?: BoolFilter<"MedicineSkill"> | boolean
    name?: StringFilter<"MedicineSkill"> | string
    skill_list?: XOR<WisdomBasedSkillsScalarRelationFilter, WisdomBasedSkillsWhereInput>
  }

  export type MedicineSkillOrderByWithRelationInput = {
    id?: SortOrder
    value?: SortOrderInput | SortOrder
    mastery?: SortOrder
    name?: SortOrder
    skill_list?: WisdomBasedSkillsOrderByWithRelationInput
  }

  export type MedicineSkillWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: MedicineSkillWhereInput | MedicineSkillWhereInput[]
    OR?: MedicineSkillWhereInput[]
    NOT?: MedicineSkillWhereInput | MedicineSkillWhereInput[]
    value?: IntNullableFilter<"MedicineSkill"> | number | null
    mastery?: BoolFilter<"MedicineSkill"> | boolean
    name?: StringFilter<"MedicineSkill"> | string
    skill_list?: XOR<WisdomBasedSkillsScalarRelationFilter, WisdomBasedSkillsWhereInput>
  }, "id">

  export type MedicineSkillOrderByWithAggregationInput = {
    id?: SortOrder
    value?: SortOrderInput | SortOrder
    mastery?: SortOrder
    name?: SortOrder
    _count?: MedicineSkillCountOrderByAggregateInput
    _avg?: MedicineSkillAvgOrderByAggregateInput
    _max?: MedicineSkillMaxOrderByAggregateInput
    _min?: MedicineSkillMinOrderByAggregateInput
    _sum?: MedicineSkillSumOrderByAggregateInput
  }

  export type MedicineSkillScalarWhereWithAggregatesInput = {
    AND?: MedicineSkillScalarWhereWithAggregatesInput | MedicineSkillScalarWhereWithAggregatesInput[]
    OR?: MedicineSkillScalarWhereWithAggregatesInput[]
    NOT?: MedicineSkillScalarWhereWithAggregatesInput | MedicineSkillScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"MedicineSkill"> | string
    value?: IntNullableWithAggregatesFilter<"MedicineSkill"> | number | null
    mastery?: BoolWithAggregatesFilter<"MedicineSkill"> | boolean
    name?: StringWithAggregatesFilter<"MedicineSkill"> | string
  }

  export type PerceptionSkillWhereInput = {
    AND?: PerceptionSkillWhereInput | PerceptionSkillWhereInput[]
    OR?: PerceptionSkillWhereInput[]
    NOT?: PerceptionSkillWhereInput | PerceptionSkillWhereInput[]
    id?: StringFilter<"PerceptionSkill"> | string
    value?: IntNullableFilter<"PerceptionSkill"> | number | null
    mastery?: BoolFilter<"PerceptionSkill"> | boolean
    name?: StringFilter<"PerceptionSkill"> | string
    skill_list?: XOR<WisdomBasedSkillsScalarRelationFilter, WisdomBasedSkillsWhereInput>
  }

  export type PerceptionSkillOrderByWithRelationInput = {
    id?: SortOrder
    value?: SortOrderInput | SortOrder
    mastery?: SortOrder
    name?: SortOrder
    skill_list?: WisdomBasedSkillsOrderByWithRelationInput
  }

  export type PerceptionSkillWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PerceptionSkillWhereInput | PerceptionSkillWhereInput[]
    OR?: PerceptionSkillWhereInput[]
    NOT?: PerceptionSkillWhereInput | PerceptionSkillWhereInput[]
    value?: IntNullableFilter<"PerceptionSkill"> | number | null
    mastery?: BoolFilter<"PerceptionSkill"> | boolean
    name?: StringFilter<"PerceptionSkill"> | string
    skill_list?: XOR<WisdomBasedSkillsScalarRelationFilter, WisdomBasedSkillsWhereInput>
  }, "id">

  export type PerceptionSkillOrderByWithAggregationInput = {
    id?: SortOrder
    value?: SortOrderInput | SortOrder
    mastery?: SortOrder
    name?: SortOrder
    _count?: PerceptionSkillCountOrderByAggregateInput
    _avg?: PerceptionSkillAvgOrderByAggregateInput
    _max?: PerceptionSkillMaxOrderByAggregateInput
    _min?: PerceptionSkillMinOrderByAggregateInput
    _sum?: PerceptionSkillSumOrderByAggregateInput
  }

  export type PerceptionSkillScalarWhereWithAggregatesInput = {
    AND?: PerceptionSkillScalarWhereWithAggregatesInput | PerceptionSkillScalarWhereWithAggregatesInput[]
    OR?: PerceptionSkillScalarWhereWithAggregatesInput[]
    NOT?: PerceptionSkillScalarWhereWithAggregatesInput | PerceptionSkillScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PerceptionSkill"> | string
    value?: IntNullableWithAggregatesFilter<"PerceptionSkill"> | number | null
    mastery?: BoolWithAggregatesFilter<"PerceptionSkill"> | boolean
    name?: StringWithAggregatesFilter<"PerceptionSkill"> | string
  }

  export type SurvivalSkillWhereInput = {
    AND?: SurvivalSkillWhereInput | SurvivalSkillWhereInput[]
    OR?: SurvivalSkillWhereInput[]
    NOT?: SurvivalSkillWhereInput | SurvivalSkillWhereInput[]
    id?: StringFilter<"SurvivalSkill"> | string
    value?: IntNullableFilter<"SurvivalSkill"> | number | null
    mastery?: BoolFilter<"SurvivalSkill"> | boolean
    name?: StringFilter<"SurvivalSkill"> | string
    skill_list?: XOR<WisdomBasedSkillsScalarRelationFilter, WisdomBasedSkillsWhereInput>
  }

  export type SurvivalSkillOrderByWithRelationInput = {
    id?: SortOrder
    value?: SortOrderInput | SortOrder
    mastery?: SortOrder
    name?: SortOrder
    skill_list?: WisdomBasedSkillsOrderByWithRelationInput
  }

  export type SurvivalSkillWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SurvivalSkillWhereInput | SurvivalSkillWhereInput[]
    OR?: SurvivalSkillWhereInput[]
    NOT?: SurvivalSkillWhereInput | SurvivalSkillWhereInput[]
    value?: IntNullableFilter<"SurvivalSkill"> | number | null
    mastery?: BoolFilter<"SurvivalSkill"> | boolean
    name?: StringFilter<"SurvivalSkill"> | string
    skill_list?: XOR<WisdomBasedSkillsScalarRelationFilter, WisdomBasedSkillsWhereInput>
  }, "id">

  export type SurvivalSkillOrderByWithAggregationInput = {
    id?: SortOrder
    value?: SortOrderInput | SortOrder
    mastery?: SortOrder
    name?: SortOrder
    _count?: SurvivalSkillCountOrderByAggregateInput
    _avg?: SurvivalSkillAvgOrderByAggregateInput
    _max?: SurvivalSkillMaxOrderByAggregateInput
    _min?: SurvivalSkillMinOrderByAggregateInput
    _sum?: SurvivalSkillSumOrderByAggregateInput
  }

  export type SurvivalSkillScalarWhereWithAggregatesInput = {
    AND?: SurvivalSkillScalarWhereWithAggregatesInput | SurvivalSkillScalarWhereWithAggregatesInput[]
    OR?: SurvivalSkillScalarWhereWithAggregatesInput[]
    NOT?: SurvivalSkillScalarWhereWithAggregatesInput | SurvivalSkillScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SurvivalSkill"> | string
    value?: IntNullableWithAggregatesFilter<"SurvivalSkill"> | number | null
    mastery?: BoolWithAggregatesFilter<"SurvivalSkill"> | boolean
    name?: StringWithAggregatesFilter<"SurvivalSkill"> | string
  }

  export type DeceptionSkillWhereInput = {
    AND?: DeceptionSkillWhereInput | DeceptionSkillWhereInput[]
    OR?: DeceptionSkillWhereInput[]
    NOT?: DeceptionSkillWhereInput | DeceptionSkillWhereInput[]
    id?: StringFilter<"DeceptionSkill"> | string
    value?: IntNullableFilter<"DeceptionSkill"> | number | null
    mastery?: BoolFilter<"DeceptionSkill"> | boolean
    name?: StringFilter<"DeceptionSkill"> | string
    skill_list?: XOR<CharismaBasedSkillsScalarRelationFilter, CharismaBasedSkillsWhereInput>
  }

  export type DeceptionSkillOrderByWithRelationInput = {
    id?: SortOrder
    value?: SortOrderInput | SortOrder
    mastery?: SortOrder
    name?: SortOrder
    skill_list?: CharismaBasedSkillsOrderByWithRelationInput
  }

  export type DeceptionSkillWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: DeceptionSkillWhereInput | DeceptionSkillWhereInput[]
    OR?: DeceptionSkillWhereInput[]
    NOT?: DeceptionSkillWhereInput | DeceptionSkillWhereInput[]
    value?: IntNullableFilter<"DeceptionSkill"> | number | null
    mastery?: BoolFilter<"DeceptionSkill"> | boolean
    name?: StringFilter<"DeceptionSkill"> | string
    skill_list?: XOR<CharismaBasedSkillsScalarRelationFilter, CharismaBasedSkillsWhereInput>
  }, "id">

  export type DeceptionSkillOrderByWithAggregationInput = {
    id?: SortOrder
    value?: SortOrderInput | SortOrder
    mastery?: SortOrder
    name?: SortOrder
    _count?: DeceptionSkillCountOrderByAggregateInput
    _avg?: DeceptionSkillAvgOrderByAggregateInput
    _max?: DeceptionSkillMaxOrderByAggregateInput
    _min?: DeceptionSkillMinOrderByAggregateInput
    _sum?: DeceptionSkillSumOrderByAggregateInput
  }

  export type DeceptionSkillScalarWhereWithAggregatesInput = {
    AND?: DeceptionSkillScalarWhereWithAggregatesInput | DeceptionSkillScalarWhereWithAggregatesInput[]
    OR?: DeceptionSkillScalarWhereWithAggregatesInput[]
    NOT?: DeceptionSkillScalarWhereWithAggregatesInput | DeceptionSkillScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"DeceptionSkill"> | string
    value?: IntNullableWithAggregatesFilter<"DeceptionSkill"> | number | null
    mastery?: BoolWithAggregatesFilter<"DeceptionSkill"> | boolean
    name?: StringWithAggregatesFilter<"DeceptionSkill"> | string
  }

  export type IntimidationSkillWhereInput = {
    AND?: IntimidationSkillWhereInput | IntimidationSkillWhereInput[]
    OR?: IntimidationSkillWhereInput[]
    NOT?: IntimidationSkillWhereInput | IntimidationSkillWhereInput[]
    id?: StringFilter<"IntimidationSkill"> | string
    value?: IntNullableFilter<"IntimidationSkill"> | number | null
    mastery?: BoolFilter<"IntimidationSkill"> | boolean
    name?: StringFilter<"IntimidationSkill"> | string
    skill_list?: XOR<CharismaBasedSkillsScalarRelationFilter, CharismaBasedSkillsWhereInput>
  }

  export type IntimidationSkillOrderByWithRelationInput = {
    id?: SortOrder
    value?: SortOrderInput | SortOrder
    mastery?: SortOrder
    name?: SortOrder
    skill_list?: CharismaBasedSkillsOrderByWithRelationInput
  }

  export type IntimidationSkillWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: IntimidationSkillWhereInput | IntimidationSkillWhereInput[]
    OR?: IntimidationSkillWhereInput[]
    NOT?: IntimidationSkillWhereInput | IntimidationSkillWhereInput[]
    value?: IntNullableFilter<"IntimidationSkill"> | number | null
    mastery?: BoolFilter<"IntimidationSkill"> | boolean
    name?: StringFilter<"IntimidationSkill"> | string
    skill_list?: XOR<CharismaBasedSkillsScalarRelationFilter, CharismaBasedSkillsWhereInput>
  }, "id">

  export type IntimidationSkillOrderByWithAggregationInput = {
    id?: SortOrder
    value?: SortOrderInput | SortOrder
    mastery?: SortOrder
    name?: SortOrder
    _count?: IntimidationSkillCountOrderByAggregateInput
    _avg?: IntimidationSkillAvgOrderByAggregateInput
    _max?: IntimidationSkillMaxOrderByAggregateInput
    _min?: IntimidationSkillMinOrderByAggregateInput
    _sum?: IntimidationSkillSumOrderByAggregateInput
  }

  export type IntimidationSkillScalarWhereWithAggregatesInput = {
    AND?: IntimidationSkillScalarWhereWithAggregatesInput | IntimidationSkillScalarWhereWithAggregatesInput[]
    OR?: IntimidationSkillScalarWhereWithAggregatesInput[]
    NOT?: IntimidationSkillScalarWhereWithAggregatesInput | IntimidationSkillScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"IntimidationSkill"> | string
    value?: IntNullableWithAggregatesFilter<"IntimidationSkill"> | number | null
    mastery?: BoolWithAggregatesFilter<"IntimidationSkill"> | boolean
    name?: StringWithAggregatesFilter<"IntimidationSkill"> | string
  }

  export type PerformanceSkillWhereInput = {
    AND?: PerformanceSkillWhereInput | PerformanceSkillWhereInput[]
    OR?: PerformanceSkillWhereInput[]
    NOT?: PerformanceSkillWhereInput | PerformanceSkillWhereInput[]
    id?: StringFilter<"PerformanceSkill"> | string
    value?: IntNullableFilter<"PerformanceSkill"> | number | null
    mastery?: BoolFilter<"PerformanceSkill"> | boolean
    name?: StringFilter<"PerformanceSkill"> | string
    skill_list?: XOR<CharismaBasedSkillsScalarRelationFilter, CharismaBasedSkillsWhereInput>
  }

  export type PerformanceSkillOrderByWithRelationInput = {
    id?: SortOrder
    value?: SortOrderInput | SortOrder
    mastery?: SortOrder
    name?: SortOrder
    skill_list?: CharismaBasedSkillsOrderByWithRelationInput
  }

  export type PerformanceSkillWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PerformanceSkillWhereInput | PerformanceSkillWhereInput[]
    OR?: PerformanceSkillWhereInput[]
    NOT?: PerformanceSkillWhereInput | PerformanceSkillWhereInput[]
    value?: IntNullableFilter<"PerformanceSkill"> | number | null
    mastery?: BoolFilter<"PerformanceSkill"> | boolean
    name?: StringFilter<"PerformanceSkill"> | string
    skill_list?: XOR<CharismaBasedSkillsScalarRelationFilter, CharismaBasedSkillsWhereInput>
  }, "id">

  export type PerformanceSkillOrderByWithAggregationInput = {
    id?: SortOrder
    value?: SortOrderInput | SortOrder
    mastery?: SortOrder
    name?: SortOrder
    _count?: PerformanceSkillCountOrderByAggregateInput
    _avg?: PerformanceSkillAvgOrderByAggregateInput
    _max?: PerformanceSkillMaxOrderByAggregateInput
    _min?: PerformanceSkillMinOrderByAggregateInput
    _sum?: PerformanceSkillSumOrderByAggregateInput
  }

  export type PerformanceSkillScalarWhereWithAggregatesInput = {
    AND?: PerformanceSkillScalarWhereWithAggregatesInput | PerformanceSkillScalarWhereWithAggregatesInput[]
    OR?: PerformanceSkillScalarWhereWithAggregatesInput[]
    NOT?: PerformanceSkillScalarWhereWithAggregatesInput | PerformanceSkillScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PerformanceSkill"> | string
    value?: IntNullableWithAggregatesFilter<"PerformanceSkill"> | number | null
    mastery?: BoolWithAggregatesFilter<"PerformanceSkill"> | boolean
    name?: StringWithAggregatesFilter<"PerformanceSkill"> | string
  }

  export type PersuasionSkillWhereInput = {
    AND?: PersuasionSkillWhereInput | PersuasionSkillWhereInput[]
    OR?: PersuasionSkillWhereInput[]
    NOT?: PersuasionSkillWhereInput | PersuasionSkillWhereInput[]
    id?: StringFilter<"PersuasionSkill"> | string
    value?: IntNullableFilter<"PersuasionSkill"> | number | null
    mastery?: BoolFilter<"PersuasionSkill"> | boolean
    name?: StringFilter<"PersuasionSkill"> | string
    skill_list?: XOR<CharismaBasedSkillsScalarRelationFilter, CharismaBasedSkillsWhereInput>
  }

  export type PersuasionSkillOrderByWithRelationInput = {
    id?: SortOrder
    value?: SortOrderInput | SortOrder
    mastery?: SortOrder
    name?: SortOrder
    skill_list?: CharismaBasedSkillsOrderByWithRelationInput
  }

  export type PersuasionSkillWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PersuasionSkillWhereInput | PersuasionSkillWhereInput[]
    OR?: PersuasionSkillWhereInput[]
    NOT?: PersuasionSkillWhereInput | PersuasionSkillWhereInput[]
    value?: IntNullableFilter<"PersuasionSkill"> | number | null
    mastery?: BoolFilter<"PersuasionSkill"> | boolean
    name?: StringFilter<"PersuasionSkill"> | string
    skill_list?: XOR<CharismaBasedSkillsScalarRelationFilter, CharismaBasedSkillsWhereInput>
  }, "id">

  export type PersuasionSkillOrderByWithAggregationInput = {
    id?: SortOrder
    value?: SortOrderInput | SortOrder
    mastery?: SortOrder
    name?: SortOrder
    _count?: PersuasionSkillCountOrderByAggregateInput
    _avg?: PersuasionSkillAvgOrderByAggregateInput
    _max?: PersuasionSkillMaxOrderByAggregateInput
    _min?: PersuasionSkillMinOrderByAggregateInput
    _sum?: PersuasionSkillSumOrderByAggregateInput
  }

  export type PersuasionSkillScalarWhereWithAggregatesInput = {
    AND?: PersuasionSkillScalarWhereWithAggregatesInput | PersuasionSkillScalarWhereWithAggregatesInput[]
    OR?: PersuasionSkillScalarWhereWithAggregatesInput[]
    NOT?: PersuasionSkillScalarWhereWithAggregatesInput | PersuasionSkillScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PersuasionSkill"> | string
    value?: IntNullableWithAggregatesFilter<"PersuasionSkill"> | number | null
    mastery?: BoolWithAggregatesFilter<"PersuasionSkill"> | boolean
    name?: StringWithAggregatesFilter<"PersuasionSkill"> | string
  }

  export type CreatureWhereInput = {
    AND?: CreatureWhereInput | CreatureWhereInput[]
    OR?: CreatureWhereInput[]
    NOT?: CreatureWhereInput | CreatureWhereInput[]
    id?: StringFilter<"Creature"> | string
    name?: StringFilter<"Creature"> | string
    creator_id?: StringNullableFilter<"Creature"> | string | null
    image_uri?: StringNullableFilter<"Creature"> | string | null
    description?: StringNullableFilter<"Creature"> | string | null
    size?: StringNullableFilter<"Creature"> | string | null
    race_id?: IntNullableFilter<"Creature"> | number | null
    source_id?: IntNullableFilter<"Creature"> | number | null
    alignment_id?: IntNullableFilter<"Creature"> | number | null
    armor_class?: IntNullableFilter<"Creature"> | number | null
    hit_points?: IntNullableFilter<"Creature"> | number | null
    challenge_rating?: StringFilter<"Creature"> | string
    biomes_ids?: IntNullableListFilter<"Creature">
    type_id?: IntNullableFilter<"Creature"> | number | null
    aSubTypes?: StringNullableListFilter<"Creature">
    speed?: XOR<Speed_statNullableScalarRelationFilter, Speed_statWhereInput> | null
    stats?: XOR<Creature_statsNullableScalarRelationFilter, Creature_statsWhereInput> | null
    skills?: XOR<SkillsListNullableScalarRelationFilter, SkillsListWhereInput> | null
    resistances?: DamageTypeListRelationFilter
    immunities?: DamageTypeListRelationFilter
    vulnerabilities?: DamageTypeListRelationFilter
    senses?: XOR<SensesNullableScalarRelationFilter, SensesWhereInput> | null
    languages?: LanguageListRelationFilter
    actions?: ActionListRelationFilter
    traits?: TraitListRelationFilter
    alignment_relation?: XOR<AlignmentNullableScalarRelationFilter, AlignmentWhereInput> | null
    race_relation?: XOR<CreatureRaceNullableScalarRelationFilter, CreatureRaceWhereInput> | null
    type_relation?: XOR<TypeNullableScalarRelationFilter, TypeWhereInput> | null
    size_relation?: XOR<SizeNullableScalarRelationFilter, SizeWhereInput> | null
    biome_relation?: BiomeListRelationFilter
    source_relation?: XOR<SourceNullableScalarRelationFilter, SourceWhereInput> | null
  }

  export type CreatureOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    creator_id?: SortOrderInput | SortOrder
    image_uri?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    size?: SortOrderInput | SortOrder
    race_id?: SortOrderInput | SortOrder
    source_id?: SortOrderInput | SortOrder
    alignment_id?: SortOrderInput | SortOrder
    armor_class?: SortOrderInput | SortOrder
    hit_points?: SortOrderInput | SortOrder
    challenge_rating?: SortOrder
    biomes_ids?: SortOrder
    type_id?: SortOrderInput | SortOrder
    aSubTypes?: SortOrder
    speed?: Speed_statOrderByWithRelationInput
    stats?: Creature_statsOrderByWithRelationInput
    skills?: SkillsListOrderByWithRelationInput
    resistances?: DamageTypeOrderByRelationAggregateInput
    immunities?: DamageTypeOrderByRelationAggregateInput
    vulnerabilities?: DamageTypeOrderByRelationAggregateInput
    senses?: SensesOrderByWithRelationInput
    languages?: LanguageOrderByRelationAggregateInput
    actions?: ActionOrderByRelationAggregateInput
    traits?: TraitOrderByRelationAggregateInput
    alignment_relation?: AlignmentOrderByWithRelationInput
    race_relation?: CreatureRaceOrderByWithRelationInput
    type_relation?: TypeOrderByWithRelationInput
    size_relation?: SizeOrderByWithRelationInput
    biome_relation?: BiomeOrderByRelationAggregateInput
    source_relation?: SourceOrderByWithRelationInput
  }

  export type CreatureWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CreatureWhereInput | CreatureWhereInput[]
    OR?: CreatureWhereInput[]
    NOT?: CreatureWhereInput | CreatureWhereInput[]
    name?: StringFilter<"Creature"> | string
    creator_id?: StringNullableFilter<"Creature"> | string | null
    image_uri?: StringNullableFilter<"Creature"> | string | null
    description?: StringNullableFilter<"Creature"> | string | null
    size?: StringNullableFilter<"Creature"> | string | null
    race_id?: IntNullableFilter<"Creature"> | number | null
    source_id?: IntNullableFilter<"Creature"> | number | null
    alignment_id?: IntNullableFilter<"Creature"> | number | null
    armor_class?: IntNullableFilter<"Creature"> | number | null
    hit_points?: IntNullableFilter<"Creature"> | number | null
    challenge_rating?: StringFilter<"Creature"> | string
    biomes_ids?: IntNullableListFilter<"Creature">
    type_id?: IntNullableFilter<"Creature"> | number | null
    aSubTypes?: StringNullableListFilter<"Creature">
    speed?: XOR<Speed_statNullableScalarRelationFilter, Speed_statWhereInput> | null
    stats?: XOR<Creature_statsNullableScalarRelationFilter, Creature_statsWhereInput> | null
    skills?: XOR<SkillsListNullableScalarRelationFilter, SkillsListWhereInput> | null
    resistances?: DamageTypeListRelationFilter
    immunities?: DamageTypeListRelationFilter
    vulnerabilities?: DamageTypeListRelationFilter
    senses?: XOR<SensesNullableScalarRelationFilter, SensesWhereInput> | null
    languages?: LanguageListRelationFilter
    actions?: ActionListRelationFilter
    traits?: TraitListRelationFilter
    alignment_relation?: XOR<AlignmentNullableScalarRelationFilter, AlignmentWhereInput> | null
    race_relation?: XOR<CreatureRaceNullableScalarRelationFilter, CreatureRaceWhereInput> | null
    type_relation?: XOR<TypeNullableScalarRelationFilter, TypeWhereInput> | null
    size_relation?: XOR<SizeNullableScalarRelationFilter, SizeWhereInput> | null
    biome_relation?: BiomeListRelationFilter
    source_relation?: XOR<SourceNullableScalarRelationFilter, SourceWhereInput> | null
  }, "id">

  export type CreatureOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    creator_id?: SortOrderInput | SortOrder
    image_uri?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    size?: SortOrderInput | SortOrder
    race_id?: SortOrderInput | SortOrder
    source_id?: SortOrderInput | SortOrder
    alignment_id?: SortOrderInput | SortOrder
    armor_class?: SortOrderInput | SortOrder
    hit_points?: SortOrderInput | SortOrder
    challenge_rating?: SortOrder
    biomes_ids?: SortOrder
    type_id?: SortOrderInput | SortOrder
    aSubTypes?: SortOrder
    _count?: CreatureCountOrderByAggregateInput
    _avg?: CreatureAvgOrderByAggregateInput
    _max?: CreatureMaxOrderByAggregateInput
    _min?: CreatureMinOrderByAggregateInput
    _sum?: CreatureSumOrderByAggregateInput
  }

  export type CreatureScalarWhereWithAggregatesInput = {
    AND?: CreatureScalarWhereWithAggregatesInput | CreatureScalarWhereWithAggregatesInput[]
    OR?: CreatureScalarWhereWithAggregatesInput[]
    NOT?: CreatureScalarWhereWithAggregatesInput | CreatureScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Creature"> | string
    name?: StringWithAggregatesFilter<"Creature"> | string
    creator_id?: StringNullableWithAggregatesFilter<"Creature"> | string | null
    image_uri?: StringNullableWithAggregatesFilter<"Creature"> | string | null
    description?: StringNullableWithAggregatesFilter<"Creature"> | string | null
    size?: StringNullableWithAggregatesFilter<"Creature"> | string | null
    race_id?: IntNullableWithAggregatesFilter<"Creature"> | number | null
    source_id?: IntNullableWithAggregatesFilter<"Creature"> | number | null
    alignment_id?: IntNullableWithAggregatesFilter<"Creature"> | number | null
    armor_class?: IntNullableWithAggregatesFilter<"Creature"> | number | null
    hit_points?: IntNullableWithAggregatesFilter<"Creature"> | number | null
    challenge_rating?: StringWithAggregatesFilter<"Creature"> | string
    biomes_ids?: IntNullableListFilter<"Creature">
    type_id?: IntNullableWithAggregatesFilter<"Creature"> | number | null
    aSubTypes?: StringNullableListFilter<"Creature">
  }

  export type SensesWhereInput = {
    AND?: SensesWhereInput | SensesWhereInput[]
    OR?: SensesWhereInput[]
    NOT?: SensesWhereInput | SensesWhereInput[]
    creature_id?: StringFilter<"Senses"> | string
    passive_perception?: IntNullableFilter<"Senses"> | number | null
    creature?: XOR<CreatureScalarRelationFilter, CreatureWhereInput>
  }

  export type SensesOrderByWithRelationInput = {
    creature_id?: SortOrder
    passive_perception?: SortOrderInput | SortOrder
    creature?: CreatureOrderByWithRelationInput
  }

  export type SensesWhereUniqueInput = Prisma.AtLeast<{
    creature_id?: string
    AND?: SensesWhereInput | SensesWhereInput[]
    OR?: SensesWhereInput[]
    NOT?: SensesWhereInput | SensesWhereInput[]
    passive_perception?: IntNullableFilter<"Senses"> | number | null
    creature?: XOR<CreatureScalarRelationFilter, CreatureWhereInput>
  }, "creature_id">

  export type SensesOrderByWithAggregationInput = {
    creature_id?: SortOrder
    passive_perception?: SortOrderInput | SortOrder
    _count?: SensesCountOrderByAggregateInput
    _avg?: SensesAvgOrderByAggregateInput
    _max?: SensesMaxOrderByAggregateInput
    _min?: SensesMinOrderByAggregateInput
    _sum?: SensesSumOrderByAggregateInput
  }

  export type SensesScalarWhereWithAggregatesInput = {
    AND?: SensesScalarWhereWithAggregatesInput | SensesScalarWhereWithAggregatesInput[]
    OR?: SensesScalarWhereWithAggregatesInput[]
    NOT?: SensesScalarWhereWithAggregatesInput | SensesScalarWhereWithAggregatesInput[]
    creature_id?: StringWithAggregatesFilter<"Senses"> | string
    passive_perception?: IntNullableWithAggregatesFilter<"Senses"> | number | null
  }

  export type ActionWhereInput = {
    AND?: ActionWhereInput | ActionWhereInput[]
    OR?: ActionWhereInput[]
    NOT?: ActionWhereInput | ActionWhereInput[]
    id?: IntFilter<"Action"> | number
    name?: StringFilter<"Action"> | string
    description?: StringFilter<"Action"> | string
    attack?: StringNullableFilter<"Action"> | string | null
    is_template?: BoolNullableFilter<"Action"> | boolean | null
    creatures?: CreatureListRelationFilter
    creatureTypes?: CreatureRaceListRelationFilter
  }

  export type ActionOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    attack?: SortOrderInput | SortOrder
    is_template?: SortOrderInput | SortOrder
    creatures?: CreatureOrderByRelationAggregateInput
    creatureTypes?: CreatureRaceOrderByRelationAggregateInput
  }

  export type ActionWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    description?: string
    AND?: ActionWhereInput | ActionWhereInput[]
    OR?: ActionWhereInput[]
    NOT?: ActionWhereInput | ActionWhereInput[]
    name?: StringFilter<"Action"> | string
    attack?: StringNullableFilter<"Action"> | string | null
    is_template?: BoolNullableFilter<"Action"> | boolean | null
    creatures?: CreatureListRelationFilter
    creatureTypes?: CreatureRaceListRelationFilter
  }, "id" | "description">

  export type ActionOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    attack?: SortOrderInput | SortOrder
    is_template?: SortOrderInput | SortOrder
    _count?: ActionCountOrderByAggregateInput
    _avg?: ActionAvgOrderByAggregateInput
    _max?: ActionMaxOrderByAggregateInput
    _min?: ActionMinOrderByAggregateInput
    _sum?: ActionSumOrderByAggregateInput
  }

  export type ActionScalarWhereWithAggregatesInput = {
    AND?: ActionScalarWhereWithAggregatesInput | ActionScalarWhereWithAggregatesInput[]
    OR?: ActionScalarWhereWithAggregatesInput[]
    NOT?: ActionScalarWhereWithAggregatesInput | ActionScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Action"> | number
    name?: StringWithAggregatesFilter<"Action"> | string
    description?: StringWithAggregatesFilter<"Action"> | string
    attack?: StringNullableWithAggregatesFilter<"Action"> | string | null
    is_template?: BoolNullableWithAggregatesFilter<"Action"> | boolean | null
  }

  export type TraitWhereInput = {
    AND?: TraitWhereInput | TraitWhereInput[]
    OR?: TraitWhereInput[]
    NOT?: TraitWhereInput | TraitWhereInput[]
    id?: IntFilter<"Trait"> | number
    name?: StringFilter<"Trait"> | string
    description?: StringFilter<"Trait"> | string
    attack?: StringNullableFilter<"Trait"> | string | null
    is_template?: BoolNullableFilter<"Trait"> | boolean | null
    cretures?: CreatureListRelationFilter
    creatureTypes?: CreatureRaceListRelationFilter
  }

  export type TraitOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    attack?: SortOrderInput | SortOrder
    is_template?: SortOrderInput | SortOrder
    cretures?: CreatureOrderByRelationAggregateInput
    creatureTypes?: CreatureRaceOrderByRelationAggregateInput
  }

  export type TraitWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    description?: string
    AND?: TraitWhereInput | TraitWhereInput[]
    OR?: TraitWhereInput[]
    NOT?: TraitWhereInput | TraitWhereInput[]
    name?: StringFilter<"Trait"> | string
    attack?: StringNullableFilter<"Trait"> | string | null
    is_template?: BoolNullableFilter<"Trait"> | boolean | null
    cretures?: CreatureListRelationFilter
    creatureTypes?: CreatureRaceListRelationFilter
  }, "id" | "description">

  export type TraitOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    attack?: SortOrderInput | SortOrder
    is_template?: SortOrderInput | SortOrder
    _count?: TraitCountOrderByAggregateInput
    _avg?: TraitAvgOrderByAggregateInput
    _max?: TraitMaxOrderByAggregateInput
    _min?: TraitMinOrderByAggregateInput
    _sum?: TraitSumOrderByAggregateInput
  }

  export type TraitScalarWhereWithAggregatesInput = {
    AND?: TraitScalarWhereWithAggregatesInput | TraitScalarWhereWithAggregatesInput[]
    OR?: TraitScalarWhereWithAggregatesInput[]
    NOT?: TraitScalarWhereWithAggregatesInput | TraitScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Trait"> | number
    name?: StringWithAggregatesFilter<"Trait"> | string
    description?: StringWithAggregatesFilter<"Trait"> | string
    attack?: StringNullableWithAggregatesFilter<"Trait"> | string | null
    is_template?: BoolNullableWithAggregatesFilter<"Trait"> | boolean | null
  }

  export type CreatureRaceWhereInput = {
    AND?: CreatureRaceWhereInput | CreatureRaceWhereInput[]
    OR?: CreatureRaceWhereInput[]
    NOT?: CreatureRaceWhereInput | CreatureRaceWhereInput[]
    id?: IntFilter<"CreatureRace"> | number
    name?: StringFilter<"CreatureRace"> | string
    description?: StringFilter<"CreatureRace"> | string
    traits?: TraitListRelationFilter
    actions?: ActionListRelationFilter
    creatures?: CreatureListRelationFilter
  }

  export type CreatureRaceOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    traits?: TraitOrderByRelationAggregateInput
    actions?: ActionOrderByRelationAggregateInput
    creatures?: CreatureOrderByRelationAggregateInput
  }

  export type CreatureRaceWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: CreatureRaceWhereInput | CreatureRaceWhereInput[]
    OR?: CreatureRaceWhereInput[]
    NOT?: CreatureRaceWhereInput | CreatureRaceWhereInput[]
    name?: StringFilter<"CreatureRace"> | string
    description?: StringFilter<"CreatureRace"> | string
    traits?: TraitListRelationFilter
    actions?: ActionListRelationFilter
    creatures?: CreatureListRelationFilter
  }, "id">

  export type CreatureRaceOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    _count?: CreatureRaceCountOrderByAggregateInput
    _avg?: CreatureRaceAvgOrderByAggregateInput
    _max?: CreatureRaceMaxOrderByAggregateInput
    _min?: CreatureRaceMinOrderByAggregateInput
    _sum?: CreatureRaceSumOrderByAggregateInput
  }

  export type CreatureRaceScalarWhereWithAggregatesInput = {
    AND?: CreatureRaceScalarWhereWithAggregatesInput | CreatureRaceScalarWhereWithAggregatesInput[]
    OR?: CreatureRaceScalarWhereWithAggregatesInput[]
    NOT?: CreatureRaceScalarWhereWithAggregatesInput | CreatureRaceScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"CreatureRace"> | number
    name?: StringWithAggregatesFilter<"CreatureRace"> | string
    description?: StringWithAggregatesFilter<"CreatureRace"> | string
  }

  export type GenrationRequestWhereInput = {
    AND?: GenrationRequestWhereInput | GenrationRequestWhereInput[]
    OR?: GenrationRequestWhereInput[]
    NOT?: GenrationRequestWhereInput | GenrationRequestWhereInput[]
    id?: IntFilter<"GenrationRequest"> | number
    request?: StringFilter<"GenrationRequest"> | string
    danger?: StringFilter<"GenrationRequest"> | string
    name?: StringFilter<"GenrationRequest"> | string
  }

  export type GenrationRequestOrderByWithRelationInput = {
    id?: SortOrder
    request?: SortOrder
    danger?: SortOrder
    name?: SortOrder
  }

  export type GenrationRequestWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: GenrationRequestWhereInput | GenrationRequestWhereInput[]
    OR?: GenrationRequestWhereInput[]
    NOT?: GenrationRequestWhereInput | GenrationRequestWhereInput[]
    request?: StringFilter<"GenrationRequest"> | string
    danger?: StringFilter<"GenrationRequest"> | string
    name?: StringFilter<"GenrationRequest"> | string
  }, "id">

  export type GenrationRequestOrderByWithAggregationInput = {
    id?: SortOrder
    request?: SortOrder
    danger?: SortOrder
    name?: SortOrder
    _count?: GenrationRequestCountOrderByAggregateInput
    _avg?: GenrationRequestAvgOrderByAggregateInput
    _max?: GenrationRequestMaxOrderByAggregateInput
    _min?: GenrationRequestMinOrderByAggregateInput
    _sum?: GenrationRequestSumOrderByAggregateInput
  }

  export type GenrationRequestScalarWhereWithAggregatesInput = {
    AND?: GenrationRequestScalarWhereWithAggregatesInput | GenrationRequestScalarWhereWithAggregatesInput[]
    OR?: GenrationRequestScalarWhereWithAggregatesInput[]
    NOT?: GenrationRequestScalarWhereWithAggregatesInput | GenrationRequestScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"GenrationRequest"> | number
    request?: StringWithAggregatesFilter<"GenrationRequest"> | string
    danger?: StringWithAggregatesFilter<"GenrationRequest"> | string
    name?: StringWithAggregatesFilter<"GenrationRequest"> | string
  }

  export type DamageTypeWhereInput = {
    AND?: DamageTypeWhereInput | DamageTypeWhereInput[]
    OR?: DamageTypeWhereInput[]
    NOT?: DamageTypeWhereInput | DamageTypeWhereInput[]
    id?: StringFilter<"DamageType"> | string
    name?: StringFilter<"DamageType"> | string
    resistant_creatures?: CreatureListRelationFilter
    immune_creatures?: CreatureListRelationFilter
    vunlerable_creatures?: CreatureListRelationFilter
  }

  export type DamageTypeOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    resistant_creatures?: CreatureOrderByRelationAggregateInput
    immune_creatures?: CreatureOrderByRelationAggregateInput
    vunlerable_creatures?: CreatureOrderByRelationAggregateInput
  }

  export type DamageTypeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    AND?: DamageTypeWhereInput | DamageTypeWhereInput[]
    OR?: DamageTypeWhereInput[]
    NOT?: DamageTypeWhereInput | DamageTypeWhereInput[]
    resistant_creatures?: CreatureListRelationFilter
    immune_creatures?: CreatureListRelationFilter
    vunlerable_creatures?: CreatureListRelationFilter
  }, "id" | "name">

  export type DamageTypeOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    _count?: DamageTypeCountOrderByAggregateInput
    _max?: DamageTypeMaxOrderByAggregateInput
    _min?: DamageTypeMinOrderByAggregateInput
  }

  export type DamageTypeScalarWhereWithAggregatesInput = {
    AND?: DamageTypeScalarWhereWithAggregatesInput | DamageTypeScalarWhereWithAggregatesInput[]
    OR?: DamageTypeScalarWhereWithAggregatesInput[]
    NOT?: DamageTypeScalarWhereWithAggregatesInput | DamageTypeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"DamageType"> | string
    name?: StringWithAggregatesFilter<"DamageType"> | string
  }

  export type ChallengeRatingWhereInput = {
    AND?: ChallengeRatingWhereInput | ChallengeRatingWhereInput[]
    OR?: ChallengeRatingWhereInput[]
    NOT?: ChallengeRatingWhereInput | ChallengeRatingWhereInput[]
    id?: StringFilter<"ChallengeRating"> | string
  }

  export type ChallengeRatingOrderByWithRelationInput = {
    id?: SortOrder
  }

  export type ChallengeRatingWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ChallengeRatingWhereInput | ChallengeRatingWhereInput[]
    OR?: ChallengeRatingWhereInput[]
    NOT?: ChallengeRatingWhereInput | ChallengeRatingWhereInput[]
  }, "id">

  export type ChallengeRatingOrderByWithAggregationInput = {
    id?: SortOrder
    _count?: ChallengeRatingCountOrderByAggregateInput
    _max?: ChallengeRatingMaxOrderByAggregateInput
    _min?: ChallengeRatingMinOrderByAggregateInput
  }

  export type ChallengeRatingScalarWhereWithAggregatesInput = {
    AND?: ChallengeRatingScalarWhereWithAggregatesInput | ChallengeRatingScalarWhereWithAggregatesInput[]
    OR?: ChallengeRatingScalarWhereWithAggregatesInput[]
    NOT?: ChallengeRatingScalarWhereWithAggregatesInput | ChallengeRatingScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ChallengeRating"> | string
  }

  export type GPTMessageHistoryWhereInput = {
    AND?: GPTMessageHistoryWhereInput | GPTMessageHistoryWhereInput[]
    OR?: GPTMessageHistoryWhereInput[]
    NOT?: GPTMessageHistoryWhereInput | GPTMessageHistoryWhereInput[]
    id?: StringFilter<"GPTMessageHistory"> | string
    type?: StringFilter<"GPTMessageHistory"> | string
    messages?: GPTMessageListRelationFilter
  }

  export type GPTMessageHistoryOrderByWithRelationInput = {
    id?: SortOrder
    type?: SortOrder
    messages?: GPTMessageOrderByRelationAggregateInput
  }

  export type GPTMessageHistoryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: GPTMessageHistoryWhereInput | GPTMessageHistoryWhereInput[]
    OR?: GPTMessageHistoryWhereInput[]
    NOT?: GPTMessageHistoryWhereInput | GPTMessageHistoryWhereInput[]
    type?: StringFilter<"GPTMessageHistory"> | string
    messages?: GPTMessageListRelationFilter
  }, "id">

  export type GPTMessageHistoryOrderByWithAggregationInput = {
    id?: SortOrder
    type?: SortOrder
    _count?: GPTMessageHistoryCountOrderByAggregateInput
    _max?: GPTMessageHistoryMaxOrderByAggregateInput
    _min?: GPTMessageHistoryMinOrderByAggregateInput
  }

  export type GPTMessageHistoryScalarWhereWithAggregatesInput = {
    AND?: GPTMessageHistoryScalarWhereWithAggregatesInput | GPTMessageHistoryScalarWhereWithAggregatesInput[]
    OR?: GPTMessageHistoryScalarWhereWithAggregatesInput[]
    NOT?: GPTMessageHistoryScalarWhereWithAggregatesInput | GPTMessageHistoryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"GPTMessageHistory"> | string
    type?: StringWithAggregatesFilter<"GPTMessageHistory"> | string
  }

  export type GPTMessageWhereInput = {
    AND?: GPTMessageWhereInput | GPTMessageWhereInput[]
    OR?: GPTMessageWhereInput[]
    NOT?: GPTMessageWhereInput | GPTMessageWhereInput[]
    number?: IntFilter<"GPTMessage"> | number
    message_history_id?: StringFilter<"GPTMessage"> | string
    text?: StringFilter<"GPTMessage"> | string
    role?: StringFilter<"GPTMessage"> | string
    message_history?: XOR<GPTMessageHistoryScalarRelationFilter, GPTMessageHistoryWhereInput>
  }

  export type GPTMessageOrderByWithRelationInput = {
    number?: SortOrder
    message_history_id?: SortOrder
    text?: SortOrder
    role?: SortOrder
    message_history?: GPTMessageHistoryOrderByWithRelationInput
  }

  export type GPTMessageWhereUniqueInput = Prisma.AtLeast<{
    message_history_id_number?: GPTMessageMessage_history_idNumberCompoundUniqueInput
    AND?: GPTMessageWhereInput | GPTMessageWhereInput[]
    OR?: GPTMessageWhereInput[]
    NOT?: GPTMessageWhereInput | GPTMessageWhereInput[]
    number?: IntFilter<"GPTMessage"> | number
    message_history_id?: StringFilter<"GPTMessage"> | string
    text?: StringFilter<"GPTMessage"> | string
    role?: StringFilter<"GPTMessage"> | string
    message_history?: XOR<GPTMessageHistoryScalarRelationFilter, GPTMessageHistoryWhereInput>
  }, "message_history_id_number">

  export type GPTMessageOrderByWithAggregationInput = {
    number?: SortOrder
    message_history_id?: SortOrder
    text?: SortOrder
    role?: SortOrder
    _count?: GPTMessageCountOrderByAggregateInput
    _avg?: GPTMessageAvgOrderByAggregateInput
    _max?: GPTMessageMaxOrderByAggregateInput
    _min?: GPTMessageMinOrderByAggregateInput
    _sum?: GPTMessageSumOrderByAggregateInput
  }

  export type GPTMessageScalarWhereWithAggregatesInput = {
    AND?: GPTMessageScalarWhereWithAggregatesInput | GPTMessageScalarWhereWithAggregatesInput[]
    OR?: GPTMessageScalarWhereWithAggregatesInput[]
    NOT?: GPTMessageScalarWhereWithAggregatesInput | GPTMessageScalarWhereWithAggregatesInput[]
    number?: IntWithAggregatesFilter<"GPTMessage"> | number
    message_history_id?: StringWithAggregatesFilter<"GPTMessage"> | string
    text?: StringWithAggregatesFilter<"GPTMessage"> | string
    role?: StringWithAggregatesFilter<"GPTMessage"> | string
  }

  export type AdventureWhereInput = {
    AND?: AdventureWhereInput | AdventureWhereInput[]
    OR?: AdventureWhereInput[]
    NOT?: AdventureWhereInput | AdventureWhereInput[]
    id?: StringFilter<"Adventure"> | string
    title?: StringFilter<"Adventure"> | string
    planned_parties?: IntFilter<"Adventure"> | number
    genre_id?: StringFilter<"Adventure"> | string
    creator_id?: StringFilter<"Adventure"> | string
    created_at?: DateTimeFilter<"Adventure"> | Date | string
    updated_at?: DateTimeFilter<"Adventure"> | Date | string
    genre?: XOR<GenreScalarRelationFilter, GenreWhereInput>
    keywords?: AdventureKeywordListRelationFilter
  }

  export type AdventureOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    planned_parties?: SortOrder
    genre_id?: SortOrder
    creator_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    genre?: GenreOrderByWithRelationInput
    keywords?: AdventureKeywordOrderByRelationAggregateInput
  }

  export type AdventureWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AdventureWhereInput | AdventureWhereInput[]
    OR?: AdventureWhereInput[]
    NOT?: AdventureWhereInput | AdventureWhereInput[]
    title?: StringFilter<"Adventure"> | string
    planned_parties?: IntFilter<"Adventure"> | number
    genre_id?: StringFilter<"Adventure"> | string
    creator_id?: StringFilter<"Adventure"> | string
    created_at?: DateTimeFilter<"Adventure"> | Date | string
    updated_at?: DateTimeFilter<"Adventure"> | Date | string
    genre?: XOR<GenreScalarRelationFilter, GenreWhereInput>
    keywords?: AdventureKeywordListRelationFilter
  }, "id">

  export type AdventureOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    planned_parties?: SortOrder
    genre_id?: SortOrder
    creator_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: AdventureCountOrderByAggregateInput
    _avg?: AdventureAvgOrderByAggregateInput
    _max?: AdventureMaxOrderByAggregateInput
    _min?: AdventureMinOrderByAggregateInput
    _sum?: AdventureSumOrderByAggregateInput
  }

  export type AdventureScalarWhereWithAggregatesInput = {
    AND?: AdventureScalarWhereWithAggregatesInput | AdventureScalarWhereWithAggregatesInput[]
    OR?: AdventureScalarWhereWithAggregatesInput[]
    NOT?: AdventureScalarWhereWithAggregatesInput | AdventureScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Adventure"> | string
    title?: StringWithAggregatesFilter<"Adventure"> | string
    planned_parties?: IntWithAggregatesFilter<"Adventure"> | number
    genre_id?: StringWithAggregatesFilter<"Adventure"> | string
    creator_id?: StringWithAggregatesFilter<"Adventure"> | string
    created_at?: DateTimeWithAggregatesFilter<"Adventure"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"Adventure"> | Date | string
  }

  export type GenreWhereInput = {
    AND?: GenreWhereInput | GenreWhereInput[]
    OR?: GenreWhereInput[]
    NOT?: GenreWhereInput | GenreWhereInput[]
    id?: StringFilter<"Genre"> | string
    name?: StringFilter<"Genre"> | string
    keywords?: KeywordListRelationFilter
    adventures?: AdventureListRelationFilter
  }

  export type GenreOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    keywords?: KeywordOrderByRelationAggregateInput
    adventures?: AdventureOrderByRelationAggregateInput
  }

  export type GenreWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: GenreWhereInput | GenreWhereInput[]
    OR?: GenreWhereInput[]
    NOT?: GenreWhereInput | GenreWhereInput[]
    name?: StringFilter<"Genre"> | string
    keywords?: KeywordListRelationFilter
    adventures?: AdventureListRelationFilter
  }, "id">

  export type GenreOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    _count?: GenreCountOrderByAggregateInput
    _max?: GenreMaxOrderByAggregateInput
    _min?: GenreMinOrderByAggregateInput
  }

  export type GenreScalarWhereWithAggregatesInput = {
    AND?: GenreScalarWhereWithAggregatesInput | GenreScalarWhereWithAggregatesInput[]
    OR?: GenreScalarWhereWithAggregatesInput[]
    NOT?: GenreScalarWhereWithAggregatesInput | GenreScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Genre"> | string
    name?: StringWithAggregatesFilter<"Genre"> | string
  }

  export type KeywordWhereInput = {
    AND?: KeywordWhereInput | KeywordWhereInput[]
    OR?: KeywordWhereInput[]
    NOT?: KeywordWhereInput | KeywordWhereInput[]
    id?: StringFilter<"Keyword"> | string
    name?: StringFilter<"Keyword"> | string
    genre_id?: StringFilter<"Keyword"> | string
    genre?: XOR<GenreScalarRelationFilter, GenreWhereInput>
    adventures?: AdventureKeywordListRelationFilter
  }

  export type KeywordOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    genre_id?: SortOrder
    genre?: GenreOrderByWithRelationInput
    adventures?: AdventureKeywordOrderByRelationAggregateInput
  }

  export type KeywordWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: KeywordWhereInput | KeywordWhereInput[]
    OR?: KeywordWhereInput[]
    NOT?: KeywordWhereInput | KeywordWhereInput[]
    name?: StringFilter<"Keyword"> | string
    genre_id?: StringFilter<"Keyword"> | string
    genre?: XOR<GenreScalarRelationFilter, GenreWhereInput>
    adventures?: AdventureKeywordListRelationFilter
  }, "id">

  export type KeywordOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    genre_id?: SortOrder
    _count?: KeywordCountOrderByAggregateInput
    _max?: KeywordMaxOrderByAggregateInput
    _min?: KeywordMinOrderByAggregateInput
  }

  export type KeywordScalarWhereWithAggregatesInput = {
    AND?: KeywordScalarWhereWithAggregatesInput | KeywordScalarWhereWithAggregatesInput[]
    OR?: KeywordScalarWhereWithAggregatesInput[]
    NOT?: KeywordScalarWhereWithAggregatesInput | KeywordScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Keyword"> | string
    name?: StringWithAggregatesFilter<"Keyword"> | string
    genre_id?: StringWithAggregatesFilter<"Keyword"> | string
  }

  export type AdventureKeywordWhereInput = {
    AND?: AdventureKeywordWhereInput | AdventureKeywordWhereInput[]
    OR?: AdventureKeywordWhereInput[]
    NOT?: AdventureKeywordWhereInput | AdventureKeywordWhereInput[]
    adventure_id?: StringFilter<"AdventureKeyword"> | string
    keyword_id?: StringFilter<"AdventureKeyword"> | string
    adventure?: XOR<AdventureScalarRelationFilter, AdventureWhereInput>
    keyword?: XOR<KeywordScalarRelationFilter, KeywordWhereInput>
  }

  export type AdventureKeywordOrderByWithRelationInput = {
    adventure_id?: SortOrder
    keyword_id?: SortOrder
    adventure?: AdventureOrderByWithRelationInput
    keyword?: KeywordOrderByWithRelationInput
  }

  export type AdventureKeywordWhereUniqueInput = Prisma.AtLeast<{
    adventure_id_keyword_id?: AdventureKeywordAdventure_idKeyword_idCompoundUniqueInput
    AND?: AdventureKeywordWhereInput | AdventureKeywordWhereInput[]
    OR?: AdventureKeywordWhereInput[]
    NOT?: AdventureKeywordWhereInput | AdventureKeywordWhereInput[]
    adventure_id?: StringFilter<"AdventureKeyword"> | string
    keyword_id?: StringFilter<"AdventureKeyword"> | string
    adventure?: XOR<AdventureScalarRelationFilter, AdventureWhereInput>
    keyword?: XOR<KeywordScalarRelationFilter, KeywordWhereInput>
  }, "adventure_id_keyword_id">

  export type AdventureKeywordOrderByWithAggregationInput = {
    adventure_id?: SortOrder
    keyword_id?: SortOrder
    _count?: AdventureKeywordCountOrderByAggregateInput
    _max?: AdventureKeywordMaxOrderByAggregateInput
    _min?: AdventureKeywordMinOrderByAggregateInput
  }

  export type AdventureKeywordScalarWhereWithAggregatesInput = {
    AND?: AdventureKeywordScalarWhereWithAggregatesInput | AdventureKeywordScalarWhereWithAggregatesInput[]
    OR?: AdventureKeywordScalarWhereWithAggregatesInput[]
    NOT?: AdventureKeywordScalarWhereWithAggregatesInput | AdventureKeywordScalarWhereWithAggregatesInput[]
    adventure_id?: StringWithAggregatesFilter<"AdventureKeyword"> | string
    keyword_id?: StringWithAggregatesFilter<"AdventureKeyword"> | string
  }

  export type SizeCreateInput = {
    id: string
    name: string
    creature?: CreatureCreateNestedManyWithoutSize_relationInput
  }

  export type SizeUncheckedCreateInput = {
    id: string
    name: string
    creature?: CreatureUncheckedCreateNestedManyWithoutSize_relationInput
  }

  export type SizeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    creature?: CreatureUpdateManyWithoutSize_relationNestedInput
  }

  export type SizeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    creature?: CreatureUncheckedUpdateManyWithoutSize_relationNestedInput
  }

  export type SizeCreateManyInput = {
    id: string
    name: string
  }

  export type SizeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type SizeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type SourceCreateInput = {
    shortName: string
    name: string
    creatures?: CreatureCreateNestedManyWithoutSource_relationInput
  }

  export type SourceUncheckedCreateInput = {
    id?: number
    shortName: string
    name: string
    creatures?: CreatureUncheckedCreateNestedManyWithoutSource_relationInput
  }

  export type SourceUpdateInput = {
    shortName?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    creatures?: CreatureUpdateManyWithoutSource_relationNestedInput
  }

  export type SourceUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    shortName?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    creatures?: CreatureUncheckedUpdateManyWithoutSource_relationNestedInput
  }

  export type SourceCreateManyInput = {
    id?: number
    shortName: string
    name: string
  }

  export type SourceUpdateManyMutationInput = {
    shortName?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type SourceUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    shortName?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type LanguageCreateInput = {
    name: string
    creatures?: CreatureCreateNestedManyWithoutLanguagesInput
  }

  export type LanguageUncheckedCreateInput = {
    id?: number
    name: string
    creatures?: CreatureUncheckedCreateNestedManyWithoutLanguagesInput
  }

  export type LanguageUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    creatures?: CreatureUpdateManyWithoutLanguagesNestedInput
  }

  export type LanguageUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    creatures?: CreatureUncheckedUpdateManyWithoutLanguagesNestedInput
  }

  export type LanguageCreateManyInput = {
    id?: number
    name: string
  }

  export type LanguageUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
  }

  export type LanguageUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type BiomeCreateInput = {
    key: string
    name: string
    creatures?: CreatureCreateNestedManyWithoutBiome_relationInput
  }

  export type BiomeUncheckedCreateInput = {
    id?: number
    key: string
    name: string
    creatures?: CreatureUncheckedCreateNestedManyWithoutBiome_relationInput
  }

  export type BiomeUpdateInput = {
    key?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    creatures?: CreatureUpdateManyWithoutBiome_relationNestedInput
  }

  export type BiomeUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    key?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    creatures?: CreatureUncheckedUpdateManyWithoutBiome_relationNestedInput
  }

  export type BiomeCreateManyInput = {
    id?: number
    key: string
    name: string
  }

  export type BiomeUpdateManyMutationInput = {
    key?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type BiomeUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    key?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type TypeCreateInput = {
    name: string
    creatures?: CreatureCreateNestedManyWithoutType_relationInput
  }

  export type TypeUncheckedCreateInput = {
    id?: number
    name: string
    creatures?: CreatureUncheckedCreateNestedManyWithoutType_relationInput
  }

  export type TypeUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    creatures?: CreatureUpdateManyWithoutType_relationNestedInput
  }

  export type TypeUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    creatures?: CreatureUncheckedUpdateManyWithoutType_relationNestedInput
  }

  export type TypeCreateManyInput = {
    id?: number
    name: string
  }

  export type TypeUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
  }

  export type TypeUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type AlignmentCreateInput = {
    name: string
    creatures?: CreatureCreateNestedManyWithoutAlignment_relationInput
  }

  export type AlignmentUncheckedCreateInput = {
    id?: number
    name: string
    creatures?: CreatureUncheckedCreateNestedManyWithoutAlignment_relationInput
  }

  export type AlignmentUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    creatures?: CreatureUpdateManyWithoutAlignment_relationNestedInput
  }

  export type AlignmentUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    creatures?: CreatureUncheckedUpdateManyWithoutAlignment_relationNestedInput
  }

  export type AlignmentCreateManyInput = {
    id?: number
    name: string
  }

  export type AlignmentUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
  }

  export type AlignmentUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type Speed_statCreateInput = {
    walk?: number | null
    fly?: number | null
    swim?: number | null
    burrow?: number | null
    climb?: number | null
    id_relation: CreatureCreateNestedOneWithoutSpeedInput
  }

  export type Speed_statUncheckedCreateInput = {
    id: string
    walk?: number | null
    fly?: number | null
    swim?: number | null
    burrow?: number | null
    climb?: number | null
  }

  export type Speed_statUpdateInput = {
    walk?: NullableIntFieldUpdateOperationsInput | number | null
    fly?: NullableIntFieldUpdateOperationsInput | number | null
    swim?: NullableIntFieldUpdateOperationsInput | number | null
    burrow?: NullableIntFieldUpdateOperationsInput | number | null
    climb?: NullableIntFieldUpdateOperationsInput | number | null
    id_relation?: CreatureUpdateOneRequiredWithoutSpeedNestedInput
  }

  export type Speed_statUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    walk?: NullableIntFieldUpdateOperationsInput | number | null
    fly?: NullableIntFieldUpdateOperationsInput | number | null
    swim?: NullableIntFieldUpdateOperationsInput | number | null
    burrow?: NullableIntFieldUpdateOperationsInput | number | null
    climb?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type Speed_statCreateManyInput = {
    id: string
    walk?: number | null
    fly?: number | null
    swim?: number | null
    burrow?: number | null
    climb?: number | null
  }

  export type Speed_statUpdateManyMutationInput = {
    walk?: NullableIntFieldUpdateOperationsInput | number | null
    fly?: NullableIntFieldUpdateOperationsInput | number | null
    swim?: NullableIntFieldUpdateOperationsInput | number | null
    burrow?: NullableIntFieldUpdateOperationsInput | number | null
    climb?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type Speed_statUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    walk?: NullableIntFieldUpdateOperationsInput | number | null
    fly?: NullableIntFieldUpdateOperationsInput | number | null
    swim?: NullableIntFieldUpdateOperationsInput | number | null
    burrow?: NullableIntFieldUpdateOperationsInput | number | null
    climb?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type Creature_statsCreateInput = {
    strength?: Strength_stat_detailsCreateNestedOneWithoutCreature_statInput
    dexterity?: Dexterity_stat_detailsCreateNestedOneWithoutCreature_statInput
    constitution?: Constitution_stat_detailsCreateNestedOneWithoutCreature_statInput
    intelligence?: Intelligence_stat_detailsCreateNestedOneWithoutCreature_statInput
    wisdom?: Wisdom_stat_detailsCreateNestedOneWithoutCreature_statInput
    charisma?: Charisma_stat_detailsCreateNestedOneWithoutCreature_statInput
    id_relation: CreatureCreateNestedOneWithoutStatsInput
  }

  export type Creature_statsUncheckedCreateInput = {
    id: string
    strength?: Strength_stat_detailsUncheckedCreateNestedOneWithoutCreature_statInput
    dexterity?: Dexterity_stat_detailsUncheckedCreateNestedOneWithoutCreature_statInput
    constitution?: Constitution_stat_detailsUncheckedCreateNestedOneWithoutCreature_statInput
    intelligence?: Intelligence_stat_detailsUncheckedCreateNestedOneWithoutCreature_statInput
    wisdom?: Wisdom_stat_detailsUncheckedCreateNestedOneWithoutCreature_statInput
    charisma?: Charisma_stat_detailsUncheckedCreateNestedOneWithoutCreature_statInput
  }

  export type Creature_statsUpdateInput = {
    strength?: Strength_stat_detailsUpdateOneWithoutCreature_statNestedInput
    dexterity?: Dexterity_stat_detailsUpdateOneWithoutCreature_statNestedInput
    constitution?: Constitution_stat_detailsUpdateOneWithoutCreature_statNestedInput
    intelligence?: Intelligence_stat_detailsUpdateOneWithoutCreature_statNestedInput
    wisdom?: Wisdom_stat_detailsUpdateOneWithoutCreature_statNestedInput
    charisma?: Charisma_stat_detailsUpdateOneWithoutCreature_statNestedInput
    id_relation?: CreatureUpdateOneRequiredWithoutStatsNestedInput
  }

  export type Creature_statsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    strength?: Strength_stat_detailsUncheckedUpdateOneWithoutCreature_statNestedInput
    dexterity?: Dexterity_stat_detailsUncheckedUpdateOneWithoutCreature_statNestedInput
    constitution?: Constitution_stat_detailsUncheckedUpdateOneWithoutCreature_statNestedInput
    intelligence?: Intelligence_stat_detailsUncheckedUpdateOneWithoutCreature_statNestedInput
    wisdom?: Wisdom_stat_detailsUncheckedUpdateOneWithoutCreature_statNestedInput
    charisma?: Charisma_stat_detailsUncheckedUpdateOneWithoutCreature_statNestedInput
  }

  export type Creature_statsCreateManyInput = {
    id: string
  }

  export type Creature_statsUpdateManyMutationInput = {

  }

  export type Creature_statsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
  }

  export type Strength_stat_detailsCreateInput = {
    value: number
    mastery: boolean
    creature_stat: Creature_statsCreateNestedOneWithoutStrengthInput
  }

  export type Strength_stat_detailsUncheckedCreateInput = {
    statblock_id: string
    value: number
    mastery: boolean
  }

  export type Strength_stat_detailsUpdateInput = {
    value?: IntFieldUpdateOperationsInput | number
    mastery?: BoolFieldUpdateOperationsInput | boolean
    creature_stat?: Creature_statsUpdateOneRequiredWithoutStrengthNestedInput
  }

  export type Strength_stat_detailsUncheckedUpdateInput = {
    statblock_id?: StringFieldUpdateOperationsInput | string
    value?: IntFieldUpdateOperationsInput | number
    mastery?: BoolFieldUpdateOperationsInput | boolean
  }

  export type Strength_stat_detailsCreateManyInput = {
    statblock_id: string
    value: number
    mastery: boolean
  }

  export type Strength_stat_detailsUpdateManyMutationInput = {
    value?: IntFieldUpdateOperationsInput | number
    mastery?: BoolFieldUpdateOperationsInput | boolean
  }

  export type Strength_stat_detailsUncheckedUpdateManyInput = {
    statblock_id?: StringFieldUpdateOperationsInput | string
    value?: IntFieldUpdateOperationsInput | number
    mastery?: BoolFieldUpdateOperationsInput | boolean
  }

  export type Dexterity_stat_detailsCreateInput = {
    value: number
    mastery: boolean
    creature_stat: Creature_statsCreateNestedOneWithoutDexterityInput
  }

  export type Dexterity_stat_detailsUncheckedCreateInput = {
    statblock_id: string
    value: number
    mastery: boolean
  }

  export type Dexterity_stat_detailsUpdateInput = {
    value?: IntFieldUpdateOperationsInput | number
    mastery?: BoolFieldUpdateOperationsInput | boolean
    creature_stat?: Creature_statsUpdateOneRequiredWithoutDexterityNestedInput
  }

  export type Dexterity_stat_detailsUncheckedUpdateInput = {
    statblock_id?: StringFieldUpdateOperationsInput | string
    value?: IntFieldUpdateOperationsInput | number
    mastery?: BoolFieldUpdateOperationsInput | boolean
  }

  export type Dexterity_stat_detailsCreateManyInput = {
    statblock_id: string
    value: number
    mastery: boolean
  }

  export type Dexterity_stat_detailsUpdateManyMutationInput = {
    value?: IntFieldUpdateOperationsInput | number
    mastery?: BoolFieldUpdateOperationsInput | boolean
  }

  export type Dexterity_stat_detailsUncheckedUpdateManyInput = {
    statblock_id?: StringFieldUpdateOperationsInput | string
    value?: IntFieldUpdateOperationsInput | number
    mastery?: BoolFieldUpdateOperationsInput | boolean
  }

  export type Constitution_stat_detailsCreateInput = {
    value: number
    mastery: boolean
    creature_stat: Creature_statsCreateNestedOneWithoutConstitutionInput
  }

  export type Constitution_stat_detailsUncheckedCreateInput = {
    statblock_id: string
    value: number
    mastery: boolean
  }

  export type Constitution_stat_detailsUpdateInput = {
    value?: IntFieldUpdateOperationsInput | number
    mastery?: BoolFieldUpdateOperationsInput | boolean
    creature_stat?: Creature_statsUpdateOneRequiredWithoutConstitutionNestedInput
  }

  export type Constitution_stat_detailsUncheckedUpdateInput = {
    statblock_id?: StringFieldUpdateOperationsInput | string
    value?: IntFieldUpdateOperationsInput | number
    mastery?: BoolFieldUpdateOperationsInput | boolean
  }

  export type Constitution_stat_detailsCreateManyInput = {
    statblock_id: string
    value: number
    mastery: boolean
  }

  export type Constitution_stat_detailsUpdateManyMutationInput = {
    value?: IntFieldUpdateOperationsInput | number
    mastery?: BoolFieldUpdateOperationsInput | boolean
  }

  export type Constitution_stat_detailsUncheckedUpdateManyInput = {
    statblock_id?: StringFieldUpdateOperationsInput | string
    value?: IntFieldUpdateOperationsInput | number
    mastery?: BoolFieldUpdateOperationsInput | boolean
  }

  export type Intelligence_stat_detailsCreateInput = {
    value: number
    mastery: boolean
    creature_stat: Creature_statsCreateNestedOneWithoutIntelligenceInput
  }

  export type Intelligence_stat_detailsUncheckedCreateInput = {
    statblock_id: string
    value: number
    mastery: boolean
  }

  export type Intelligence_stat_detailsUpdateInput = {
    value?: IntFieldUpdateOperationsInput | number
    mastery?: BoolFieldUpdateOperationsInput | boolean
    creature_stat?: Creature_statsUpdateOneRequiredWithoutIntelligenceNestedInput
  }

  export type Intelligence_stat_detailsUncheckedUpdateInput = {
    statblock_id?: StringFieldUpdateOperationsInput | string
    value?: IntFieldUpdateOperationsInput | number
    mastery?: BoolFieldUpdateOperationsInput | boolean
  }

  export type Intelligence_stat_detailsCreateManyInput = {
    statblock_id: string
    value: number
    mastery: boolean
  }

  export type Intelligence_stat_detailsUpdateManyMutationInput = {
    value?: IntFieldUpdateOperationsInput | number
    mastery?: BoolFieldUpdateOperationsInput | boolean
  }

  export type Intelligence_stat_detailsUncheckedUpdateManyInput = {
    statblock_id?: StringFieldUpdateOperationsInput | string
    value?: IntFieldUpdateOperationsInput | number
    mastery?: BoolFieldUpdateOperationsInput | boolean
  }

  export type Wisdom_stat_detailsCreateInput = {
    value: number
    mastery: boolean
    creature_stat: Creature_statsCreateNestedOneWithoutWisdomInput
  }

  export type Wisdom_stat_detailsUncheckedCreateInput = {
    statblock_id: string
    value: number
    mastery: boolean
  }

  export type Wisdom_stat_detailsUpdateInput = {
    value?: IntFieldUpdateOperationsInput | number
    mastery?: BoolFieldUpdateOperationsInput | boolean
    creature_stat?: Creature_statsUpdateOneRequiredWithoutWisdomNestedInput
  }

  export type Wisdom_stat_detailsUncheckedUpdateInput = {
    statblock_id?: StringFieldUpdateOperationsInput | string
    value?: IntFieldUpdateOperationsInput | number
    mastery?: BoolFieldUpdateOperationsInput | boolean
  }

  export type Wisdom_stat_detailsCreateManyInput = {
    statblock_id: string
    value: number
    mastery: boolean
  }

  export type Wisdom_stat_detailsUpdateManyMutationInput = {
    value?: IntFieldUpdateOperationsInput | number
    mastery?: BoolFieldUpdateOperationsInput | boolean
  }

  export type Wisdom_stat_detailsUncheckedUpdateManyInput = {
    statblock_id?: StringFieldUpdateOperationsInput | string
    value?: IntFieldUpdateOperationsInput | number
    mastery?: BoolFieldUpdateOperationsInput | boolean
  }

  export type Charisma_stat_detailsCreateInput = {
    value: number
    mastery: boolean
    creature_stat: Creature_statsCreateNestedOneWithoutCharismaInput
  }

  export type Charisma_stat_detailsUncheckedCreateInput = {
    statblock_id: string
    value: number
    mastery: boolean
  }

  export type Charisma_stat_detailsUpdateInput = {
    value?: IntFieldUpdateOperationsInput | number
    mastery?: BoolFieldUpdateOperationsInput | boolean
    creature_stat?: Creature_statsUpdateOneRequiredWithoutCharismaNestedInput
  }

  export type Charisma_stat_detailsUncheckedUpdateInput = {
    statblock_id?: StringFieldUpdateOperationsInput | string
    value?: IntFieldUpdateOperationsInput | number
    mastery?: BoolFieldUpdateOperationsInput | boolean
  }

  export type Charisma_stat_detailsCreateManyInput = {
    statblock_id: string
    value: number
    mastery: boolean
  }

  export type Charisma_stat_detailsUpdateManyMutationInput = {
    value?: IntFieldUpdateOperationsInput | number
    mastery?: BoolFieldUpdateOperationsInput | boolean
  }

  export type Charisma_stat_detailsUncheckedUpdateManyInput = {
    statblock_id?: StringFieldUpdateOperationsInput | string
    value?: IntFieldUpdateOperationsInput | number
    mastery?: BoolFieldUpdateOperationsInput | boolean
  }

  export type SkillsListCreateInput = {
    strength?: StrengthBasedSkillsCreateNestedOneWithoutSkills_list_relationInput
    dexterity?: DexterityBasedSkillsCreateNestedOneWithoutSkills_list_relationInput
    intelligence?: IntellengenceBasedSkillsCreateNestedOneWithoutSkills_list_relationInput
    wisdom?: WisdomBasedSkillsCreateNestedOneWithoutSkills_list_relationInput
    charisma?: CharismaBasedSkillsCreateNestedOneWithoutSkills_list_relationInput
    id_relation: CreatureCreateNestedOneWithoutSkillsInput
  }

  export type SkillsListUncheckedCreateInput = {
    id: string
    strength?: StrengthBasedSkillsUncheckedCreateNestedOneWithoutSkills_list_relationInput
    dexterity?: DexterityBasedSkillsUncheckedCreateNestedOneWithoutSkills_list_relationInput
    intelligence?: IntellengenceBasedSkillsUncheckedCreateNestedOneWithoutSkills_list_relationInput
    wisdom?: WisdomBasedSkillsUncheckedCreateNestedOneWithoutSkills_list_relationInput
    charisma?: CharismaBasedSkillsUncheckedCreateNestedOneWithoutSkills_list_relationInput
  }

  export type SkillsListUpdateInput = {
    strength?: StrengthBasedSkillsUpdateOneWithoutSkills_list_relationNestedInput
    dexterity?: DexterityBasedSkillsUpdateOneWithoutSkills_list_relationNestedInput
    intelligence?: IntellengenceBasedSkillsUpdateOneWithoutSkills_list_relationNestedInput
    wisdom?: WisdomBasedSkillsUpdateOneWithoutSkills_list_relationNestedInput
    charisma?: CharismaBasedSkillsUpdateOneWithoutSkills_list_relationNestedInput
    id_relation?: CreatureUpdateOneRequiredWithoutSkillsNestedInput
  }

  export type SkillsListUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    strength?: StrengthBasedSkillsUncheckedUpdateOneWithoutSkills_list_relationNestedInput
    dexterity?: DexterityBasedSkillsUncheckedUpdateOneWithoutSkills_list_relationNestedInput
    intelligence?: IntellengenceBasedSkillsUncheckedUpdateOneWithoutSkills_list_relationNestedInput
    wisdom?: WisdomBasedSkillsUncheckedUpdateOneWithoutSkills_list_relationNestedInput
    charisma?: CharismaBasedSkillsUncheckedUpdateOneWithoutSkills_list_relationNestedInput
  }

  export type SkillsListCreateManyInput = {
    id: string
  }

  export type SkillsListUpdateManyMutationInput = {

  }

  export type SkillsListUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
  }

  export type StrengthBasedSkillsCreateInput = {
    athletics?: AthleticsSkillCreateNestedOneWithoutSkill_listInput
    skills_list_relation: SkillsListCreateNestedOneWithoutStrengthInput
  }

  export type StrengthBasedSkillsUncheckedCreateInput = {
    id: string
    athletics?: AthleticsSkillUncheckedCreateNestedOneWithoutSkill_listInput
  }

  export type StrengthBasedSkillsUpdateInput = {
    athletics?: AthleticsSkillUpdateOneWithoutSkill_listNestedInput
    skills_list_relation?: SkillsListUpdateOneRequiredWithoutStrengthNestedInput
  }

  export type StrengthBasedSkillsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    athletics?: AthleticsSkillUncheckedUpdateOneWithoutSkill_listNestedInput
  }

  export type StrengthBasedSkillsCreateManyInput = {
    id: string
  }

  export type StrengthBasedSkillsUpdateManyMutationInput = {

  }

  export type StrengthBasedSkillsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
  }

  export type DexterityBasedSkillsCreateInput = {
    acrobatics?: AcrobaticsSkillCreateNestedOneWithoutSkill_listInput
    sleight_of_hand?: SleightOfHandSkillCreateNestedOneWithoutSkill_listInput
    stealth?: StealthSkillCreateNestedOneWithoutSkill_listInput
    skills_list_relation: SkillsListCreateNestedOneWithoutDexterityInput
  }

  export type DexterityBasedSkillsUncheckedCreateInput = {
    id: string
    acrobatics?: AcrobaticsSkillUncheckedCreateNestedOneWithoutSkill_listInput
    sleight_of_hand?: SleightOfHandSkillUncheckedCreateNestedOneWithoutSkill_listInput
    stealth?: StealthSkillUncheckedCreateNestedOneWithoutSkill_listInput
  }

  export type DexterityBasedSkillsUpdateInput = {
    acrobatics?: AcrobaticsSkillUpdateOneWithoutSkill_listNestedInput
    sleight_of_hand?: SleightOfHandSkillUpdateOneWithoutSkill_listNestedInput
    stealth?: StealthSkillUpdateOneWithoutSkill_listNestedInput
    skills_list_relation?: SkillsListUpdateOneRequiredWithoutDexterityNestedInput
  }

  export type DexterityBasedSkillsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    acrobatics?: AcrobaticsSkillUncheckedUpdateOneWithoutSkill_listNestedInput
    sleight_of_hand?: SleightOfHandSkillUncheckedUpdateOneWithoutSkill_listNestedInput
    stealth?: StealthSkillUncheckedUpdateOneWithoutSkill_listNestedInput
  }

  export type DexterityBasedSkillsCreateManyInput = {
    id: string
  }

  export type DexterityBasedSkillsUpdateManyMutationInput = {

  }

  export type DexterityBasedSkillsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
  }

  export type IntellengenceBasedSkillsCreateInput = {
    arcana?: ArcanaSkillCreateNestedOneWithoutSkill_listInput
    history?: HistorySkillCreateNestedOneWithoutSkill_listInput
    investigation?: InvestigationSkillCreateNestedOneWithoutSkill_listInput
    nature?: NatureSkillCreateNestedOneWithoutSkill_listInput
    religion?: ReligionSkillCreateNestedOneWithoutSkill_listInput
    skills_list_relation: SkillsListCreateNestedOneWithoutIntelligenceInput
  }

  export type IntellengenceBasedSkillsUncheckedCreateInput = {
    id: string
    arcana?: ArcanaSkillUncheckedCreateNestedOneWithoutSkill_listInput
    history?: HistorySkillUncheckedCreateNestedOneWithoutSkill_listInput
    investigation?: InvestigationSkillUncheckedCreateNestedOneWithoutSkill_listInput
    nature?: NatureSkillUncheckedCreateNestedOneWithoutSkill_listInput
    religion?: ReligionSkillUncheckedCreateNestedOneWithoutSkill_listInput
  }

  export type IntellengenceBasedSkillsUpdateInput = {
    arcana?: ArcanaSkillUpdateOneWithoutSkill_listNestedInput
    history?: HistorySkillUpdateOneWithoutSkill_listNestedInput
    investigation?: InvestigationSkillUpdateOneWithoutSkill_listNestedInput
    nature?: NatureSkillUpdateOneWithoutSkill_listNestedInput
    religion?: ReligionSkillUpdateOneWithoutSkill_listNestedInput
    skills_list_relation?: SkillsListUpdateOneRequiredWithoutIntelligenceNestedInput
  }

  export type IntellengenceBasedSkillsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    arcana?: ArcanaSkillUncheckedUpdateOneWithoutSkill_listNestedInput
    history?: HistorySkillUncheckedUpdateOneWithoutSkill_listNestedInput
    investigation?: InvestigationSkillUncheckedUpdateOneWithoutSkill_listNestedInput
    nature?: NatureSkillUncheckedUpdateOneWithoutSkill_listNestedInput
    religion?: ReligionSkillUncheckedUpdateOneWithoutSkill_listNestedInput
  }

  export type IntellengenceBasedSkillsCreateManyInput = {
    id: string
  }

  export type IntellengenceBasedSkillsUpdateManyMutationInput = {

  }

  export type IntellengenceBasedSkillsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
  }

  export type WisdomBasedSkillsCreateInput = {
    animal_handling?: AnimalHandlingSkillCreateNestedOneWithoutSkill_listInput
    insight?: InsightSkillCreateNestedOneWithoutSkill_listInput
    medicine?: MedicineSkillCreateNestedOneWithoutSkill_listInput
    perception?: PerceptionSkillCreateNestedOneWithoutSkill_listInput
    survival?: SurvivalSkillCreateNestedOneWithoutSkill_listInput
    skills_list_relation: SkillsListCreateNestedOneWithoutWisdomInput
  }

  export type WisdomBasedSkillsUncheckedCreateInput = {
    id: string
    animal_handling?: AnimalHandlingSkillUncheckedCreateNestedOneWithoutSkill_listInput
    insight?: InsightSkillUncheckedCreateNestedOneWithoutSkill_listInput
    medicine?: MedicineSkillUncheckedCreateNestedOneWithoutSkill_listInput
    perception?: PerceptionSkillUncheckedCreateNestedOneWithoutSkill_listInput
    survival?: SurvivalSkillUncheckedCreateNestedOneWithoutSkill_listInput
  }

  export type WisdomBasedSkillsUpdateInput = {
    animal_handling?: AnimalHandlingSkillUpdateOneWithoutSkill_listNestedInput
    insight?: InsightSkillUpdateOneWithoutSkill_listNestedInput
    medicine?: MedicineSkillUpdateOneWithoutSkill_listNestedInput
    perception?: PerceptionSkillUpdateOneWithoutSkill_listNestedInput
    survival?: SurvivalSkillUpdateOneWithoutSkill_listNestedInput
    skills_list_relation?: SkillsListUpdateOneRequiredWithoutWisdomNestedInput
  }

  export type WisdomBasedSkillsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    animal_handling?: AnimalHandlingSkillUncheckedUpdateOneWithoutSkill_listNestedInput
    insight?: InsightSkillUncheckedUpdateOneWithoutSkill_listNestedInput
    medicine?: MedicineSkillUncheckedUpdateOneWithoutSkill_listNestedInput
    perception?: PerceptionSkillUncheckedUpdateOneWithoutSkill_listNestedInput
    survival?: SurvivalSkillUncheckedUpdateOneWithoutSkill_listNestedInput
  }

  export type WisdomBasedSkillsCreateManyInput = {
    id: string
  }

  export type WisdomBasedSkillsUpdateManyMutationInput = {

  }

  export type WisdomBasedSkillsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
  }

  export type CharismaBasedSkillsCreateInput = {
    deception?: DeceptionSkillCreateNestedOneWithoutSkill_listInput
    intimidation?: IntimidationSkillCreateNestedOneWithoutSkill_listInput
    performance?: PerformanceSkillCreateNestedOneWithoutSkill_listInput
    persuasion?: PersuasionSkillCreateNestedOneWithoutSkill_listInput
    skills_list_relation: SkillsListCreateNestedOneWithoutCharismaInput
  }

  export type CharismaBasedSkillsUncheckedCreateInput = {
    id: string
    deception?: DeceptionSkillUncheckedCreateNestedOneWithoutSkill_listInput
    intimidation?: IntimidationSkillUncheckedCreateNestedOneWithoutSkill_listInput
    performance?: PerformanceSkillUncheckedCreateNestedOneWithoutSkill_listInput
    persuasion?: PersuasionSkillUncheckedCreateNestedOneWithoutSkill_listInput
  }

  export type CharismaBasedSkillsUpdateInput = {
    deception?: DeceptionSkillUpdateOneWithoutSkill_listNestedInput
    intimidation?: IntimidationSkillUpdateOneWithoutSkill_listNestedInput
    performance?: PerformanceSkillUpdateOneWithoutSkill_listNestedInput
    persuasion?: PersuasionSkillUpdateOneWithoutSkill_listNestedInput
    skills_list_relation?: SkillsListUpdateOneRequiredWithoutCharismaNestedInput
  }

  export type CharismaBasedSkillsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    deception?: DeceptionSkillUncheckedUpdateOneWithoutSkill_listNestedInput
    intimidation?: IntimidationSkillUncheckedUpdateOneWithoutSkill_listNestedInput
    performance?: PerformanceSkillUncheckedUpdateOneWithoutSkill_listNestedInput
    persuasion?: PersuasionSkillUncheckedUpdateOneWithoutSkill_listNestedInput
  }

  export type CharismaBasedSkillsCreateManyInput = {
    id: string
  }

  export type CharismaBasedSkillsUpdateManyMutationInput = {

  }

  export type CharismaBasedSkillsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
  }

  export type AthleticsSkillCreateInput = {
    value?: number | null
    mastery: boolean
    name?: string
    skill_list: StrengthBasedSkillsCreateNestedOneWithoutAthleticsInput
  }

  export type AthleticsSkillUncheckedCreateInput = {
    id: string
    value?: number | null
    mastery: boolean
    name?: string
  }

  export type AthleticsSkillUpdateInput = {
    value?: NullableIntFieldUpdateOperationsInput | number | null
    mastery?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
    skill_list?: StrengthBasedSkillsUpdateOneRequiredWithoutAthleticsNestedInput
  }

  export type AthleticsSkillUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    value?: NullableIntFieldUpdateOperationsInput | number | null
    mastery?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
  }

  export type AthleticsSkillCreateManyInput = {
    id: string
    value?: number | null
    mastery: boolean
    name?: string
  }

  export type AthleticsSkillUpdateManyMutationInput = {
    value?: NullableIntFieldUpdateOperationsInput | number | null
    mastery?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
  }

  export type AthleticsSkillUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    value?: NullableIntFieldUpdateOperationsInput | number | null
    mastery?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
  }

  export type AcrobaticsSkillCreateInput = {
    value?: number | null
    mastery: boolean
    name?: string
    skill_list: DexterityBasedSkillsCreateNestedOneWithoutAcrobaticsInput
  }

  export type AcrobaticsSkillUncheckedCreateInput = {
    id: string
    value?: number | null
    mastery: boolean
    name?: string
  }

  export type AcrobaticsSkillUpdateInput = {
    value?: NullableIntFieldUpdateOperationsInput | number | null
    mastery?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
    skill_list?: DexterityBasedSkillsUpdateOneRequiredWithoutAcrobaticsNestedInput
  }

  export type AcrobaticsSkillUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    value?: NullableIntFieldUpdateOperationsInput | number | null
    mastery?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
  }

  export type AcrobaticsSkillCreateManyInput = {
    id: string
    value?: number | null
    mastery: boolean
    name?: string
  }

  export type AcrobaticsSkillUpdateManyMutationInput = {
    value?: NullableIntFieldUpdateOperationsInput | number | null
    mastery?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
  }

  export type AcrobaticsSkillUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    value?: NullableIntFieldUpdateOperationsInput | number | null
    mastery?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
  }

  export type SleightOfHandSkillCreateInput = {
    value?: number | null
    mastery: boolean
    name?: string
    skill_list: DexterityBasedSkillsCreateNestedOneWithoutSleight_of_handInput
  }

  export type SleightOfHandSkillUncheckedCreateInput = {
    id: string
    value?: number | null
    mastery: boolean
    name?: string
  }

  export type SleightOfHandSkillUpdateInput = {
    value?: NullableIntFieldUpdateOperationsInput | number | null
    mastery?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
    skill_list?: DexterityBasedSkillsUpdateOneRequiredWithoutSleight_of_handNestedInput
  }

  export type SleightOfHandSkillUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    value?: NullableIntFieldUpdateOperationsInput | number | null
    mastery?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
  }

  export type SleightOfHandSkillCreateManyInput = {
    id: string
    value?: number | null
    mastery: boolean
    name?: string
  }

  export type SleightOfHandSkillUpdateManyMutationInput = {
    value?: NullableIntFieldUpdateOperationsInput | number | null
    mastery?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
  }

  export type SleightOfHandSkillUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    value?: NullableIntFieldUpdateOperationsInput | number | null
    mastery?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
  }

  export type StealthSkillCreateInput = {
    value?: number | null
    mastery: boolean
    name?: string
    skill_list: DexterityBasedSkillsCreateNestedOneWithoutStealthInput
  }

  export type StealthSkillUncheckedCreateInput = {
    id: string
    value?: number | null
    mastery: boolean
    name?: string
  }

  export type StealthSkillUpdateInput = {
    value?: NullableIntFieldUpdateOperationsInput | number | null
    mastery?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
    skill_list?: DexterityBasedSkillsUpdateOneRequiredWithoutStealthNestedInput
  }

  export type StealthSkillUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    value?: NullableIntFieldUpdateOperationsInput | number | null
    mastery?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
  }

  export type StealthSkillCreateManyInput = {
    id: string
    value?: number | null
    mastery: boolean
    name?: string
  }

  export type StealthSkillUpdateManyMutationInput = {
    value?: NullableIntFieldUpdateOperationsInput | number | null
    mastery?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
  }

  export type StealthSkillUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    value?: NullableIntFieldUpdateOperationsInput | number | null
    mastery?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
  }

  export type ArcanaSkillCreateInput = {
    value?: number | null
    mastery: boolean
    name?: string
    skill_list: IntellengenceBasedSkillsCreateNestedOneWithoutArcanaInput
  }

  export type ArcanaSkillUncheckedCreateInput = {
    id: string
    value?: number | null
    mastery: boolean
    name?: string
  }

  export type ArcanaSkillUpdateInput = {
    value?: NullableIntFieldUpdateOperationsInput | number | null
    mastery?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
    skill_list?: IntellengenceBasedSkillsUpdateOneRequiredWithoutArcanaNestedInput
  }

  export type ArcanaSkillUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    value?: NullableIntFieldUpdateOperationsInput | number | null
    mastery?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
  }

  export type ArcanaSkillCreateManyInput = {
    id: string
    value?: number | null
    mastery: boolean
    name?: string
  }

  export type ArcanaSkillUpdateManyMutationInput = {
    value?: NullableIntFieldUpdateOperationsInput | number | null
    mastery?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
  }

  export type ArcanaSkillUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    value?: NullableIntFieldUpdateOperationsInput | number | null
    mastery?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
  }

  export type HistorySkillCreateInput = {
    value?: number | null
    mastery: boolean
    name?: string
    skill_list: IntellengenceBasedSkillsCreateNestedOneWithoutHistoryInput
  }

  export type HistorySkillUncheckedCreateInput = {
    id: string
    value?: number | null
    mastery: boolean
    name?: string
  }

  export type HistorySkillUpdateInput = {
    value?: NullableIntFieldUpdateOperationsInput | number | null
    mastery?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
    skill_list?: IntellengenceBasedSkillsUpdateOneRequiredWithoutHistoryNestedInput
  }

  export type HistorySkillUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    value?: NullableIntFieldUpdateOperationsInput | number | null
    mastery?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
  }

  export type HistorySkillCreateManyInput = {
    id: string
    value?: number | null
    mastery: boolean
    name?: string
  }

  export type HistorySkillUpdateManyMutationInput = {
    value?: NullableIntFieldUpdateOperationsInput | number | null
    mastery?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
  }

  export type HistorySkillUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    value?: NullableIntFieldUpdateOperationsInput | number | null
    mastery?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
  }

  export type InvestigationSkillCreateInput = {
    value?: number | null
    mastery: boolean
    name?: string
    skill_list: IntellengenceBasedSkillsCreateNestedOneWithoutInvestigationInput
  }

  export type InvestigationSkillUncheckedCreateInput = {
    id: string
    value?: number | null
    mastery: boolean
    name?: string
  }

  export type InvestigationSkillUpdateInput = {
    value?: NullableIntFieldUpdateOperationsInput | number | null
    mastery?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
    skill_list?: IntellengenceBasedSkillsUpdateOneRequiredWithoutInvestigationNestedInput
  }

  export type InvestigationSkillUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    value?: NullableIntFieldUpdateOperationsInput | number | null
    mastery?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
  }

  export type InvestigationSkillCreateManyInput = {
    id: string
    value?: number | null
    mastery: boolean
    name?: string
  }

  export type InvestigationSkillUpdateManyMutationInput = {
    value?: NullableIntFieldUpdateOperationsInput | number | null
    mastery?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
  }

  export type InvestigationSkillUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    value?: NullableIntFieldUpdateOperationsInput | number | null
    mastery?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
  }

  export type NatureSkillCreateInput = {
    value?: number | null
    mastery: boolean
    name?: string
    skill_list: IntellengenceBasedSkillsCreateNestedOneWithoutNatureInput
  }

  export type NatureSkillUncheckedCreateInput = {
    id: string
    value?: number | null
    mastery: boolean
    name?: string
  }

  export type NatureSkillUpdateInput = {
    value?: NullableIntFieldUpdateOperationsInput | number | null
    mastery?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
    skill_list?: IntellengenceBasedSkillsUpdateOneRequiredWithoutNatureNestedInput
  }

  export type NatureSkillUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    value?: NullableIntFieldUpdateOperationsInput | number | null
    mastery?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
  }

  export type NatureSkillCreateManyInput = {
    id: string
    value?: number | null
    mastery: boolean
    name?: string
  }

  export type NatureSkillUpdateManyMutationInput = {
    value?: NullableIntFieldUpdateOperationsInput | number | null
    mastery?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
  }

  export type NatureSkillUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    value?: NullableIntFieldUpdateOperationsInput | number | null
    mastery?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
  }

  export type ReligionSkillCreateInput = {
    value?: number | null
    mastery: boolean
    name?: string
    skill_list: IntellengenceBasedSkillsCreateNestedOneWithoutReligionInput
  }

  export type ReligionSkillUncheckedCreateInput = {
    id: string
    value?: number | null
    mastery: boolean
    name?: string
  }

  export type ReligionSkillUpdateInput = {
    value?: NullableIntFieldUpdateOperationsInput | number | null
    mastery?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
    skill_list?: IntellengenceBasedSkillsUpdateOneRequiredWithoutReligionNestedInput
  }

  export type ReligionSkillUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    value?: NullableIntFieldUpdateOperationsInput | number | null
    mastery?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
  }

  export type ReligionSkillCreateManyInput = {
    id: string
    value?: number | null
    mastery: boolean
    name?: string
  }

  export type ReligionSkillUpdateManyMutationInput = {
    value?: NullableIntFieldUpdateOperationsInput | number | null
    mastery?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
  }

  export type ReligionSkillUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    value?: NullableIntFieldUpdateOperationsInput | number | null
    mastery?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
  }

  export type AnimalHandlingSkillCreateInput = {
    value?: number | null
    mastery: boolean
    name?: string
    skill_list: WisdomBasedSkillsCreateNestedOneWithoutAnimal_handlingInput
  }

  export type AnimalHandlingSkillUncheckedCreateInput = {
    id: string
    value?: number | null
    mastery: boolean
    name?: string
  }

  export type AnimalHandlingSkillUpdateInput = {
    value?: NullableIntFieldUpdateOperationsInput | number | null
    mastery?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
    skill_list?: WisdomBasedSkillsUpdateOneRequiredWithoutAnimal_handlingNestedInput
  }

  export type AnimalHandlingSkillUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    value?: NullableIntFieldUpdateOperationsInput | number | null
    mastery?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
  }

  export type AnimalHandlingSkillCreateManyInput = {
    id: string
    value?: number | null
    mastery: boolean
    name?: string
  }

  export type AnimalHandlingSkillUpdateManyMutationInput = {
    value?: NullableIntFieldUpdateOperationsInput | number | null
    mastery?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
  }

  export type AnimalHandlingSkillUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    value?: NullableIntFieldUpdateOperationsInput | number | null
    mastery?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
  }

  export type InsightSkillCreateInput = {
    value?: number | null
    mastery: boolean
    name?: string
    skill_list: WisdomBasedSkillsCreateNestedOneWithoutInsightInput
  }

  export type InsightSkillUncheckedCreateInput = {
    id: string
    value?: number | null
    mastery: boolean
    name?: string
  }

  export type InsightSkillUpdateInput = {
    value?: NullableIntFieldUpdateOperationsInput | number | null
    mastery?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
    skill_list?: WisdomBasedSkillsUpdateOneRequiredWithoutInsightNestedInput
  }

  export type InsightSkillUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    value?: NullableIntFieldUpdateOperationsInput | number | null
    mastery?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
  }

  export type InsightSkillCreateManyInput = {
    id: string
    value?: number | null
    mastery: boolean
    name?: string
  }

  export type InsightSkillUpdateManyMutationInput = {
    value?: NullableIntFieldUpdateOperationsInput | number | null
    mastery?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
  }

  export type InsightSkillUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    value?: NullableIntFieldUpdateOperationsInput | number | null
    mastery?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
  }

  export type MedicineSkillCreateInput = {
    value?: number | null
    mastery: boolean
    name?: string
    skill_list: WisdomBasedSkillsCreateNestedOneWithoutMedicineInput
  }

  export type MedicineSkillUncheckedCreateInput = {
    id: string
    value?: number | null
    mastery: boolean
    name?: string
  }

  export type MedicineSkillUpdateInput = {
    value?: NullableIntFieldUpdateOperationsInput | number | null
    mastery?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
    skill_list?: WisdomBasedSkillsUpdateOneRequiredWithoutMedicineNestedInput
  }

  export type MedicineSkillUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    value?: NullableIntFieldUpdateOperationsInput | number | null
    mastery?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
  }

  export type MedicineSkillCreateManyInput = {
    id: string
    value?: number | null
    mastery: boolean
    name?: string
  }

  export type MedicineSkillUpdateManyMutationInput = {
    value?: NullableIntFieldUpdateOperationsInput | number | null
    mastery?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
  }

  export type MedicineSkillUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    value?: NullableIntFieldUpdateOperationsInput | number | null
    mastery?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
  }

  export type PerceptionSkillCreateInput = {
    value?: number | null
    mastery: boolean
    name?: string
    skill_list: WisdomBasedSkillsCreateNestedOneWithoutPerceptionInput
  }

  export type PerceptionSkillUncheckedCreateInput = {
    id: string
    value?: number | null
    mastery: boolean
    name?: string
  }

  export type PerceptionSkillUpdateInput = {
    value?: NullableIntFieldUpdateOperationsInput | number | null
    mastery?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
    skill_list?: WisdomBasedSkillsUpdateOneRequiredWithoutPerceptionNestedInput
  }

  export type PerceptionSkillUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    value?: NullableIntFieldUpdateOperationsInput | number | null
    mastery?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
  }

  export type PerceptionSkillCreateManyInput = {
    id: string
    value?: number | null
    mastery: boolean
    name?: string
  }

  export type PerceptionSkillUpdateManyMutationInput = {
    value?: NullableIntFieldUpdateOperationsInput | number | null
    mastery?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
  }

  export type PerceptionSkillUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    value?: NullableIntFieldUpdateOperationsInput | number | null
    mastery?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
  }

  export type SurvivalSkillCreateInput = {
    value?: number | null
    mastery: boolean
    name?: string
    skill_list: WisdomBasedSkillsCreateNestedOneWithoutSurvivalInput
  }

  export type SurvivalSkillUncheckedCreateInput = {
    id: string
    value?: number | null
    mastery: boolean
    name?: string
  }

  export type SurvivalSkillUpdateInput = {
    value?: NullableIntFieldUpdateOperationsInput | number | null
    mastery?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
    skill_list?: WisdomBasedSkillsUpdateOneRequiredWithoutSurvivalNestedInput
  }

  export type SurvivalSkillUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    value?: NullableIntFieldUpdateOperationsInput | number | null
    mastery?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
  }

  export type SurvivalSkillCreateManyInput = {
    id: string
    value?: number | null
    mastery: boolean
    name?: string
  }

  export type SurvivalSkillUpdateManyMutationInput = {
    value?: NullableIntFieldUpdateOperationsInput | number | null
    mastery?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
  }

  export type SurvivalSkillUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    value?: NullableIntFieldUpdateOperationsInput | number | null
    mastery?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
  }

  export type DeceptionSkillCreateInput = {
    value?: number | null
    mastery: boolean
    name?: string
    skill_list: CharismaBasedSkillsCreateNestedOneWithoutDeceptionInput
  }

  export type DeceptionSkillUncheckedCreateInput = {
    id: string
    value?: number | null
    mastery: boolean
    name?: string
  }

  export type DeceptionSkillUpdateInput = {
    value?: NullableIntFieldUpdateOperationsInput | number | null
    mastery?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
    skill_list?: CharismaBasedSkillsUpdateOneRequiredWithoutDeceptionNestedInput
  }

  export type DeceptionSkillUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    value?: NullableIntFieldUpdateOperationsInput | number | null
    mastery?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
  }

  export type DeceptionSkillCreateManyInput = {
    id: string
    value?: number | null
    mastery: boolean
    name?: string
  }

  export type DeceptionSkillUpdateManyMutationInput = {
    value?: NullableIntFieldUpdateOperationsInput | number | null
    mastery?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
  }

  export type DeceptionSkillUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    value?: NullableIntFieldUpdateOperationsInput | number | null
    mastery?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
  }

  export type IntimidationSkillCreateInput = {
    value?: number | null
    mastery: boolean
    name?: string
    skill_list: CharismaBasedSkillsCreateNestedOneWithoutIntimidationInput
  }

  export type IntimidationSkillUncheckedCreateInput = {
    id: string
    value?: number | null
    mastery: boolean
    name?: string
  }

  export type IntimidationSkillUpdateInput = {
    value?: NullableIntFieldUpdateOperationsInput | number | null
    mastery?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
    skill_list?: CharismaBasedSkillsUpdateOneRequiredWithoutIntimidationNestedInput
  }

  export type IntimidationSkillUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    value?: NullableIntFieldUpdateOperationsInput | number | null
    mastery?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
  }

  export type IntimidationSkillCreateManyInput = {
    id: string
    value?: number | null
    mastery: boolean
    name?: string
  }

  export type IntimidationSkillUpdateManyMutationInput = {
    value?: NullableIntFieldUpdateOperationsInput | number | null
    mastery?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
  }

  export type IntimidationSkillUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    value?: NullableIntFieldUpdateOperationsInput | number | null
    mastery?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
  }

  export type PerformanceSkillCreateInput = {
    value?: number | null
    mastery: boolean
    name?: string
    skill_list: CharismaBasedSkillsCreateNestedOneWithoutPerformanceInput
  }

  export type PerformanceSkillUncheckedCreateInput = {
    id: string
    value?: number | null
    mastery: boolean
    name?: string
  }

  export type PerformanceSkillUpdateInput = {
    value?: NullableIntFieldUpdateOperationsInput | number | null
    mastery?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
    skill_list?: CharismaBasedSkillsUpdateOneRequiredWithoutPerformanceNestedInput
  }

  export type PerformanceSkillUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    value?: NullableIntFieldUpdateOperationsInput | number | null
    mastery?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
  }

  export type PerformanceSkillCreateManyInput = {
    id: string
    value?: number | null
    mastery: boolean
    name?: string
  }

  export type PerformanceSkillUpdateManyMutationInput = {
    value?: NullableIntFieldUpdateOperationsInput | number | null
    mastery?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
  }

  export type PerformanceSkillUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    value?: NullableIntFieldUpdateOperationsInput | number | null
    mastery?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
  }

  export type PersuasionSkillCreateInput = {
    value?: number | null
    mastery: boolean
    name?: string
    skill_list: CharismaBasedSkillsCreateNestedOneWithoutPersuasionInput
  }

  export type PersuasionSkillUncheckedCreateInput = {
    id: string
    value?: number | null
    mastery: boolean
    name?: string
  }

  export type PersuasionSkillUpdateInput = {
    value?: NullableIntFieldUpdateOperationsInput | number | null
    mastery?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
    skill_list?: CharismaBasedSkillsUpdateOneRequiredWithoutPersuasionNestedInput
  }

  export type PersuasionSkillUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    value?: NullableIntFieldUpdateOperationsInput | number | null
    mastery?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
  }

  export type PersuasionSkillCreateManyInput = {
    id: string
    value?: number | null
    mastery: boolean
    name?: string
  }

  export type PersuasionSkillUpdateManyMutationInput = {
    value?: NullableIntFieldUpdateOperationsInput | number | null
    mastery?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
  }

  export type PersuasionSkillUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    value?: NullableIntFieldUpdateOperationsInput | number | null
    mastery?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
  }

  export type CreatureCreateInput = {
    id?: string
    name: string
    creator_id?: string | null
    image_uri?: string | null
    description?: string | null
    armor_class?: number | null
    hit_points?: number | null
    challenge_rating: string
    biomes_ids?: CreatureCreatebiomes_idsInput | number[]
    aSubTypes?: CreatureCreateaSubTypesInput | string[]
    speed?: Speed_statCreateNestedOneWithoutId_relationInput
    stats?: Creature_statsCreateNestedOneWithoutId_relationInput
    skills?: SkillsListCreateNestedOneWithoutId_relationInput
    resistances?: DamageTypeCreateNestedManyWithoutResistant_creaturesInput
    immunities?: DamageTypeCreateNestedManyWithoutImmune_creaturesInput
    vulnerabilities?: DamageTypeCreateNestedManyWithoutVunlerable_creaturesInput
    senses?: SensesCreateNestedOneWithoutCreatureInput
    languages?: LanguageCreateNestedManyWithoutCreaturesInput
    actions?: ActionCreateNestedManyWithoutCreaturesInput
    traits?: TraitCreateNestedManyWithoutCreturesInput
    alignment_relation?: AlignmentCreateNestedOneWithoutCreaturesInput
    race_relation?: CreatureRaceCreateNestedOneWithoutCreaturesInput
    type_relation?: TypeCreateNestedOneWithoutCreaturesInput
    size_relation?: SizeCreateNestedOneWithoutCreatureInput
    biome_relation?: BiomeCreateNestedManyWithoutCreaturesInput
    source_relation?: SourceCreateNestedOneWithoutCreaturesInput
  }

  export type CreatureUncheckedCreateInput = {
    id?: string
    name: string
    creator_id?: string | null
    image_uri?: string | null
    description?: string | null
    size?: string | null
    race_id?: number | null
    source_id?: number | null
    alignment_id?: number | null
    armor_class?: number | null
    hit_points?: number | null
    challenge_rating: string
    biomes_ids?: CreatureCreatebiomes_idsInput | number[]
    type_id?: number | null
    aSubTypes?: CreatureCreateaSubTypesInput | string[]
    speed?: Speed_statUncheckedCreateNestedOneWithoutId_relationInput
    stats?: Creature_statsUncheckedCreateNestedOneWithoutId_relationInput
    skills?: SkillsListUncheckedCreateNestedOneWithoutId_relationInput
    resistances?: DamageTypeUncheckedCreateNestedManyWithoutResistant_creaturesInput
    immunities?: DamageTypeUncheckedCreateNestedManyWithoutImmune_creaturesInput
    vulnerabilities?: DamageTypeUncheckedCreateNestedManyWithoutVunlerable_creaturesInput
    senses?: SensesUncheckedCreateNestedOneWithoutCreatureInput
    languages?: LanguageUncheckedCreateNestedManyWithoutCreaturesInput
    actions?: ActionUncheckedCreateNestedManyWithoutCreaturesInput
    traits?: TraitUncheckedCreateNestedManyWithoutCreturesInput
    biome_relation?: BiomeUncheckedCreateNestedManyWithoutCreaturesInput
  }

  export type CreatureUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    creator_id?: NullableStringFieldUpdateOperationsInput | string | null
    image_uri?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    armor_class?: NullableIntFieldUpdateOperationsInput | number | null
    hit_points?: NullableIntFieldUpdateOperationsInput | number | null
    challenge_rating?: StringFieldUpdateOperationsInput | string
    biomes_ids?: CreatureUpdatebiomes_idsInput | number[]
    aSubTypes?: CreatureUpdateaSubTypesInput | string[]
    speed?: Speed_statUpdateOneWithoutId_relationNestedInput
    stats?: Creature_statsUpdateOneWithoutId_relationNestedInput
    skills?: SkillsListUpdateOneWithoutId_relationNestedInput
    resistances?: DamageTypeUpdateManyWithoutResistant_creaturesNestedInput
    immunities?: DamageTypeUpdateManyWithoutImmune_creaturesNestedInput
    vulnerabilities?: DamageTypeUpdateManyWithoutVunlerable_creaturesNestedInput
    senses?: SensesUpdateOneWithoutCreatureNestedInput
    languages?: LanguageUpdateManyWithoutCreaturesNestedInput
    actions?: ActionUpdateManyWithoutCreaturesNestedInput
    traits?: TraitUpdateManyWithoutCreturesNestedInput
    alignment_relation?: AlignmentUpdateOneWithoutCreaturesNestedInput
    race_relation?: CreatureRaceUpdateOneWithoutCreaturesNestedInput
    type_relation?: TypeUpdateOneWithoutCreaturesNestedInput
    size_relation?: SizeUpdateOneWithoutCreatureNestedInput
    biome_relation?: BiomeUpdateManyWithoutCreaturesNestedInput
    source_relation?: SourceUpdateOneWithoutCreaturesNestedInput
  }

  export type CreatureUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    creator_id?: NullableStringFieldUpdateOperationsInput | string | null
    image_uri?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableStringFieldUpdateOperationsInput | string | null
    race_id?: NullableIntFieldUpdateOperationsInput | number | null
    source_id?: NullableIntFieldUpdateOperationsInput | number | null
    alignment_id?: NullableIntFieldUpdateOperationsInput | number | null
    armor_class?: NullableIntFieldUpdateOperationsInput | number | null
    hit_points?: NullableIntFieldUpdateOperationsInput | number | null
    challenge_rating?: StringFieldUpdateOperationsInput | string
    biomes_ids?: CreatureUpdatebiomes_idsInput | number[]
    type_id?: NullableIntFieldUpdateOperationsInput | number | null
    aSubTypes?: CreatureUpdateaSubTypesInput | string[]
    speed?: Speed_statUncheckedUpdateOneWithoutId_relationNestedInput
    stats?: Creature_statsUncheckedUpdateOneWithoutId_relationNestedInput
    skills?: SkillsListUncheckedUpdateOneWithoutId_relationNestedInput
    resistances?: DamageTypeUncheckedUpdateManyWithoutResistant_creaturesNestedInput
    immunities?: DamageTypeUncheckedUpdateManyWithoutImmune_creaturesNestedInput
    vulnerabilities?: DamageTypeUncheckedUpdateManyWithoutVunlerable_creaturesNestedInput
    senses?: SensesUncheckedUpdateOneWithoutCreatureNestedInput
    languages?: LanguageUncheckedUpdateManyWithoutCreaturesNestedInput
    actions?: ActionUncheckedUpdateManyWithoutCreaturesNestedInput
    traits?: TraitUncheckedUpdateManyWithoutCreturesNestedInput
    biome_relation?: BiomeUncheckedUpdateManyWithoutCreaturesNestedInput
  }

  export type CreatureCreateManyInput = {
    id?: string
    name: string
    creator_id?: string | null
    image_uri?: string | null
    description?: string | null
    size?: string | null
    race_id?: number | null
    source_id?: number | null
    alignment_id?: number | null
    armor_class?: number | null
    hit_points?: number | null
    challenge_rating: string
    biomes_ids?: CreatureCreatebiomes_idsInput | number[]
    type_id?: number | null
    aSubTypes?: CreatureCreateaSubTypesInput | string[]
  }

  export type CreatureUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    creator_id?: NullableStringFieldUpdateOperationsInput | string | null
    image_uri?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    armor_class?: NullableIntFieldUpdateOperationsInput | number | null
    hit_points?: NullableIntFieldUpdateOperationsInput | number | null
    challenge_rating?: StringFieldUpdateOperationsInput | string
    biomes_ids?: CreatureUpdatebiomes_idsInput | number[]
    aSubTypes?: CreatureUpdateaSubTypesInput | string[]
  }

  export type CreatureUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    creator_id?: NullableStringFieldUpdateOperationsInput | string | null
    image_uri?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableStringFieldUpdateOperationsInput | string | null
    race_id?: NullableIntFieldUpdateOperationsInput | number | null
    source_id?: NullableIntFieldUpdateOperationsInput | number | null
    alignment_id?: NullableIntFieldUpdateOperationsInput | number | null
    armor_class?: NullableIntFieldUpdateOperationsInput | number | null
    hit_points?: NullableIntFieldUpdateOperationsInput | number | null
    challenge_rating?: StringFieldUpdateOperationsInput | string
    biomes_ids?: CreatureUpdatebiomes_idsInput | number[]
    type_id?: NullableIntFieldUpdateOperationsInput | number | null
    aSubTypes?: CreatureUpdateaSubTypesInput | string[]
  }

  export type SensesCreateInput = {
    passive_perception?: number | null
    creature: CreatureCreateNestedOneWithoutSensesInput
  }

  export type SensesUncheckedCreateInput = {
    creature_id: string
    passive_perception?: number | null
  }

  export type SensesUpdateInput = {
    passive_perception?: NullableIntFieldUpdateOperationsInput | number | null
    creature?: CreatureUpdateOneRequiredWithoutSensesNestedInput
  }

  export type SensesUncheckedUpdateInput = {
    creature_id?: StringFieldUpdateOperationsInput | string
    passive_perception?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type SensesCreateManyInput = {
    creature_id: string
    passive_perception?: number | null
  }

  export type SensesUpdateManyMutationInput = {
    passive_perception?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type SensesUncheckedUpdateManyInput = {
    creature_id?: StringFieldUpdateOperationsInput | string
    passive_perception?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ActionCreateInput = {
    name: string
    description: string
    attack?: string | null
    is_template?: boolean | null
    creatures?: CreatureCreateNestedManyWithoutActionsInput
    creatureTypes?: CreatureRaceCreateNestedManyWithoutActionsInput
  }

  export type ActionUncheckedCreateInput = {
    id?: number
    name: string
    description: string
    attack?: string | null
    is_template?: boolean | null
    creatures?: CreatureUncheckedCreateNestedManyWithoutActionsInput
    creatureTypes?: CreatureRaceUncheckedCreateNestedManyWithoutActionsInput
  }

  export type ActionUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    attack?: NullableStringFieldUpdateOperationsInput | string | null
    is_template?: NullableBoolFieldUpdateOperationsInput | boolean | null
    creatures?: CreatureUpdateManyWithoutActionsNestedInput
    creatureTypes?: CreatureRaceUpdateManyWithoutActionsNestedInput
  }

  export type ActionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    attack?: NullableStringFieldUpdateOperationsInput | string | null
    is_template?: NullableBoolFieldUpdateOperationsInput | boolean | null
    creatures?: CreatureUncheckedUpdateManyWithoutActionsNestedInput
    creatureTypes?: CreatureRaceUncheckedUpdateManyWithoutActionsNestedInput
  }

  export type ActionCreateManyInput = {
    id?: number
    name: string
    description: string
    attack?: string | null
    is_template?: boolean | null
  }

  export type ActionUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    attack?: NullableStringFieldUpdateOperationsInput | string | null
    is_template?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type ActionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    attack?: NullableStringFieldUpdateOperationsInput | string | null
    is_template?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type TraitCreateInput = {
    name: string
    description: string
    attack?: string | null
    is_template?: boolean | null
    cretures?: CreatureCreateNestedManyWithoutTraitsInput
    creatureTypes?: CreatureRaceCreateNestedManyWithoutTraitsInput
  }

  export type TraitUncheckedCreateInput = {
    id?: number
    name: string
    description: string
    attack?: string | null
    is_template?: boolean | null
    cretures?: CreatureUncheckedCreateNestedManyWithoutTraitsInput
    creatureTypes?: CreatureRaceUncheckedCreateNestedManyWithoutTraitsInput
  }

  export type TraitUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    attack?: NullableStringFieldUpdateOperationsInput | string | null
    is_template?: NullableBoolFieldUpdateOperationsInput | boolean | null
    cretures?: CreatureUpdateManyWithoutTraitsNestedInput
    creatureTypes?: CreatureRaceUpdateManyWithoutTraitsNestedInput
  }

  export type TraitUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    attack?: NullableStringFieldUpdateOperationsInput | string | null
    is_template?: NullableBoolFieldUpdateOperationsInput | boolean | null
    cretures?: CreatureUncheckedUpdateManyWithoutTraitsNestedInput
    creatureTypes?: CreatureRaceUncheckedUpdateManyWithoutTraitsNestedInput
  }

  export type TraitCreateManyInput = {
    id?: number
    name: string
    description: string
    attack?: string | null
    is_template?: boolean | null
  }

  export type TraitUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    attack?: NullableStringFieldUpdateOperationsInput | string | null
    is_template?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type TraitUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    attack?: NullableStringFieldUpdateOperationsInput | string | null
    is_template?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type CreatureRaceCreateInput = {
    name: string
    description: string
    traits?: TraitCreateNestedManyWithoutCreatureTypesInput
    actions?: ActionCreateNestedManyWithoutCreatureTypesInput
    creatures?: CreatureCreateNestedManyWithoutRace_relationInput
  }

  export type CreatureRaceUncheckedCreateInput = {
    id?: number
    name: string
    description: string
    traits?: TraitUncheckedCreateNestedManyWithoutCreatureTypesInput
    actions?: ActionUncheckedCreateNestedManyWithoutCreatureTypesInput
    creatures?: CreatureUncheckedCreateNestedManyWithoutRace_relationInput
  }

  export type CreatureRaceUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    traits?: TraitUpdateManyWithoutCreatureTypesNestedInput
    actions?: ActionUpdateManyWithoutCreatureTypesNestedInput
    creatures?: CreatureUpdateManyWithoutRace_relationNestedInput
  }

  export type CreatureRaceUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    traits?: TraitUncheckedUpdateManyWithoutCreatureTypesNestedInput
    actions?: ActionUncheckedUpdateManyWithoutCreatureTypesNestedInput
    creatures?: CreatureUncheckedUpdateManyWithoutRace_relationNestedInput
  }

  export type CreatureRaceCreateManyInput = {
    id?: number
    name: string
    description: string
  }

  export type CreatureRaceUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
  }

  export type CreatureRaceUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
  }

  export type GenrationRequestCreateInput = {
    request: string
    danger: string
    name: string
  }

  export type GenrationRequestUncheckedCreateInput = {
    id?: number
    request: string
    danger: string
    name: string
  }

  export type GenrationRequestUpdateInput = {
    request?: StringFieldUpdateOperationsInput | string
    danger?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type GenrationRequestUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    request?: StringFieldUpdateOperationsInput | string
    danger?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type GenrationRequestCreateManyInput = {
    id?: number
    request: string
    danger: string
    name: string
  }

  export type GenrationRequestUpdateManyMutationInput = {
    request?: StringFieldUpdateOperationsInput | string
    danger?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type GenrationRequestUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    request?: StringFieldUpdateOperationsInput | string
    danger?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type DamageTypeCreateInput = {
    id: string
    name: string
    resistant_creatures?: CreatureCreateNestedManyWithoutResistancesInput
    immune_creatures?: CreatureCreateNestedManyWithoutImmunitiesInput
    vunlerable_creatures?: CreatureCreateNestedManyWithoutVulnerabilitiesInput
  }

  export type DamageTypeUncheckedCreateInput = {
    id: string
    name: string
    resistant_creatures?: CreatureUncheckedCreateNestedManyWithoutResistancesInput
    immune_creatures?: CreatureUncheckedCreateNestedManyWithoutImmunitiesInput
    vunlerable_creatures?: CreatureUncheckedCreateNestedManyWithoutVulnerabilitiesInput
  }

  export type DamageTypeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    resistant_creatures?: CreatureUpdateManyWithoutResistancesNestedInput
    immune_creatures?: CreatureUpdateManyWithoutImmunitiesNestedInput
    vunlerable_creatures?: CreatureUpdateManyWithoutVulnerabilitiesNestedInput
  }

  export type DamageTypeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    resistant_creatures?: CreatureUncheckedUpdateManyWithoutResistancesNestedInput
    immune_creatures?: CreatureUncheckedUpdateManyWithoutImmunitiesNestedInput
    vunlerable_creatures?: CreatureUncheckedUpdateManyWithoutVulnerabilitiesNestedInput
  }

  export type DamageTypeCreateManyInput = {
    id: string
    name: string
  }

  export type DamageTypeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type DamageTypeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type ChallengeRatingCreateInput = {
    id: string
  }

  export type ChallengeRatingUncheckedCreateInput = {
    id: string
  }

  export type ChallengeRatingUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
  }

  export type ChallengeRatingUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
  }

  export type ChallengeRatingCreateManyInput = {
    id: string
  }

  export type ChallengeRatingUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
  }

  export type ChallengeRatingUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
  }

  export type GPTMessageHistoryCreateInput = {
    id?: string
    type: string
    messages?: GPTMessageCreateNestedManyWithoutMessage_historyInput
  }

  export type GPTMessageHistoryUncheckedCreateInput = {
    id?: string
    type: string
    messages?: GPTMessageUncheckedCreateNestedManyWithoutMessage_historyInput
  }

  export type GPTMessageHistoryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    messages?: GPTMessageUpdateManyWithoutMessage_historyNestedInput
  }

  export type GPTMessageHistoryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    messages?: GPTMessageUncheckedUpdateManyWithoutMessage_historyNestedInput
  }

  export type GPTMessageHistoryCreateManyInput = {
    id?: string
    type: string
  }

  export type GPTMessageHistoryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
  }

  export type GPTMessageHistoryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
  }

  export type GPTMessageCreateInput = {
    number: number
    text: string
    role: string
    message_history: GPTMessageHistoryCreateNestedOneWithoutMessagesInput
  }

  export type GPTMessageUncheckedCreateInput = {
    number: number
    message_history_id: string
    text: string
    role: string
  }

  export type GPTMessageUpdateInput = {
    number?: IntFieldUpdateOperationsInput | number
    text?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    message_history?: GPTMessageHistoryUpdateOneRequiredWithoutMessagesNestedInput
  }

  export type GPTMessageUncheckedUpdateInput = {
    number?: IntFieldUpdateOperationsInput | number
    message_history_id?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
  }

  export type GPTMessageCreateManyInput = {
    number: number
    message_history_id: string
    text: string
    role: string
  }

  export type GPTMessageUpdateManyMutationInput = {
    number?: IntFieldUpdateOperationsInput | number
    text?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
  }

  export type GPTMessageUncheckedUpdateManyInput = {
    number?: IntFieldUpdateOperationsInput | number
    message_history_id?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
  }

  export type AdventureCreateInput = {
    id?: string
    title: string
    planned_parties: number
    creator_id: string
    created_at?: Date | string
    updated_at?: Date | string
    genre: GenreCreateNestedOneWithoutAdventuresInput
    keywords?: AdventureKeywordCreateNestedManyWithoutAdventureInput
  }

  export type AdventureUncheckedCreateInput = {
    id?: string
    title: string
    planned_parties: number
    genre_id: string
    creator_id: string
    created_at?: Date | string
    updated_at?: Date | string
    keywords?: AdventureKeywordUncheckedCreateNestedManyWithoutAdventureInput
  }

  export type AdventureUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    planned_parties?: IntFieldUpdateOperationsInput | number
    creator_id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    genre?: GenreUpdateOneRequiredWithoutAdventuresNestedInput
    keywords?: AdventureKeywordUpdateManyWithoutAdventureNestedInput
  }

  export type AdventureUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    planned_parties?: IntFieldUpdateOperationsInput | number
    genre_id?: StringFieldUpdateOperationsInput | string
    creator_id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    keywords?: AdventureKeywordUncheckedUpdateManyWithoutAdventureNestedInput
  }

  export type AdventureCreateManyInput = {
    id?: string
    title: string
    planned_parties: number
    genre_id: string
    creator_id: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type AdventureUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    planned_parties?: IntFieldUpdateOperationsInput | number
    creator_id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdventureUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    planned_parties?: IntFieldUpdateOperationsInput | number
    genre_id?: StringFieldUpdateOperationsInput | string
    creator_id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GenreCreateInput = {
    id?: string
    name: string
    keywords?: KeywordCreateNestedManyWithoutGenreInput
    adventures?: AdventureCreateNestedManyWithoutGenreInput
  }

  export type GenreUncheckedCreateInput = {
    id?: string
    name: string
    keywords?: KeywordUncheckedCreateNestedManyWithoutGenreInput
    adventures?: AdventureUncheckedCreateNestedManyWithoutGenreInput
  }

  export type GenreUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    keywords?: KeywordUpdateManyWithoutGenreNestedInput
    adventures?: AdventureUpdateManyWithoutGenreNestedInput
  }

  export type GenreUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    keywords?: KeywordUncheckedUpdateManyWithoutGenreNestedInput
    adventures?: AdventureUncheckedUpdateManyWithoutGenreNestedInput
  }

  export type GenreCreateManyInput = {
    id?: string
    name: string
  }

  export type GenreUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type GenreUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type KeywordCreateInput = {
    id?: string
    name: string
    genre: GenreCreateNestedOneWithoutKeywordsInput
    adventures?: AdventureKeywordCreateNestedManyWithoutKeywordInput
  }

  export type KeywordUncheckedCreateInput = {
    id?: string
    name: string
    genre_id: string
    adventures?: AdventureKeywordUncheckedCreateNestedManyWithoutKeywordInput
  }

  export type KeywordUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    genre?: GenreUpdateOneRequiredWithoutKeywordsNestedInput
    adventures?: AdventureKeywordUpdateManyWithoutKeywordNestedInput
  }

  export type KeywordUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    genre_id?: StringFieldUpdateOperationsInput | string
    adventures?: AdventureKeywordUncheckedUpdateManyWithoutKeywordNestedInput
  }

  export type KeywordCreateManyInput = {
    id?: string
    name: string
    genre_id: string
  }

  export type KeywordUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type KeywordUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    genre_id?: StringFieldUpdateOperationsInput | string
  }

  export type AdventureKeywordCreateInput = {
    adventure: AdventureCreateNestedOneWithoutKeywordsInput
    keyword: KeywordCreateNestedOneWithoutAdventuresInput
  }

  export type AdventureKeywordUncheckedCreateInput = {
    adventure_id: string
    keyword_id: string
  }

  export type AdventureKeywordUpdateInput = {
    adventure?: AdventureUpdateOneRequiredWithoutKeywordsNestedInput
    keyword?: KeywordUpdateOneRequiredWithoutAdventuresNestedInput
  }

  export type AdventureKeywordUncheckedUpdateInput = {
    adventure_id?: StringFieldUpdateOperationsInput | string
    keyword_id?: StringFieldUpdateOperationsInput | string
  }

  export type AdventureKeywordCreateManyInput = {
    adventure_id: string
    keyword_id: string
  }

  export type AdventureKeywordUpdateManyMutationInput = {

  }

  export type AdventureKeywordUncheckedUpdateManyInput = {
    adventure_id?: StringFieldUpdateOperationsInput | string
    keyword_id?: StringFieldUpdateOperationsInput | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type CreatureListRelationFilter = {
    every?: CreatureWhereInput
    some?: CreatureWhereInput
    none?: CreatureWhereInput
  }

  export type CreatureOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SizeCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type SizeMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type SizeMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type SourceCountOrderByAggregateInput = {
    id?: SortOrder
    shortName?: SortOrder
    name?: SortOrder
  }

  export type SourceAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type SourceMaxOrderByAggregateInput = {
    id?: SortOrder
    shortName?: SortOrder
    name?: SortOrder
  }

  export type SourceMinOrderByAggregateInput = {
    id?: SortOrder
    shortName?: SortOrder
    name?: SortOrder
  }

  export type SourceSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type LanguageCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type LanguageAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type LanguageMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type LanguageMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type LanguageSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type BiomeCountOrderByAggregateInput = {
    id?: SortOrder
    key?: SortOrder
    name?: SortOrder
  }

  export type BiomeAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type BiomeMaxOrderByAggregateInput = {
    id?: SortOrder
    key?: SortOrder
    name?: SortOrder
  }

  export type BiomeMinOrderByAggregateInput = {
    id?: SortOrder
    key?: SortOrder
    name?: SortOrder
  }

  export type BiomeSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type TypeCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type TypeAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type TypeMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type TypeMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type TypeSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type AlignmentCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type AlignmentAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type AlignmentMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type AlignmentMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type AlignmentSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type CreatureScalarRelationFilter = {
    is?: CreatureWhereInput
    isNot?: CreatureWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type Speed_statCountOrderByAggregateInput = {
    id?: SortOrder
    walk?: SortOrder
    fly?: SortOrder
    swim?: SortOrder
    burrow?: SortOrder
    climb?: SortOrder
  }

  export type Speed_statAvgOrderByAggregateInput = {
    walk?: SortOrder
    fly?: SortOrder
    swim?: SortOrder
    burrow?: SortOrder
    climb?: SortOrder
  }

  export type Speed_statMaxOrderByAggregateInput = {
    id?: SortOrder
    walk?: SortOrder
    fly?: SortOrder
    swim?: SortOrder
    burrow?: SortOrder
    climb?: SortOrder
  }

  export type Speed_statMinOrderByAggregateInput = {
    id?: SortOrder
    walk?: SortOrder
    fly?: SortOrder
    swim?: SortOrder
    burrow?: SortOrder
    climb?: SortOrder
  }

  export type Speed_statSumOrderByAggregateInput = {
    walk?: SortOrder
    fly?: SortOrder
    swim?: SortOrder
    burrow?: SortOrder
    climb?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type Strength_stat_detailsNullableScalarRelationFilter = {
    is?: Strength_stat_detailsWhereInput | null
    isNot?: Strength_stat_detailsWhereInput | null
  }

  export type Dexterity_stat_detailsNullableScalarRelationFilter = {
    is?: Dexterity_stat_detailsWhereInput | null
    isNot?: Dexterity_stat_detailsWhereInput | null
  }

  export type Constitution_stat_detailsNullableScalarRelationFilter = {
    is?: Constitution_stat_detailsWhereInput | null
    isNot?: Constitution_stat_detailsWhereInput | null
  }

  export type Intelligence_stat_detailsNullableScalarRelationFilter = {
    is?: Intelligence_stat_detailsWhereInput | null
    isNot?: Intelligence_stat_detailsWhereInput | null
  }

  export type Wisdom_stat_detailsNullableScalarRelationFilter = {
    is?: Wisdom_stat_detailsWhereInput | null
    isNot?: Wisdom_stat_detailsWhereInput | null
  }

  export type Charisma_stat_detailsNullableScalarRelationFilter = {
    is?: Charisma_stat_detailsWhereInput | null
    isNot?: Charisma_stat_detailsWhereInput | null
  }

  export type Creature_statsCountOrderByAggregateInput = {
    id?: SortOrder
  }

  export type Creature_statsMaxOrderByAggregateInput = {
    id?: SortOrder
  }

  export type Creature_statsMinOrderByAggregateInput = {
    id?: SortOrder
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type Creature_statsScalarRelationFilter = {
    is?: Creature_statsWhereInput
    isNot?: Creature_statsWhereInput
  }

  export type Strength_stat_detailsCountOrderByAggregateInput = {
    statblock_id?: SortOrder
    value?: SortOrder
    mastery?: SortOrder
  }

  export type Strength_stat_detailsAvgOrderByAggregateInput = {
    value?: SortOrder
  }

  export type Strength_stat_detailsMaxOrderByAggregateInput = {
    statblock_id?: SortOrder
    value?: SortOrder
    mastery?: SortOrder
  }

  export type Strength_stat_detailsMinOrderByAggregateInput = {
    statblock_id?: SortOrder
    value?: SortOrder
    mastery?: SortOrder
  }

  export type Strength_stat_detailsSumOrderByAggregateInput = {
    value?: SortOrder
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type Dexterity_stat_detailsCountOrderByAggregateInput = {
    statblock_id?: SortOrder
    value?: SortOrder
    mastery?: SortOrder
  }

  export type Dexterity_stat_detailsAvgOrderByAggregateInput = {
    value?: SortOrder
  }

  export type Dexterity_stat_detailsMaxOrderByAggregateInput = {
    statblock_id?: SortOrder
    value?: SortOrder
    mastery?: SortOrder
  }

  export type Dexterity_stat_detailsMinOrderByAggregateInput = {
    statblock_id?: SortOrder
    value?: SortOrder
    mastery?: SortOrder
  }

  export type Dexterity_stat_detailsSumOrderByAggregateInput = {
    value?: SortOrder
  }

  export type Constitution_stat_detailsCountOrderByAggregateInput = {
    statblock_id?: SortOrder
    value?: SortOrder
    mastery?: SortOrder
  }

  export type Constitution_stat_detailsAvgOrderByAggregateInput = {
    value?: SortOrder
  }

  export type Constitution_stat_detailsMaxOrderByAggregateInput = {
    statblock_id?: SortOrder
    value?: SortOrder
    mastery?: SortOrder
  }

  export type Constitution_stat_detailsMinOrderByAggregateInput = {
    statblock_id?: SortOrder
    value?: SortOrder
    mastery?: SortOrder
  }

  export type Constitution_stat_detailsSumOrderByAggregateInput = {
    value?: SortOrder
  }

  export type Intelligence_stat_detailsCountOrderByAggregateInput = {
    statblock_id?: SortOrder
    value?: SortOrder
    mastery?: SortOrder
  }

  export type Intelligence_stat_detailsAvgOrderByAggregateInput = {
    value?: SortOrder
  }

  export type Intelligence_stat_detailsMaxOrderByAggregateInput = {
    statblock_id?: SortOrder
    value?: SortOrder
    mastery?: SortOrder
  }

  export type Intelligence_stat_detailsMinOrderByAggregateInput = {
    statblock_id?: SortOrder
    value?: SortOrder
    mastery?: SortOrder
  }

  export type Intelligence_stat_detailsSumOrderByAggregateInput = {
    value?: SortOrder
  }

  export type Wisdom_stat_detailsCountOrderByAggregateInput = {
    statblock_id?: SortOrder
    value?: SortOrder
    mastery?: SortOrder
  }

  export type Wisdom_stat_detailsAvgOrderByAggregateInput = {
    value?: SortOrder
  }

  export type Wisdom_stat_detailsMaxOrderByAggregateInput = {
    statblock_id?: SortOrder
    value?: SortOrder
    mastery?: SortOrder
  }

  export type Wisdom_stat_detailsMinOrderByAggregateInput = {
    statblock_id?: SortOrder
    value?: SortOrder
    mastery?: SortOrder
  }

  export type Wisdom_stat_detailsSumOrderByAggregateInput = {
    value?: SortOrder
  }

  export type Charisma_stat_detailsCountOrderByAggregateInput = {
    statblock_id?: SortOrder
    value?: SortOrder
    mastery?: SortOrder
  }

  export type Charisma_stat_detailsAvgOrderByAggregateInput = {
    value?: SortOrder
  }

  export type Charisma_stat_detailsMaxOrderByAggregateInput = {
    statblock_id?: SortOrder
    value?: SortOrder
    mastery?: SortOrder
  }

  export type Charisma_stat_detailsMinOrderByAggregateInput = {
    statblock_id?: SortOrder
    value?: SortOrder
    mastery?: SortOrder
  }

  export type Charisma_stat_detailsSumOrderByAggregateInput = {
    value?: SortOrder
  }

  export type StrengthBasedSkillsNullableScalarRelationFilter = {
    is?: StrengthBasedSkillsWhereInput | null
    isNot?: StrengthBasedSkillsWhereInput | null
  }

  export type DexterityBasedSkillsNullableScalarRelationFilter = {
    is?: DexterityBasedSkillsWhereInput | null
    isNot?: DexterityBasedSkillsWhereInput | null
  }

  export type IntellengenceBasedSkillsNullableScalarRelationFilter = {
    is?: IntellengenceBasedSkillsWhereInput | null
    isNot?: IntellengenceBasedSkillsWhereInput | null
  }

  export type WisdomBasedSkillsNullableScalarRelationFilter = {
    is?: WisdomBasedSkillsWhereInput | null
    isNot?: WisdomBasedSkillsWhereInput | null
  }

  export type CharismaBasedSkillsNullableScalarRelationFilter = {
    is?: CharismaBasedSkillsWhereInput | null
    isNot?: CharismaBasedSkillsWhereInput | null
  }

  export type SkillsListCountOrderByAggregateInput = {
    id?: SortOrder
  }

  export type SkillsListMaxOrderByAggregateInput = {
    id?: SortOrder
  }

  export type SkillsListMinOrderByAggregateInput = {
    id?: SortOrder
  }

  export type AthleticsSkillNullableScalarRelationFilter = {
    is?: AthleticsSkillWhereInput | null
    isNot?: AthleticsSkillWhereInput | null
  }

  export type SkillsListScalarRelationFilter = {
    is?: SkillsListWhereInput
    isNot?: SkillsListWhereInput
  }

  export type StrengthBasedSkillsCountOrderByAggregateInput = {
    id?: SortOrder
  }

  export type StrengthBasedSkillsMaxOrderByAggregateInput = {
    id?: SortOrder
  }

  export type StrengthBasedSkillsMinOrderByAggregateInput = {
    id?: SortOrder
  }

  export type AcrobaticsSkillNullableScalarRelationFilter = {
    is?: AcrobaticsSkillWhereInput | null
    isNot?: AcrobaticsSkillWhereInput | null
  }

  export type SleightOfHandSkillNullableScalarRelationFilter = {
    is?: SleightOfHandSkillWhereInput | null
    isNot?: SleightOfHandSkillWhereInput | null
  }

  export type StealthSkillNullableScalarRelationFilter = {
    is?: StealthSkillWhereInput | null
    isNot?: StealthSkillWhereInput | null
  }

  export type DexterityBasedSkillsCountOrderByAggregateInput = {
    id?: SortOrder
  }

  export type DexterityBasedSkillsMaxOrderByAggregateInput = {
    id?: SortOrder
  }

  export type DexterityBasedSkillsMinOrderByAggregateInput = {
    id?: SortOrder
  }

  export type ArcanaSkillNullableScalarRelationFilter = {
    is?: ArcanaSkillWhereInput | null
    isNot?: ArcanaSkillWhereInput | null
  }

  export type HistorySkillNullableScalarRelationFilter = {
    is?: HistorySkillWhereInput | null
    isNot?: HistorySkillWhereInput | null
  }

  export type InvestigationSkillNullableScalarRelationFilter = {
    is?: InvestigationSkillWhereInput | null
    isNot?: InvestigationSkillWhereInput | null
  }

  export type NatureSkillNullableScalarRelationFilter = {
    is?: NatureSkillWhereInput | null
    isNot?: NatureSkillWhereInput | null
  }

  export type ReligionSkillNullableScalarRelationFilter = {
    is?: ReligionSkillWhereInput | null
    isNot?: ReligionSkillWhereInput | null
  }

  export type IntellengenceBasedSkillsCountOrderByAggregateInput = {
    id?: SortOrder
  }

  export type IntellengenceBasedSkillsMaxOrderByAggregateInput = {
    id?: SortOrder
  }

  export type IntellengenceBasedSkillsMinOrderByAggregateInput = {
    id?: SortOrder
  }

  export type AnimalHandlingSkillNullableScalarRelationFilter = {
    is?: AnimalHandlingSkillWhereInput | null
    isNot?: AnimalHandlingSkillWhereInput | null
  }

  export type InsightSkillNullableScalarRelationFilter = {
    is?: InsightSkillWhereInput | null
    isNot?: InsightSkillWhereInput | null
  }

  export type MedicineSkillNullableScalarRelationFilter = {
    is?: MedicineSkillWhereInput | null
    isNot?: MedicineSkillWhereInput | null
  }

  export type PerceptionSkillNullableScalarRelationFilter = {
    is?: PerceptionSkillWhereInput | null
    isNot?: PerceptionSkillWhereInput | null
  }

  export type SurvivalSkillNullableScalarRelationFilter = {
    is?: SurvivalSkillWhereInput | null
    isNot?: SurvivalSkillWhereInput | null
  }

  export type WisdomBasedSkillsCountOrderByAggregateInput = {
    id?: SortOrder
  }

  export type WisdomBasedSkillsMaxOrderByAggregateInput = {
    id?: SortOrder
  }

  export type WisdomBasedSkillsMinOrderByAggregateInput = {
    id?: SortOrder
  }

  export type DeceptionSkillNullableScalarRelationFilter = {
    is?: DeceptionSkillWhereInput | null
    isNot?: DeceptionSkillWhereInput | null
  }

  export type IntimidationSkillNullableScalarRelationFilter = {
    is?: IntimidationSkillWhereInput | null
    isNot?: IntimidationSkillWhereInput | null
  }

  export type PerformanceSkillNullableScalarRelationFilter = {
    is?: PerformanceSkillWhereInput | null
    isNot?: PerformanceSkillWhereInput | null
  }

  export type PersuasionSkillNullableScalarRelationFilter = {
    is?: PersuasionSkillWhereInput | null
    isNot?: PersuasionSkillWhereInput | null
  }

  export type CharismaBasedSkillsCountOrderByAggregateInput = {
    id?: SortOrder
  }

  export type CharismaBasedSkillsMaxOrderByAggregateInput = {
    id?: SortOrder
  }

  export type CharismaBasedSkillsMinOrderByAggregateInput = {
    id?: SortOrder
  }

  export type StrengthBasedSkillsScalarRelationFilter = {
    is?: StrengthBasedSkillsWhereInput
    isNot?: StrengthBasedSkillsWhereInput
  }

  export type AthleticsSkillCountOrderByAggregateInput = {
    id?: SortOrder
    value?: SortOrder
    mastery?: SortOrder
    name?: SortOrder
  }

  export type AthleticsSkillAvgOrderByAggregateInput = {
    value?: SortOrder
  }

  export type AthleticsSkillMaxOrderByAggregateInput = {
    id?: SortOrder
    value?: SortOrder
    mastery?: SortOrder
    name?: SortOrder
  }

  export type AthleticsSkillMinOrderByAggregateInput = {
    id?: SortOrder
    value?: SortOrder
    mastery?: SortOrder
    name?: SortOrder
  }

  export type AthleticsSkillSumOrderByAggregateInput = {
    value?: SortOrder
  }

  export type DexterityBasedSkillsScalarRelationFilter = {
    is?: DexterityBasedSkillsWhereInput
    isNot?: DexterityBasedSkillsWhereInput
  }

  export type AcrobaticsSkillCountOrderByAggregateInput = {
    id?: SortOrder
    value?: SortOrder
    mastery?: SortOrder
    name?: SortOrder
  }

  export type AcrobaticsSkillAvgOrderByAggregateInput = {
    value?: SortOrder
  }

  export type AcrobaticsSkillMaxOrderByAggregateInput = {
    id?: SortOrder
    value?: SortOrder
    mastery?: SortOrder
    name?: SortOrder
  }

  export type AcrobaticsSkillMinOrderByAggregateInput = {
    id?: SortOrder
    value?: SortOrder
    mastery?: SortOrder
    name?: SortOrder
  }

  export type AcrobaticsSkillSumOrderByAggregateInput = {
    value?: SortOrder
  }

  export type SleightOfHandSkillCountOrderByAggregateInput = {
    id?: SortOrder
    value?: SortOrder
    mastery?: SortOrder
    name?: SortOrder
  }

  export type SleightOfHandSkillAvgOrderByAggregateInput = {
    value?: SortOrder
  }

  export type SleightOfHandSkillMaxOrderByAggregateInput = {
    id?: SortOrder
    value?: SortOrder
    mastery?: SortOrder
    name?: SortOrder
  }

  export type SleightOfHandSkillMinOrderByAggregateInput = {
    id?: SortOrder
    value?: SortOrder
    mastery?: SortOrder
    name?: SortOrder
  }

  export type SleightOfHandSkillSumOrderByAggregateInput = {
    value?: SortOrder
  }

  export type StealthSkillCountOrderByAggregateInput = {
    id?: SortOrder
    value?: SortOrder
    mastery?: SortOrder
    name?: SortOrder
  }

  export type StealthSkillAvgOrderByAggregateInput = {
    value?: SortOrder
  }

  export type StealthSkillMaxOrderByAggregateInput = {
    id?: SortOrder
    value?: SortOrder
    mastery?: SortOrder
    name?: SortOrder
  }

  export type StealthSkillMinOrderByAggregateInput = {
    id?: SortOrder
    value?: SortOrder
    mastery?: SortOrder
    name?: SortOrder
  }

  export type StealthSkillSumOrderByAggregateInput = {
    value?: SortOrder
  }

  export type IntellengenceBasedSkillsScalarRelationFilter = {
    is?: IntellengenceBasedSkillsWhereInput
    isNot?: IntellengenceBasedSkillsWhereInput
  }

  export type ArcanaSkillCountOrderByAggregateInput = {
    id?: SortOrder
    value?: SortOrder
    mastery?: SortOrder
    name?: SortOrder
  }

  export type ArcanaSkillAvgOrderByAggregateInput = {
    value?: SortOrder
  }

  export type ArcanaSkillMaxOrderByAggregateInput = {
    id?: SortOrder
    value?: SortOrder
    mastery?: SortOrder
    name?: SortOrder
  }

  export type ArcanaSkillMinOrderByAggregateInput = {
    id?: SortOrder
    value?: SortOrder
    mastery?: SortOrder
    name?: SortOrder
  }

  export type ArcanaSkillSumOrderByAggregateInput = {
    value?: SortOrder
  }

  export type HistorySkillCountOrderByAggregateInput = {
    id?: SortOrder
    value?: SortOrder
    mastery?: SortOrder
    name?: SortOrder
  }

  export type HistorySkillAvgOrderByAggregateInput = {
    value?: SortOrder
  }

  export type HistorySkillMaxOrderByAggregateInput = {
    id?: SortOrder
    value?: SortOrder
    mastery?: SortOrder
    name?: SortOrder
  }

  export type HistorySkillMinOrderByAggregateInput = {
    id?: SortOrder
    value?: SortOrder
    mastery?: SortOrder
    name?: SortOrder
  }

  export type HistorySkillSumOrderByAggregateInput = {
    value?: SortOrder
  }

  export type InvestigationSkillCountOrderByAggregateInput = {
    id?: SortOrder
    value?: SortOrder
    mastery?: SortOrder
    name?: SortOrder
  }

  export type InvestigationSkillAvgOrderByAggregateInput = {
    value?: SortOrder
  }

  export type InvestigationSkillMaxOrderByAggregateInput = {
    id?: SortOrder
    value?: SortOrder
    mastery?: SortOrder
    name?: SortOrder
  }

  export type InvestigationSkillMinOrderByAggregateInput = {
    id?: SortOrder
    value?: SortOrder
    mastery?: SortOrder
    name?: SortOrder
  }

  export type InvestigationSkillSumOrderByAggregateInput = {
    value?: SortOrder
  }

  export type NatureSkillCountOrderByAggregateInput = {
    id?: SortOrder
    value?: SortOrder
    mastery?: SortOrder
    name?: SortOrder
  }

  export type NatureSkillAvgOrderByAggregateInput = {
    value?: SortOrder
  }

  export type NatureSkillMaxOrderByAggregateInput = {
    id?: SortOrder
    value?: SortOrder
    mastery?: SortOrder
    name?: SortOrder
  }

  export type NatureSkillMinOrderByAggregateInput = {
    id?: SortOrder
    value?: SortOrder
    mastery?: SortOrder
    name?: SortOrder
  }

  export type NatureSkillSumOrderByAggregateInput = {
    value?: SortOrder
  }

  export type ReligionSkillCountOrderByAggregateInput = {
    id?: SortOrder
    value?: SortOrder
    mastery?: SortOrder
    name?: SortOrder
  }

  export type ReligionSkillAvgOrderByAggregateInput = {
    value?: SortOrder
  }

  export type ReligionSkillMaxOrderByAggregateInput = {
    id?: SortOrder
    value?: SortOrder
    mastery?: SortOrder
    name?: SortOrder
  }

  export type ReligionSkillMinOrderByAggregateInput = {
    id?: SortOrder
    value?: SortOrder
    mastery?: SortOrder
    name?: SortOrder
  }

  export type ReligionSkillSumOrderByAggregateInput = {
    value?: SortOrder
  }

  export type WisdomBasedSkillsScalarRelationFilter = {
    is?: WisdomBasedSkillsWhereInput
    isNot?: WisdomBasedSkillsWhereInput
  }

  export type AnimalHandlingSkillCountOrderByAggregateInput = {
    id?: SortOrder
    value?: SortOrder
    mastery?: SortOrder
    name?: SortOrder
  }

  export type AnimalHandlingSkillAvgOrderByAggregateInput = {
    value?: SortOrder
  }

  export type AnimalHandlingSkillMaxOrderByAggregateInput = {
    id?: SortOrder
    value?: SortOrder
    mastery?: SortOrder
    name?: SortOrder
  }

  export type AnimalHandlingSkillMinOrderByAggregateInput = {
    id?: SortOrder
    value?: SortOrder
    mastery?: SortOrder
    name?: SortOrder
  }

  export type AnimalHandlingSkillSumOrderByAggregateInput = {
    value?: SortOrder
  }

  export type InsightSkillCountOrderByAggregateInput = {
    id?: SortOrder
    value?: SortOrder
    mastery?: SortOrder
    name?: SortOrder
  }

  export type InsightSkillAvgOrderByAggregateInput = {
    value?: SortOrder
  }

  export type InsightSkillMaxOrderByAggregateInput = {
    id?: SortOrder
    value?: SortOrder
    mastery?: SortOrder
    name?: SortOrder
  }

  export type InsightSkillMinOrderByAggregateInput = {
    id?: SortOrder
    value?: SortOrder
    mastery?: SortOrder
    name?: SortOrder
  }

  export type InsightSkillSumOrderByAggregateInput = {
    value?: SortOrder
  }

  export type MedicineSkillCountOrderByAggregateInput = {
    id?: SortOrder
    value?: SortOrder
    mastery?: SortOrder
    name?: SortOrder
  }

  export type MedicineSkillAvgOrderByAggregateInput = {
    value?: SortOrder
  }

  export type MedicineSkillMaxOrderByAggregateInput = {
    id?: SortOrder
    value?: SortOrder
    mastery?: SortOrder
    name?: SortOrder
  }

  export type MedicineSkillMinOrderByAggregateInput = {
    id?: SortOrder
    value?: SortOrder
    mastery?: SortOrder
    name?: SortOrder
  }

  export type MedicineSkillSumOrderByAggregateInput = {
    value?: SortOrder
  }

  export type PerceptionSkillCountOrderByAggregateInput = {
    id?: SortOrder
    value?: SortOrder
    mastery?: SortOrder
    name?: SortOrder
  }

  export type PerceptionSkillAvgOrderByAggregateInput = {
    value?: SortOrder
  }

  export type PerceptionSkillMaxOrderByAggregateInput = {
    id?: SortOrder
    value?: SortOrder
    mastery?: SortOrder
    name?: SortOrder
  }

  export type PerceptionSkillMinOrderByAggregateInput = {
    id?: SortOrder
    value?: SortOrder
    mastery?: SortOrder
    name?: SortOrder
  }

  export type PerceptionSkillSumOrderByAggregateInput = {
    value?: SortOrder
  }

  export type SurvivalSkillCountOrderByAggregateInput = {
    id?: SortOrder
    value?: SortOrder
    mastery?: SortOrder
    name?: SortOrder
  }

  export type SurvivalSkillAvgOrderByAggregateInput = {
    value?: SortOrder
  }

  export type SurvivalSkillMaxOrderByAggregateInput = {
    id?: SortOrder
    value?: SortOrder
    mastery?: SortOrder
    name?: SortOrder
  }

  export type SurvivalSkillMinOrderByAggregateInput = {
    id?: SortOrder
    value?: SortOrder
    mastery?: SortOrder
    name?: SortOrder
  }

  export type SurvivalSkillSumOrderByAggregateInput = {
    value?: SortOrder
  }

  export type CharismaBasedSkillsScalarRelationFilter = {
    is?: CharismaBasedSkillsWhereInput
    isNot?: CharismaBasedSkillsWhereInput
  }

  export type DeceptionSkillCountOrderByAggregateInput = {
    id?: SortOrder
    value?: SortOrder
    mastery?: SortOrder
    name?: SortOrder
  }

  export type DeceptionSkillAvgOrderByAggregateInput = {
    value?: SortOrder
  }

  export type DeceptionSkillMaxOrderByAggregateInput = {
    id?: SortOrder
    value?: SortOrder
    mastery?: SortOrder
    name?: SortOrder
  }

  export type DeceptionSkillMinOrderByAggregateInput = {
    id?: SortOrder
    value?: SortOrder
    mastery?: SortOrder
    name?: SortOrder
  }

  export type DeceptionSkillSumOrderByAggregateInput = {
    value?: SortOrder
  }

  export type IntimidationSkillCountOrderByAggregateInput = {
    id?: SortOrder
    value?: SortOrder
    mastery?: SortOrder
    name?: SortOrder
  }

  export type IntimidationSkillAvgOrderByAggregateInput = {
    value?: SortOrder
  }

  export type IntimidationSkillMaxOrderByAggregateInput = {
    id?: SortOrder
    value?: SortOrder
    mastery?: SortOrder
    name?: SortOrder
  }

  export type IntimidationSkillMinOrderByAggregateInput = {
    id?: SortOrder
    value?: SortOrder
    mastery?: SortOrder
    name?: SortOrder
  }

  export type IntimidationSkillSumOrderByAggregateInput = {
    value?: SortOrder
  }

  export type PerformanceSkillCountOrderByAggregateInput = {
    id?: SortOrder
    value?: SortOrder
    mastery?: SortOrder
    name?: SortOrder
  }

  export type PerformanceSkillAvgOrderByAggregateInput = {
    value?: SortOrder
  }

  export type PerformanceSkillMaxOrderByAggregateInput = {
    id?: SortOrder
    value?: SortOrder
    mastery?: SortOrder
    name?: SortOrder
  }

  export type PerformanceSkillMinOrderByAggregateInput = {
    id?: SortOrder
    value?: SortOrder
    mastery?: SortOrder
    name?: SortOrder
  }

  export type PerformanceSkillSumOrderByAggregateInput = {
    value?: SortOrder
  }

  export type PersuasionSkillCountOrderByAggregateInput = {
    id?: SortOrder
    value?: SortOrder
    mastery?: SortOrder
    name?: SortOrder
  }

  export type PersuasionSkillAvgOrderByAggregateInput = {
    value?: SortOrder
  }

  export type PersuasionSkillMaxOrderByAggregateInput = {
    id?: SortOrder
    value?: SortOrder
    mastery?: SortOrder
    name?: SortOrder
  }

  export type PersuasionSkillMinOrderByAggregateInput = {
    id?: SortOrder
    value?: SortOrder
    mastery?: SortOrder
    name?: SortOrder
  }

  export type PersuasionSkillSumOrderByAggregateInput = {
    value?: SortOrder
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type IntNullableListFilter<$PrismaModel = never> = {
    equals?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    has?: number | IntFieldRefInput<$PrismaModel> | null
    hasEvery?: number[] | ListIntFieldRefInput<$PrismaModel>
    hasSome?: number[] | ListIntFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type StringNullableListFilter<$PrismaModel = never> = {
    equals?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    has?: string | StringFieldRefInput<$PrismaModel> | null
    hasEvery?: string[] | ListStringFieldRefInput<$PrismaModel>
    hasSome?: string[] | ListStringFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type Speed_statNullableScalarRelationFilter = {
    is?: Speed_statWhereInput | null
    isNot?: Speed_statWhereInput | null
  }

  export type Creature_statsNullableScalarRelationFilter = {
    is?: Creature_statsWhereInput | null
    isNot?: Creature_statsWhereInput | null
  }

  export type SkillsListNullableScalarRelationFilter = {
    is?: SkillsListWhereInput | null
    isNot?: SkillsListWhereInput | null
  }

  export type DamageTypeListRelationFilter = {
    every?: DamageTypeWhereInput
    some?: DamageTypeWhereInput
    none?: DamageTypeWhereInput
  }

  export type SensesNullableScalarRelationFilter = {
    is?: SensesWhereInput | null
    isNot?: SensesWhereInput | null
  }

  export type LanguageListRelationFilter = {
    every?: LanguageWhereInput
    some?: LanguageWhereInput
    none?: LanguageWhereInput
  }

  export type ActionListRelationFilter = {
    every?: ActionWhereInput
    some?: ActionWhereInput
    none?: ActionWhereInput
  }

  export type TraitListRelationFilter = {
    every?: TraitWhereInput
    some?: TraitWhereInput
    none?: TraitWhereInput
  }

  export type AlignmentNullableScalarRelationFilter = {
    is?: AlignmentWhereInput | null
    isNot?: AlignmentWhereInput | null
  }

  export type CreatureRaceNullableScalarRelationFilter = {
    is?: CreatureRaceWhereInput | null
    isNot?: CreatureRaceWhereInput | null
  }

  export type TypeNullableScalarRelationFilter = {
    is?: TypeWhereInput | null
    isNot?: TypeWhereInput | null
  }

  export type SizeNullableScalarRelationFilter = {
    is?: SizeWhereInput | null
    isNot?: SizeWhereInput | null
  }

  export type BiomeListRelationFilter = {
    every?: BiomeWhereInput
    some?: BiomeWhereInput
    none?: BiomeWhereInput
  }

  export type SourceNullableScalarRelationFilter = {
    is?: SourceWhereInput | null
    isNot?: SourceWhereInput | null
  }

  export type DamageTypeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LanguageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ActionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TraitOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BiomeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CreatureCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    creator_id?: SortOrder
    image_uri?: SortOrder
    description?: SortOrder
    size?: SortOrder
    race_id?: SortOrder
    source_id?: SortOrder
    alignment_id?: SortOrder
    armor_class?: SortOrder
    hit_points?: SortOrder
    challenge_rating?: SortOrder
    biomes_ids?: SortOrder
    type_id?: SortOrder
    aSubTypes?: SortOrder
  }

  export type CreatureAvgOrderByAggregateInput = {
    race_id?: SortOrder
    source_id?: SortOrder
    alignment_id?: SortOrder
    armor_class?: SortOrder
    hit_points?: SortOrder
    biomes_ids?: SortOrder
    type_id?: SortOrder
  }

  export type CreatureMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    creator_id?: SortOrder
    image_uri?: SortOrder
    description?: SortOrder
    size?: SortOrder
    race_id?: SortOrder
    source_id?: SortOrder
    alignment_id?: SortOrder
    armor_class?: SortOrder
    hit_points?: SortOrder
    challenge_rating?: SortOrder
    type_id?: SortOrder
  }

  export type CreatureMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    creator_id?: SortOrder
    image_uri?: SortOrder
    description?: SortOrder
    size?: SortOrder
    race_id?: SortOrder
    source_id?: SortOrder
    alignment_id?: SortOrder
    armor_class?: SortOrder
    hit_points?: SortOrder
    challenge_rating?: SortOrder
    type_id?: SortOrder
  }

  export type CreatureSumOrderByAggregateInput = {
    race_id?: SortOrder
    source_id?: SortOrder
    alignment_id?: SortOrder
    armor_class?: SortOrder
    hit_points?: SortOrder
    biomes_ids?: SortOrder
    type_id?: SortOrder
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type SensesCountOrderByAggregateInput = {
    creature_id?: SortOrder
    passive_perception?: SortOrder
  }

  export type SensesAvgOrderByAggregateInput = {
    passive_perception?: SortOrder
  }

  export type SensesMaxOrderByAggregateInput = {
    creature_id?: SortOrder
    passive_perception?: SortOrder
  }

  export type SensesMinOrderByAggregateInput = {
    creature_id?: SortOrder
    passive_perception?: SortOrder
  }

  export type SensesSumOrderByAggregateInput = {
    passive_perception?: SortOrder
  }

  export type BoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type CreatureRaceListRelationFilter = {
    every?: CreatureRaceWhereInput
    some?: CreatureRaceWhereInput
    none?: CreatureRaceWhereInput
  }

  export type CreatureRaceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ActionCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    attack?: SortOrder
    is_template?: SortOrder
  }

  export type ActionAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type ActionMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    attack?: SortOrder
    is_template?: SortOrder
  }

  export type ActionMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    attack?: SortOrder
    is_template?: SortOrder
  }

  export type ActionSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type BoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type TraitCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    attack?: SortOrder
    is_template?: SortOrder
  }

  export type TraitAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type TraitMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    attack?: SortOrder
    is_template?: SortOrder
  }

  export type TraitMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    attack?: SortOrder
    is_template?: SortOrder
  }

  export type TraitSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type CreatureRaceCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
  }

  export type CreatureRaceAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type CreatureRaceMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
  }

  export type CreatureRaceMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
  }

  export type CreatureRaceSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type GenrationRequestCountOrderByAggregateInput = {
    id?: SortOrder
    request?: SortOrder
    danger?: SortOrder
    name?: SortOrder
  }

  export type GenrationRequestAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type GenrationRequestMaxOrderByAggregateInput = {
    id?: SortOrder
    request?: SortOrder
    danger?: SortOrder
    name?: SortOrder
  }

  export type GenrationRequestMinOrderByAggregateInput = {
    id?: SortOrder
    request?: SortOrder
    danger?: SortOrder
    name?: SortOrder
  }

  export type GenrationRequestSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type DamageTypeCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type DamageTypeMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type DamageTypeMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type ChallengeRatingCountOrderByAggregateInput = {
    id?: SortOrder
  }

  export type ChallengeRatingMaxOrderByAggregateInput = {
    id?: SortOrder
  }

  export type ChallengeRatingMinOrderByAggregateInput = {
    id?: SortOrder
  }

  export type GPTMessageListRelationFilter = {
    every?: GPTMessageWhereInput
    some?: GPTMessageWhereInput
    none?: GPTMessageWhereInput
  }

  export type GPTMessageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type GPTMessageHistoryCountOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
  }

  export type GPTMessageHistoryMaxOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
  }

  export type GPTMessageHistoryMinOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
  }

  export type GPTMessageHistoryScalarRelationFilter = {
    is?: GPTMessageHistoryWhereInput
    isNot?: GPTMessageHistoryWhereInput
  }

  export type GPTMessageMessage_history_idNumberCompoundUniqueInput = {
    message_history_id: string
    number: number
  }

  export type GPTMessageCountOrderByAggregateInput = {
    number?: SortOrder
    message_history_id?: SortOrder
    text?: SortOrder
    role?: SortOrder
  }

  export type GPTMessageAvgOrderByAggregateInput = {
    number?: SortOrder
  }

  export type GPTMessageMaxOrderByAggregateInput = {
    number?: SortOrder
    message_history_id?: SortOrder
    text?: SortOrder
    role?: SortOrder
  }

  export type GPTMessageMinOrderByAggregateInput = {
    number?: SortOrder
    message_history_id?: SortOrder
    text?: SortOrder
    role?: SortOrder
  }

  export type GPTMessageSumOrderByAggregateInput = {
    number?: SortOrder
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type GenreScalarRelationFilter = {
    is?: GenreWhereInput
    isNot?: GenreWhereInput
  }

  export type AdventureKeywordListRelationFilter = {
    every?: AdventureKeywordWhereInput
    some?: AdventureKeywordWhereInput
    none?: AdventureKeywordWhereInput
  }

  export type AdventureKeywordOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AdventureCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    planned_parties?: SortOrder
    genre_id?: SortOrder
    creator_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type AdventureAvgOrderByAggregateInput = {
    planned_parties?: SortOrder
  }

  export type AdventureMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    planned_parties?: SortOrder
    genre_id?: SortOrder
    creator_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type AdventureMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    planned_parties?: SortOrder
    genre_id?: SortOrder
    creator_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type AdventureSumOrderByAggregateInput = {
    planned_parties?: SortOrder
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type KeywordListRelationFilter = {
    every?: KeywordWhereInput
    some?: KeywordWhereInput
    none?: KeywordWhereInput
  }

  export type AdventureListRelationFilter = {
    every?: AdventureWhereInput
    some?: AdventureWhereInput
    none?: AdventureWhereInput
  }

  export type KeywordOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AdventureOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type GenreCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type GenreMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type GenreMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type KeywordCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    genre_id?: SortOrder
  }

  export type KeywordMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    genre_id?: SortOrder
  }

  export type KeywordMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    genre_id?: SortOrder
  }

  export type AdventureScalarRelationFilter = {
    is?: AdventureWhereInput
    isNot?: AdventureWhereInput
  }

  export type KeywordScalarRelationFilter = {
    is?: KeywordWhereInput
    isNot?: KeywordWhereInput
  }

  export type AdventureKeywordAdventure_idKeyword_idCompoundUniqueInput = {
    adventure_id: string
    keyword_id: string
  }

  export type AdventureKeywordCountOrderByAggregateInput = {
    adventure_id?: SortOrder
    keyword_id?: SortOrder
  }

  export type AdventureKeywordMaxOrderByAggregateInput = {
    adventure_id?: SortOrder
    keyword_id?: SortOrder
  }

  export type AdventureKeywordMinOrderByAggregateInput = {
    adventure_id?: SortOrder
    keyword_id?: SortOrder
  }

  export type CreatureCreateNestedManyWithoutSize_relationInput = {
    create?: XOR<CreatureCreateWithoutSize_relationInput, CreatureUncheckedCreateWithoutSize_relationInput> | CreatureCreateWithoutSize_relationInput[] | CreatureUncheckedCreateWithoutSize_relationInput[]
    connectOrCreate?: CreatureCreateOrConnectWithoutSize_relationInput | CreatureCreateOrConnectWithoutSize_relationInput[]
    createMany?: CreatureCreateManySize_relationInputEnvelope
    connect?: CreatureWhereUniqueInput | CreatureWhereUniqueInput[]
  }

  export type CreatureUncheckedCreateNestedManyWithoutSize_relationInput = {
    create?: XOR<CreatureCreateWithoutSize_relationInput, CreatureUncheckedCreateWithoutSize_relationInput> | CreatureCreateWithoutSize_relationInput[] | CreatureUncheckedCreateWithoutSize_relationInput[]
    connectOrCreate?: CreatureCreateOrConnectWithoutSize_relationInput | CreatureCreateOrConnectWithoutSize_relationInput[]
    createMany?: CreatureCreateManySize_relationInputEnvelope
    connect?: CreatureWhereUniqueInput | CreatureWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type CreatureUpdateManyWithoutSize_relationNestedInput = {
    create?: XOR<CreatureCreateWithoutSize_relationInput, CreatureUncheckedCreateWithoutSize_relationInput> | CreatureCreateWithoutSize_relationInput[] | CreatureUncheckedCreateWithoutSize_relationInput[]
    connectOrCreate?: CreatureCreateOrConnectWithoutSize_relationInput | CreatureCreateOrConnectWithoutSize_relationInput[]
    upsert?: CreatureUpsertWithWhereUniqueWithoutSize_relationInput | CreatureUpsertWithWhereUniqueWithoutSize_relationInput[]
    createMany?: CreatureCreateManySize_relationInputEnvelope
    set?: CreatureWhereUniqueInput | CreatureWhereUniqueInput[]
    disconnect?: CreatureWhereUniqueInput | CreatureWhereUniqueInput[]
    delete?: CreatureWhereUniqueInput | CreatureWhereUniqueInput[]
    connect?: CreatureWhereUniqueInput | CreatureWhereUniqueInput[]
    update?: CreatureUpdateWithWhereUniqueWithoutSize_relationInput | CreatureUpdateWithWhereUniqueWithoutSize_relationInput[]
    updateMany?: CreatureUpdateManyWithWhereWithoutSize_relationInput | CreatureUpdateManyWithWhereWithoutSize_relationInput[]
    deleteMany?: CreatureScalarWhereInput | CreatureScalarWhereInput[]
  }

  export type CreatureUncheckedUpdateManyWithoutSize_relationNestedInput = {
    create?: XOR<CreatureCreateWithoutSize_relationInput, CreatureUncheckedCreateWithoutSize_relationInput> | CreatureCreateWithoutSize_relationInput[] | CreatureUncheckedCreateWithoutSize_relationInput[]
    connectOrCreate?: CreatureCreateOrConnectWithoutSize_relationInput | CreatureCreateOrConnectWithoutSize_relationInput[]
    upsert?: CreatureUpsertWithWhereUniqueWithoutSize_relationInput | CreatureUpsertWithWhereUniqueWithoutSize_relationInput[]
    createMany?: CreatureCreateManySize_relationInputEnvelope
    set?: CreatureWhereUniqueInput | CreatureWhereUniqueInput[]
    disconnect?: CreatureWhereUniqueInput | CreatureWhereUniqueInput[]
    delete?: CreatureWhereUniqueInput | CreatureWhereUniqueInput[]
    connect?: CreatureWhereUniqueInput | CreatureWhereUniqueInput[]
    update?: CreatureUpdateWithWhereUniqueWithoutSize_relationInput | CreatureUpdateWithWhereUniqueWithoutSize_relationInput[]
    updateMany?: CreatureUpdateManyWithWhereWithoutSize_relationInput | CreatureUpdateManyWithWhereWithoutSize_relationInput[]
    deleteMany?: CreatureScalarWhereInput | CreatureScalarWhereInput[]
  }

  export type CreatureCreateNestedManyWithoutSource_relationInput = {
    create?: XOR<CreatureCreateWithoutSource_relationInput, CreatureUncheckedCreateWithoutSource_relationInput> | CreatureCreateWithoutSource_relationInput[] | CreatureUncheckedCreateWithoutSource_relationInput[]
    connectOrCreate?: CreatureCreateOrConnectWithoutSource_relationInput | CreatureCreateOrConnectWithoutSource_relationInput[]
    createMany?: CreatureCreateManySource_relationInputEnvelope
    connect?: CreatureWhereUniqueInput | CreatureWhereUniqueInput[]
  }

  export type CreatureUncheckedCreateNestedManyWithoutSource_relationInput = {
    create?: XOR<CreatureCreateWithoutSource_relationInput, CreatureUncheckedCreateWithoutSource_relationInput> | CreatureCreateWithoutSource_relationInput[] | CreatureUncheckedCreateWithoutSource_relationInput[]
    connectOrCreate?: CreatureCreateOrConnectWithoutSource_relationInput | CreatureCreateOrConnectWithoutSource_relationInput[]
    createMany?: CreatureCreateManySource_relationInputEnvelope
    connect?: CreatureWhereUniqueInput | CreatureWhereUniqueInput[]
  }

  export type CreatureUpdateManyWithoutSource_relationNestedInput = {
    create?: XOR<CreatureCreateWithoutSource_relationInput, CreatureUncheckedCreateWithoutSource_relationInput> | CreatureCreateWithoutSource_relationInput[] | CreatureUncheckedCreateWithoutSource_relationInput[]
    connectOrCreate?: CreatureCreateOrConnectWithoutSource_relationInput | CreatureCreateOrConnectWithoutSource_relationInput[]
    upsert?: CreatureUpsertWithWhereUniqueWithoutSource_relationInput | CreatureUpsertWithWhereUniqueWithoutSource_relationInput[]
    createMany?: CreatureCreateManySource_relationInputEnvelope
    set?: CreatureWhereUniqueInput | CreatureWhereUniqueInput[]
    disconnect?: CreatureWhereUniqueInput | CreatureWhereUniqueInput[]
    delete?: CreatureWhereUniqueInput | CreatureWhereUniqueInput[]
    connect?: CreatureWhereUniqueInput | CreatureWhereUniqueInput[]
    update?: CreatureUpdateWithWhereUniqueWithoutSource_relationInput | CreatureUpdateWithWhereUniqueWithoutSource_relationInput[]
    updateMany?: CreatureUpdateManyWithWhereWithoutSource_relationInput | CreatureUpdateManyWithWhereWithoutSource_relationInput[]
    deleteMany?: CreatureScalarWhereInput | CreatureScalarWhereInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type CreatureUncheckedUpdateManyWithoutSource_relationNestedInput = {
    create?: XOR<CreatureCreateWithoutSource_relationInput, CreatureUncheckedCreateWithoutSource_relationInput> | CreatureCreateWithoutSource_relationInput[] | CreatureUncheckedCreateWithoutSource_relationInput[]
    connectOrCreate?: CreatureCreateOrConnectWithoutSource_relationInput | CreatureCreateOrConnectWithoutSource_relationInput[]
    upsert?: CreatureUpsertWithWhereUniqueWithoutSource_relationInput | CreatureUpsertWithWhereUniqueWithoutSource_relationInput[]
    createMany?: CreatureCreateManySource_relationInputEnvelope
    set?: CreatureWhereUniqueInput | CreatureWhereUniqueInput[]
    disconnect?: CreatureWhereUniqueInput | CreatureWhereUniqueInput[]
    delete?: CreatureWhereUniqueInput | CreatureWhereUniqueInput[]
    connect?: CreatureWhereUniqueInput | CreatureWhereUniqueInput[]
    update?: CreatureUpdateWithWhereUniqueWithoutSource_relationInput | CreatureUpdateWithWhereUniqueWithoutSource_relationInput[]
    updateMany?: CreatureUpdateManyWithWhereWithoutSource_relationInput | CreatureUpdateManyWithWhereWithoutSource_relationInput[]
    deleteMany?: CreatureScalarWhereInput | CreatureScalarWhereInput[]
  }

  export type CreatureCreateNestedManyWithoutLanguagesInput = {
    create?: XOR<CreatureCreateWithoutLanguagesInput, CreatureUncheckedCreateWithoutLanguagesInput> | CreatureCreateWithoutLanguagesInput[] | CreatureUncheckedCreateWithoutLanguagesInput[]
    connectOrCreate?: CreatureCreateOrConnectWithoutLanguagesInput | CreatureCreateOrConnectWithoutLanguagesInput[]
    connect?: CreatureWhereUniqueInput | CreatureWhereUniqueInput[]
  }

  export type CreatureUncheckedCreateNestedManyWithoutLanguagesInput = {
    create?: XOR<CreatureCreateWithoutLanguagesInput, CreatureUncheckedCreateWithoutLanguagesInput> | CreatureCreateWithoutLanguagesInput[] | CreatureUncheckedCreateWithoutLanguagesInput[]
    connectOrCreate?: CreatureCreateOrConnectWithoutLanguagesInput | CreatureCreateOrConnectWithoutLanguagesInput[]
    connect?: CreatureWhereUniqueInput | CreatureWhereUniqueInput[]
  }

  export type CreatureUpdateManyWithoutLanguagesNestedInput = {
    create?: XOR<CreatureCreateWithoutLanguagesInput, CreatureUncheckedCreateWithoutLanguagesInput> | CreatureCreateWithoutLanguagesInput[] | CreatureUncheckedCreateWithoutLanguagesInput[]
    connectOrCreate?: CreatureCreateOrConnectWithoutLanguagesInput | CreatureCreateOrConnectWithoutLanguagesInput[]
    upsert?: CreatureUpsertWithWhereUniqueWithoutLanguagesInput | CreatureUpsertWithWhereUniqueWithoutLanguagesInput[]
    set?: CreatureWhereUniqueInput | CreatureWhereUniqueInput[]
    disconnect?: CreatureWhereUniqueInput | CreatureWhereUniqueInput[]
    delete?: CreatureWhereUniqueInput | CreatureWhereUniqueInput[]
    connect?: CreatureWhereUniqueInput | CreatureWhereUniqueInput[]
    update?: CreatureUpdateWithWhereUniqueWithoutLanguagesInput | CreatureUpdateWithWhereUniqueWithoutLanguagesInput[]
    updateMany?: CreatureUpdateManyWithWhereWithoutLanguagesInput | CreatureUpdateManyWithWhereWithoutLanguagesInput[]
    deleteMany?: CreatureScalarWhereInput | CreatureScalarWhereInput[]
  }

  export type CreatureUncheckedUpdateManyWithoutLanguagesNestedInput = {
    create?: XOR<CreatureCreateWithoutLanguagesInput, CreatureUncheckedCreateWithoutLanguagesInput> | CreatureCreateWithoutLanguagesInput[] | CreatureUncheckedCreateWithoutLanguagesInput[]
    connectOrCreate?: CreatureCreateOrConnectWithoutLanguagesInput | CreatureCreateOrConnectWithoutLanguagesInput[]
    upsert?: CreatureUpsertWithWhereUniqueWithoutLanguagesInput | CreatureUpsertWithWhereUniqueWithoutLanguagesInput[]
    set?: CreatureWhereUniqueInput | CreatureWhereUniqueInput[]
    disconnect?: CreatureWhereUniqueInput | CreatureWhereUniqueInput[]
    delete?: CreatureWhereUniqueInput | CreatureWhereUniqueInput[]
    connect?: CreatureWhereUniqueInput | CreatureWhereUniqueInput[]
    update?: CreatureUpdateWithWhereUniqueWithoutLanguagesInput | CreatureUpdateWithWhereUniqueWithoutLanguagesInput[]
    updateMany?: CreatureUpdateManyWithWhereWithoutLanguagesInput | CreatureUpdateManyWithWhereWithoutLanguagesInput[]
    deleteMany?: CreatureScalarWhereInput | CreatureScalarWhereInput[]
  }

  export type CreatureCreateNestedManyWithoutBiome_relationInput = {
    create?: XOR<CreatureCreateWithoutBiome_relationInput, CreatureUncheckedCreateWithoutBiome_relationInput> | CreatureCreateWithoutBiome_relationInput[] | CreatureUncheckedCreateWithoutBiome_relationInput[]
    connectOrCreate?: CreatureCreateOrConnectWithoutBiome_relationInput | CreatureCreateOrConnectWithoutBiome_relationInput[]
    connect?: CreatureWhereUniqueInput | CreatureWhereUniqueInput[]
  }

  export type CreatureUncheckedCreateNestedManyWithoutBiome_relationInput = {
    create?: XOR<CreatureCreateWithoutBiome_relationInput, CreatureUncheckedCreateWithoutBiome_relationInput> | CreatureCreateWithoutBiome_relationInput[] | CreatureUncheckedCreateWithoutBiome_relationInput[]
    connectOrCreate?: CreatureCreateOrConnectWithoutBiome_relationInput | CreatureCreateOrConnectWithoutBiome_relationInput[]
    connect?: CreatureWhereUniqueInput | CreatureWhereUniqueInput[]
  }

  export type CreatureUpdateManyWithoutBiome_relationNestedInput = {
    create?: XOR<CreatureCreateWithoutBiome_relationInput, CreatureUncheckedCreateWithoutBiome_relationInput> | CreatureCreateWithoutBiome_relationInput[] | CreatureUncheckedCreateWithoutBiome_relationInput[]
    connectOrCreate?: CreatureCreateOrConnectWithoutBiome_relationInput | CreatureCreateOrConnectWithoutBiome_relationInput[]
    upsert?: CreatureUpsertWithWhereUniqueWithoutBiome_relationInput | CreatureUpsertWithWhereUniqueWithoutBiome_relationInput[]
    set?: CreatureWhereUniqueInput | CreatureWhereUniqueInput[]
    disconnect?: CreatureWhereUniqueInput | CreatureWhereUniqueInput[]
    delete?: CreatureWhereUniqueInput | CreatureWhereUniqueInput[]
    connect?: CreatureWhereUniqueInput | CreatureWhereUniqueInput[]
    update?: CreatureUpdateWithWhereUniqueWithoutBiome_relationInput | CreatureUpdateWithWhereUniqueWithoutBiome_relationInput[]
    updateMany?: CreatureUpdateManyWithWhereWithoutBiome_relationInput | CreatureUpdateManyWithWhereWithoutBiome_relationInput[]
    deleteMany?: CreatureScalarWhereInput | CreatureScalarWhereInput[]
  }

  export type CreatureUncheckedUpdateManyWithoutBiome_relationNestedInput = {
    create?: XOR<CreatureCreateWithoutBiome_relationInput, CreatureUncheckedCreateWithoutBiome_relationInput> | CreatureCreateWithoutBiome_relationInput[] | CreatureUncheckedCreateWithoutBiome_relationInput[]
    connectOrCreate?: CreatureCreateOrConnectWithoutBiome_relationInput | CreatureCreateOrConnectWithoutBiome_relationInput[]
    upsert?: CreatureUpsertWithWhereUniqueWithoutBiome_relationInput | CreatureUpsertWithWhereUniqueWithoutBiome_relationInput[]
    set?: CreatureWhereUniqueInput | CreatureWhereUniqueInput[]
    disconnect?: CreatureWhereUniqueInput | CreatureWhereUniqueInput[]
    delete?: CreatureWhereUniqueInput | CreatureWhereUniqueInput[]
    connect?: CreatureWhereUniqueInput | CreatureWhereUniqueInput[]
    update?: CreatureUpdateWithWhereUniqueWithoutBiome_relationInput | CreatureUpdateWithWhereUniqueWithoutBiome_relationInput[]
    updateMany?: CreatureUpdateManyWithWhereWithoutBiome_relationInput | CreatureUpdateManyWithWhereWithoutBiome_relationInput[]
    deleteMany?: CreatureScalarWhereInput | CreatureScalarWhereInput[]
  }

  export type CreatureCreateNestedManyWithoutType_relationInput = {
    create?: XOR<CreatureCreateWithoutType_relationInput, CreatureUncheckedCreateWithoutType_relationInput> | CreatureCreateWithoutType_relationInput[] | CreatureUncheckedCreateWithoutType_relationInput[]
    connectOrCreate?: CreatureCreateOrConnectWithoutType_relationInput | CreatureCreateOrConnectWithoutType_relationInput[]
    createMany?: CreatureCreateManyType_relationInputEnvelope
    connect?: CreatureWhereUniqueInput | CreatureWhereUniqueInput[]
  }

  export type CreatureUncheckedCreateNestedManyWithoutType_relationInput = {
    create?: XOR<CreatureCreateWithoutType_relationInput, CreatureUncheckedCreateWithoutType_relationInput> | CreatureCreateWithoutType_relationInput[] | CreatureUncheckedCreateWithoutType_relationInput[]
    connectOrCreate?: CreatureCreateOrConnectWithoutType_relationInput | CreatureCreateOrConnectWithoutType_relationInput[]
    createMany?: CreatureCreateManyType_relationInputEnvelope
    connect?: CreatureWhereUniqueInput | CreatureWhereUniqueInput[]
  }

  export type CreatureUpdateManyWithoutType_relationNestedInput = {
    create?: XOR<CreatureCreateWithoutType_relationInput, CreatureUncheckedCreateWithoutType_relationInput> | CreatureCreateWithoutType_relationInput[] | CreatureUncheckedCreateWithoutType_relationInput[]
    connectOrCreate?: CreatureCreateOrConnectWithoutType_relationInput | CreatureCreateOrConnectWithoutType_relationInput[]
    upsert?: CreatureUpsertWithWhereUniqueWithoutType_relationInput | CreatureUpsertWithWhereUniqueWithoutType_relationInput[]
    createMany?: CreatureCreateManyType_relationInputEnvelope
    set?: CreatureWhereUniqueInput | CreatureWhereUniqueInput[]
    disconnect?: CreatureWhereUniqueInput | CreatureWhereUniqueInput[]
    delete?: CreatureWhereUniqueInput | CreatureWhereUniqueInput[]
    connect?: CreatureWhereUniqueInput | CreatureWhereUniqueInput[]
    update?: CreatureUpdateWithWhereUniqueWithoutType_relationInput | CreatureUpdateWithWhereUniqueWithoutType_relationInput[]
    updateMany?: CreatureUpdateManyWithWhereWithoutType_relationInput | CreatureUpdateManyWithWhereWithoutType_relationInput[]
    deleteMany?: CreatureScalarWhereInput | CreatureScalarWhereInput[]
  }

  export type CreatureUncheckedUpdateManyWithoutType_relationNestedInput = {
    create?: XOR<CreatureCreateWithoutType_relationInput, CreatureUncheckedCreateWithoutType_relationInput> | CreatureCreateWithoutType_relationInput[] | CreatureUncheckedCreateWithoutType_relationInput[]
    connectOrCreate?: CreatureCreateOrConnectWithoutType_relationInput | CreatureCreateOrConnectWithoutType_relationInput[]
    upsert?: CreatureUpsertWithWhereUniqueWithoutType_relationInput | CreatureUpsertWithWhereUniqueWithoutType_relationInput[]
    createMany?: CreatureCreateManyType_relationInputEnvelope
    set?: CreatureWhereUniqueInput | CreatureWhereUniqueInput[]
    disconnect?: CreatureWhereUniqueInput | CreatureWhereUniqueInput[]
    delete?: CreatureWhereUniqueInput | CreatureWhereUniqueInput[]
    connect?: CreatureWhereUniqueInput | CreatureWhereUniqueInput[]
    update?: CreatureUpdateWithWhereUniqueWithoutType_relationInput | CreatureUpdateWithWhereUniqueWithoutType_relationInput[]
    updateMany?: CreatureUpdateManyWithWhereWithoutType_relationInput | CreatureUpdateManyWithWhereWithoutType_relationInput[]
    deleteMany?: CreatureScalarWhereInput | CreatureScalarWhereInput[]
  }

  export type CreatureCreateNestedManyWithoutAlignment_relationInput = {
    create?: XOR<CreatureCreateWithoutAlignment_relationInput, CreatureUncheckedCreateWithoutAlignment_relationInput> | CreatureCreateWithoutAlignment_relationInput[] | CreatureUncheckedCreateWithoutAlignment_relationInput[]
    connectOrCreate?: CreatureCreateOrConnectWithoutAlignment_relationInput | CreatureCreateOrConnectWithoutAlignment_relationInput[]
    createMany?: CreatureCreateManyAlignment_relationInputEnvelope
    connect?: CreatureWhereUniqueInput | CreatureWhereUniqueInput[]
  }

  export type CreatureUncheckedCreateNestedManyWithoutAlignment_relationInput = {
    create?: XOR<CreatureCreateWithoutAlignment_relationInput, CreatureUncheckedCreateWithoutAlignment_relationInput> | CreatureCreateWithoutAlignment_relationInput[] | CreatureUncheckedCreateWithoutAlignment_relationInput[]
    connectOrCreate?: CreatureCreateOrConnectWithoutAlignment_relationInput | CreatureCreateOrConnectWithoutAlignment_relationInput[]
    createMany?: CreatureCreateManyAlignment_relationInputEnvelope
    connect?: CreatureWhereUniqueInput | CreatureWhereUniqueInput[]
  }

  export type CreatureUpdateManyWithoutAlignment_relationNestedInput = {
    create?: XOR<CreatureCreateWithoutAlignment_relationInput, CreatureUncheckedCreateWithoutAlignment_relationInput> | CreatureCreateWithoutAlignment_relationInput[] | CreatureUncheckedCreateWithoutAlignment_relationInput[]
    connectOrCreate?: CreatureCreateOrConnectWithoutAlignment_relationInput | CreatureCreateOrConnectWithoutAlignment_relationInput[]
    upsert?: CreatureUpsertWithWhereUniqueWithoutAlignment_relationInput | CreatureUpsertWithWhereUniqueWithoutAlignment_relationInput[]
    createMany?: CreatureCreateManyAlignment_relationInputEnvelope
    set?: CreatureWhereUniqueInput | CreatureWhereUniqueInput[]
    disconnect?: CreatureWhereUniqueInput | CreatureWhereUniqueInput[]
    delete?: CreatureWhereUniqueInput | CreatureWhereUniqueInput[]
    connect?: CreatureWhereUniqueInput | CreatureWhereUniqueInput[]
    update?: CreatureUpdateWithWhereUniqueWithoutAlignment_relationInput | CreatureUpdateWithWhereUniqueWithoutAlignment_relationInput[]
    updateMany?: CreatureUpdateManyWithWhereWithoutAlignment_relationInput | CreatureUpdateManyWithWhereWithoutAlignment_relationInput[]
    deleteMany?: CreatureScalarWhereInput | CreatureScalarWhereInput[]
  }

  export type CreatureUncheckedUpdateManyWithoutAlignment_relationNestedInput = {
    create?: XOR<CreatureCreateWithoutAlignment_relationInput, CreatureUncheckedCreateWithoutAlignment_relationInput> | CreatureCreateWithoutAlignment_relationInput[] | CreatureUncheckedCreateWithoutAlignment_relationInput[]
    connectOrCreate?: CreatureCreateOrConnectWithoutAlignment_relationInput | CreatureCreateOrConnectWithoutAlignment_relationInput[]
    upsert?: CreatureUpsertWithWhereUniqueWithoutAlignment_relationInput | CreatureUpsertWithWhereUniqueWithoutAlignment_relationInput[]
    createMany?: CreatureCreateManyAlignment_relationInputEnvelope
    set?: CreatureWhereUniqueInput | CreatureWhereUniqueInput[]
    disconnect?: CreatureWhereUniqueInput | CreatureWhereUniqueInput[]
    delete?: CreatureWhereUniqueInput | CreatureWhereUniqueInput[]
    connect?: CreatureWhereUniqueInput | CreatureWhereUniqueInput[]
    update?: CreatureUpdateWithWhereUniqueWithoutAlignment_relationInput | CreatureUpdateWithWhereUniqueWithoutAlignment_relationInput[]
    updateMany?: CreatureUpdateManyWithWhereWithoutAlignment_relationInput | CreatureUpdateManyWithWhereWithoutAlignment_relationInput[]
    deleteMany?: CreatureScalarWhereInput | CreatureScalarWhereInput[]
  }

  export type CreatureCreateNestedOneWithoutSpeedInput = {
    create?: XOR<CreatureCreateWithoutSpeedInput, CreatureUncheckedCreateWithoutSpeedInput>
    connectOrCreate?: CreatureCreateOrConnectWithoutSpeedInput
    connect?: CreatureWhereUniqueInput
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type CreatureUpdateOneRequiredWithoutSpeedNestedInput = {
    create?: XOR<CreatureCreateWithoutSpeedInput, CreatureUncheckedCreateWithoutSpeedInput>
    connectOrCreate?: CreatureCreateOrConnectWithoutSpeedInput
    upsert?: CreatureUpsertWithoutSpeedInput
    connect?: CreatureWhereUniqueInput
    update?: XOR<XOR<CreatureUpdateToOneWithWhereWithoutSpeedInput, CreatureUpdateWithoutSpeedInput>, CreatureUncheckedUpdateWithoutSpeedInput>
  }

  export type Strength_stat_detailsCreateNestedOneWithoutCreature_statInput = {
    create?: XOR<Strength_stat_detailsCreateWithoutCreature_statInput, Strength_stat_detailsUncheckedCreateWithoutCreature_statInput>
    connectOrCreate?: Strength_stat_detailsCreateOrConnectWithoutCreature_statInput
    connect?: Strength_stat_detailsWhereUniqueInput
  }

  export type Dexterity_stat_detailsCreateNestedOneWithoutCreature_statInput = {
    create?: XOR<Dexterity_stat_detailsCreateWithoutCreature_statInput, Dexterity_stat_detailsUncheckedCreateWithoutCreature_statInput>
    connectOrCreate?: Dexterity_stat_detailsCreateOrConnectWithoutCreature_statInput
    connect?: Dexterity_stat_detailsWhereUniqueInput
  }

  export type Constitution_stat_detailsCreateNestedOneWithoutCreature_statInput = {
    create?: XOR<Constitution_stat_detailsCreateWithoutCreature_statInput, Constitution_stat_detailsUncheckedCreateWithoutCreature_statInput>
    connectOrCreate?: Constitution_stat_detailsCreateOrConnectWithoutCreature_statInput
    connect?: Constitution_stat_detailsWhereUniqueInput
  }

  export type Intelligence_stat_detailsCreateNestedOneWithoutCreature_statInput = {
    create?: XOR<Intelligence_stat_detailsCreateWithoutCreature_statInput, Intelligence_stat_detailsUncheckedCreateWithoutCreature_statInput>
    connectOrCreate?: Intelligence_stat_detailsCreateOrConnectWithoutCreature_statInput
    connect?: Intelligence_stat_detailsWhereUniqueInput
  }

  export type Wisdom_stat_detailsCreateNestedOneWithoutCreature_statInput = {
    create?: XOR<Wisdom_stat_detailsCreateWithoutCreature_statInput, Wisdom_stat_detailsUncheckedCreateWithoutCreature_statInput>
    connectOrCreate?: Wisdom_stat_detailsCreateOrConnectWithoutCreature_statInput
    connect?: Wisdom_stat_detailsWhereUniqueInput
  }

  export type Charisma_stat_detailsCreateNestedOneWithoutCreature_statInput = {
    create?: XOR<Charisma_stat_detailsCreateWithoutCreature_statInput, Charisma_stat_detailsUncheckedCreateWithoutCreature_statInput>
    connectOrCreate?: Charisma_stat_detailsCreateOrConnectWithoutCreature_statInput
    connect?: Charisma_stat_detailsWhereUniqueInput
  }

  export type CreatureCreateNestedOneWithoutStatsInput = {
    create?: XOR<CreatureCreateWithoutStatsInput, CreatureUncheckedCreateWithoutStatsInput>
    connectOrCreate?: CreatureCreateOrConnectWithoutStatsInput
    connect?: CreatureWhereUniqueInput
  }

  export type Strength_stat_detailsUncheckedCreateNestedOneWithoutCreature_statInput = {
    create?: XOR<Strength_stat_detailsCreateWithoutCreature_statInput, Strength_stat_detailsUncheckedCreateWithoutCreature_statInput>
    connectOrCreate?: Strength_stat_detailsCreateOrConnectWithoutCreature_statInput
    connect?: Strength_stat_detailsWhereUniqueInput
  }

  export type Dexterity_stat_detailsUncheckedCreateNestedOneWithoutCreature_statInput = {
    create?: XOR<Dexterity_stat_detailsCreateWithoutCreature_statInput, Dexterity_stat_detailsUncheckedCreateWithoutCreature_statInput>
    connectOrCreate?: Dexterity_stat_detailsCreateOrConnectWithoutCreature_statInput
    connect?: Dexterity_stat_detailsWhereUniqueInput
  }

  export type Constitution_stat_detailsUncheckedCreateNestedOneWithoutCreature_statInput = {
    create?: XOR<Constitution_stat_detailsCreateWithoutCreature_statInput, Constitution_stat_detailsUncheckedCreateWithoutCreature_statInput>
    connectOrCreate?: Constitution_stat_detailsCreateOrConnectWithoutCreature_statInput
    connect?: Constitution_stat_detailsWhereUniqueInput
  }

  export type Intelligence_stat_detailsUncheckedCreateNestedOneWithoutCreature_statInput = {
    create?: XOR<Intelligence_stat_detailsCreateWithoutCreature_statInput, Intelligence_stat_detailsUncheckedCreateWithoutCreature_statInput>
    connectOrCreate?: Intelligence_stat_detailsCreateOrConnectWithoutCreature_statInput
    connect?: Intelligence_stat_detailsWhereUniqueInput
  }

  export type Wisdom_stat_detailsUncheckedCreateNestedOneWithoutCreature_statInput = {
    create?: XOR<Wisdom_stat_detailsCreateWithoutCreature_statInput, Wisdom_stat_detailsUncheckedCreateWithoutCreature_statInput>
    connectOrCreate?: Wisdom_stat_detailsCreateOrConnectWithoutCreature_statInput
    connect?: Wisdom_stat_detailsWhereUniqueInput
  }

  export type Charisma_stat_detailsUncheckedCreateNestedOneWithoutCreature_statInput = {
    create?: XOR<Charisma_stat_detailsCreateWithoutCreature_statInput, Charisma_stat_detailsUncheckedCreateWithoutCreature_statInput>
    connectOrCreate?: Charisma_stat_detailsCreateOrConnectWithoutCreature_statInput
    connect?: Charisma_stat_detailsWhereUniqueInput
  }

  export type Strength_stat_detailsUpdateOneWithoutCreature_statNestedInput = {
    create?: XOR<Strength_stat_detailsCreateWithoutCreature_statInput, Strength_stat_detailsUncheckedCreateWithoutCreature_statInput>
    connectOrCreate?: Strength_stat_detailsCreateOrConnectWithoutCreature_statInput
    upsert?: Strength_stat_detailsUpsertWithoutCreature_statInput
    disconnect?: Strength_stat_detailsWhereInput | boolean
    delete?: Strength_stat_detailsWhereInput | boolean
    connect?: Strength_stat_detailsWhereUniqueInput
    update?: XOR<XOR<Strength_stat_detailsUpdateToOneWithWhereWithoutCreature_statInput, Strength_stat_detailsUpdateWithoutCreature_statInput>, Strength_stat_detailsUncheckedUpdateWithoutCreature_statInput>
  }

  export type Dexterity_stat_detailsUpdateOneWithoutCreature_statNestedInput = {
    create?: XOR<Dexterity_stat_detailsCreateWithoutCreature_statInput, Dexterity_stat_detailsUncheckedCreateWithoutCreature_statInput>
    connectOrCreate?: Dexterity_stat_detailsCreateOrConnectWithoutCreature_statInput
    upsert?: Dexterity_stat_detailsUpsertWithoutCreature_statInput
    disconnect?: Dexterity_stat_detailsWhereInput | boolean
    delete?: Dexterity_stat_detailsWhereInput | boolean
    connect?: Dexterity_stat_detailsWhereUniqueInput
    update?: XOR<XOR<Dexterity_stat_detailsUpdateToOneWithWhereWithoutCreature_statInput, Dexterity_stat_detailsUpdateWithoutCreature_statInput>, Dexterity_stat_detailsUncheckedUpdateWithoutCreature_statInput>
  }

  export type Constitution_stat_detailsUpdateOneWithoutCreature_statNestedInput = {
    create?: XOR<Constitution_stat_detailsCreateWithoutCreature_statInput, Constitution_stat_detailsUncheckedCreateWithoutCreature_statInput>
    connectOrCreate?: Constitution_stat_detailsCreateOrConnectWithoutCreature_statInput
    upsert?: Constitution_stat_detailsUpsertWithoutCreature_statInput
    disconnect?: Constitution_stat_detailsWhereInput | boolean
    delete?: Constitution_stat_detailsWhereInput | boolean
    connect?: Constitution_stat_detailsWhereUniqueInput
    update?: XOR<XOR<Constitution_stat_detailsUpdateToOneWithWhereWithoutCreature_statInput, Constitution_stat_detailsUpdateWithoutCreature_statInput>, Constitution_stat_detailsUncheckedUpdateWithoutCreature_statInput>
  }

  export type Intelligence_stat_detailsUpdateOneWithoutCreature_statNestedInput = {
    create?: XOR<Intelligence_stat_detailsCreateWithoutCreature_statInput, Intelligence_stat_detailsUncheckedCreateWithoutCreature_statInput>
    connectOrCreate?: Intelligence_stat_detailsCreateOrConnectWithoutCreature_statInput
    upsert?: Intelligence_stat_detailsUpsertWithoutCreature_statInput
    disconnect?: Intelligence_stat_detailsWhereInput | boolean
    delete?: Intelligence_stat_detailsWhereInput | boolean
    connect?: Intelligence_stat_detailsWhereUniqueInput
    update?: XOR<XOR<Intelligence_stat_detailsUpdateToOneWithWhereWithoutCreature_statInput, Intelligence_stat_detailsUpdateWithoutCreature_statInput>, Intelligence_stat_detailsUncheckedUpdateWithoutCreature_statInput>
  }

  export type Wisdom_stat_detailsUpdateOneWithoutCreature_statNestedInput = {
    create?: XOR<Wisdom_stat_detailsCreateWithoutCreature_statInput, Wisdom_stat_detailsUncheckedCreateWithoutCreature_statInput>
    connectOrCreate?: Wisdom_stat_detailsCreateOrConnectWithoutCreature_statInput
    upsert?: Wisdom_stat_detailsUpsertWithoutCreature_statInput
    disconnect?: Wisdom_stat_detailsWhereInput | boolean
    delete?: Wisdom_stat_detailsWhereInput | boolean
    connect?: Wisdom_stat_detailsWhereUniqueInput
    update?: XOR<XOR<Wisdom_stat_detailsUpdateToOneWithWhereWithoutCreature_statInput, Wisdom_stat_detailsUpdateWithoutCreature_statInput>, Wisdom_stat_detailsUncheckedUpdateWithoutCreature_statInput>
  }

  export type Charisma_stat_detailsUpdateOneWithoutCreature_statNestedInput = {
    create?: XOR<Charisma_stat_detailsCreateWithoutCreature_statInput, Charisma_stat_detailsUncheckedCreateWithoutCreature_statInput>
    connectOrCreate?: Charisma_stat_detailsCreateOrConnectWithoutCreature_statInput
    upsert?: Charisma_stat_detailsUpsertWithoutCreature_statInput
    disconnect?: Charisma_stat_detailsWhereInput | boolean
    delete?: Charisma_stat_detailsWhereInput | boolean
    connect?: Charisma_stat_detailsWhereUniqueInput
    update?: XOR<XOR<Charisma_stat_detailsUpdateToOneWithWhereWithoutCreature_statInput, Charisma_stat_detailsUpdateWithoutCreature_statInput>, Charisma_stat_detailsUncheckedUpdateWithoutCreature_statInput>
  }

  export type CreatureUpdateOneRequiredWithoutStatsNestedInput = {
    create?: XOR<CreatureCreateWithoutStatsInput, CreatureUncheckedCreateWithoutStatsInput>
    connectOrCreate?: CreatureCreateOrConnectWithoutStatsInput
    upsert?: CreatureUpsertWithoutStatsInput
    connect?: CreatureWhereUniqueInput
    update?: XOR<XOR<CreatureUpdateToOneWithWhereWithoutStatsInput, CreatureUpdateWithoutStatsInput>, CreatureUncheckedUpdateWithoutStatsInput>
  }

  export type Strength_stat_detailsUncheckedUpdateOneWithoutCreature_statNestedInput = {
    create?: XOR<Strength_stat_detailsCreateWithoutCreature_statInput, Strength_stat_detailsUncheckedCreateWithoutCreature_statInput>
    connectOrCreate?: Strength_stat_detailsCreateOrConnectWithoutCreature_statInput
    upsert?: Strength_stat_detailsUpsertWithoutCreature_statInput
    disconnect?: Strength_stat_detailsWhereInput | boolean
    delete?: Strength_stat_detailsWhereInput | boolean
    connect?: Strength_stat_detailsWhereUniqueInput
    update?: XOR<XOR<Strength_stat_detailsUpdateToOneWithWhereWithoutCreature_statInput, Strength_stat_detailsUpdateWithoutCreature_statInput>, Strength_stat_detailsUncheckedUpdateWithoutCreature_statInput>
  }

  export type Dexterity_stat_detailsUncheckedUpdateOneWithoutCreature_statNestedInput = {
    create?: XOR<Dexterity_stat_detailsCreateWithoutCreature_statInput, Dexterity_stat_detailsUncheckedCreateWithoutCreature_statInput>
    connectOrCreate?: Dexterity_stat_detailsCreateOrConnectWithoutCreature_statInput
    upsert?: Dexterity_stat_detailsUpsertWithoutCreature_statInput
    disconnect?: Dexterity_stat_detailsWhereInput | boolean
    delete?: Dexterity_stat_detailsWhereInput | boolean
    connect?: Dexterity_stat_detailsWhereUniqueInput
    update?: XOR<XOR<Dexterity_stat_detailsUpdateToOneWithWhereWithoutCreature_statInput, Dexterity_stat_detailsUpdateWithoutCreature_statInput>, Dexterity_stat_detailsUncheckedUpdateWithoutCreature_statInput>
  }

  export type Constitution_stat_detailsUncheckedUpdateOneWithoutCreature_statNestedInput = {
    create?: XOR<Constitution_stat_detailsCreateWithoutCreature_statInput, Constitution_stat_detailsUncheckedCreateWithoutCreature_statInput>
    connectOrCreate?: Constitution_stat_detailsCreateOrConnectWithoutCreature_statInput
    upsert?: Constitution_stat_detailsUpsertWithoutCreature_statInput
    disconnect?: Constitution_stat_detailsWhereInput | boolean
    delete?: Constitution_stat_detailsWhereInput | boolean
    connect?: Constitution_stat_detailsWhereUniqueInput
    update?: XOR<XOR<Constitution_stat_detailsUpdateToOneWithWhereWithoutCreature_statInput, Constitution_stat_detailsUpdateWithoutCreature_statInput>, Constitution_stat_detailsUncheckedUpdateWithoutCreature_statInput>
  }

  export type Intelligence_stat_detailsUncheckedUpdateOneWithoutCreature_statNestedInput = {
    create?: XOR<Intelligence_stat_detailsCreateWithoutCreature_statInput, Intelligence_stat_detailsUncheckedCreateWithoutCreature_statInput>
    connectOrCreate?: Intelligence_stat_detailsCreateOrConnectWithoutCreature_statInput
    upsert?: Intelligence_stat_detailsUpsertWithoutCreature_statInput
    disconnect?: Intelligence_stat_detailsWhereInput | boolean
    delete?: Intelligence_stat_detailsWhereInput | boolean
    connect?: Intelligence_stat_detailsWhereUniqueInput
    update?: XOR<XOR<Intelligence_stat_detailsUpdateToOneWithWhereWithoutCreature_statInput, Intelligence_stat_detailsUpdateWithoutCreature_statInput>, Intelligence_stat_detailsUncheckedUpdateWithoutCreature_statInput>
  }

  export type Wisdom_stat_detailsUncheckedUpdateOneWithoutCreature_statNestedInput = {
    create?: XOR<Wisdom_stat_detailsCreateWithoutCreature_statInput, Wisdom_stat_detailsUncheckedCreateWithoutCreature_statInput>
    connectOrCreate?: Wisdom_stat_detailsCreateOrConnectWithoutCreature_statInput
    upsert?: Wisdom_stat_detailsUpsertWithoutCreature_statInput
    disconnect?: Wisdom_stat_detailsWhereInput | boolean
    delete?: Wisdom_stat_detailsWhereInput | boolean
    connect?: Wisdom_stat_detailsWhereUniqueInput
    update?: XOR<XOR<Wisdom_stat_detailsUpdateToOneWithWhereWithoutCreature_statInput, Wisdom_stat_detailsUpdateWithoutCreature_statInput>, Wisdom_stat_detailsUncheckedUpdateWithoutCreature_statInput>
  }

  export type Charisma_stat_detailsUncheckedUpdateOneWithoutCreature_statNestedInput = {
    create?: XOR<Charisma_stat_detailsCreateWithoutCreature_statInput, Charisma_stat_detailsUncheckedCreateWithoutCreature_statInput>
    connectOrCreate?: Charisma_stat_detailsCreateOrConnectWithoutCreature_statInput
    upsert?: Charisma_stat_detailsUpsertWithoutCreature_statInput
    disconnect?: Charisma_stat_detailsWhereInput | boolean
    delete?: Charisma_stat_detailsWhereInput | boolean
    connect?: Charisma_stat_detailsWhereUniqueInput
    update?: XOR<XOR<Charisma_stat_detailsUpdateToOneWithWhereWithoutCreature_statInput, Charisma_stat_detailsUpdateWithoutCreature_statInput>, Charisma_stat_detailsUncheckedUpdateWithoutCreature_statInput>
  }

  export type Creature_statsCreateNestedOneWithoutStrengthInput = {
    create?: XOR<Creature_statsCreateWithoutStrengthInput, Creature_statsUncheckedCreateWithoutStrengthInput>
    connectOrCreate?: Creature_statsCreateOrConnectWithoutStrengthInput
    connect?: Creature_statsWhereUniqueInput
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type Creature_statsUpdateOneRequiredWithoutStrengthNestedInput = {
    create?: XOR<Creature_statsCreateWithoutStrengthInput, Creature_statsUncheckedCreateWithoutStrengthInput>
    connectOrCreate?: Creature_statsCreateOrConnectWithoutStrengthInput
    upsert?: Creature_statsUpsertWithoutStrengthInput
    connect?: Creature_statsWhereUniqueInput
    update?: XOR<XOR<Creature_statsUpdateToOneWithWhereWithoutStrengthInput, Creature_statsUpdateWithoutStrengthInput>, Creature_statsUncheckedUpdateWithoutStrengthInput>
  }

  export type Creature_statsCreateNestedOneWithoutDexterityInput = {
    create?: XOR<Creature_statsCreateWithoutDexterityInput, Creature_statsUncheckedCreateWithoutDexterityInput>
    connectOrCreate?: Creature_statsCreateOrConnectWithoutDexterityInput
    connect?: Creature_statsWhereUniqueInput
  }

  export type Creature_statsUpdateOneRequiredWithoutDexterityNestedInput = {
    create?: XOR<Creature_statsCreateWithoutDexterityInput, Creature_statsUncheckedCreateWithoutDexterityInput>
    connectOrCreate?: Creature_statsCreateOrConnectWithoutDexterityInput
    upsert?: Creature_statsUpsertWithoutDexterityInput
    connect?: Creature_statsWhereUniqueInput
    update?: XOR<XOR<Creature_statsUpdateToOneWithWhereWithoutDexterityInput, Creature_statsUpdateWithoutDexterityInput>, Creature_statsUncheckedUpdateWithoutDexterityInput>
  }

  export type Creature_statsCreateNestedOneWithoutConstitutionInput = {
    create?: XOR<Creature_statsCreateWithoutConstitutionInput, Creature_statsUncheckedCreateWithoutConstitutionInput>
    connectOrCreate?: Creature_statsCreateOrConnectWithoutConstitutionInput
    connect?: Creature_statsWhereUniqueInput
  }

  export type Creature_statsUpdateOneRequiredWithoutConstitutionNestedInput = {
    create?: XOR<Creature_statsCreateWithoutConstitutionInput, Creature_statsUncheckedCreateWithoutConstitutionInput>
    connectOrCreate?: Creature_statsCreateOrConnectWithoutConstitutionInput
    upsert?: Creature_statsUpsertWithoutConstitutionInput
    connect?: Creature_statsWhereUniqueInput
    update?: XOR<XOR<Creature_statsUpdateToOneWithWhereWithoutConstitutionInput, Creature_statsUpdateWithoutConstitutionInput>, Creature_statsUncheckedUpdateWithoutConstitutionInput>
  }

  export type Creature_statsCreateNestedOneWithoutIntelligenceInput = {
    create?: XOR<Creature_statsCreateWithoutIntelligenceInput, Creature_statsUncheckedCreateWithoutIntelligenceInput>
    connectOrCreate?: Creature_statsCreateOrConnectWithoutIntelligenceInput
    connect?: Creature_statsWhereUniqueInput
  }

  export type Creature_statsUpdateOneRequiredWithoutIntelligenceNestedInput = {
    create?: XOR<Creature_statsCreateWithoutIntelligenceInput, Creature_statsUncheckedCreateWithoutIntelligenceInput>
    connectOrCreate?: Creature_statsCreateOrConnectWithoutIntelligenceInput
    upsert?: Creature_statsUpsertWithoutIntelligenceInput
    connect?: Creature_statsWhereUniqueInput
    update?: XOR<XOR<Creature_statsUpdateToOneWithWhereWithoutIntelligenceInput, Creature_statsUpdateWithoutIntelligenceInput>, Creature_statsUncheckedUpdateWithoutIntelligenceInput>
  }

  export type Creature_statsCreateNestedOneWithoutWisdomInput = {
    create?: XOR<Creature_statsCreateWithoutWisdomInput, Creature_statsUncheckedCreateWithoutWisdomInput>
    connectOrCreate?: Creature_statsCreateOrConnectWithoutWisdomInput
    connect?: Creature_statsWhereUniqueInput
  }

  export type Creature_statsUpdateOneRequiredWithoutWisdomNestedInput = {
    create?: XOR<Creature_statsCreateWithoutWisdomInput, Creature_statsUncheckedCreateWithoutWisdomInput>
    connectOrCreate?: Creature_statsCreateOrConnectWithoutWisdomInput
    upsert?: Creature_statsUpsertWithoutWisdomInput
    connect?: Creature_statsWhereUniqueInput
    update?: XOR<XOR<Creature_statsUpdateToOneWithWhereWithoutWisdomInput, Creature_statsUpdateWithoutWisdomInput>, Creature_statsUncheckedUpdateWithoutWisdomInput>
  }

  export type Creature_statsCreateNestedOneWithoutCharismaInput = {
    create?: XOR<Creature_statsCreateWithoutCharismaInput, Creature_statsUncheckedCreateWithoutCharismaInput>
    connectOrCreate?: Creature_statsCreateOrConnectWithoutCharismaInput
    connect?: Creature_statsWhereUniqueInput
  }

  export type Creature_statsUpdateOneRequiredWithoutCharismaNestedInput = {
    create?: XOR<Creature_statsCreateWithoutCharismaInput, Creature_statsUncheckedCreateWithoutCharismaInput>
    connectOrCreate?: Creature_statsCreateOrConnectWithoutCharismaInput
    upsert?: Creature_statsUpsertWithoutCharismaInput
    connect?: Creature_statsWhereUniqueInput
    update?: XOR<XOR<Creature_statsUpdateToOneWithWhereWithoutCharismaInput, Creature_statsUpdateWithoutCharismaInput>, Creature_statsUncheckedUpdateWithoutCharismaInput>
  }

  export type StrengthBasedSkillsCreateNestedOneWithoutSkills_list_relationInput = {
    create?: XOR<StrengthBasedSkillsCreateWithoutSkills_list_relationInput, StrengthBasedSkillsUncheckedCreateWithoutSkills_list_relationInput>
    connectOrCreate?: StrengthBasedSkillsCreateOrConnectWithoutSkills_list_relationInput
    connect?: StrengthBasedSkillsWhereUniqueInput
  }

  export type DexterityBasedSkillsCreateNestedOneWithoutSkills_list_relationInput = {
    create?: XOR<DexterityBasedSkillsCreateWithoutSkills_list_relationInput, DexterityBasedSkillsUncheckedCreateWithoutSkills_list_relationInput>
    connectOrCreate?: DexterityBasedSkillsCreateOrConnectWithoutSkills_list_relationInput
    connect?: DexterityBasedSkillsWhereUniqueInput
  }

  export type IntellengenceBasedSkillsCreateNestedOneWithoutSkills_list_relationInput = {
    create?: XOR<IntellengenceBasedSkillsCreateWithoutSkills_list_relationInput, IntellengenceBasedSkillsUncheckedCreateWithoutSkills_list_relationInput>
    connectOrCreate?: IntellengenceBasedSkillsCreateOrConnectWithoutSkills_list_relationInput
    connect?: IntellengenceBasedSkillsWhereUniqueInput
  }

  export type WisdomBasedSkillsCreateNestedOneWithoutSkills_list_relationInput = {
    create?: XOR<WisdomBasedSkillsCreateWithoutSkills_list_relationInput, WisdomBasedSkillsUncheckedCreateWithoutSkills_list_relationInput>
    connectOrCreate?: WisdomBasedSkillsCreateOrConnectWithoutSkills_list_relationInput
    connect?: WisdomBasedSkillsWhereUniqueInput
  }

  export type CharismaBasedSkillsCreateNestedOneWithoutSkills_list_relationInput = {
    create?: XOR<CharismaBasedSkillsCreateWithoutSkills_list_relationInput, CharismaBasedSkillsUncheckedCreateWithoutSkills_list_relationInput>
    connectOrCreate?: CharismaBasedSkillsCreateOrConnectWithoutSkills_list_relationInput
    connect?: CharismaBasedSkillsWhereUniqueInput
  }

  export type CreatureCreateNestedOneWithoutSkillsInput = {
    create?: XOR<CreatureCreateWithoutSkillsInput, CreatureUncheckedCreateWithoutSkillsInput>
    connectOrCreate?: CreatureCreateOrConnectWithoutSkillsInput
    connect?: CreatureWhereUniqueInput
  }

  export type StrengthBasedSkillsUncheckedCreateNestedOneWithoutSkills_list_relationInput = {
    create?: XOR<StrengthBasedSkillsCreateWithoutSkills_list_relationInput, StrengthBasedSkillsUncheckedCreateWithoutSkills_list_relationInput>
    connectOrCreate?: StrengthBasedSkillsCreateOrConnectWithoutSkills_list_relationInput
    connect?: StrengthBasedSkillsWhereUniqueInput
  }

  export type DexterityBasedSkillsUncheckedCreateNestedOneWithoutSkills_list_relationInput = {
    create?: XOR<DexterityBasedSkillsCreateWithoutSkills_list_relationInput, DexterityBasedSkillsUncheckedCreateWithoutSkills_list_relationInput>
    connectOrCreate?: DexterityBasedSkillsCreateOrConnectWithoutSkills_list_relationInput
    connect?: DexterityBasedSkillsWhereUniqueInput
  }

  export type IntellengenceBasedSkillsUncheckedCreateNestedOneWithoutSkills_list_relationInput = {
    create?: XOR<IntellengenceBasedSkillsCreateWithoutSkills_list_relationInput, IntellengenceBasedSkillsUncheckedCreateWithoutSkills_list_relationInput>
    connectOrCreate?: IntellengenceBasedSkillsCreateOrConnectWithoutSkills_list_relationInput
    connect?: IntellengenceBasedSkillsWhereUniqueInput
  }

  export type WisdomBasedSkillsUncheckedCreateNestedOneWithoutSkills_list_relationInput = {
    create?: XOR<WisdomBasedSkillsCreateWithoutSkills_list_relationInput, WisdomBasedSkillsUncheckedCreateWithoutSkills_list_relationInput>
    connectOrCreate?: WisdomBasedSkillsCreateOrConnectWithoutSkills_list_relationInput
    connect?: WisdomBasedSkillsWhereUniqueInput
  }

  export type CharismaBasedSkillsUncheckedCreateNestedOneWithoutSkills_list_relationInput = {
    create?: XOR<CharismaBasedSkillsCreateWithoutSkills_list_relationInput, CharismaBasedSkillsUncheckedCreateWithoutSkills_list_relationInput>
    connectOrCreate?: CharismaBasedSkillsCreateOrConnectWithoutSkills_list_relationInput
    connect?: CharismaBasedSkillsWhereUniqueInput
  }

  export type StrengthBasedSkillsUpdateOneWithoutSkills_list_relationNestedInput = {
    create?: XOR<StrengthBasedSkillsCreateWithoutSkills_list_relationInput, StrengthBasedSkillsUncheckedCreateWithoutSkills_list_relationInput>
    connectOrCreate?: StrengthBasedSkillsCreateOrConnectWithoutSkills_list_relationInput
    upsert?: StrengthBasedSkillsUpsertWithoutSkills_list_relationInput
    disconnect?: StrengthBasedSkillsWhereInput | boolean
    delete?: StrengthBasedSkillsWhereInput | boolean
    connect?: StrengthBasedSkillsWhereUniqueInput
    update?: XOR<XOR<StrengthBasedSkillsUpdateToOneWithWhereWithoutSkills_list_relationInput, StrengthBasedSkillsUpdateWithoutSkills_list_relationInput>, StrengthBasedSkillsUncheckedUpdateWithoutSkills_list_relationInput>
  }

  export type DexterityBasedSkillsUpdateOneWithoutSkills_list_relationNestedInput = {
    create?: XOR<DexterityBasedSkillsCreateWithoutSkills_list_relationInput, DexterityBasedSkillsUncheckedCreateWithoutSkills_list_relationInput>
    connectOrCreate?: DexterityBasedSkillsCreateOrConnectWithoutSkills_list_relationInput
    upsert?: DexterityBasedSkillsUpsertWithoutSkills_list_relationInput
    disconnect?: DexterityBasedSkillsWhereInput | boolean
    delete?: DexterityBasedSkillsWhereInput | boolean
    connect?: DexterityBasedSkillsWhereUniqueInput
    update?: XOR<XOR<DexterityBasedSkillsUpdateToOneWithWhereWithoutSkills_list_relationInput, DexterityBasedSkillsUpdateWithoutSkills_list_relationInput>, DexterityBasedSkillsUncheckedUpdateWithoutSkills_list_relationInput>
  }

  export type IntellengenceBasedSkillsUpdateOneWithoutSkills_list_relationNestedInput = {
    create?: XOR<IntellengenceBasedSkillsCreateWithoutSkills_list_relationInput, IntellengenceBasedSkillsUncheckedCreateWithoutSkills_list_relationInput>
    connectOrCreate?: IntellengenceBasedSkillsCreateOrConnectWithoutSkills_list_relationInput
    upsert?: IntellengenceBasedSkillsUpsertWithoutSkills_list_relationInput
    disconnect?: IntellengenceBasedSkillsWhereInput | boolean
    delete?: IntellengenceBasedSkillsWhereInput | boolean
    connect?: IntellengenceBasedSkillsWhereUniqueInput
    update?: XOR<XOR<IntellengenceBasedSkillsUpdateToOneWithWhereWithoutSkills_list_relationInput, IntellengenceBasedSkillsUpdateWithoutSkills_list_relationInput>, IntellengenceBasedSkillsUncheckedUpdateWithoutSkills_list_relationInput>
  }

  export type WisdomBasedSkillsUpdateOneWithoutSkills_list_relationNestedInput = {
    create?: XOR<WisdomBasedSkillsCreateWithoutSkills_list_relationInput, WisdomBasedSkillsUncheckedCreateWithoutSkills_list_relationInput>
    connectOrCreate?: WisdomBasedSkillsCreateOrConnectWithoutSkills_list_relationInput
    upsert?: WisdomBasedSkillsUpsertWithoutSkills_list_relationInput
    disconnect?: WisdomBasedSkillsWhereInput | boolean
    delete?: WisdomBasedSkillsWhereInput | boolean
    connect?: WisdomBasedSkillsWhereUniqueInput
    update?: XOR<XOR<WisdomBasedSkillsUpdateToOneWithWhereWithoutSkills_list_relationInput, WisdomBasedSkillsUpdateWithoutSkills_list_relationInput>, WisdomBasedSkillsUncheckedUpdateWithoutSkills_list_relationInput>
  }

  export type CharismaBasedSkillsUpdateOneWithoutSkills_list_relationNestedInput = {
    create?: XOR<CharismaBasedSkillsCreateWithoutSkills_list_relationInput, CharismaBasedSkillsUncheckedCreateWithoutSkills_list_relationInput>
    connectOrCreate?: CharismaBasedSkillsCreateOrConnectWithoutSkills_list_relationInput
    upsert?: CharismaBasedSkillsUpsertWithoutSkills_list_relationInput
    disconnect?: CharismaBasedSkillsWhereInput | boolean
    delete?: CharismaBasedSkillsWhereInput | boolean
    connect?: CharismaBasedSkillsWhereUniqueInput
    update?: XOR<XOR<CharismaBasedSkillsUpdateToOneWithWhereWithoutSkills_list_relationInput, CharismaBasedSkillsUpdateWithoutSkills_list_relationInput>, CharismaBasedSkillsUncheckedUpdateWithoutSkills_list_relationInput>
  }

  export type CreatureUpdateOneRequiredWithoutSkillsNestedInput = {
    create?: XOR<CreatureCreateWithoutSkillsInput, CreatureUncheckedCreateWithoutSkillsInput>
    connectOrCreate?: CreatureCreateOrConnectWithoutSkillsInput
    upsert?: CreatureUpsertWithoutSkillsInput
    connect?: CreatureWhereUniqueInput
    update?: XOR<XOR<CreatureUpdateToOneWithWhereWithoutSkillsInput, CreatureUpdateWithoutSkillsInput>, CreatureUncheckedUpdateWithoutSkillsInput>
  }

  export type StrengthBasedSkillsUncheckedUpdateOneWithoutSkills_list_relationNestedInput = {
    create?: XOR<StrengthBasedSkillsCreateWithoutSkills_list_relationInput, StrengthBasedSkillsUncheckedCreateWithoutSkills_list_relationInput>
    connectOrCreate?: StrengthBasedSkillsCreateOrConnectWithoutSkills_list_relationInput
    upsert?: StrengthBasedSkillsUpsertWithoutSkills_list_relationInput
    disconnect?: StrengthBasedSkillsWhereInput | boolean
    delete?: StrengthBasedSkillsWhereInput | boolean
    connect?: StrengthBasedSkillsWhereUniqueInput
    update?: XOR<XOR<StrengthBasedSkillsUpdateToOneWithWhereWithoutSkills_list_relationInput, StrengthBasedSkillsUpdateWithoutSkills_list_relationInput>, StrengthBasedSkillsUncheckedUpdateWithoutSkills_list_relationInput>
  }

  export type DexterityBasedSkillsUncheckedUpdateOneWithoutSkills_list_relationNestedInput = {
    create?: XOR<DexterityBasedSkillsCreateWithoutSkills_list_relationInput, DexterityBasedSkillsUncheckedCreateWithoutSkills_list_relationInput>
    connectOrCreate?: DexterityBasedSkillsCreateOrConnectWithoutSkills_list_relationInput
    upsert?: DexterityBasedSkillsUpsertWithoutSkills_list_relationInput
    disconnect?: DexterityBasedSkillsWhereInput | boolean
    delete?: DexterityBasedSkillsWhereInput | boolean
    connect?: DexterityBasedSkillsWhereUniqueInput
    update?: XOR<XOR<DexterityBasedSkillsUpdateToOneWithWhereWithoutSkills_list_relationInput, DexterityBasedSkillsUpdateWithoutSkills_list_relationInput>, DexterityBasedSkillsUncheckedUpdateWithoutSkills_list_relationInput>
  }

  export type IntellengenceBasedSkillsUncheckedUpdateOneWithoutSkills_list_relationNestedInput = {
    create?: XOR<IntellengenceBasedSkillsCreateWithoutSkills_list_relationInput, IntellengenceBasedSkillsUncheckedCreateWithoutSkills_list_relationInput>
    connectOrCreate?: IntellengenceBasedSkillsCreateOrConnectWithoutSkills_list_relationInput
    upsert?: IntellengenceBasedSkillsUpsertWithoutSkills_list_relationInput
    disconnect?: IntellengenceBasedSkillsWhereInput | boolean
    delete?: IntellengenceBasedSkillsWhereInput | boolean
    connect?: IntellengenceBasedSkillsWhereUniqueInput
    update?: XOR<XOR<IntellengenceBasedSkillsUpdateToOneWithWhereWithoutSkills_list_relationInput, IntellengenceBasedSkillsUpdateWithoutSkills_list_relationInput>, IntellengenceBasedSkillsUncheckedUpdateWithoutSkills_list_relationInput>
  }

  export type WisdomBasedSkillsUncheckedUpdateOneWithoutSkills_list_relationNestedInput = {
    create?: XOR<WisdomBasedSkillsCreateWithoutSkills_list_relationInput, WisdomBasedSkillsUncheckedCreateWithoutSkills_list_relationInput>
    connectOrCreate?: WisdomBasedSkillsCreateOrConnectWithoutSkills_list_relationInput
    upsert?: WisdomBasedSkillsUpsertWithoutSkills_list_relationInput
    disconnect?: WisdomBasedSkillsWhereInput | boolean
    delete?: WisdomBasedSkillsWhereInput | boolean
    connect?: WisdomBasedSkillsWhereUniqueInput
    update?: XOR<XOR<WisdomBasedSkillsUpdateToOneWithWhereWithoutSkills_list_relationInput, WisdomBasedSkillsUpdateWithoutSkills_list_relationInput>, WisdomBasedSkillsUncheckedUpdateWithoutSkills_list_relationInput>
  }

  export type CharismaBasedSkillsUncheckedUpdateOneWithoutSkills_list_relationNestedInput = {
    create?: XOR<CharismaBasedSkillsCreateWithoutSkills_list_relationInput, CharismaBasedSkillsUncheckedCreateWithoutSkills_list_relationInput>
    connectOrCreate?: CharismaBasedSkillsCreateOrConnectWithoutSkills_list_relationInput
    upsert?: CharismaBasedSkillsUpsertWithoutSkills_list_relationInput
    disconnect?: CharismaBasedSkillsWhereInput | boolean
    delete?: CharismaBasedSkillsWhereInput | boolean
    connect?: CharismaBasedSkillsWhereUniqueInput
    update?: XOR<XOR<CharismaBasedSkillsUpdateToOneWithWhereWithoutSkills_list_relationInput, CharismaBasedSkillsUpdateWithoutSkills_list_relationInput>, CharismaBasedSkillsUncheckedUpdateWithoutSkills_list_relationInput>
  }

  export type AthleticsSkillCreateNestedOneWithoutSkill_listInput = {
    create?: XOR<AthleticsSkillCreateWithoutSkill_listInput, AthleticsSkillUncheckedCreateWithoutSkill_listInput>
    connectOrCreate?: AthleticsSkillCreateOrConnectWithoutSkill_listInput
    connect?: AthleticsSkillWhereUniqueInput
  }

  export type SkillsListCreateNestedOneWithoutStrengthInput = {
    create?: XOR<SkillsListCreateWithoutStrengthInput, SkillsListUncheckedCreateWithoutStrengthInput>
    connectOrCreate?: SkillsListCreateOrConnectWithoutStrengthInput
    connect?: SkillsListWhereUniqueInput
  }

  export type AthleticsSkillUncheckedCreateNestedOneWithoutSkill_listInput = {
    create?: XOR<AthleticsSkillCreateWithoutSkill_listInput, AthleticsSkillUncheckedCreateWithoutSkill_listInput>
    connectOrCreate?: AthleticsSkillCreateOrConnectWithoutSkill_listInput
    connect?: AthleticsSkillWhereUniqueInput
  }

  export type AthleticsSkillUpdateOneWithoutSkill_listNestedInput = {
    create?: XOR<AthleticsSkillCreateWithoutSkill_listInput, AthleticsSkillUncheckedCreateWithoutSkill_listInput>
    connectOrCreate?: AthleticsSkillCreateOrConnectWithoutSkill_listInput
    upsert?: AthleticsSkillUpsertWithoutSkill_listInput
    disconnect?: AthleticsSkillWhereInput | boolean
    delete?: AthleticsSkillWhereInput | boolean
    connect?: AthleticsSkillWhereUniqueInput
    update?: XOR<XOR<AthleticsSkillUpdateToOneWithWhereWithoutSkill_listInput, AthleticsSkillUpdateWithoutSkill_listInput>, AthleticsSkillUncheckedUpdateWithoutSkill_listInput>
  }

  export type SkillsListUpdateOneRequiredWithoutStrengthNestedInput = {
    create?: XOR<SkillsListCreateWithoutStrengthInput, SkillsListUncheckedCreateWithoutStrengthInput>
    connectOrCreate?: SkillsListCreateOrConnectWithoutStrengthInput
    upsert?: SkillsListUpsertWithoutStrengthInput
    connect?: SkillsListWhereUniqueInput
    update?: XOR<XOR<SkillsListUpdateToOneWithWhereWithoutStrengthInput, SkillsListUpdateWithoutStrengthInput>, SkillsListUncheckedUpdateWithoutStrengthInput>
  }

  export type AthleticsSkillUncheckedUpdateOneWithoutSkill_listNestedInput = {
    create?: XOR<AthleticsSkillCreateWithoutSkill_listInput, AthleticsSkillUncheckedCreateWithoutSkill_listInput>
    connectOrCreate?: AthleticsSkillCreateOrConnectWithoutSkill_listInput
    upsert?: AthleticsSkillUpsertWithoutSkill_listInput
    disconnect?: AthleticsSkillWhereInput | boolean
    delete?: AthleticsSkillWhereInput | boolean
    connect?: AthleticsSkillWhereUniqueInput
    update?: XOR<XOR<AthleticsSkillUpdateToOneWithWhereWithoutSkill_listInput, AthleticsSkillUpdateWithoutSkill_listInput>, AthleticsSkillUncheckedUpdateWithoutSkill_listInput>
  }

  export type AcrobaticsSkillCreateNestedOneWithoutSkill_listInput = {
    create?: XOR<AcrobaticsSkillCreateWithoutSkill_listInput, AcrobaticsSkillUncheckedCreateWithoutSkill_listInput>
    connectOrCreate?: AcrobaticsSkillCreateOrConnectWithoutSkill_listInput
    connect?: AcrobaticsSkillWhereUniqueInput
  }

  export type SleightOfHandSkillCreateNestedOneWithoutSkill_listInput = {
    create?: XOR<SleightOfHandSkillCreateWithoutSkill_listInput, SleightOfHandSkillUncheckedCreateWithoutSkill_listInput>
    connectOrCreate?: SleightOfHandSkillCreateOrConnectWithoutSkill_listInput
    connect?: SleightOfHandSkillWhereUniqueInput
  }

  export type StealthSkillCreateNestedOneWithoutSkill_listInput = {
    create?: XOR<StealthSkillCreateWithoutSkill_listInput, StealthSkillUncheckedCreateWithoutSkill_listInput>
    connectOrCreate?: StealthSkillCreateOrConnectWithoutSkill_listInput
    connect?: StealthSkillWhereUniqueInput
  }

  export type SkillsListCreateNestedOneWithoutDexterityInput = {
    create?: XOR<SkillsListCreateWithoutDexterityInput, SkillsListUncheckedCreateWithoutDexterityInput>
    connectOrCreate?: SkillsListCreateOrConnectWithoutDexterityInput
    connect?: SkillsListWhereUniqueInput
  }

  export type AcrobaticsSkillUncheckedCreateNestedOneWithoutSkill_listInput = {
    create?: XOR<AcrobaticsSkillCreateWithoutSkill_listInput, AcrobaticsSkillUncheckedCreateWithoutSkill_listInput>
    connectOrCreate?: AcrobaticsSkillCreateOrConnectWithoutSkill_listInput
    connect?: AcrobaticsSkillWhereUniqueInput
  }

  export type SleightOfHandSkillUncheckedCreateNestedOneWithoutSkill_listInput = {
    create?: XOR<SleightOfHandSkillCreateWithoutSkill_listInput, SleightOfHandSkillUncheckedCreateWithoutSkill_listInput>
    connectOrCreate?: SleightOfHandSkillCreateOrConnectWithoutSkill_listInput
    connect?: SleightOfHandSkillWhereUniqueInput
  }

  export type StealthSkillUncheckedCreateNestedOneWithoutSkill_listInput = {
    create?: XOR<StealthSkillCreateWithoutSkill_listInput, StealthSkillUncheckedCreateWithoutSkill_listInput>
    connectOrCreate?: StealthSkillCreateOrConnectWithoutSkill_listInput
    connect?: StealthSkillWhereUniqueInput
  }

  export type AcrobaticsSkillUpdateOneWithoutSkill_listNestedInput = {
    create?: XOR<AcrobaticsSkillCreateWithoutSkill_listInput, AcrobaticsSkillUncheckedCreateWithoutSkill_listInput>
    connectOrCreate?: AcrobaticsSkillCreateOrConnectWithoutSkill_listInput
    upsert?: AcrobaticsSkillUpsertWithoutSkill_listInput
    disconnect?: AcrobaticsSkillWhereInput | boolean
    delete?: AcrobaticsSkillWhereInput | boolean
    connect?: AcrobaticsSkillWhereUniqueInput
    update?: XOR<XOR<AcrobaticsSkillUpdateToOneWithWhereWithoutSkill_listInput, AcrobaticsSkillUpdateWithoutSkill_listInput>, AcrobaticsSkillUncheckedUpdateWithoutSkill_listInput>
  }

  export type SleightOfHandSkillUpdateOneWithoutSkill_listNestedInput = {
    create?: XOR<SleightOfHandSkillCreateWithoutSkill_listInput, SleightOfHandSkillUncheckedCreateWithoutSkill_listInput>
    connectOrCreate?: SleightOfHandSkillCreateOrConnectWithoutSkill_listInput
    upsert?: SleightOfHandSkillUpsertWithoutSkill_listInput
    disconnect?: SleightOfHandSkillWhereInput | boolean
    delete?: SleightOfHandSkillWhereInput | boolean
    connect?: SleightOfHandSkillWhereUniqueInput
    update?: XOR<XOR<SleightOfHandSkillUpdateToOneWithWhereWithoutSkill_listInput, SleightOfHandSkillUpdateWithoutSkill_listInput>, SleightOfHandSkillUncheckedUpdateWithoutSkill_listInput>
  }

  export type StealthSkillUpdateOneWithoutSkill_listNestedInput = {
    create?: XOR<StealthSkillCreateWithoutSkill_listInput, StealthSkillUncheckedCreateWithoutSkill_listInput>
    connectOrCreate?: StealthSkillCreateOrConnectWithoutSkill_listInput
    upsert?: StealthSkillUpsertWithoutSkill_listInput
    disconnect?: StealthSkillWhereInput | boolean
    delete?: StealthSkillWhereInput | boolean
    connect?: StealthSkillWhereUniqueInput
    update?: XOR<XOR<StealthSkillUpdateToOneWithWhereWithoutSkill_listInput, StealthSkillUpdateWithoutSkill_listInput>, StealthSkillUncheckedUpdateWithoutSkill_listInput>
  }

  export type SkillsListUpdateOneRequiredWithoutDexterityNestedInput = {
    create?: XOR<SkillsListCreateWithoutDexterityInput, SkillsListUncheckedCreateWithoutDexterityInput>
    connectOrCreate?: SkillsListCreateOrConnectWithoutDexterityInput
    upsert?: SkillsListUpsertWithoutDexterityInput
    connect?: SkillsListWhereUniqueInput
    update?: XOR<XOR<SkillsListUpdateToOneWithWhereWithoutDexterityInput, SkillsListUpdateWithoutDexterityInput>, SkillsListUncheckedUpdateWithoutDexterityInput>
  }

  export type AcrobaticsSkillUncheckedUpdateOneWithoutSkill_listNestedInput = {
    create?: XOR<AcrobaticsSkillCreateWithoutSkill_listInput, AcrobaticsSkillUncheckedCreateWithoutSkill_listInput>
    connectOrCreate?: AcrobaticsSkillCreateOrConnectWithoutSkill_listInput
    upsert?: AcrobaticsSkillUpsertWithoutSkill_listInput
    disconnect?: AcrobaticsSkillWhereInput | boolean
    delete?: AcrobaticsSkillWhereInput | boolean
    connect?: AcrobaticsSkillWhereUniqueInput
    update?: XOR<XOR<AcrobaticsSkillUpdateToOneWithWhereWithoutSkill_listInput, AcrobaticsSkillUpdateWithoutSkill_listInput>, AcrobaticsSkillUncheckedUpdateWithoutSkill_listInput>
  }

  export type SleightOfHandSkillUncheckedUpdateOneWithoutSkill_listNestedInput = {
    create?: XOR<SleightOfHandSkillCreateWithoutSkill_listInput, SleightOfHandSkillUncheckedCreateWithoutSkill_listInput>
    connectOrCreate?: SleightOfHandSkillCreateOrConnectWithoutSkill_listInput
    upsert?: SleightOfHandSkillUpsertWithoutSkill_listInput
    disconnect?: SleightOfHandSkillWhereInput | boolean
    delete?: SleightOfHandSkillWhereInput | boolean
    connect?: SleightOfHandSkillWhereUniqueInput
    update?: XOR<XOR<SleightOfHandSkillUpdateToOneWithWhereWithoutSkill_listInput, SleightOfHandSkillUpdateWithoutSkill_listInput>, SleightOfHandSkillUncheckedUpdateWithoutSkill_listInput>
  }

  export type StealthSkillUncheckedUpdateOneWithoutSkill_listNestedInput = {
    create?: XOR<StealthSkillCreateWithoutSkill_listInput, StealthSkillUncheckedCreateWithoutSkill_listInput>
    connectOrCreate?: StealthSkillCreateOrConnectWithoutSkill_listInput
    upsert?: StealthSkillUpsertWithoutSkill_listInput
    disconnect?: StealthSkillWhereInput | boolean
    delete?: StealthSkillWhereInput | boolean
    connect?: StealthSkillWhereUniqueInput
    update?: XOR<XOR<StealthSkillUpdateToOneWithWhereWithoutSkill_listInput, StealthSkillUpdateWithoutSkill_listInput>, StealthSkillUncheckedUpdateWithoutSkill_listInput>
  }

  export type ArcanaSkillCreateNestedOneWithoutSkill_listInput = {
    create?: XOR<ArcanaSkillCreateWithoutSkill_listInput, ArcanaSkillUncheckedCreateWithoutSkill_listInput>
    connectOrCreate?: ArcanaSkillCreateOrConnectWithoutSkill_listInput
    connect?: ArcanaSkillWhereUniqueInput
  }

  export type HistorySkillCreateNestedOneWithoutSkill_listInput = {
    create?: XOR<HistorySkillCreateWithoutSkill_listInput, HistorySkillUncheckedCreateWithoutSkill_listInput>
    connectOrCreate?: HistorySkillCreateOrConnectWithoutSkill_listInput
    connect?: HistorySkillWhereUniqueInput
  }

  export type InvestigationSkillCreateNestedOneWithoutSkill_listInput = {
    create?: XOR<InvestigationSkillCreateWithoutSkill_listInput, InvestigationSkillUncheckedCreateWithoutSkill_listInput>
    connectOrCreate?: InvestigationSkillCreateOrConnectWithoutSkill_listInput
    connect?: InvestigationSkillWhereUniqueInput
  }

  export type NatureSkillCreateNestedOneWithoutSkill_listInput = {
    create?: XOR<NatureSkillCreateWithoutSkill_listInput, NatureSkillUncheckedCreateWithoutSkill_listInput>
    connectOrCreate?: NatureSkillCreateOrConnectWithoutSkill_listInput
    connect?: NatureSkillWhereUniqueInput
  }

  export type ReligionSkillCreateNestedOneWithoutSkill_listInput = {
    create?: XOR<ReligionSkillCreateWithoutSkill_listInput, ReligionSkillUncheckedCreateWithoutSkill_listInput>
    connectOrCreate?: ReligionSkillCreateOrConnectWithoutSkill_listInput
    connect?: ReligionSkillWhereUniqueInput
  }

  export type SkillsListCreateNestedOneWithoutIntelligenceInput = {
    create?: XOR<SkillsListCreateWithoutIntelligenceInput, SkillsListUncheckedCreateWithoutIntelligenceInput>
    connectOrCreate?: SkillsListCreateOrConnectWithoutIntelligenceInput
    connect?: SkillsListWhereUniqueInput
  }

  export type ArcanaSkillUncheckedCreateNestedOneWithoutSkill_listInput = {
    create?: XOR<ArcanaSkillCreateWithoutSkill_listInput, ArcanaSkillUncheckedCreateWithoutSkill_listInput>
    connectOrCreate?: ArcanaSkillCreateOrConnectWithoutSkill_listInput
    connect?: ArcanaSkillWhereUniqueInput
  }

  export type HistorySkillUncheckedCreateNestedOneWithoutSkill_listInput = {
    create?: XOR<HistorySkillCreateWithoutSkill_listInput, HistorySkillUncheckedCreateWithoutSkill_listInput>
    connectOrCreate?: HistorySkillCreateOrConnectWithoutSkill_listInput
    connect?: HistorySkillWhereUniqueInput
  }

  export type InvestigationSkillUncheckedCreateNestedOneWithoutSkill_listInput = {
    create?: XOR<InvestigationSkillCreateWithoutSkill_listInput, InvestigationSkillUncheckedCreateWithoutSkill_listInput>
    connectOrCreate?: InvestigationSkillCreateOrConnectWithoutSkill_listInput
    connect?: InvestigationSkillWhereUniqueInput
  }

  export type NatureSkillUncheckedCreateNestedOneWithoutSkill_listInput = {
    create?: XOR<NatureSkillCreateWithoutSkill_listInput, NatureSkillUncheckedCreateWithoutSkill_listInput>
    connectOrCreate?: NatureSkillCreateOrConnectWithoutSkill_listInput
    connect?: NatureSkillWhereUniqueInput
  }

  export type ReligionSkillUncheckedCreateNestedOneWithoutSkill_listInput = {
    create?: XOR<ReligionSkillCreateWithoutSkill_listInput, ReligionSkillUncheckedCreateWithoutSkill_listInput>
    connectOrCreate?: ReligionSkillCreateOrConnectWithoutSkill_listInput
    connect?: ReligionSkillWhereUniqueInput
  }

  export type ArcanaSkillUpdateOneWithoutSkill_listNestedInput = {
    create?: XOR<ArcanaSkillCreateWithoutSkill_listInput, ArcanaSkillUncheckedCreateWithoutSkill_listInput>
    connectOrCreate?: ArcanaSkillCreateOrConnectWithoutSkill_listInput
    upsert?: ArcanaSkillUpsertWithoutSkill_listInput
    disconnect?: ArcanaSkillWhereInput | boolean
    delete?: ArcanaSkillWhereInput | boolean
    connect?: ArcanaSkillWhereUniqueInput
    update?: XOR<XOR<ArcanaSkillUpdateToOneWithWhereWithoutSkill_listInput, ArcanaSkillUpdateWithoutSkill_listInput>, ArcanaSkillUncheckedUpdateWithoutSkill_listInput>
  }

  export type HistorySkillUpdateOneWithoutSkill_listNestedInput = {
    create?: XOR<HistorySkillCreateWithoutSkill_listInput, HistorySkillUncheckedCreateWithoutSkill_listInput>
    connectOrCreate?: HistorySkillCreateOrConnectWithoutSkill_listInput
    upsert?: HistorySkillUpsertWithoutSkill_listInput
    disconnect?: HistorySkillWhereInput | boolean
    delete?: HistorySkillWhereInput | boolean
    connect?: HistorySkillWhereUniqueInput
    update?: XOR<XOR<HistorySkillUpdateToOneWithWhereWithoutSkill_listInput, HistorySkillUpdateWithoutSkill_listInput>, HistorySkillUncheckedUpdateWithoutSkill_listInput>
  }

  export type InvestigationSkillUpdateOneWithoutSkill_listNestedInput = {
    create?: XOR<InvestigationSkillCreateWithoutSkill_listInput, InvestigationSkillUncheckedCreateWithoutSkill_listInput>
    connectOrCreate?: InvestigationSkillCreateOrConnectWithoutSkill_listInput
    upsert?: InvestigationSkillUpsertWithoutSkill_listInput
    disconnect?: InvestigationSkillWhereInput | boolean
    delete?: InvestigationSkillWhereInput | boolean
    connect?: InvestigationSkillWhereUniqueInput
    update?: XOR<XOR<InvestigationSkillUpdateToOneWithWhereWithoutSkill_listInput, InvestigationSkillUpdateWithoutSkill_listInput>, InvestigationSkillUncheckedUpdateWithoutSkill_listInput>
  }

  export type NatureSkillUpdateOneWithoutSkill_listNestedInput = {
    create?: XOR<NatureSkillCreateWithoutSkill_listInput, NatureSkillUncheckedCreateWithoutSkill_listInput>
    connectOrCreate?: NatureSkillCreateOrConnectWithoutSkill_listInput
    upsert?: NatureSkillUpsertWithoutSkill_listInput
    disconnect?: NatureSkillWhereInput | boolean
    delete?: NatureSkillWhereInput | boolean
    connect?: NatureSkillWhereUniqueInput
    update?: XOR<XOR<NatureSkillUpdateToOneWithWhereWithoutSkill_listInput, NatureSkillUpdateWithoutSkill_listInput>, NatureSkillUncheckedUpdateWithoutSkill_listInput>
  }

  export type ReligionSkillUpdateOneWithoutSkill_listNestedInput = {
    create?: XOR<ReligionSkillCreateWithoutSkill_listInput, ReligionSkillUncheckedCreateWithoutSkill_listInput>
    connectOrCreate?: ReligionSkillCreateOrConnectWithoutSkill_listInput
    upsert?: ReligionSkillUpsertWithoutSkill_listInput
    disconnect?: ReligionSkillWhereInput | boolean
    delete?: ReligionSkillWhereInput | boolean
    connect?: ReligionSkillWhereUniqueInput
    update?: XOR<XOR<ReligionSkillUpdateToOneWithWhereWithoutSkill_listInput, ReligionSkillUpdateWithoutSkill_listInput>, ReligionSkillUncheckedUpdateWithoutSkill_listInput>
  }

  export type SkillsListUpdateOneRequiredWithoutIntelligenceNestedInput = {
    create?: XOR<SkillsListCreateWithoutIntelligenceInput, SkillsListUncheckedCreateWithoutIntelligenceInput>
    connectOrCreate?: SkillsListCreateOrConnectWithoutIntelligenceInput
    upsert?: SkillsListUpsertWithoutIntelligenceInput
    connect?: SkillsListWhereUniqueInput
    update?: XOR<XOR<SkillsListUpdateToOneWithWhereWithoutIntelligenceInput, SkillsListUpdateWithoutIntelligenceInput>, SkillsListUncheckedUpdateWithoutIntelligenceInput>
  }

  export type ArcanaSkillUncheckedUpdateOneWithoutSkill_listNestedInput = {
    create?: XOR<ArcanaSkillCreateWithoutSkill_listInput, ArcanaSkillUncheckedCreateWithoutSkill_listInput>
    connectOrCreate?: ArcanaSkillCreateOrConnectWithoutSkill_listInput
    upsert?: ArcanaSkillUpsertWithoutSkill_listInput
    disconnect?: ArcanaSkillWhereInput | boolean
    delete?: ArcanaSkillWhereInput | boolean
    connect?: ArcanaSkillWhereUniqueInput
    update?: XOR<XOR<ArcanaSkillUpdateToOneWithWhereWithoutSkill_listInput, ArcanaSkillUpdateWithoutSkill_listInput>, ArcanaSkillUncheckedUpdateWithoutSkill_listInput>
  }

  export type HistorySkillUncheckedUpdateOneWithoutSkill_listNestedInput = {
    create?: XOR<HistorySkillCreateWithoutSkill_listInput, HistorySkillUncheckedCreateWithoutSkill_listInput>
    connectOrCreate?: HistorySkillCreateOrConnectWithoutSkill_listInput
    upsert?: HistorySkillUpsertWithoutSkill_listInput
    disconnect?: HistorySkillWhereInput | boolean
    delete?: HistorySkillWhereInput | boolean
    connect?: HistorySkillWhereUniqueInput
    update?: XOR<XOR<HistorySkillUpdateToOneWithWhereWithoutSkill_listInput, HistorySkillUpdateWithoutSkill_listInput>, HistorySkillUncheckedUpdateWithoutSkill_listInput>
  }

  export type InvestigationSkillUncheckedUpdateOneWithoutSkill_listNestedInput = {
    create?: XOR<InvestigationSkillCreateWithoutSkill_listInput, InvestigationSkillUncheckedCreateWithoutSkill_listInput>
    connectOrCreate?: InvestigationSkillCreateOrConnectWithoutSkill_listInput
    upsert?: InvestigationSkillUpsertWithoutSkill_listInput
    disconnect?: InvestigationSkillWhereInput | boolean
    delete?: InvestigationSkillWhereInput | boolean
    connect?: InvestigationSkillWhereUniqueInput
    update?: XOR<XOR<InvestigationSkillUpdateToOneWithWhereWithoutSkill_listInput, InvestigationSkillUpdateWithoutSkill_listInput>, InvestigationSkillUncheckedUpdateWithoutSkill_listInput>
  }

  export type NatureSkillUncheckedUpdateOneWithoutSkill_listNestedInput = {
    create?: XOR<NatureSkillCreateWithoutSkill_listInput, NatureSkillUncheckedCreateWithoutSkill_listInput>
    connectOrCreate?: NatureSkillCreateOrConnectWithoutSkill_listInput
    upsert?: NatureSkillUpsertWithoutSkill_listInput
    disconnect?: NatureSkillWhereInput | boolean
    delete?: NatureSkillWhereInput | boolean
    connect?: NatureSkillWhereUniqueInput
    update?: XOR<XOR<NatureSkillUpdateToOneWithWhereWithoutSkill_listInput, NatureSkillUpdateWithoutSkill_listInput>, NatureSkillUncheckedUpdateWithoutSkill_listInput>
  }

  export type ReligionSkillUncheckedUpdateOneWithoutSkill_listNestedInput = {
    create?: XOR<ReligionSkillCreateWithoutSkill_listInput, ReligionSkillUncheckedCreateWithoutSkill_listInput>
    connectOrCreate?: ReligionSkillCreateOrConnectWithoutSkill_listInput
    upsert?: ReligionSkillUpsertWithoutSkill_listInput
    disconnect?: ReligionSkillWhereInput | boolean
    delete?: ReligionSkillWhereInput | boolean
    connect?: ReligionSkillWhereUniqueInput
    update?: XOR<XOR<ReligionSkillUpdateToOneWithWhereWithoutSkill_listInput, ReligionSkillUpdateWithoutSkill_listInput>, ReligionSkillUncheckedUpdateWithoutSkill_listInput>
  }

  export type AnimalHandlingSkillCreateNestedOneWithoutSkill_listInput = {
    create?: XOR<AnimalHandlingSkillCreateWithoutSkill_listInput, AnimalHandlingSkillUncheckedCreateWithoutSkill_listInput>
    connectOrCreate?: AnimalHandlingSkillCreateOrConnectWithoutSkill_listInput
    connect?: AnimalHandlingSkillWhereUniqueInput
  }

  export type InsightSkillCreateNestedOneWithoutSkill_listInput = {
    create?: XOR<InsightSkillCreateWithoutSkill_listInput, InsightSkillUncheckedCreateWithoutSkill_listInput>
    connectOrCreate?: InsightSkillCreateOrConnectWithoutSkill_listInput
    connect?: InsightSkillWhereUniqueInput
  }

  export type MedicineSkillCreateNestedOneWithoutSkill_listInput = {
    create?: XOR<MedicineSkillCreateWithoutSkill_listInput, MedicineSkillUncheckedCreateWithoutSkill_listInput>
    connectOrCreate?: MedicineSkillCreateOrConnectWithoutSkill_listInput
    connect?: MedicineSkillWhereUniqueInput
  }

  export type PerceptionSkillCreateNestedOneWithoutSkill_listInput = {
    create?: XOR<PerceptionSkillCreateWithoutSkill_listInput, PerceptionSkillUncheckedCreateWithoutSkill_listInput>
    connectOrCreate?: PerceptionSkillCreateOrConnectWithoutSkill_listInput
    connect?: PerceptionSkillWhereUniqueInput
  }

  export type SurvivalSkillCreateNestedOneWithoutSkill_listInput = {
    create?: XOR<SurvivalSkillCreateWithoutSkill_listInput, SurvivalSkillUncheckedCreateWithoutSkill_listInput>
    connectOrCreate?: SurvivalSkillCreateOrConnectWithoutSkill_listInput
    connect?: SurvivalSkillWhereUniqueInput
  }

  export type SkillsListCreateNestedOneWithoutWisdomInput = {
    create?: XOR<SkillsListCreateWithoutWisdomInput, SkillsListUncheckedCreateWithoutWisdomInput>
    connectOrCreate?: SkillsListCreateOrConnectWithoutWisdomInput
    connect?: SkillsListWhereUniqueInput
  }

  export type AnimalHandlingSkillUncheckedCreateNestedOneWithoutSkill_listInput = {
    create?: XOR<AnimalHandlingSkillCreateWithoutSkill_listInput, AnimalHandlingSkillUncheckedCreateWithoutSkill_listInput>
    connectOrCreate?: AnimalHandlingSkillCreateOrConnectWithoutSkill_listInput
    connect?: AnimalHandlingSkillWhereUniqueInput
  }

  export type InsightSkillUncheckedCreateNestedOneWithoutSkill_listInput = {
    create?: XOR<InsightSkillCreateWithoutSkill_listInput, InsightSkillUncheckedCreateWithoutSkill_listInput>
    connectOrCreate?: InsightSkillCreateOrConnectWithoutSkill_listInput
    connect?: InsightSkillWhereUniqueInput
  }

  export type MedicineSkillUncheckedCreateNestedOneWithoutSkill_listInput = {
    create?: XOR<MedicineSkillCreateWithoutSkill_listInput, MedicineSkillUncheckedCreateWithoutSkill_listInput>
    connectOrCreate?: MedicineSkillCreateOrConnectWithoutSkill_listInput
    connect?: MedicineSkillWhereUniqueInput
  }

  export type PerceptionSkillUncheckedCreateNestedOneWithoutSkill_listInput = {
    create?: XOR<PerceptionSkillCreateWithoutSkill_listInput, PerceptionSkillUncheckedCreateWithoutSkill_listInput>
    connectOrCreate?: PerceptionSkillCreateOrConnectWithoutSkill_listInput
    connect?: PerceptionSkillWhereUniqueInput
  }

  export type SurvivalSkillUncheckedCreateNestedOneWithoutSkill_listInput = {
    create?: XOR<SurvivalSkillCreateWithoutSkill_listInput, SurvivalSkillUncheckedCreateWithoutSkill_listInput>
    connectOrCreate?: SurvivalSkillCreateOrConnectWithoutSkill_listInput
    connect?: SurvivalSkillWhereUniqueInput
  }

  export type AnimalHandlingSkillUpdateOneWithoutSkill_listNestedInput = {
    create?: XOR<AnimalHandlingSkillCreateWithoutSkill_listInput, AnimalHandlingSkillUncheckedCreateWithoutSkill_listInput>
    connectOrCreate?: AnimalHandlingSkillCreateOrConnectWithoutSkill_listInput
    upsert?: AnimalHandlingSkillUpsertWithoutSkill_listInput
    disconnect?: AnimalHandlingSkillWhereInput | boolean
    delete?: AnimalHandlingSkillWhereInput | boolean
    connect?: AnimalHandlingSkillWhereUniqueInput
    update?: XOR<XOR<AnimalHandlingSkillUpdateToOneWithWhereWithoutSkill_listInput, AnimalHandlingSkillUpdateWithoutSkill_listInput>, AnimalHandlingSkillUncheckedUpdateWithoutSkill_listInput>
  }

  export type InsightSkillUpdateOneWithoutSkill_listNestedInput = {
    create?: XOR<InsightSkillCreateWithoutSkill_listInput, InsightSkillUncheckedCreateWithoutSkill_listInput>
    connectOrCreate?: InsightSkillCreateOrConnectWithoutSkill_listInput
    upsert?: InsightSkillUpsertWithoutSkill_listInput
    disconnect?: InsightSkillWhereInput | boolean
    delete?: InsightSkillWhereInput | boolean
    connect?: InsightSkillWhereUniqueInput
    update?: XOR<XOR<InsightSkillUpdateToOneWithWhereWithoutSkill_listInput, InsightSkillUpdateWithoutSkill_listInput>, InsightSkillUncheckedUpdateWithoutSkill_listInput>
  }

  export type MedicineSkillUpdateOneWithoutSkill_listNestedInput = {
    create?: XOR<MedicineSkillCreateWithoutSkill_listInput, MedicineSkillUncheckedCreateWithoutSkill_listInput>
    connectOrCreate?: MedicineSkillCreateOrConnectWithoutSkill_listInput
    upsert?: MedicineSkillUpsertWithoutSkill_listInput
    disconnect?: MedicineSkillWhereInput | boolean
    delete?: MedicineSkillWhereInput | boolean
    connect?: MedicineSkillWhereUniqueInput
    update?: XOR<XOR<MedicineSkillUpdateToOneWithWhereWithoutSkill_listInput, MedicineSkillUpdateWithoutSkill_listInput>, MedicineSkillUncheckedUpdateWithoutSkill_listInput>
  }

  export type PerceptionSkillUpdateOneWithoutSkill_listNestedInput = {
    create?: XOR<PerceptionSkillCreateWithoutSkill_listInput, PerceptionSkillUncheckedCreateWithoutSkill_listInput>
    connectOrCreate?: PerceptionSkillCreateOrConnectWithoutSkill_listInput
    upsert?: PerceptionSkillUpsertWithoutSkill_listInput
    disconnect?: PerceptionSkillWhereInput | boolean
    delete?: PerceptionSkillWhereInput | boolean
    connect?: PerceptionSkillWhereUniqueInput
    update?: XOR<XOR<PerceptionSkillUpdateToOneWithWhereWithoutSkill_listInput, PerceptionSkillUpdateWithoutSkill_listInput>, PerceptionSkillUncheckedUpdateWithoutSkill_listInput>
  }

  export type SurvivalSkillUpdateOneWithoutSkill_listNestedInput = {
    create?: XOR<SurvivalSkillCreateWithoutSkill_listInput, SurvivalSkillUncheckedCreateWithoutSkill_listInput>
    connectOrCreate?: SurvivalSkillCreateOrConnectWithoutSkill_listInput
    upsert?: SurvivalSkillUpsertWithoutSkill_listInput
    disconnect?: SurvivalSkillWhereInput | boolean
    delete?: SurvivalSkillWhereInput | boolean
    connect?: SurvivalSkillWhereUniqueInput
    update?: XOR<XOR<SurvivalSkillUpdateToOneWithWhereWithoutSkill_listInput, SurvivalSkillUpdateWithoutSkill_listInput>, SurvivalSkillUncheckedUpdateWithoutSkill_listInput>
  }

  export type SkillsListUpdateOneRequiredWithoutWisdomNestedInput = {
    create?: XOR<SkillsListCreateWithoutWisdomInput, SkillsListUncheckedCreateWithoutWisdomInput>
    connectOrCreate?: SkillsListCreateOrConnectWithoutWisdomInput
    upsert?: SkillsListUpsertWithoutWisdomInput
    connect?: SkillsListWhereUniqueInput
    update?: XOR<XOR<SkillsListUpdateToOneWithWhereWithoutWisdomInput, SkillsListUpdateWithoutWisdomInput>, SkillsListUncheckedUpdateWithoutWisdomInput>
  }

  export type AnimalHandlingSkillUncheckedUpdateOneWithoutSkill_listNestedInput = {
    create?: XOR<AnimalHandlingSkillCreateWithoutSkill_listInput, AnimalHandlingSkillUncheckedCreateWithoutSkill_listInput>
    connectOrCreate?: AnimalHandlingSkillCreateOrConnectWithoutSkill_listInput
    upsert?: AnimalHandlingSkillUpsertWithoutSkill_listInput
    disconnect?: AnimalHandlingSkillWhereInput | boolean
    delete?: AnimalHandlingSkillWhereInput | boolean
    connect?: AnimalHandlingSkillWhereUniqueInput
    update?: XOR<XOR<AnimalHandlingSkillUpdateToOneWithWhereWithoutSkill_listInput, AnimalHandlingSkillUpdateWithoutSkill_listInput>, AnimalHandlingSkillUncheckedUpdateWithoutSkill_listInput>
  }

  export type InsightSkillUncheckedUpdateOneWithoutSkill_listNestedInput = {
    create?: XOR<InsightSkillCreateWithoutSkill_listInput, InsightSkillUncheckedCreateWithoutSkill_listInput>
    connectOrCreate?: InsightSkillCreateOrConnectWithoutSkill_listInput
    upsert?: InsightSkillUpsertWithoutSkill_listInput
    disconnect?: InsightSkillWhereInput | boolean
    delete?: InsightSkillWhereInput | boolean
    connect?: InsightSkillWhereUniqueInput
    update?: XOR<XOR<InsightSkillUpdateToOneWithWhereWithoutSkill_listInput, InsightSkillUpdateWithoutSkill_listInput>, InsightSkillUncheckedUpdateWithoutSkill_listInput>
  }

  export type MedicineSkillUncheckedUpdateOneWithoutSkill_listNestedInput = {
    create?: XOR<MedicineSkillCreateWithoutSkill_listInput, MedicineSkillUncheckedCreateWithoutSkill_listInput>
    connectOrCreate?: MedicineSkillCreateOrConnectWithoutSkill_listInput
    upsert?: MedicineSkillUpsertWithoutSkill_listInput
    disconnect?: MedicineSkillWhereInput | boolean
    delete?: MedicineSkillWhereInput | boolean
    connect?: MedicineSkillWhereUniqueInput
    update?: XOR<XOR<MedicineSkillUpdateToOneWithWhereWithoutSkill_listInput, MedicineSkillUpdateWithoutSkill_listInput>, MedicineSkillUncheckedUpdateWithoutSkill_listInput>
  }

  export type PerceptionSkillUncheckedUpdateOneWithoutSkill_listNestedInput = {
    create?: XOR<PerceptionSkillCreateWithoutSkill_listInput, PerceptionSkillUncheckedCreateWithoutSkill_listInput>
    connectOrCreate?: PerceptionSkillCreateOrConnectWithoutSkill_listInput
    upsert?: PerceptionSkillUpsertWithoutSkill_listInput
    disconnect?: PerceptionSkillWhereInput | boolean
    delete?: PerceptionSkillWhereInput | boolean
    connect?: PerceptionSkillWhereUniqueInput
    update?: XOR<XOR<PerceptionSkillUpdateToOneWithWhereWithoutSkill_listInput, PerceptionSkillUpdateWithoutSkill_listInput>, PerceptionSkillUncheckedUpdateWithoutSkill_listInput>
  }

  export type SurvivalSkillUncheckedUpdateOneWithoutSkill_listNestedInput = {
    create?: XOR<SurvivalSkillCreateWithoutSkill_listInput, SurvivalSkillUncheckedCreateWithoutSkill_listInput>
    connectOrCreate?: SurvivalSkillCreateOrConnectWithoutSkill_listInput
    upsert?: SurvivalSkillUpsertWithoutSkill_listInput
    disconnect?: SurvivalSkillWhereInput | boolean
    delete?: SurvivalSkillWhereInput | boolean
    connect?: SurvivalSkillWhereUniqueInput
    update?: XOR<XOR<SurvivalSkillUpdateToOneWithWhereWithoutSkill_listInput, SurvivalSkillUpdateWithoutSkill_listInput>, SurvivalSkillUncheckedUpdateWithoutSkill_listInput>
  }

  export type DeceptionSkillCreateNestedOneWithoutSkill_listInput = {
    create?: XOR<DeceptionSkillCreateWithoutSkill_listInput, DeceptionSkillUncheckedCreateWithoutSkill_listInput>
    connectOrCreate?: DeceptionSkillCreateOrConnectWithoutSkill_listInput
    connect?: DeceptionSkillWhereUniqueInput
  }

  export type IntimidationSkillCreateNestedOneWithoutSkill_listInput = {
    create?: XOR<IntimidationSkillCreateWithoutSkill_listInput, IntimidationSkillUncheckedCreateWithoutSkill_listInput>
    connectOrCreate?: IntimidationSkillCreateOrConnectWithoutSkill_listInput
    connect?: IntimidationSkillWhereUniqueInput
  }

  export type PerformanceSkillCreateNestedOneWithoutSkill_listInput = {
    create?: XOR<PerformanceSkillCreateWithoutSkill_listInput, PerformanceSkillUncheckedCreateWithoutSkill_listInput>
    connectOrCreate?: PerformanceSkillCreateOrConnectWithoutSkill_listInput
    connect?: PerformanceSkillWhereUniqueInput
  }

  export type PersuasionSkillCreateNestedOneWithoutSkill_listInput = {
    create?: XOR<PersuasionSkillCreateWithoutSkill_listInput, PersuasionSkillUncheckedCreateWithoutSkill_listInput>
    connectOrCreate?: PersuasionSkillCreateOrConnectWithoutSkill_listInput
    connect?: PersuasionSkillWhereUniqueInput
  }

  export type SkillsListCreateNestedOneWithoutCharismaInput = {
    create?: XOR<SkillsListCreateWithoutCharismaInput, SkillsListUncheckedCreateWithoutCharismaInput>
    connectOrCreate?: SkillsListCreateOrConnectWithoutCharismaInput
    connect?: SkillsListWhereUniqueInput
  }

  export type DeceptionSkillUncheckedCreateNestedOneWithoutSkill_listInput = {
    create?: XOR<DeceptionSkillCreateWithoutSkill_listInput, DeceptionSkillUncheckedCreateWithoutSkill_listInput>
    connectOrCreate?: DeceptionSkillCreateOrConnectWithoutSkill_listInput
    connect?: DeceptionSkillWhereUniqueInput
  }

  export type IntimidationSkillUncheckedCreateNestedOneWithoutSkill_listInput = {
    create?: XOR<IntimidationSkillCreateWithoutSkill_listInput, IntimidationSkillUncheckedCreateWithoutSkill_listInput>
    connectOrCreate?: IntimidationSkillCreateOrConnectWithoutSkill_listInput
    connect?: IntimidationSkillWhereUniqueInput
  }

  export type PerformanceSkillUncheckedCreateNestedOneWithoutSkill_listInput = {
    create?: XOR<PerformanceSkillCreateWithoutSkill_listInput, PerformanceSkillUncheckedCreateWithoutSkill_listInput>
    connectOrCreate?: PerformanceSkillCreateOrConnectWithoutSkill_listInput
    connect?: PerformanceSkillWhereUniqueInput
  }

  export type PersuasionSkillUncheckedCreateNestedOneWithoutSkill_listInput = {
    create?: XOR<PersuasionSkillCreateWithoutSkill_listInput, PersuasionSkillUncheckedCreateWithoutSkill_listInput>
    connectOrCreate?: PersuasionSkillCreateOrConnectWithoutSkill_listInput
    connect?: PersuasionSkillWhereUniqueInput
  }

  export type DeceptionSkillUpdateOneWithoutSkill_listNestedInput = {
    create?: XOR<DeceptionSkillCreateWithoutSkill_listInput, DeceptionSkillUncheckedCreateWithoutSkill_listInput>
    connectOrCreate?: DeceptionSkillCreateOrConnectWithoutSkill_listInput
    upsert?: DeceptionSkillUpsertWithoutSkill_listInput
    disconnect?: DeceptionSkillWhereInput | boolean
    delete?: DeceptionSkillWhereInput | boolean
    connect?: DeceptionSkillWhereUniqueInput
    update?: XOR<XOR<DeceptionSkillUpdateToOneWithWhereWithoutSkill_listInput, DeceptionSkillUpdateWithoutSkill_listInput>, DeceptionSkillUncheckedUpdateWithoutSkill_listInput>
  }

  export type IntimidationSkillUpdateOneWithoutSkill_listNestedInput = {
    create?: XOR<IntimidationSkillCreateWithoutSkill_listInput, IntimidationSkillUncheckedCreateWithoutSkill_listInput>
    connectOrCreate?: IntimidationSkillCreateOrConnectWithoutSkill_listInput
    upsert?: IntimidationSkillUpsertWithoutSkill_listInput
    disconnect?: IntimidationSkillWhereInput | boolean
    delete?: IntimidationSkillWhereInput | boolean
    connect?: IntimidationSkillWhereUniqueInput
    update?: XOR<XOR<IntimidationSkillUpdateToOneWithWhereWithoutSkill_listInput, IntimidationSkillUpdateWithoutSkill_listInput>, IntimidationSkillUncheckedUpdateWithoutSkill_listInput>
  }

  export type PerformanceSkillUpdateOneWithoutSkill_listNestedInput = {
    create?: XOR<PerformanceSkillCreateWithoutSkill_listInput, PerformanceSkillUncheckedCreateWithoutSkill_listInput>
    connectOrCreate?: PerformanceSkillCreateOrConnectWithoutSkill_listInput
    upsert?: PerformanceSkillUpsertWithoutSkill_listInput
    disconnect?: PerformanceSkillWhereInput | boolean
    delete?: PerformanceSkillWhereInput | boolean
    connect?: PerformanceSkillWhereUniqueInput
    update?: XOR<XOR<PerformanceSkillUpdateToOneWithWhereWithoutSkill_listInput, PerformanceSkillUpdateWithoutSkill_listInput>, PerformanceSkillUncheckedUpdateWithoutSkill_listInput>
  }

  export type PersuasionSkillUpdateOneWithoutSkill_listNestedInput = {
    create?: XOR<PersuasionSkillCreateWithoutSkill_listInput, PersuasionSkillUncheckedCreateWithoutSkill_listInput>
    connectOrCreate?: PersuasionSkillCreateOrConnectWithoutSkill_listInput
    upsert?: PersuasionSkillUpsertWithoutSkill_listInput
    disconnect?: PersuasionSkillWhereInput | boolean
    delete?: PersuasionSkillWhereInput | boolean
    connect?: PersuasionSkillWhereUniqueInput
    update?: XOR<XOR<PersuasionSkillUpdateToOneWithWhereWithoutSkill_listInput, PersuasionSkillUpdateWithoutSkill_listInput>, PersuasionSkillUncheckedUpdateWithoutSkill_listInput>
  }

  export type SkillsListUpdateOneRequiredWithoutCharismaNestedInput = {
    create?: XOR<SkillsListCreateWithoutCharismaInput, SkillsListUncheckedCreateWithoutCharismaInput>
    connectOrCreate?: SkillsListCreateOrConnectWithoutCharismaInput
    upsert?: SkillsListUpsertWithoutCharismaInput
    connect?: SkillsListWhereUniqueInput
    update?: XOR<XOR<SkillsListUpdateToOneWithWhereWithoutCharismaInput, SkillsListUpdateWithoutCharismaInput>, SkillsListUncheckedUpdateWithoutCharismaInput>
  }

  export type DeceptionSkillUncheckedUpdateOneWithoutSkill_listNestedInput = {
    create?: XOR<DeceptionSkillCreateWithoutSkill_listInput, DeceptionSkillUncheckedCreateWithoutSkill_listInput>
    connectOrCreate?: DeceptionSkillCreateOrConnectWithoutSkill_listInput
    upsert?: DeceptionSkillUpsertWithoutSkill_listInput
    disconnect?: DeceptionSkillWhereInput | boolean
    delete?: DeceptionSkillWhereInput | boolean
    connect?: DeceptionSkillWhereUniqueInput
    update?: XOR<XOR<DeceptionSkillUpdateToOneWithWhereWithoutSkill_listInput, DeceptionSkillUpdateWithoutSkill_listInput>, DeceptionSkillUncheckedUpdateWithoutSkill_listInput>
  }

  export type IntimidationSkillUncheckedUpdateOneWithoutSkill_listNestedInput = {
    create?: XOR<IntimidationSkillCreateWithoutSkill_listInput, IntimidationSkillUncheckedCreateWithoutSkill_listInput>
    connectOrCreate?: IntimidationSkillCreateOrConnectWithoutSkill_listInput
    upsert?: IntimidationSkillUpsertWithoutSkill_listInput
    disconnect?: IntimidationSkillWhereInput | boolean
    delete?: IntimidationSkillWhereInput | boolean
    connect?: IntimidationSkillWhereUniqueInput
    update?: XOR<XOR<IntimidationSkillUpdateToOneWithWhereWithoutSkill_listInput, IntimidationSkillUpdateWithoutSkill_listInput>, IntimidationSkillUncheckedUpdateWithoutSkill_listInput>
  }

  export type PerformanceSkillUncheckedUpdateOneWithoutSkill_listNestedInput = {
    create?: XOR<PerformanceSkillCreateWithoutSkill_listInput, PerformanceSkillUncheckedCreateWithoutSkill_listInput>
    connectOrCreate?: PerformanceSkillCreateOrConnectWithoutSkill_listInput
    upsert?: PerformanceSkillUpsertWithoutSkill_listInput
    disconnect?: PerformanceSkillWhereInput | boolean
    delete?: PerformanceSkillWhereInput | boolean
    connect?: PerformanceSkillWhereUniqueInput
    update?: XOR<XOR<PerformanceSkillUpdateToOneWithWhereWithoutSkill_listInput, PerformanceSkillUpdateWithoutSkill_listInput>, PerformanceSkillUncheckedUpdateWithoutSkill_listInput>
  }

  export type PersuasionSkillUncheckedUpdateOneWithoutSkill_listNestedInput = {
    create?: XOR<PersuasionSkillCreateWithoutSkill_listInput, PersuasionSkillUncheckedCreateWithoutSkill_listInput>
    connectOrCreate?: PersuasionSkillCreateOrConnectWithoutSkill_listInput
    upsert?: PersuasionSkillUpsertWithoutSkill_listInput
    disconnect?: PersuasionSkillWhereInput | boolean
    delete?: PersuasionSkillWhereInput | boolean
    connect?: PersuasionSkillWhereUniqueInput
    update?: XOR<XOR<PersuasionSkillUpdateToOneWithWhereWithoutSkill_listInput, PersuasionSkillUpdateWithoutSkill_listInput>, PersuasionSkillUncheckedUpdateWithoutSkill_listInput>
  }

  export type StrengthBasedSkillsCreateNestedOneWithoutAthleticsInput = {
    create?: XOR<StrengthBasedSkillsCreateWithoutAthleticsInput, StrengthBasedSkillsUncheckedCreateWithoutAthleticsInput>
    connectOrCreate?: StrengthBasedSkillsCreateOrConnectWithoutAthleticsInput
    connect?: StrengthBasedSkillsWhereUniqueInput
  }

  export type StrengthBasedSkillsUpdateOneRequiredWithoutAthleticsNestedInput = {
    create?: XOR<StrengthBasedSkillsCreateWithoutAthleticsInput, StrengthBasedSkillsUncheckedCreateWithoutAthleticsInput>
    connectOrCreate?: StrengthBasedSkillsCreateOrConnectWithoutAthleticsInput
    upsert?: StrengthBasedSkillsUpsertWithoutAthleticsInput
    connect?: StrengthBasedSkillsWhereUniqueInput
    update?: XOR<XOR<StrengthBasedSkillsUpdateToOneWithWhereWithoutAthleticsInput, StrengthBasedSkillsUpdateWithoutAthleticsInput>, StrengthBasedSkillsUncheckedUpdateWithoutAthleticsInput>
  }

  export type DexterityBasedSkillsCreateNestedOneWithoutAcrobaticsInput = {
    create?: XOR<DexterityBasedSkillsCreateWithoutAcrobaticsInput, DexterityBasedSkillsUncheckedCreateWithoutAcrobaticsInput>
    connectOrCreate?: DexterityBasedSkillsCreateOrConnectWithoutAcrobaticsInput
    connect?: DexterityBasedSkillsWhereUniqueInput
  }

  export type DexterityBasedSkillsUpdateOneRequiredWithoutAcrobaticsNestedInput = {
    create?: XOR<DexterityBasedSkillsCreateWithoutAcrobaticsInput, DexterityBasedSkillsUncheckedCreateWithoutAcrobaticsInput>
    connectOrCreate?: DexterityBasedSkillsCreateOrConnectWithoutAcrobaticsInput
    upsert?: DexterityBasedSkillsUpsertWithoutAcrobaticsInput
    connect?: DexterityBasedSkillsWhereUniqueInput
    update?: XOR<XOR<DexterityBasedSkillsUpdateToOneWithWhereWithoutAcrobaticsInput, DexterityBasedSkillsUpdateWithoutAcrobaticsInput>, DexterityBasedSkillsUncheckedUpdateWithoutAcrobaticsInput>
  }

  export type DexterityBasedSkillsCreateNestedOneWithoutSleight_of_handInput = {
    create?: XOR<DexterityBasedSkillsCreateWithoutSleight_of_handInput, DexterityBasedSkillsUncheckedCreateWithoutSleight_of_handInput>
    connectOrCreate?: DexterityBasedSkillsCreateOrConnectWithoutSleight_of_handInput
    connect?: DexterityBasedSkillsWhereUniqueInput
  }

  export type DexterityBasedSkillsUpdateOneRequiredWithoutSleight_of_handNestedInput = {
    create?: XOR<DexterityBasedSkillsCreateWithoutSleight_of_handInput, DexterityBasedSkillsUncheckedCreateWithoutSleight_of_handInput>
    connectOrCreate?: DexterityBasedSkillsCreateOrConnectWithoutSleight_of_handInput
    upsert?: DexterityBasedSkillsUpsertWithoutSleight_of_handInput
    connect?: DexterityBasedSkillsWhereUniqueInput
    update?: XOR<XOR<DexterityBasedSkillsUpdateToOneWithWhereWithoutSleight_of_handInput, DexterityBasedSkillsUpdateWithoutSleight_of_handInput>, DexterityBasedSkillsUncheckedUpdateWithoutSleight_of_handInput>
  }

  export type DexterityBasedSkillsCreateNestedOneWithoutStealthInput = {
    create?: XOR<DexterityBasedSkillsCreateWithoutStealthInput, DexterityBasedSkillsUncheckedCreateWithoutStealthInput>
    connectOrCreate?: DexterityBasedSkillsCreateOrConnectWithoutStealthInput
    connect?: DexterityBasedSkillsWhereUniqueInput
  }

  export type DexterityBasedSkillsUpdateOneRequiredWithoutStealthNestedInput = {
    create?: XOR<DexterityBasedSkillsCreateWithoutStealthInput, DexterityBasedSkillsUncheckedCreateWithoutStealthInput>
    connectOrCreate?: DexterityBasedSkillsCreateOrConnectWithoutStealthInput
    upsert?: DexterityBasedSkillsUpsertWithoutStealthInput
    connect?: DexterityBasedSkillsWhereUniqueInput
    update?: XOR<XOR<DexterityBasedSkillsUpdateToOneWithWhereWithoutStealthInput, DexterityBasedSkillsUpdateWithoutStealthInput>, DexterityBasedSkillsUncheckedUpdateWithoutStealthInput>
  }

  export type IntellengenceBasedSkillsCreateNestedOneWithoutArcanaInput = {
    create?: XOR<IntellengenceBasedSkillsCreateWithoutArcanaInput, IntellengenceBasedSkillsUncheckedCreateWithoutArcanaInput>
    connectOrCreate?: IntellengenceBasedSkillsCreateOrConnectWithoutArcanaInput
    connect?: IntellengenceBasedSkillsWhereUniqueInput
  }

  export type IntellengenceBasedSkillsUpdateOneRequiredWithoutArcanaNestedInput = {
    create?: XOR<IntellengenceBasedSkillsCreateWithoutArcanaInput, IntellengenceBasedSkillsUncheckedCreateWithoutArcanaInput>
    connectOrCreate?: IntellengenceBasedSkillsCreateOrConnectWithoutArcanaInput
    upsert?: IntellengenceBasedSkillsUpsertWithoutArcanaInput
    connect?: IntellengenceBasedSkillsWhereUniqueInput
    update?: XOR<XOR<IntellengenceBasedSkillsUpdateToOneWithWhereWithoutArcanaInput, IntellengenceBasedSkillsUpdateWithoutArcanaInput>, IntellengenceBasedSkillsUncheckedUpdateWithoutArcanaInput>
  }

  export type IntellengenceBasedSkillsCreateNestedOneWithoutHistoryInput = {
    create?: XOR<IntellengenceBasedSkillsCreateWithoutHistoryInput, IntellengenceBasedSkillsUncheckedCreateWithoutHistoryInput>
    connectOrCreate?: IntellengenceBasedSkillsCreateOrConnectWithoutHistoryInput
    connect?: IntellengenceBasedSkillsWhereUniqueInput
  }

  export type IntellengenceBasedSkillsUpdateOneRequiredWithoutHistoryNestedInput = {
    create?: XOR<IntellengenceBasedSkillsCreateWithoutHistoryInput, IntellengenceBasedSkillsUncheckedCreateWithoutHistoryInput>
    connectOrCreate?: IntellengenceBasedSkillsCreateOrConnectWithoutHistoryInput
    upsert?: IntellengenceBasedSkillsUpsertWithoutHistoryInput
    connect?: IntellengenceBasedSkillsWhereUniqueInput
    update?: XOR<XOR<IntellengenceBasedSkillsUpdateToOneWithWhereWithoutHistoryInput, IntellengenceBasedSkillsUpdateWithoutHistoryInput>, IntellengenceBasedSkillsUncheckedUpdateWithoutHistoryInput>
  }

  export type IntellengenceBasedSkillsCreateNestedOneWithoutInvestigationInput = {
    create?: XOR<IntellengenceBasedSkillsCreateWithoutInvestigationInput, IntellengenceBasedSkillsUncheckedCreateWithoutInvestigationInput>
    connectOrCreate?: IntellengenceBasedSkillsCreateOrConnectWithoutInvestigationInput
    connect?: IntellengenceBasedSkillsWhereUniqueInput
  }

  export type IntellengenceBasedSkillsUpdateOneRequiredWithoutInvestigationNestedInput = {
    create?: XOR<IntellengenceBasedSkillsCreateWithoutInvestigationInput, IntellengenceBasedSkillsUncheckedCreateWithoutInvestigationInput>
    connectOrCreate?: IntellengenceBasedSkillsCreateOrConnectWithoutInvestigationInput
    upsert?: IntellengenceBasedSkillsUpsertWithoutInvestigationInput
    connect?: IntellengenceBasedSkillsWhereUniqueInput
    update?: XOR<XOR<IntellengenceBasedSkillsUpdateToOneWithWhereWithoutInvestigationInput, IntellengenceBasedSkillsUpdateWithoutInvestigationInput>, IntellengenceBasedSkillsUncheckedUpdateWithoutInvestigationInput>
  }

  export type IntellengenceBasedSkillsCreateNestedOneWithoutNatureInput = {
    create?: XOR<IntellengenceBasedSkillsCreateWithoutNatureInput, IntellengenceBasedSkillsUncheckedCreateWithoutNatureInput>
    connectOrCreate?: IntellengenceBasedSkillsCreateOrConnectWithoutNatureInput
    connect?: IntellengenceBasedSkillsWhereUniqueInput
  }

  export type IntellengenceBasedSkillsUpdateOneRequiredWithoutNatureNestedInput = {
    create?: XOR<IntellengenceBasedSkillsCreateWithoutNatureInput, IntellengenceBasedSkillsUncheckedCreateWithoutNatureInput>
    connectOrCreate?: IntellengenceBasedSkillsCreateOrConnectWithoutNatureInput
    upsert?: IntellengenceBasedSkillsUpsertWithoutNatureInput
    connect?: IntellengenceBasedSkillsWhereUniqueInput
    update?: XOR<XOR<IntellengenceBasedSkillsUpdateToOneWithWhereWithoutNatureInput, IntellengenceBasedSkillsUpdateWithoutNatureInput>, IntellengenceBasedSkillsUncheckedUpdateWithoutNatureInput>
  }

  export type IntellengenceBasedSkillsCreateNestedOneWithoutReligionInput = {
    create?: XOR<IntellengenceBasedSkillsCreateWithoutReligionInput, IntellengenceBasedSkillsUncheckedCreateWithoutReligionInput>
    connectOrCreate?: IntellengenceBasedSkillsCreateOrConnectWithoutReligionInput
    connect?: IntellengenceBasedSkillsWhereUniqueInput
  }

  export type IntellengenceBasedSkillsUpdateOneRequiredWithoutReligionNestedInput = {
    create?: XOR<IntellengenceBasedSkillsCreateWithoutReligionInput, IntellengenceBasedSkillsUncheckedCreateWithoutReligionInput>
    connectOrCreate?: IntellengenceBasedSkillsCreateOrConnectWithoutReligionInput
    upsert?: IntellengenceBasedSkillsUpsertWithoutReligionInput
    connect?: IntellengenceBasedSkillsWhereUniqueInput
    update?: XOR<XOR<IntellengenceBasedSkillsUpdateToOneWithWhereWithoutReligionInput, IntellengenceBasedSkillsUpdateWithoutReligionInput>, IntellengenceBasedSkillsUncheckedUpdateWithoutReligionInput>
  }

  export type WisdomBasedSkillsCreateNestedOneWithoutAnimal_handlingInput = {
    create?: XOR<WisdomBasedSkillsCreateWithoutAnimal_handlingInput, WisdomBasedSkillsUncheckedCreateWithoutAnimal_handlingInput>
    connectOrCreate?: WisdomBasedSkillsCreateOrConnectWithoutAnimal_handlingInput
    connect?: WisdomBasedSkillsWhereUniqueInput
  }

  export type WisdomBasedSkillsUpdateOneRequiredWithoutAnimal_handlingNestedInput = {
    create?: XOR<WisdomBasedSkillsCreateWithoutAnimal_handlingInput, WisdomBasedSkillsUncheckedCreateWithoutAnimal_handlingInput>
    connectOrCreate?: WisdomBasedSkillsCreateOrConnectWithoutAnimal_handlingInput
    upsert?: WisdomBasedSkillsUpsertWithoutAnimal_handlingInput
    connect?: WisdomBasedSkillsWhereUniqueInput
    update?: XOR<XOR<WisdomBasedSkillsUpdateToOneWithWhereWithoutAnimal_handlingInput, WisdomBasedSkillsUpdateWithoutAnimal_handlingInput>, WisdomBasedSkillsUncheckedUpdateWithoutAnimal_handlingInput>
  }

  export type WisdomBasedSkillsCreateNestedOneWithoutInsightInput = {
    create?: XOR<WisdomBasedSkillsCreateWithoutInsightInput, WisdomBasedSkillsUncheckedCreateWithoutInsightInput>
    connectOrCreate?: WisdomBasedSkillsCreateOrConnectWithoutInsightInput
    connect?: WisdomBasedSkillsWhereUniqueInput
  }

  export type WisdomBasedSkillsUpdateOneRequiredWithoutInsightNestedInput = {
    create?: XOR<WisdomBasedSkillsCreateWithoutInsightInput, WisdomBasedSkillsUncheckedCreateWithoutInsightInput>
    connectOrCreate?: WisdomBasedSkillsCreateOrConnectWithoutInsightInput
    upsert?: WisdomBasedSkillsUpsertWithoutInsightInput
    connect?: WisdomBasedSkillsWhereUniqueInput
    update?: XOR<XOR<WisdomBasedSkillsUpdateToOneWithWhereWithoutInsightInput, WisdomBasedSkillsUpdateWithoutInsightInput>, WisdomBasedSkillsUncheckedUpdateWithoutInsightInput>
  }

  export type WisdomBasedSkillsCreateNestedOneWithoutMedicineInput = {
    create?: XOR<WisdomBasedSkillsCreateWithoutMedicineInput, WisdomBasedSkillsUncheckedCreateWithoutMedicineInput>
    connectOrCreate?: WisdomBasedSkillsCreateOrConnectWithoutMedicineInput
    connect?: WisdomBasedSkillsWhereUniqueInput
  }

  export type WisdomBasedSkillsUpdateOneRequiredWithoutMedicineNestedInput = {
    create?: XOR<WisdomBasedSkillsCreateWithoutMedicineInput, WisdomBasedSkillsUncheckedCreateWithoutMedicineInput>
    connectOrCreate?: WisdomBasedSkillsCreateOrConnectWithoutMedicineInput
    upsert?: WisdomBasedSkillsUpsertWithoutMedicineInput
    connect?: WisdomBasedSkillsWhereUniqueInput
    update?: XOR<XOR<WisdomBasedSkillsUpdateToOneWithWhereWithoutMedicineInput, WisdomBasedSkillsUpdateWithoutMedicineInput>, WisdomBasedSkillsUncheckedUpdateWithoutMedicineInput>
  }

  export type WisdomBasedSkillsCreateNestedOneWithoutPerceptionInput = {
    create?: XOR<WisdomBasedSkillsCreateWithoutPerceptionInput, WisdomBasedSkillsUncheckedCreateWithoutPerceptionInput>
    connectOrCreate?: WisdomBasedSkillsCreateOrConnectWithoutPerceptionInput
    connect?: WisdomBasedSkillsWhereUniqueInput
  }

  export type WisdomBasedSkillsUpdateOneRequiredWithoutPerceptionNestedInput = {
    create?: XOR<WisdomBasedSkillsCreateWithoutPerceptionInput, WisdomBasedSkillsUncheckedCreateWithoutPerceptionInput>
    connectOrCreate?: WisdomBasedSkillsCreateOrConnectWithoutPerceptionInput
    upsert?: WisdomBasedSkillsUpsertWithoutPerceptionInput
    connect?: WisdomBasedSkillsWhereUniqueInput
    update?: XOR<XOR<WisdomBasedSkillsUpdateToOneWithWhereWithoutPerceptionInput, WisdomBasedSkillsUpdateWithoutPerceptionInput>, WisdomBasedSkillsUncheckedUpdateWithoutPerceptionInput>
  }

  export type WisdomBasedSkillsCreateNestedOneWithoutSurvivalInput = {
    create?: XOR<WisdomBasedSkillsCreateWithoutSurvivalInput, WisdomBasedSkillsUncheckedCreateWithoutSurvivalInput>
    connectOrCreate?: WisdomBasedSkillsCreateOrConnectWithoutSurvivalInput
    connect?: WisdomBasedSkillsWhereUniqueInput
  }

  export type WisdomBasedSkillsUpdateOneRequiredWithoutSurvivalNestedInput = {
    create?: XOR<WisdomBasedSkillsCreateWithoutSurvivalInput, WisdomBasedSkillsUncheckedCreateWithoutSurvivalInput>
    connectOrCreate?: WisdomBasedSkillsCreateOrConnectWithoutSurvivalInput
    upsert?: WisdomBasedSkillsUpsertWithoutSurvivalInput
    connect?: WisdomBasedSkillsWhereUniqueInput
    update?: XOR<XOR<WisdomBasedSkillsUpdateToOneWithWhereWithoutSurvivalInput, WisdomBasedSkillsUpdateWithoutSurvivalInput>, WisdomBasedSkillsUncheckedUpdateWithoutSurvivalInput>
  }

  export type CharismaBasedSkillsCreateNestedOneWithoutDeceptionInput = {
    create?: XOR<CharismaBasedSkillsCreateWithoutDeceptionInput, CharismaBasedSkillsUncheckedCreateWithoutDeceptionInput>
    connectOrCreate?: CharismaBasedSkillsCreateOrConnectWithoutDeceptionInput
    connect?: CharismaBasedSkillsWhereUniqueInput
  }

  export type CharismaBasedSkillsUpdateOneRequiredWithoutDeceptionNestedInput = {
    create?: XOR<CharismaBasedSkillsCreateWithoutDeceptionInput, CharismaBasedSkillsUncheckedCreateWithoutDeceptionInput>
    connectOrCreate?: CharismaBasedSkillsCreateOrConnectWithoutDeceptionInput
    upsert?: CharismaBasedSkillsUpsertWithoutDeceptionInput
    connect?: CharismaBasedSkillsWhereUniqueInput
    update?: XOR<XOR<CharismaBasedSkillsUpdateToOneWithWhereWithoutDeceptionInput, CharismaBasedSkillsUpdateWithoutDeceptionInput>, CharismaBasedSkillsUncheckedUpdateWithoutDeceptionInput>
  }

  export type CharismaBasedSkillsCreateNestedOneWithoutIntimidationInput = {
    create?: XOR<CharismaBasedSkillsCreateWithoutIntimidationInput, CharismaBasedSkillsUncheckedCreateWithoutIntimidationInput>
    connectOrCreate?: CharismaBasedSkillsCreateOrConnectWithoutIntimidationInput
    connect?: CharismaBasedSkillsWhereUniqueInput
  }

  export type CharismaBasedSkillsUpdateOneRequiredWithoutIntimidationNestedInput = {
    create?: XOR<CharismaBasedSkillsCreateWithoutIntimidationInput, CharismaBasedSkillsUncheckedCreateWithoutIntimidationInput>
    connectOrCreate?: CharismaBasedSkillsCreateOrConnectWithoutIntimidationInput
    upsert?: CharismaBasedSkillsUpsertWithoutIntimidationInput
    connect?: CharismaBasedSkillsWhereUniqueInput
    update?: XOR<XOR<CharismaBasedSkillsUpdateToOneWithWhereWithoutIntimidationInput, CharismaBasedSkillsUpdateWithoutIntimidationInput>, CharismaBasedSkillsUncheckedUpdateWithoutIntimidationInput>
  }

  export type CharismaBasedSkillsCreateNestedOneWithoutPerformanceInput = {
    create?: XOR<CharismaBasedSkillsCreateWithoutPerformanceInput, CharismaBasedSkillsUncheckedCreateWithoutPerformanceInput>
    connectOrCreate?: CharismaBasedSkillsCreateOrConnectWithoutPerformanceInput
    connect?: CharismaBasedSkillsWhereUniqueInput
  }

  export type CharismaBasedSkillsUpdateOneRequiredWithoutPerformanceNestedInput = {
    create?: XOR<CharismaBasedSkillsCreateWithoutPerformanceInput, CharismaBasedSkillsUncheckedCreateWithoutPerformanceInput>
    connectOrCreate?: CharismaBasedSkillsCreateOrConnectWithoutPerformanceInput
    upsert?: CharismaBasedSkillsUpsertWithoutPerformanceInput
    connect?: CharismaBasedSkillsWhereUniqueInput
    update?: XOR<XOR<CharismaBasedSkillsUpdateToOneWithWhereWithoutPerformanceInput, CharismaBasedSkillsUpdateWithoutPerformanceInput>, CharismaBasedSkillsUncheckedUpdateWithoutPerformanceInput>
  }

  export type CharismaBasedSkillsCreateNestedOneWithoutPersuasionInput = {
    create?: XOR<CharismaBasedSkillsCreateWithoutPersuasionInput, CharismaBasedSkillsUncheckedCreateWithoutPersuasionInput>
    connectOrCreate?: CharismaBasedSkillsCreateOrConnectWithoutPersuasionInput
    connect?: CharismaBasedSkillsWhereUniqueInput
  }

  export type CharismaBasedSkillsUpdateOneRequiredWithoutPersuasionNestedInput = {
    create?: XOR<CharismaBasedSkillsCreateWithoutPersuasionInput, CharismaBasedSkillsUncheckedCreateWithoutPersuasionInput>
    connectOrCreate?: CharismaBasedSkillsCreateOrConnectWithoutPersuasionInput
    upsert?: CharismaBasedSkillsUpsertWithoutPersuasionInput
    connect?: CharismaBasedSkillsWhereUniqueInput
    update?: XOR<XOR<CharismaBasedSkillsUpdateToOneWithWhereWithoutPersuasionInput, CharismaBasedSkillsUpdateWithoutPersuasionInput>, CharismaBasedSkillsUncheckedUpdateWithoutPersuasionInput>
  }

  export type CreatureCreatebiomes_idsInput = {
    set: number[]
  }

  export type CreatureCreateaSubTypesInput = {
    set: string[]
  }

  export type Speed_statCreateNestedOneWithoutId_relationInput = {
    create?: XOR<Speed_statCreateWithoutId_relationInput, Speed_statUncheckedCreateWithoutId_relationInput>
    connectOrCreate?: Speed_statCreateOrConnectWithoutId_relationInput
    connect?: Speed_statWhereUniqueInput
  }

  export type Creature_statsCreateNestedOneWithoutId_relationInput = {
    create?: XOR<Creature_statsCreateWithoutId_relationInput, Creature_statsUncheckedCreateWithoutId_relationInput>
    connectOrCreate?: Creature_statsCreateOrConnectWithoutId_relationInput
    connect?: Creature_statsWhereUniqueInput
  }

  export type SkillsListCreateNestedOneWithoutId_relationInput = {
    create?: XOR<SkillsListCreateWithoutId_relationInput, SkillsListUncheckedCreateWithoutId_relationInput>
    connectOrCreate?: SkillsListCreateOrConnectWithoutId_relationInput
    connect?: SkillsListWhereUniqueInput
  }

  export type DamageTypeCreateNestedManyWithoutResistant_creaturesInput = {
    create?: XOR<DamageTypeCreateWithoutResistant_creaturesInput, DamageTypeUncheckedCreateWithoutResistant_creaturesInput> | DamageTypeCreateWithoutResistant_creaturesInput[] | DamageTypeUncheckedCreateWithoutResistant_creaturesInput[]
    connectOrCreate?: DamageTypeCreateOrConnectWithoutResistant_creaturesInput | DamageTypeCreateOrConnectWithoutResistant_creaturesInput[]
    connect?: DamageTypeWhereUniqueInput | DamageTypeWhereUniqueInput[]
  }

  export type DamageTypeCreateNestedManyWithoutImmune_creaturesInput = {
    create?: XOR<DamageTypeCreateWithoutImmune_creaturesInput, DamageTypeUncheckedCreateWithoutImmune_creaturesInput> | DamageTypeCreateWithoutImmune_creaturesInput[] | DamageTypeUncheckedCreateWithoutImmune_creaturesInput[]
    connectOrCreate?: DamageTypeCreateOrConnectWithoutImmune_creaturesInput | DamageTypeCreateOrConnectWithoutImmune_creaturesInput[]
    connect?: DamageTypeWhereUniqueInput | DamageTypeWhereUniqueInput[]
  }

  export type DamageTypeCreateNestedManyWithoutVunlerable_creaturesInput = {
    create?: XOR<DamageTypeCreateWithoutVunlerable_creaturesInput, DamageTypeUncheckedCreateWithoutVunlerable_creaturesInput> | DamageTypeCreateWithoutVunlerable_creaturesInput[] | DamageTypeUncheckedCreateWithoutVunlerable_creaturesInput[]
    connectOrCreate?: DamageTypeCreateOrConnectWithoutVunlerable_creaturesInput | DamageTypeCreateOrConnectWithoutVunlerable_creaturesInput[]
    connect?: DamageTypeWhereUniqueInput | DamageTypeWhereUniqueInput[]
  }

  export type SensesCreateNestedOneWithoutCreatureInput = {
    create?: XOR<SensesCreateWithoutCreatureInput, SensesUncheckedCreateWithoutCreatureInput>
    connectOrCreate?: SensesCreateOrConnectWithoutCreatureInput
    connect?: SensesWhereUniqueInput
  }

  export type LanguageCreateNestedManyWithoutCreaturesInput = {
    create?: XOR<LanguageCreateWithoutCreaturesInput, LanguageUncheckedCreateWithoutCreaturesInput> | LanguageCreateWithoutCreaturesInput[] | LanguageUncheckedCreateWithoutCreaturesInput[]
    connectOrCreate?: LanguageCreateOrConnectWithoutCreaturesInput | LanguageCreateOrConnectWithoutCreaturesInput[]
    connect?: LanguageWhereUniqueInput | LanguageWhereUniqueInput[]
  }

  export type ActionCreateNestedManyWithoutCreaturesInput = {
    create?: XOR<ActionCreateWithoutCreaturesInput, ActionUncheckedCreateWithoutCreaturesInput> | ActionCreateWithoutCreaturesInput[] | ActionUncheckedCreateWithoutCreaturesInput[]
    connectOrCreate?: ActionCreateOrConnectWithoutCreaturesInput | ActionCreateOrConnectWithoutCreaturesInput[]
    connect?: ActionWhereUniqueInput | ActionWhereUniqueInput[]
  }

  export type TraitCreateNestedManyWithoutCreturesInput = {
    create?: XOR<TraitCreateWithoutCreturesInput, TraitUncheckedCreateWithoutCreturesInput> | TraitCreateWithoutCreturesInput[] | TraitUncheckedCreateWithoutCreturesInput[]
    connectOrCreate?: TraitCreateOrConnectWithoutCreturesInput | TraitCreateOrConnectWithoutCreturesInput[]
    connect?: TraitWhereUniqueInput | TraitWhereUniqueInput[]
  }

  export type AlignmentCreateNestedOneWithoutCreaturesInput = {
    create?: XOR<AlignmentCreateWithoutCreaturesInput, AlignmentUncheckedCreateWithoutCreaturesInput>
    connectOrCreate?: AlignmentCreateOrConnectWithoutCreaturesInput
    connect?: AlignmentWhereUniqueInput
  }

  export type CreatureRaceCreateNestedOneWithoutCreaturesInput = {
    create?: XOR<CreatureRaceCreateWithoutCreaturesInput, CreatureRaceUncheckedCreateWithoutCreaturesInput>
    connectOrCreate?: CreatureRaceCreateOrConnectWithoutCreaturesInput
    connect?: CreatureRaceWhereUniqueInput
  }

  export type TypeCreateNestedOneWithoutCreaturesInput = {
    create?: XOR<TypeCreateWithoutCreaturesInput, TypeUncheckedCreateWithoutCreaturesInput>
    connectOrCreate?: TypeCreateOrConnectWithoutCreaturesInput
    connect?: TypeWhereUniqueInput
  }

  export type SizeCreateNestedOneWithoutCreatureInput = {
    create?: XOR<SizeCreateWithoutCreatureInput, SizeUncheckedCreateWithoutCreatureInput>
    connectOrCreate?: SizeCreateOrConnectWithoutCreatureInput
    connect?: SizeWhereUniqueInput
  }

  export type BiomeCreateNestedManyWithoutCreaturesInput = {
    create?: XOR<BiomeCreateWithoutCreaturesInput, BiomeUncheckedCreateWithoutCreaturesInput> | BiomeCreateWithoutCreaturesInput[] | BiomeUncheckedCreateWithoutCreaturesInput[]
    connectOrCreate?: BiomeCreateOrConnectWithoutCreaturesInput | BiomeCreateOrConnectWithoutCreaturesInput[]
    connect?: BiomeWhereUniqueInput | BiomeWhereUniqueInput[]
  }

  export type SourceCreateNestedOneWithoutCreaturesInput = {
    create?: XOR<SourceCreateWithoutCreaturesInput, SourceUncheckedCreateWithoutCreaturesInput>
    connectOrCreate?: SourceCreateOrConnectWithoutCreaturesInput
    connect?: SourceWhereUniqueInput
  }

  export type Speed_statUncheckedCreateNestedOneWithoutId_relationInput = {
    create?: XOR<Speed_statCreateWithoutId_relationInput, Speed_statUncheckedCreateWithoutId_relationInput>
    connectOrCreate?: Speed_statCreateOrConnectWithoutId_relationInput
    connect?: Speed_statWhereUniqueInput
  }

  export type Creature_statsUncheckedCreateNestedOneWithoutId_relationInput = {
    create?: XOR<Creature_statsCreateWithoutId_relationInput, Creature_statsUncheckedCreateWithoutId_relationInput>
    connectOrCreate?: Creature_statsCreateOrConnectWithoutId_relationInput
    connect?: Creature_statsWhereUniqueInput
  }

  export type SkillsListUncheckedCreateNestedOneWithoutId_relationInput = {
    create?: XOR<SkillsListCreateWithoutId_relationInput, SkillsListUncheckedCreateWithoutId_relationInput>
    connectOrCreate?: SkillsListCreateOrConnectWithoutId_relationInput
    connect?: SkillsListWhereUniqueInput
  }

  export type DamageTypeUncheckedCreateNestedManyWithoutResistant_creaturesInput = {
    create?: XOR<DamageTypeCreateWithoutResistant_creaturesInput, DamageTypeUncheckedCreateWithoutResistant_creaturesInput> | DamageTypeCreateWithoutResistant_creaturesInput[] | DamageTypeUncheckedCreateWithoutResistant_creaturesInput[]
    connectOrCreate?: DamageTypeCreateOrConnectWithoutResistant_creaturesInput | DamageTypeCreateOrConnectWithoutResistant_creaturesInput[]
    connect?: DamageTypeWhereUniqueInput | DamageTypeWhereUniqueInput[]
  }

  export type DamageTypeUncheckedCreateNestedManyWithoutImmune_creaturesInput = {
    create?: XOR<DamageTypeCreateWithoutImmune_creaturesInput, DamageTypeUncheckedCreateWithoutImmune_creaturesInput> | DamageTypeCreateWithoutImmune_creaturesInput[] | DamageTypeUncheckedCreateWithoutImmune_creaturesInput[]
    connectOrCreate?: DamageTypeCreateOrConnectWithoutImmune_creaturesInput | DamageTypeCreateOrConnectWithoutImmune_creaturesInput[]
    connect?: DamageTypeWhereUniqueInput | DamageTypeWhereUniqueInput[]
  }

  export type DamageTypeUncheckedCreateNestedManyWithoutVunlerable_creaturesInput = {
    create?: XOR<DamageTypeCreateWithoutVunlerable_creaturesInput, DamageTypeUncheckedCreateWithoutVunlerable_creaturesInput> | DamageTypeCreateWithoutVunlerable_creaturesInput[] | DamageTypeUncheckedCreateWithoutVunlerable_creaturesInput[]
    connectOrCreate?: DamageTypeCreateOrConnectWithoutVunlerable_creaturesInput | DamageTypeCreateOrConnectWithoutVunlerable_creaturesInput[]
    connect?: DamageTypeWhereUniqueInput | DamageTypeWhereUniqueInput[]
  }

  export type SensesUncheckedCreateNestedOneWithoutCreatureInput = {
    create?: XOR<SensesCreateWithoutCreatureInput, SensesUncheckedCreateWithoutCreatureInput>
    connectOrCreate?: SensesCreateOrConnectWithoutCreatureInput
    connect?: SensesWhereUniqueInput
  }

  export type LanguageUncheckedCreateNestedManyWithoutCreaturesInput = {
    create?: XOR<LanguageCreateWithoutCreaturesInput, LanguageUncheckedCreateWithoutCreaturesInput> | LanguageCreateWithoutCreaturesInput[] | LanguageUncheckedCreateWithoutCreaturesInput[]
    connectOrCreate?: LanguageCreateOrConnectWithoutCreaturesInput | LanguageCreateOrConnectWithoutCreaturesInput[]
    connect?: LanguageWhereUniqueInput | LanguageWhereUniqueInput[]
  }

  export type ActionUncheckedCreateNestedManyWithoutCreaturesInput = {
    create?: XOR<ActionCreateWithoutCreaturesInput, ActionUncheckedCreateWithoutCreaturesInput> | ActionCreateWithoutCreaturesInput[] | ActionUncheckedCreateWithoutCreaturesInput[]
    connectOrCreate?: ActionCreateOrConnectWithoutCreaturesInput | ActionCreateOrConnectWithoutCreaturesInput[]
    connect?: ActionWhereUniqueInput | ActionWhereUniqueInput[]
  }

  export type TraitUncheckedCreateNestedManyWithoutCreturesInput = {
    create?: XOR<TraitCreateWithoutCreturesInput, TraitUncheckedCreateWithoutCreturesInput> | TraitCreateWithoutCreturesInput[] | TraitUncheckedCreateWithoutCreturesInput[]
    connectOrCreate?: TraitCreateOrConnectWithoutCreturesInput | TraitCreateOrConnectWithoutCreturesInput[]
    connect?: TraitWhereUniqueInput | TraitWhereUniqueInput[]
  }

  export type BiomeUncheckedCreateNestedManyWithoutCreaturesInput = {
    create?: XOR<BiomeCreateWithoutCreaturesInput, BiomeUncheckedCreateWithoutCreaturesInput> | BiomeCreateWithoutCreaturesInput[] | BiomeUncheckedCreateWithoutCreaturesInput[]
    connectOrCreate?: BiomeCreateOrConnectWithoutCreaturesInput | BiomeCreateOrConnectWithoutCreaturesInput[]
    connect?: BiomeWhereUniqueInput | BiomeWhereUniqueInput[]
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type CreatureUpdatebiomes_idsInput = {
    set?: number[]
    push?: number | number[]
  }

  export type CreatureUpdateaSubTypesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type Speed_statUpdateOneWithoutId_relationNestedInput = {
    create?: XOR<Speed_statCreateWithoutId_relationInput, Speed_statUncheckedCreateWithoutId_relationInput>
    connectOrCreate?: Speed_statCreateOrConnectWithoutId_relationInput
    upsert?: Speed_statUpsertWithoutId_relationInput
    disconnect?: Speed_statWhereInput | boolean
    delete?: Speed_statWhereInput | boolean
    connect?: Speed_statWhereUniqueInput
    update?: XOR<XOR<Speed_statUpdateToOneWithWhereWithoutId_relationInput, Speed_statUpdateWithoutId_relationInput>, Speed_statUncheckedUpdateWithoutId_relationInput>
  }

  export type Creature_statsUpdateOneWithoutId_relationNestedInput = {
    create?: XOR<Creature_statsCreateWithoutId_relationInput, Creature_statsUncheckedCreateWithoutId_relationInput>
    connectOrCreate?: Creature_statsCreateOrConnectWithoutId_relationInput
    upsert?: Creature_statsUpsertWithoutId_relationInput
    disconnect?: Creature_statsWhereInput | boolean
    delete?: Creature_statsWhereInput | boolean
    connect?: Creature_statsWhereUniqueInput
    update?: XOR<XOR<Creature_statsUpdateToOneWithWhereWithoutId_relationInput, Creature_statsUpdateWithoutId_relationInput>, Creature_statsUncheckedUpdateWithoutId_relationInput>
  }

  export type SkillsListUpdateOneWithoutId_relationNestedInput = {
    create?: XOR<SkillsListCreateWithoutId_relationInput, SkillsListUncheckedCreateWithoutId_relationInput>
    connectOrCreate?: SkillsListCreateOrConnectWithoutId_relationInput
    upsert?: SkillsListUpsertWithoutId_relationInput
    disconnect?: SkillsListWhereInput | boolean
    delete?: SkillsListWhereInput | boolean
    connect?: SkillsListWhereUniqueInput
    update?: XOR<XOR<SkillsListUpdateToOneWithWhereWithoutId_relationInput, SkillsListUpdateWithoutId_relationInput>, SkillsListUncheckedUpdateWithoutId_relationInput>
  }

  export type DamageTypeUpdateManyWithoutResistant_creaturesNestedInput = {
    create?: XOR<DamageTypeCreateWithoutResistant_creaturesInput, DamageTypeUncheckedCreateWithoutResistant_creaturesInput> | DamageTypeCreateWithoutResistant_creaturesInput[] | DamageTypeUncheckedCreateWithoutResistant_creaturesInput[]
    connectOrCreate?: DamageTypeCreateOrConnectWithoutResistant_creaturesInput | DamageTypeCreateOrConnectWithoutResistant_creaturesInput[]
    upsert?: DamageTypeUpsertWithWhereUniqueWithoutResistant_creaturesInput | DamageTypeUpsertWithWhereUniqueWithoutResistant_creaturesInput[]
    set?: DamageTypeWhereUniqueInput | DamageTypeWhereUniqueInput[]
    disconnect?: DamageTypeWhereUniqueInput | DamageTypeWhereUniqueInput[]
    delete?: DamageTypeWhereUniqueInput | DamageTypeWhereUniqueInput[]
    connect?: DamageTypeWhereUniqueInput | DamageTypeWhereUniqueInput[]
    update?: DamageTypeUpdateWithWhereUniqueWithoutResistant_creaturesInput | DamageTypeUpdateWithWhereUniqueWithoutResistant_creaturesInput[]
    updateMany?: DamageTypeUpdateManyWithWhereWithoutResistant_creaturesInput | DamageTypeUpdateManyWithWhereWithoutResistant_creaturesInput[]
    deleteMany?: DamageTypeScalarWhereInput | DamageTypeScalarWhereInput[]
  }

  export type DamageTypeUpdateManyWithoutImmune_creaturesNestedInput = {
    create?: XOR<DamageTypeCreateWithoutImmune_creaturesInput, DamageTypeUncheckedCreateWithoutImmune_creaturesInput> | DamageTypeCreateWithoutImmune_creaturesInput[] | DamageTypeUncheckedCreateWithoutImmune_creaturesInput[]
    connectOrCreate?: DamageTypeCreateOrConnectWithoutImmune_creaturesInput | DamageTypeCreateOrConnectWithoutImmune_creaturesInput[]
    upsert?: DamageTypeUpsertWithWhereUniqueWithoutImmune_creaturesInput | DamageTypeUpsertWithWhereUniqueWithoutImmune_creaturesInput[]
    set?: DamageTypeWhereUniqueInput | DamageTypeWhereUniqueInput[]
    disconnect?: DamageTypeWhereUniqueInput | DamageTypeWhereUniqueInput[]
    delete?: DamageTypeWhereUniqueInput | DamageTypeWhereUniqueInput[]
    connect?: DamageTypeWhereUniqueInput | DamageTypeWhereUniqueInput[]
    update?: DamageTypeUpdateWithWhereUniqueWithoutImmune_creaturesInput | DamageTypeUpdateWithWhereUniqueWithoutImmune_creaturesInput[]
    updateMany?: DamageTypeUpdateManyWithWhereWithoutImmune_creaturesInput | DamageTypeUpdateManyWithWhereWithoutImmune_creaturesInput[]
    deleteMany?: DamageTypeScalarWhereInput | DamageTypeScalarWhereInput[]
  }

  export type DamageTypeUpdateManyWithoutVunlerable_creaturesNestedInput = {
    create?: XOR<DamageTypeCreateWithoutVunlerable_creaturesInput, DamageTypeUncheckedCreateWithoutVunlerable_creaturesInput> | DamageTypeCreateWithoutVunlerable_creaturesInput[] | DamageTypeUncheckedCreateWithoutVunlerable_creaturesInput[]
    connectOrCreate?: DamageTypeCreateOrConnectWithoutVunlerable_creaturesInput | DamageTypeCreateOrConnectWithoutVunlerable_creaturesInput[]
    upsert?: DamageTypeUpsertWithWhereUniqueWithoutVunlerable_creaturesInput | DamageTypeUpsertWithWhereUniqueWithoutVunlerable_creaturesInput[]
    set?: DamageTypeWhereUniqueInput | DamageTypeWhereUniqueInput[]
    disconnect?: DamageTypeWhereUniqueInput | DamageTypeWhereUniqueInput[]
    delete?: DamageTypeWhereUniqueInput | DamageTypeWhereUniqueInput[]
    connect?: DamageTypeWhereUniqueInput | DamageTypeWhereUniqueInput[]
    update?: DamageTypeUpdateWithWhereUniqueWithoutVunlerable_creaturesInput | DamageTypeUpdateWithWhereUniqueWithoutVunlerable_creaturesInput[]
    updateMany?: DamageTypeUpdateManyWithWhereWithoutVunlerable_creaturesInput | DamageTypeUpdateManyWithWhereWithoutVunlerable_creaturesInput[]
    deleteMany?: DamageTypeScalarWhereInput | DamageTypeScalarWhereInput[]
  }

  export type SensesUpdateOneWithoutCreatureNestedInput = {
    create?: XOR<SensesCreateWithoutCreatureInput, SensesUncheckedCreateWithoutCreatureInput>
    connectOrCreate?: SensesCreateOrConnectWithoutCreatureInput
    upsert?: SensesUpsertWithoutCreatureInput
    disconnect?: SensesWhereInput | boolean
    delete?: SensesWhereInput | boolean
    connect?: SensesWhereUniqueInput
    update?: XOR<XOR<SensesUpdateToOneWithWhereWithoutCreatureInput, SensesUpdateWithoutCreatureInput>, SensesUncheckedUpdateWithoutCreatureInput>
  }

  export type LanguageUpdateManyWithoutCreaturesNestedInput = {
    create?: XOR<LanguageCreateWithoutCreaturesInput, LanguageUncheckedCreateWithoutCreaturesInput> | LanguageCreateWithoutCreaturesInput[] | LanguageUncheckedCreateWithoutCreaturesInput[]
    connectOrCreate?: LanguageCreateOrConnectWithoutCreaturesInput | LanguageCreateOrConnectWithoutCreaturesInput[]
    upsert?: LanguageUpsertWithWhereUniqueWithoutCreaturesInput | LanguageUpsertWithWhereUniqueWithoutCreaturesInput[]
    set?: LanguageWhereUniqueInput | LanguageWhereUniqueInput[]
    disconnect?: LanguageWhereUniqueInput | LanguageWhereUniqueInput[]
    delete?: LanguageWhereUniqueInput | LanguageWhereUniqueInput[]
    connect?: LanguageWhereUniqueInput | LanguageWhereUniqueInput[]
    update?: LanguageUpdateWithWhereUniqueWithoutCreaturesInput | LanguageUpdateWithWhereUniqueWithoutCreaturesInput[]
    updateMany?: LanguageUpdateManyWithWhereWithoutCreaturesInput | LanguageUpdateManyWithWhereWithoutCreaturesInput[]
    deleteMany?: LanguageScalarWhereInput | LanguageScalarWhereInput[]
  }

  export type ActionUpdateManyWithoutCreaturesNestedInput = {
    create?: XOR<ActionCreateWithoutCreaturesInput, ActionUncheckedCreateWithoutCreaturesInput> | ActionCreateWithoutCreaturesInput[] | ActionUncheckedCreateWithoutCreaturesInput[]
    connectOrCreate?: ActionCreateOrConnectWithoutCreaturesInput | ActionCreateOrConnectWithoutCreaturesInput[]
    upsert?: ActionUpsertWithWhereUniqueWithoutCreaturesInput | ActionUpsertWithWhereUniqueWithoutCreaturesInput[]
    set?: ActionWhereUniqueInput | ActionWhereUniqueInput[]
    disconnect?: ActionWhereUniqueInput | ActionWhereUniqueInput[]
    delete?: ActionWhereUniqueInput | ActionWhereUniqueInput[]
    connect?: ActionWhereUniqueInput | ActionWhereUniqueInput[]
    update?: ActionUpdateWithWhereUniqueWithoutCreaturesInput | ActionUpdateWithWhereUniqueWithoutCreaturesInput[]
    updateMany?: ActionUpdateManyWithWhereWithoutCreaturesInput | ActionUpdateManyWithWhereWithoutCreaturesInput[]
    deleteMany?: ActionScalarWhereInput | ActionScalarWhereInput[]
  }

  export type TraitUpdateManyWithoutCreturesNestedInput = {
    create?: XOR<TraitCreateWithoutCreturesInput, TraitUncheckedCreateWithoutCreturesInput> | TraitCreateWithoutCreturesInput[] | TraitUncheckedCreateWithoutCreturesInput[]
    connectOrCreate?: TraitCreateOrConnectWithoutCreturesInput | TraitCreateOrConnectWithoutCreturesInput[]
    upsert?: TraitUpsertWithWhereUniqueWithoutCreturesInput | TraitUpsertWithWhereUniqueWithoutCreturesInput[]
    set?: TraitWhereUniqueInput | TraitWhereUniqueInput[]
    disconnect?: TraitWhereUniqueInput | TraitWhereUniqueInput[]
    delete?: TraitWhereUniqueInput | TraitWhereUniqueInput[]
    connect?: TraitWhereUniqueInput | TraitWhereUniqueInput[]
    update?: TraitUpdateWithWhereUniqueWithoutCreturesInput | TraitUpdateWithWhereUniqueWithoutCreturesInput[]
    updateMany?: TraitUpdateManyWithWhereWithoutCreturesInput | TraitUpdateManyWithWhereWithoutCreturesInput[]
    deleteMany?: TraitScalarWhereInput | TraitScalarWhereInput[]
  }

  export type AlignmentUpdateOneWithoutCreaturesNestedInput = {
    create?: XOR<AlignmentCreateWithoutCreaturesInput, AlignmentUncheckedCreateWithoutCreaturesInput>
    connectOrCreate?: AlignmentCreateOrConnectWithoutCreaturesInput
    upsert?: AlignmentUpsertWithoutCreaturesInput
    disconnect?: AlignmentWhereInput | boolean
    delete?: AlignmentWhereInput | boolean
    connect?: AlignmentWhereUniqueInput
    update?: XOR<XOR<AlignmentUpdateToOneWithWhereWithoutCreaturesInput, AlignmentUpdateWithoutCreaturesInput>, AlignmentUncheckedUpdateWithoutCreaturesInput>
  }

  export type CreatureRaceUpdateOneWithoutCreaturesNestedInput = {
    create?: XOR<CreatureRaceCreateWithoutCreaturesInput, CreatureRaceUncheckedCreateWithoutCreaturesInput>
    connectOrCreate?: CreatureRaceCreateOrConnectWithoutCreaturesInput
    upsert?: CreatureRaceUpsertWithoutCreaturesInput
    disconnect?: CreatureRaceWhereInput | boolean
    delete?: CreatureRaceWhereInput | boolean
    connect?: CreatureRaceWhereUniqueInput
    update?: XOR<XOR<CreatureRaceUpdateToOneWithWhereWithoutCreaturesInput, CreatureRaceUpdateWithoutCreaturesInput>, CreatureRaceUncheckedUpdateWithoutCreaturesInput>
  }

  export type TypeUpdateOneWithoutCreaturesNestedInput = {
    create?: XOR<TypeCreateWithoutCreaturesInput, TypeUncheckedCreateWithoutCreaturesInput>
    connectOrCreate?: TypeCreateOrConnectWithoutCreaturesInput
    upsert?: TypeUpsertWithoutCreaturesInput
    disconnect?: TypeWhereInput | boolean
    delete?: TypeWhereInput | boolean
    connect?: TypeWhereUniqueInput
    update?: XOR<XOR<TypeUpdateToOneWithWhereWithoutCreaturesInput, TypeUpdateWithoutCreaturesInput>, TypeUncheckedUpdateWithoutCreaturesInput>
  }

  export type SizeUpdateOneWithoutCreatureNestedInput = {
    create?: XOR<SizeCreateWithoutCreatureInput, SizeUncheckedCreateWithoutCreatureInput>
    connectOrCreate?: SizeCreateOrConnectWithoutCreatureInput
    upsert?: SizeUpsertWithoutCreatureInput
    disconnect?: SizeWhereInput | boolean
    delete?: SizeWhereInput | boolean
    connect?: SizeWhereUniqueInput
    update?: XOR<XOR<SizeUpdateToOneWithWhereWithoutCreatureInput, SizeUpdateWithoutCreatureInput>, SizeUncheckedUpdateWithoutCreatureInput>
  }

  export type BiomeUpdateManyWithoutCreaturesNestedInput = {
    create?: XOR<BiomeCreateWithoutCreaturesInput, BiomeUncheckedCreateWithoutCreaturesInput> | BiomeCreateWithoutCreaturesInput[] | BiomeUncheckedCreateWithoutCreaturesInput[]
    connectOrCreate?: BiomeCreateOrConnectWithoutCreaturesInput | BiomeCreateOrConnectWithoutCreaturesInput[]
    upsert?: BiomeUpsertWithWhereUniqueWithoutCreaturesInput | BiomeUpsertWithWhereUniqueWithoutCreaturesInput[]
    set?: BiomeWhereUniqueInput | BiomeWhereUniqueInput[]
    disconnect?: BiomeWhereUniqueInput | BiomeWhereUniqueInput[]
    delete?: BiomeWhereUniqueInput | BiomeWhereUniqueInput[]
    connect?: BiomeWhereUniqueInput | BiomeWhereUniqueInput[]
    update?: BiomeUpdateWithWhereUniqueWithoutCreaturesInput | BiomeUpdateWithWhereUniqueWithoutCreaturesInput[]
    updateMany?: BiomeUpdateManyWithWhereWithoutCreaturesInput | BiomeUpdateManyWithWhereWithoutCreaturesInput[]
    deleteMany?: BiomeScalarWhereInput | BiomeScalarWhereInput[]
  }

  export type SourceUpdateOneWithoutCreaturesNestedInput = {
    create?: XOR<SourceCreateWithoutCreaturesInput, SourceUncheckedCreateWithoutCreaturesInput>
    connectOrCreate?: SourceCreateOrConnectWithoutCreaturesInput
    upsert?: SourceUpsertWithoutCreaturesInput
    disconnect?: SourceWhereInput | boolean
    delete?: SourceWhereInput | boolean
    connect?: SourceWhereUniqueInput
    update?: XOR<XOR<SourceUpdateToOneWithWhereWithoutCreaturesInput, SourceUpdateWithoutCreaturesInput>, SourceUncheckedUpdateWithoutCreaturesInput>
  }

  export type Speed_statUncheckedUpdateOneWithoutId_relationNestedInput = {
    create?: XOR<Speed_statCreateWithoutId_relationInput, Speed_statUncheckedCreateWithoutId_relationInput>
    connectOrCreate?: Speed_statCreateOrConnectWithoutId_relationInput
    upsert?: Speed_statUpsertWithoutId_relationInput
    disconnect?: Speed_statWhereInput | boolean
    delete?: Speed_statWhereInput | boolean
    connect?: Speed_statWhereUniqueInput
    update?: XOR<XOR<Speed_statUpdateToOneWithWhereWithoutId_relationInput, Speed_statUpdateWithoutId_relationInput>, Speed_statUncheckedUpdateWithoutId_relationInput>
  }

  export type Creature_statsUncheckedUpdateOneWithoutId_relationNestedInput = {
    create?: XOR<Creature_statsCreateWithoutId_relationInput, Creature_statsUncheckedCreateWithoutId_relationInput>
    connectOrCreate?: Creature_statsCreateOrConnectWithoutId_relationInput
    upsert?: Creature_statsUpsertWithoutId_relationInput
    disconnect?: Creature_statsWhereInput | boolean
    delete?: Creature_statsWhereInput | boolean
    connect?: Creature_statsWhereUniqueInput
    update?: XOR<XOR<Creature_statsUpdateToOneWithWhereWithoutId_relationInput, Creature_statsUpdateWithoutId_relationInput>, Creature_statsUncheckedUpdateWithoutId_relationInput>
  }

  export type SkillsListUncheckedUpdateOneWithoutId_relationNestedInput = {
    create?: XOR<SkillsListCreateWithoutId_relationInput, SkillsListUncheckedCreateWithoutId_relationInput>
    connectOrCreate?: SkillsListCreateOrConnectWithoutId_relationInput
    upsert?: SkillsListUpsertWithoutId_relationInput
    disconnect?: SkillsListWhereInput | boolean
    delete?: SkillsListWhereInput | boolean
    connect?: SkillsListWhereUniqueInput
    update?: XOR<XOR<SkillsListUpdateToOneWithWhereWithoutId_relationInput, SkillsListUpdateWithoutId_relationInput>, SkillsListUncheckedUpdateWithoutId_relationInput>
  }

  export type DamageTypeUncheckedUpdateManyWithoutResistant_creaturesNestedInput = {
    create?: XOR<DamageTypeCreateWithoutResistant_creaturesInput, DamageTypeUncheckedCreateWithoutResistant_creaturesInput> | DamageTypeCreateWithoutResistant_creaturesInput[] | DamageTypeUncheckedCreateWithoutResistant_creaturesInput[]
    connectOrCreate?: DamageTypeCreateOrConnectWithoutResistant_creaturesInput | DamageTypeCreateOrConnectWithoutResistant_creaturesInput[]
    upsert?: DamageTypeUpsertWithWhereUniqueWithoutResistant_creaturesInput | DamageTypeUpsertWithWhereUniqueWithoutResistant_creaturesInput[]
    set?: DamageTypeWhereUniqueInput | DamageTypeWhereUniqueInput[]
    disconnect?: DamageTypeWhereUniqueInput | DamageTypeWhereUniqueInput[]
    delete?: DamageTypeWhereUniqueInput | DamageTypeWhereUniqueInput[]
    connect?: DamageTypeWhereUniqueInput | DamageTypeWhereUniqueInput[]
    update?: DamageTypeUpdateWithWhereUniqueWithoutResistant_creaturesInput | DamageTypeUpdateWithWhereUniqueWithoutResistant_creaturesInput[]
    updateMany?: DamageTypeUpdateManyWithWhereWithoutResistant_creaturesInput | DamageTypeUpdateManyWithWhereWithoutResistant_creaturesInput[]
    deleteMany?: DamageTypeScalarWhereInput | DamageTypeScalarWhereInput[]
  }

  export type DamageTypeUncheckedUpdateManyWithoutImmune_creaturesNestedInput = {
    create?: XOR<DamageTypeCreateWithoutImmune_creaturesInput, DamageTypeUncheckedCreateWithoutImmune_creaturesInput> | DamageTypeCreateWithoutImmune_creaturesInput[] | DamageTypeUncheckedCreateWithoutImmune_creaturesInput[]
    connectOrCreate?: DamageTypeCreateOrConnectWithoutImmune_creaturesInput | DamageTypeCreateOrConnectWithoutImmune_creaturesInput[]
    upsert?: DamageTypeUpsertWithWhereUniqueWithoutImmune_creaturesInput | DamageTypeUpsertWithWhereUniqueWithoutImmune_creaturesInput[]
    set?: DamageTypeWhereUniqueInput | DamageTypeWhereUniqueInput[]
    disconnect?: DamageTypeWhereUniqueInput | DamageTypeWhereUniqueInput[]
    delete?: DamageTypeWhereUniqueInput | DamageTypeWhereUniqueInput[]
    connect?: DamageTypeWhereUniqueInput | DamageTypeWhereUniqueInput[]
    update?: DamageTypeUpdateWithWhereUniqueWithoutImmune_creaturesInput | DamageTypeUpdateWithWhereUniqueWithoutImmune_creaturesInput[]
    updateMany?: DamageTypeUpdateManyWithWhereWithoutImmune_creaturesInput | DamageTypeUpdateManyWithWhereWithoutImmune_creaturesInput[]
    deleteMany?: DamageTypeScalarWhereInput | DamageTypeScalarWhereInput[]
  }

  export type DamageTypeUncheckedUpdateManyWithoutVunlerable_creaturesNestedInput = {
    create?: XOR<DamageTypeCreateWithoutVunlerable_creaturesInput, DamageTypeUncheckedCreateWithoutVunlerable_creaturesInput> | DamageTypeCreateWithoutVunlerable_creaturesInput[] | DamageTypeUncheckedCreateWithoutVunlerable_creaturesInput[]
    connectOrCreate?: DamageTypeCreateOrConnectWithoutVunlerable_creaturesInput | DamageTypeCreateOrConnectWithoutVunlerable_creaturesInput[]
    upsert?: DamageTypeUpsertWithWhereUniqueWithoutVunlerable_creaturesInput | DamageTypeUpsertWithWhereUniqueWithoutVunlerable_creaturesInput[]
    set?: DamageTypeWhereUniqueInput | DamageTypeWhereUniqueInput[]
    disconnect?: DamageTypeWhereUniqueInput | DamageTypeWhereUniqueInput[]
    delete?: DamageTypeWhereUniqueInput | DamageTypeWhereUniqueInput[]
    connect?: DamageTypeWhereUniqueInput | DamageTypeWhereUniqueInput[]
    update?: DamageTypeUpdateWithWhereUniqueWithoutVunlerable_creaturesInput | DamageTypeUpdateWithWhereUniqueWithoutVunlerable_creaturesInput[]
    updateMany?: DamageTypeUpdateManyWithWhereWithoutVunlerable_creaturesInput | DamageTypeUpdateManyWithWhereWithoutVunlerable_creaturesInput[]
    deleteMany?: DamageTypeScalarWhereInput | DamageTypeScalarWhereInput[]
  }

  export type SensesUncheckedUpdateOneWithoutCreatureNestedInput = {
    create?: XOR<SensesCreateWithoutCreatureInput, SensesUncheckedCreateWithoutCreatureInput>
    connectOrCreate?: SensesCreateOrConnectWithoutCreatureInput
    upsert?: SensesUpsertWithoutCreatureInput
    disconnect?: SensesWhereInput | boolean
    delete?: SensesWhereInput | boolean
    connect?: SensesWhereUniqueInput
    update?: XOR<XOR<SensesUpdateToOneWithWhereWithoutCreatureInput, SensesUpdateWithoutCreatureInput>, SensesUncheckedUpdateWithoutCreatureInput>
  }

  export type LanguageUncheckedUpdateManyWithoutCreaturesNestedInput = {
    create?: XOR<LanguageCreateWithoutCreaturesInput, LanguageUncheckedCreateWithoutCreaturesInput> | LanguageCreateWithoutCreaturesInput[] | LanguageUncheckedCreateWithoutCreaturesInput[]
    connectOrCreate?: LanguageCreateOrConnectWithoutCreaturesInput | LanguageCreateOrConnectWithoutCreaturesInput[]
    upsert?: LanguageUpsertWithWhereUniqueWithoutCreaturesInput | LanguageUpsertWithWhereUniqueWithoutCreaturesInput[]
    set?: LanguageWhereUniqueInput | LanguageWhereUniqueInput[]
    disconnect?: LanguageWhereUniqueInput | LanguageWhereUniqueInput[]
    delete?: LanguageWhereUniqueInput | LanguageWhereUniqueInput[]
    connect?: LanguageWhereUniqueInput | LanguageWhereUniqueInput[]
    update?: LanguageUpdateWithWhereUniqueWithoutCreaturesInput | LanguageUpdateWithWhereUniqueWithoutCreaturesInput[]
    updateMany?: LanguageUpdateManyWithWhereWithoutCreaturesInput | LanguageUpdateManyWithWhereWithoutCreaturesInput[]
    deleteMany?: LanguageScalarWhereInput | LanguageScalarWhereInput[]
  }

  export type ActionUncheckedUpdateManyWithoutCreaturesNestedInput = {
    create?: XOR<ActionCreateWithoutCreaturesInput, ActionUncheckedCreateWithoutCreaturesInput> | ActionCreateWithoutCreaturesInput[] | ActionUncheckedCreateWithoutCreaturesInput[]
    connectOrCreate?: ActionCreateOrConnectWithoutCreaturesInput | ActionCreateOrConnectWithoutCreaturesInput[]
    upsert?: ActionUpsertWithWhereUniqueWithoutCreaturesInput | ActionUpsertWithWhereUniqueWithoutCreaturesInput[]
    set?: ActionWhereUniqueInput | ActionWhereUniqueInput[]
    disconnect?: ActionWhereUniqueInput | ActionWhereUniqueInput[]
    delete?: ActionWhereUniqueInput | ActionWhereUniqueInput[]
    connect?: ActionWhereUniqueInput | ActionWhereUniqueInput[]
    update?: ActionUpdateWithWhereUniqueWithoutCreaturesInput | ActionUpdateWithWhereUniqueWithoutCreaturesInput[]
    updateMany?: ActionUpdateManyWithWhereWithoutCreaturesInput | ActionUpdateManyWithWhereWithoutCreaturesInput[]
    deleteMany?: ActionScalarWhereInput | ActionScalarWhereInput[]
  }

  export type TraitUncheckedUpdateManyWithoutCreturesNestedInput = {
    create?: XOR<TraitCreateWithoutCreturesInput, TraitUncheckedCreateWithoutCreturesInput> | TraitCreateWithoutCreturesInput[] | TraitUncheckedCreateWithoutCreturesInput[]
    connectOrCreate?: TraitCreateOrConnectWithoutCreturesInput | TraitCreateOrConnectWithoutCreturesInput[]
    upsert?: TraitUpsertWithWhereUniqueWithoutCreturesInput | TraitUpsertWithWhereUniqueWithoutCreturesInput[]
    set?: TraitWhereUniqueInput | TraitWhereUniqueInput[]
    disconnect?: TraitWhereUniqueInput | TraitWhereUniqueInput[]
    delete?: TraitWhereUniqueInput | TraitWhereUniqueInput[]
    connect?: TraitWhereUniqueInput | TraitWhereUniqueInput[]
    update?: TraitUpdateWithWhereUniqueWithoutCreturesInput | TraitUpdateWithWhereUniqueWithoutCreturesInput[]
    updateMany?: TraitUpdateManyWithWhereWithoutCreturesInput | TraitUpdateManyWithWhereWithoutCreturesInput[]
    deleteMany?: TraitScalarWhereInput | TraitScalarWhereInput[]
  }

  export type BiomeUncheckedUpdateManyWithoutCreaturesNestedInput = {
    create?: XOR<BiomeCreateWithoutCreaturesInput, BiomeUncheckedCreateWithoutCreaturesInput> | BiomeCreateWithoutCreaturesInput[] | BiomeUncheckedCreateWithoutCreaturesInput[]
    connectOrCreate?: BiomeCreateOrConnectWithoutCreaturesInput | BiomeCreateOrConnectWithoutCreaturesInput[]
    upsert?: BiomeUpsertWithWhereUniqueWithoutCreaturesInput | BiomeUpsertWithWhereUniqueWithoutCreaturesInput[]
    set?: BiomeWhereUniqueInput | BiomeWhereUniqueInput[]
    disconnect?: BiomeWhereUniqueInput | BiomeWhereUniqueInput[]
    delete?: BiomeWhereUniqueInput | BiomeWhereUniqueInput[]
    connect?: BiomeWhereUniqueInput | BiomeWhereUniqueInput[]
    update?: BiomeUpdateWithWhereUniqueWithoutCreaturesInput | BiomeUpdateWithWhereUniqueWithoutCreaturesInput[]
    updateMany?: BiomeUpdateManyWithWhereWithoutCreaturesInput | BiomeUpdateManyWithWhereWithoutCreaturesInput[]
    deleteMany?: BiomeScalarWhereInput | BiomeScalarWhereInput[]
  }

  export type CreatureCreateNestedOneWithoutSensesInput = {
    create?: XOR<CreatureCreateWithoutSensesInput, CreatureUncheckedCreateWithoutSensesInput>
    connectOrCreate?: CreatureCreateOrConnectWithoutSensesInput
    connect?: CreatureWhereUniqueInput
  }

  export type CreatureUpdateOneRequiredWithoutSensesNestedInput = {
    create?: XOR<CreatureCreateWithoutSensesInput, CreatureUncheckedCreateWithoutSensesInput>
    connectOrCreate?: CreatureCreateOrConnectWithoutSensesInput
    upsert?: CreatureUpsertWithoutSensesInput
    connect?: CreatureWhereUniqueInput
    update?: XOR<XOR<CreatureUpdateToOneWithWhereWithoutSensesInput, CreatureUpdateWithoutSensesInput>, CreatureUncheckedUpdateWithoutSensesInput>
  }

  export type CreatureCreateNestedManyWithoutActionsInput = {
    create?: XOR<CreatureCreateWithoutActionsInput, CreatureUncheckedCreateWithoutActionsInput> | CreatureCreateWithoutActionsInput[] | CreatureUncheckedCreateWithoutActionsInput[]
    connectOrCreate?: CreatureCreateOrConnectWithoutActionsInput | CreatureCreateOrConnectWithoutActionsInput[]
    connect?: CreatureWhereUniqueInput | CreatureWhereUniqueInput[]
  }

  export type CreatureRaceCreateNestedManyWithoutActionsInput = {
    create?: XOR<CreatureRaceCreateWithoutActionsInput, CreatureRaceUncheckedCreateWithoutActionsInput> | CreatureRaceCreateWithoutActionsInput[] | CreatureRaceUncheckedCreateWithoutActionsInput[]
    connectOrCreate?: CreatureRaceCreateOrConnectWithoutActionsInput | CreatureRaceCreateOrConnectWithoutActionsInput[]
    connect?: CreatureRaceWhereUniqueInput | CreatureRaceWhereUniqueInput[]
  }

  export type CreatureUncheckedCreateNestedManyWithoutActionsInput = {
    create?: XOR<CreatureCreateWithoutActionsInput, CreatureUncheckedCreateWithoutActionsInput> | CreatureCreateWithoutActionsInput[] | CreatureUncheckedCreateWithoutActionsInput[]
    connectOrCreate?: CreatureCreateOrConnectWithoutActionsInput | CreatureCreateOrConnectWithoutActionsInput[]
    connect?: CreatureWhereUniqueInput | CreatureWhereUniqueInput[]
  }

  export type CreatureRaceUncheckedCreateNestedManyWithoutActionsInput = {
    create?: XOR<CreatureRaceCreateWithoutActionsInput, CreatureRaceUncheckedCreateWithoutActionsInput> | CreatureRaceCreateWithoutActionsInput[] | CreatureRaceUncheckedCreateWithoutActionsInput[]
    connectOrCreate?: CreatureRaceCreateOrConnectWithoutActionsInput | CreatureRaceCreateOrConnectWithoutActionsInput[]
    connect?: CreatureRaceWhereUniqueInput | CreatureRaceWhereUniqueInput[]
  }

  export type NullableBoolFieldUpdateOperationsInput = {
    set?: boolean | null
  }

  export type CreatureUpdateManyWithoutActionsNestedInput = {
    create?: XOR<CreatureCreateWithoutActionsInput, CreatureUncheckedCreateWithoutActionsInput> | CreatureCreateWithoutActionsInput[] | CreatureUncheckedCreateWithoutActionsInput[]
    connectOrCreate?: CreatureCreateOrConnectWithoutActionsInput | CreatureCreateOrConnectWithoutActionsInput[]
    upsert?: CreatureUpsertWithWhereUniqueWithoutActionsInput | CreatureUpsertWithWhereUniqueWithoutActionsInput[]
    set?: CreatureWhereUniqueInput | CreatureWhereUniqueInput[]
    disconnect?: CreatureWhereUniqueInput | CreatureWhereUniqueInput[]
    delete?: CreatureWhereUniqueInput | CreatureWhereUniqueInput[]
    connect?: CreatureWhereUniqueInput | CreatureWhereUniqueInput[]
    update?: CreatureUpdateWithWhereUniqueWithoutActionsInput | CreatureUpdateWithWhereUniqueWithoutActionsInput[]
    updateMany?: CreatureUpdateManyWithWhereWithoutActionsInput | CreatureUpdateManyWithWhereWithoutActionsInput[]
    deleteMany?: CreatureScalarWhereInput | CreatureScalarWhereInput[]
  }

  export type CreatureRaceUpdateManyWithoutActionsNestedInput = {
    create?: XOR<CreatureRaceCreateWithoutActionsInput, CreatureRaceUncheckedCreateWithoutActionsInput> | CreatureRaceCreateWithoutActionsInput[] | CreatureRaceUncheckedCreateWithoutActionsInput[]
    connectOrCreate?: CreatureRaceCreateOrConnectWithoutActionsInput | CreatureRaceCreateOrConnectWithoutActionsInput[]
    upsert?: CreatureRaceUpsertWithWhereUniqueWithoutActionsInput | CreatureRaceUpsertWithWhereUniqueWithoutActionsInput[]
    set?: CreatureRaceWhereUniqueInput | CreatureRaceWhereUniqueInput[]
    disconnect?: CreatureRaceWhereUniqueInput | CreatureRaceWhereUniqueInput[]
    delete?: CreatureRaceWhereUniqueInput | CreatureRaceWhereUniqueInput[]
    connect?: CreatureRaceWhereUniqueInput | CreatureRaceWhereUniqueInput[]
    update?: CreatureRaceUpdateWithWhereUniqueWithoutActionsInput | CreatureRaceUpdateWithWhereUniqueWithoutActionsInput[]
    updateMany?: CreatureRaceUpdateManyWithWhereWithoutActionsInput | CreatureRaceUpdateManyWithWhereWithoutActionsInput[]
    deleteMany?: CreatureRaceScalarWhereInput | CreatureRaceScalarWhereInput[]
  }

  export type CreatureUncheckedUpdateManyWithoutActionsNestedInput = {
    create?: XOR<CreatureCreateWithoutActionsInput, CreatureUncheckedCreateWithoutActionsInput> | CreatureCreateWithoutActionsInput[] | CreatureUncheckedCreateWithoutActionsInput[]
    connectOrCreate?: CreatureCreateOrConnectWithoutActionsInput | CreatureCreateOrConnectWithoutActionsInput[]
    upsert?: CreatureUpsertWithWhereUniqueWithoutActionsInput | CreatureUpsertWithWhereUniqueWithoutActionsInput[]
    set?: CreatureWhereUniqueInput | CreatureWhereUniqueInput[]
    disconnect?: CreatureWhereUniqueInput | CreatureWhereUniqueInput[]
    delete?: CreatureWhereUniqueInput | CreatureWhereUniqueInput[]
    connect?: CreatureWhereUniqueInput | CreatureWhereUniqueInput[]
    update?: CreatureUpdateWithWhereUniqueWithoutActionsInput | CreatureUpdateWithWhereUniqueWithoutActionsInput[]
    updateMany?: CreatureUpdateManyWithWhereWithoutActionsInput | CreatureUpdateManyWithWhereWithoutActionsInput[]
    deleteMany?: CreatureScalarWhereInput | CreatureScalarWhereInput[]
  }

  export type CreatureRaceUncheckedUpdateManyWithoutActionsNestedInput = {
    create?: XOR<CreatureRaceCreateWithoutActionsInput, CreatureRaceUncheckedCreateWithoutActionsInput> | CreatureRaceCreateWithoutActionsInput[] | CreatureRaceUncheckedCreateWithoutActionsInput[]
    connectOrCreate?: CreatureRaceCreateOrConnectWithoutActionsInput | CreatureRaceCreateOrConnectWithoutActionsInput[]
    upsert?: CreatureRaceUpsertWithWhereUniqueWithoutActionsInput | CreatureRaceUpsertWithWhereUniqueWithoutActionsInput[]
    set?: CreatureRaceWhereUniqueInput | CreatureRaceWhereUniqueInput[]
    disconnect?: CreatureRaceWhereUniqueInput | CreatureRaceWhereUniqueInput[]
    delete?: CreatureRaceWhereUniqueInput | CreatureRaceWhereUniqueInput[]
    connect?: CreatureRaceWhereUniqueInput | CreatureRaceWhereUniqueInput[]
    update?: CreatureRaceUpdateWithWhereUniqueWithoutActionsInput | CreatureRaceUpdateWithWhereUniqueWithoutActionsInput[]
    updateMany?: CreatureRaceUpdateManyWithWhereWithoutActionsInput | CreatureRaceUpdateManyWithWhereWithoutActionsInput[]
    deleteMany?: CreatureRaceScalarWhereInput | CreatureRaceScalarWhereInput[]
  }

  export type CreatureCreateNestedManyWithoutTraitsInput = {
    create?: XOR<CreatureCreateWithoutTraitsInput, CreatureUncheckedCreateWithoutTraitsInput> | CreatureCreateWithoutTraitsInput[] | CreatureUncheckedCreateWithoutTraitsInput[]
    connectOrCreate?: CreatureCreateOrConnectWithoutTraitsInput | CreatureCreateOrConnectWithoutTraitsInput[]
    connect?: CreatureWhereUniqueInput | CreatureWhereUniqueInput[]
  }

  export type CreatureRaceCreateNestedManyWithoutTraitsInput = {
    create?: XOR<CreatureRaceCreateWithoutTraitsInput, CreatureRaceUncheckedCreateWithoutTraitsInput> | CreatureRaceCreateWithoutTraitsInput[] | CreatureRaceUncheckedCreateWithoutTraitsInput[]
    connectOrCreate?: CreatureRaceCreateOrConnectWithoutTraitsInput | CreatureRaceCreateOrConnectWithoutTraitsInput[]
    connect?: CreatureRaceWhereUniqueInput | CreatureRaceWhereUniqueInput[]
  }

  export type CreatureUncheckedCreateNestedManyWithoutTraitsInput = {
    create?: XOR<CreatureCreateWithoutTraitsInput, CreatureUncheckedCreateWithoutTraitsInput> | CreatureCreateWithoutTraitsInput[] | CreatureUncheckedCreateWithoutTraitsInput[]
    connectOrCreate?: CreatureCreateOrConnectWithoutTraitsInput | CreatureCreateOrConnectWithoutTraitsInput[]
    connect?: CreatureWhereUniqueInput | CreatureWhereUniqueInput[]
  }

  export type CreatureRaceUncheckedCreateNestedManyWithoutTraitsInput = {
    create?: XOR<CreatureRaceCreateWithoutTraitsInput, CreatureRaceUncheckedCreateWithoutTraitsInput> | CreatureRaceCreateWithoutTraitsInput[] | CreatureRaceUncheckedCreateWithoutTraitsInput[]
    connectOrCreate?: CreatureRaceCreateOrConnectWithoutTraitsInput | CreatureRaceCreateOrConnectWithoutTraitsInput[]
    connect?: CreatureRaceWhereUniqueInput | CreatureRaceWhereUniqueInput[]
  }

  export type CreatureUpdateManyWithoutTraitsNestedInput = {
    create?: XOR<CreatureCreateWithoutTraitsInput, CreatureUncheckedCreateWithoutTraitsInput> | CreatureCreateWithoutTraitsInput[] | CreatureUncheckedCreateWithoutTraitsInput[]
    connectOrCreate?: CreatureCreateOrConnectWithoutTraitsInput | CreatureCreateOrConnectWithoutTraitsInput[]
    upsert?: CreatureUpsertWithWhereUniqueWithoutTraitsInput | CreatureUpsertWithWhereUniqueWithoutTraitsInput[]
    set?: CreatureWhereUniqueInput | CreatureWhereUniqueInput[]
    disconnect?: CreatureWhereUniqueInput | CreatureWhereUniqueInput[]
    delete?: CreatureWhereUniqueInput | CreatureWhereUniqueInput[]
    connect?: CreatureWhereUniqueInput | CreatureWhereUniqueInput[]
    update?: CreatureUpdateWithWhereUniqueWithoutTraitsInput | CreatureUpdateWithWhereUniqueWithoutTraitsInput[]
    updateMany?: CreatureUpdateManyWithWhereWithoutTraitsInput | CreatureUpdateManyWithWhereWithoutTraitsInput[]
    deleteMany?: CreatureScalarWhereInput | CreatureScalarWhereInput[]
  }

  export type CreatureRaceUpdateManyWithoutTraitsNestedInput = {
    create?: XOR<CreatureRaceCreateWithoutTraitsInput, CreatureRaceUncheckedCreateWithoutTraitsInput> | CreatureRaceCreateWithoutTraitsInput[] | CreatureRaceUncheckedCreateWithoutTraitsInput[]
    connectOrCreate?: CreatureRaceCreateOrConnectWithoutTraitsInput | CreatureRaceCreateOrConnectWithoutTraitsInput[]
    upsert?: CreatureRaceUpsertWithWhereUniqueWithoutTraitsInput | CreatureRaceUpsertWithWhereUniqueWithoutTraitsInput[]
    set?: CreatureRaceWhereUniqueInput | CreatureRaceWhereUniqueInput[]
    disconnect?: CreatureRaceWhereUniqueInput | CreatureRaceWhereUniqueInput[]
    delete?: CreatureRaceWhereUniqueInput | CreatureRaceWhereUniqueInput[]
    connect?: CreatureRaceWhereUniqueInput | CreatureRaceWhereUniqueInput[]
    update?: CreatureRaceUpdateWithWhereUniqueWithoutTraitsInput | CreatureRaceUpdateWithWhereUniqueWithoutTraitsInput[]
    updateMany?: CreatureRaceUpdateManyWithWhereWithoutTraitsInput | CreatureRaceUpdateManyWithWhereWithoutTraitsInput[]
    deleteMany?: CreatureRaceScalarWhereInput | CreatureRaceScalarWhereInput[]
  }

  export type CreatureUncheckedUpdateManyWithoutTraitsNestedInput = {
    create?: XOR<CreatureCreateWithoutTraitsInput, CreatureUncheckedCreateWithoutTraitsInput> | CreatureCreateWithoutTraitsInput[] | CreatureUncheckedCreateWithoutTraitsInput[]
    connectOrCreate?: CreatureCreateOrConnectWithoutTraitsInput | CreatureCreateOrConnectWithoutTraitsInput[]
    upsert?: CreatureUpsertWithWhereUniqueWithoutTraitsInput | CreatureUpsertWithWhereUniqueWithoutTraitsInput[]
    set?: CreatureWhereUniqueInput | CreatureWhereUniqueInput[]
    disconnect?: CreatureWhereUniqueInput | CreatureWhereUniqueInput[]
    delete?: CreatureWhereUniqueInput | CreatureWhereUniqueInput[]
    connect?: CreatureWhereUniqueInput | CreatureWhereUniqueInput[]
    update?: CreatureUpdateWithWhereUniqueWithoutTraitsInput | CreatureUpdateWithWhereUniqueWithoutTraitsInput[]
    updateMany?: CreatureUpdateManyWithWhereWithoutTraitsInput | CreatureUpdateManyWithWhereWithoutTraitsInput[]
    deleteMany?: CreatureScalarWhereInput | CreatureScalarWhereInput[]
  }

  export type CreatureRaceUncheckedUpdateManyWithoutTraitsNestedInput = {
    create?: XOR<CreatureRaceCreateWithoutTraitsInput, CreatureRaceUncheckedCreateWithoutTraitsInput> | CreatureRaceCreateWithoutTraitsInput[] | CreatureRaceUncheckedCreateWithoutTraitsInput[]
    connectOrCreate?: CreatureRaceCreateOrConnectWithoutTraitsInput | CreatureRaceCreateOrConnectWithoutTraitsInput[]
    upsert?: CreatureRaceUpsertWithWhereUniqueWithoutTraitsInput | CreatureRaceUpsertWithWhereUniqueWithoutTraitsInput[]
    set?: CreatureRaceWhereUniqueInput | CreatureRaceWhereUniqueInput[]
    disconnect?: CreatureRaceWhereUniqueInput | CreatureRaceWhereUniqueInput[]
    delete?: CreatureRaceWhereUniqueInput | CreatureRaceWhereUniqueInput[]
    connect?: CreatureRaceWhereUniqueInput | CreatureRaceWhereUniqueInput[]
    update?: CreatureRaceUpdateWithWhereUniqueWithoutTraitsInput | CreatureRaceUpdateWithWhereUniqueWithoutTraitsInput[]
    updateMany?: CreatureRaceUpdateManyWithWhereWithoutTraitsInput | CreatureRaceUpdateManyWithWhereWithoutTraitsInput[]
    deleteMany?: CreatureRaceScalarWhereInput | CreatureRaceScalarWhereInput[]
  }

  export type TraitCreateNestedManyWithoutCreatureTypesInput = {
    create?: XOR<TraitCreateWithoutCreatureTypesInput, TraitUncheckedCreateWithoutCreatureTypesInput> | TraitCreateWithoutCreatureTypesInput[] | TraitUncheckedCreateWithoutCreatureTypesInput[]
    connectOrCreate?: TraitCreateOrConnectWithoutCreatureTypesInput | TraitCreateOrConnectWithoutCreatureTypesInput[]
    connect?: TraitWhereUniqueInput | TraitWhereUniqueInput[]
  }

  export type ActionCreateNestedManyWithoutCreatureTypesInput = {
    create?: XOR<ActionCreateWithoutCreatureTypesInput, ActionUncheckedCreateWithoutCreatureTypesInput> | ActionCreateWithoutCreatureTypesInput[] | ActionUncheckedCreateWithoutCreatureTypesInput[]
    connectOrCreate?: ActionCreateOrConnectWithoutCreatureTypesInput | ActionCreateOrConnectWithoutCreatureTypesInput[]
    connect?: ActionWhereUniqueInput | ActionWhereUniqueInput[]
  }

  export type CreatureCreateNestedManyWithoutRace_relationInput = {
    create?: XOR<CreatureCreateWithoutRace_relationInput, CreatureUncheckedCreateWithoutRace_relationInput> | CreatureCreateWithoutRace_relationInput[] | CreatureUncheckedCreateWithoutRace_relationInput[]
    connectOrCreate?: CreatureCreateOrConnectWithoutRace_relationInput | CreatureCreateOrConnectWithoutRace_relationInput[]
    createMany?: CreatureCreateManyRace_relationInputEnvelope
    connect?: CreatureWhereUniqueInput | CreatureWhereUniqueInput[]
  }

  export type TraitUncheckedCreateNestedManyWithoutCreatureTypesInput = {
    create?: XOR<TraitCreateWithoutCreatureTypesInput, TraitUncheckedCreateWithoutCreatureTypesInput> | TraitCreateWithoutCreatureTypesInput[] | TraitUncheckedCreateWithoutCreatureTypesInput[]
    connectOrCreate?: TraitCreateOrConnectWithoutCreatureTypesInput | TraitCreateOrConnectWithoutCreatureTypesInput[]
    connect?: TraitWhereUniqueInput | TraitWhereUniqueInput[]
  }

  export type ActionUncheckedCreateNestedManyWithoutCreatureTypesInput = {
    create?: XOR<ActionCreateWithoutCreatureTypesInput, ActionUncheckedCreateWithoutCreatureTypesInput> | ActionCreateWithoutCreatureTypesInput[] | ActionUncheckedCreateWithoutCreatureTypesInput[]
    connectOrCreate?: ActionCreateOrConnectWithoutCreatureTypesInput | ActionCreateOrConnectWithoutCreatureTypesInput[]
    connect?: ActionWhereUniqueInput | ActionWhereUniqueInput[]
  }

  export type CreatureUncheckedCreateNestedManyWithoutRace_relationInput = {
    create?: XOR<CreatureCreateWithoutRace_relationInput, CreatureUncheckedCreateWithoutRace_relationInput> | CreatureCreateWithoutRace_relationInput[] | CreatureUncheckedCreateWithoutRace_relationInput[]
    connectOrCreate?: CreatureCreateOrConnectWithoutRace_relationInput | CreatureCreateOrConnectWithoutRace_relationInput[]
    createMany?: CreatureCreateManyRace_relationInputEnvelope
    connect?: CreatureWhereUniqueInput | CreatureWhereUniqueInput[]
  }

  export type TraitUpdateManyWithoutCreatureTypesNestedInput = {
    create?: XOR<TraitCreateWithoutCreatureTypesInput, TraitUncheckedCreateWithoutCreatureTypesInput> | TraitCreateWithoutCreatureTypesInput[] | TraitUncheckedCreateWithoutCreatureTypesInput[]
    connectOrCreate?: TraitCreateOrConnectWithoutCreatureTypesInput | TraitCreateOrConnectWithoutCreatureTypesInput[]
    upsert?: TraitUpsertWithWhereUniqueWithoutCreatureTypesInput | TraitUpsertWithWhereUniqueWithoutCreatureTypesInput[]
    set?: TraitWhereUniqueInput | TraitWhereUniqueInput[]
    disconnect?: TraitWhereUniqueInput | TraitWhereUniqueInput[]
    delete?: TraitWhereUniqueInput | TraitWhereUniqueInput[]
    connect?: TraitWhereUniqueInput | TraitWhereUniqueInput[]
    update?: TraitUpdateWithWhereUniqueWithoutCreatureTypesInput | TraitUpdateWithWhereUniqueWithoutCreatureTypesInput[]
    updateMany?: TraitUpdateManyWithWhereWithoutCreatureTypesInput | TraitUpdateManyWithWhereWithoutCreatureTypesInput[]
    deleteMany?: TraitScalarWhereInput | TraitScalarWhereInput[]
  }

  export type ActionUpdateManyWithoutCreatureTypesNestedInput = {
    create?: XOR<ActionCreateWithoutCreatureTypesInput, ActionUncheckedCreateWithoutCreatureTypesInput> | ActionCreateWithoutCreatureTypesInput[] | ActionUncheckedCreateWithoutCreatureTypesInput[]
    connectOrCreate?: ActionCreateOrConnectWithoutCreatureTypesInput | ActionCreateOrConnectWithoutCreatureTypesInput[]
    upsert?: ActionUpsertWithWhereUniqueWithoutCreatureTypesInput | ActionUpsertWithWhereUniqueWithoutCreatureTypesInput[]
    set?: ActionWhereUniqueInput | ActionWhereUniqueInput[]
    disconnect?: ActionWhereUniqueInput | ActionWhereUniqueInput[]
    delete?: ActionWhereUniqueInput | ActionWhereUniqueInput[]
    connect?: ActionWhereUniqueInput | ActionWhereUniqueInput[]
    update?: ActionUpdateWithWhereUniqueWithoutCreatureTypesInput | ActionUpdateWithWhereUniqueWithoutCreatureTypesInput[]
    updateMany?: ActionUpdateManyWithWhereWithoutCreatureTypesInput | ActionUpdateManyWithWhereWithoutCreatureTypesInput[]
    deleteMany?: ActionScalarWhereInput | ActionScalarWhereInput[]
  }

  export type CreatureUpdateManyWithoutRace_relationNestedInput = {
    create?: XOR<CreatureCreateWithoutRace_relationInput, CreatureUncheckedCreateWithoutRace_relationInput> | CreatureCreateWithoutRace_relationInput[] | CreatureUncheckedCreateWithoutRace_relationInput[]
    connectOrCreate?: CreatureCreateOrConnectWithoutRace_relationInput | CreatureCreateOrConnectWithoutRace_relationInput[]
    upsert?: CreatureUpsertWithWhereUniqueWithoutRace_relationInput | CreatureUpsertWithWhereUniqueWithoutRace_relationInput[]
    createMany?: CreatureCreateManyRace_relationInputEnvelope
    set?: CreatureWhereUniqueInput | CreatureWhereUniqueInput[]
    disconnect?: CreatureWhereUniqueInput | CreatureWhereUniqueInput[]
    delete?: CreatureWhereUniqueInput | CreatureWhereUniqueInput[]
    connect?: CreatureWhereUniqueInput | CreatureWhereUniqueInput[]
    update?: CreatureUpdateWithWhereUniqueWithoutRace_relationInput | CreatureUpdateWithWhereUniqueWithoutRace_relationInput[]
    updateMany?: CreatureUpdateManyWithWhereWithoutRace_relationInput | CreatureUpdateManyWithWhereWithoutRace_relationInput[]
    deleteMany?: CreatureScalarWhereInput | CreatureScalarWhereInput[]
  }

  export type TraitUncheckedUpdateManyWithoutCreatureTypesNestedInput = {
    create?: XOR<TraitCreateWithoutCreatureTypesInput, TraitUncheckedCreateWithoutCreatureTypesInput> | TraitCreateWithoutCreatureTypesInput[] | TraitUncheckedCreateWithoutCreatureTypesInput[]
    connectOrCreate?: TraitCreateOrConnectWithoutCreatureTypesInput | TraitCreateOrConnectWithoutCreatureTypesInput[]
    upsert?: TraitUpsertWithWhereUniqueWithoutCreatureTypesInput | TraitUpsertWithWhereUniqueWithoutCreatureTypesInput[]
    set?: TraitWhereUniqueInput | TraitWhereUniqueInput[]
    disconnect?: TraitWhereUniqueInput | TraitWhereUniqueInput[]
    delete?: TraitWhereUniqueInput | TraitWhereUniqueInput[]
    connect?: TraitWhereUniqueInput | TraitWhereUniqueInput[]
    update?: TraitUpdateWithWhereUniqueWithoutCreatureTypesInput | TraitUpdateWithWhereUniqueWithoutCreatureTypesInput[]
    updateMany?: TraitUpdateManyWithWhereWithoutCreatureTypesInput | TraitUpdateManyWithWhereWithoutCreatureTypesInput[]
    deleteMany?: TraitScalarWhereInput | TraitScalarWhereInput[]
  }

  export type ActionUncheckedUpdateManyWithoutCreatureTypesNestedInput = {
    create?: XOR<ActionCreateWithoutCreatureTypesInput, ActionUncheckedCreateWithoutCreatureTypesInput> | ActionCreateWithoutCreatureTypesInput[] | ActionUncheckedCreateWithoutCreatureTypesInput[]
    connectOrCreate?: ActionCreateOrConnectWithoutCreatureTypesInput | ActionCreateOrConnectWithoutCreatureTypesInput[]
    upsert?: ActionUpsertWithWhereUniqueWithoutCreatureTypesInput | ActionUpsertWithWhereUniqueWithoutCreatureTypesInput[]
    set?: ActionWhereUniqueInput | ActionWhereUniqueInput[]
    disconnect?: ActionWhereUniqueInput | ActionWhereUniqueInput[]
    delete?: ActionWhereUniqueInput | ActionWhereUniqueInput[]
    connect?: ActionWhereUniqueInput | ActionWhereUniqueInput[]
    update?: ActionUpdateWithWhereUniqueWithoutCreatureTypesInput | ActionUpdateWithWhereUniqueWithoutCreatureTypesInput[]
    updateMany?: ActionUpdateManyWithWhereWithoutCreatureTypesInput | ActionUpdateManyWithWhereWithoutCreatureTypesInput[]
    deleteMany?: ActionScalarWhereInput | ActionScalarWhereInput[]
  }

  export type CreatureUncheckedUpdateManyWithoutRace_relationNestedInput = {
    create?: XOR<CreatureCreateWithoutRace_relationInput, CreatureUncheckedCreateWithoutRace_relationInput> | CreatureCreateWithoutRace_relationInput[] | CreatureUncheckedCreateWithoutRace_relationInput[]
    connectOrCreate?: CreatureCreateOrConnectWithoutRace_relationInput | CreatureCreateOrConnectWithoutRace_relationInput[]
    upsert?: CreatureUpsertWithWhereUniqueWithoutRace_relationInput | CreatureUpsertWithWhereUniqueWithoutRace_relationInput[]
    createMany?: CreatureCreateManyRace_relationInputEnvelope
    set?: CreatureWhereUniqueInput | CreatureWhereUniqueInput[]
    disconnect?: CreatureWhereUniqueInput | CreatureWhereUniqueInput[]
    delete?: CreatureWhereUniqueInput | CreatureWhereUniqueInput[]
    connect?: CreatureWhereUniqueInput | CreatureWhereUniqueInput[]
    update?: CreatureUpdateWithWhereUniqueWithoutRace_relationInput | CreatureUpdateWithWhereUniqueWithoutRace_relationInput[]
    updateMany?: CreatureUpdateManyWithWhereWithoutRace_relationInput | CreatureUpdateManyWithWhereWithoutRace_relationInput[]
    deleteMany?: CreatureScalarWhereInput | CreatureScalarWhereInput[]
  }

  export type CreatureCreateNestedManyWithoutResistancesInput = {
    create?: XOR<CreatureCreateWithoutResistancesInput, CreatureUncheckedCreateWithoutResistancesInput> | CreatureCreateWithoutResistancesInput[] | CreatureUncheckedCreateWithoutResistancesInput[]
    connectOrCreate?: CreatureCreateOrConnectWithoutResistancesInput | CreatureCreateOrConnectWithoutResistancesInput[]
    connect?: CreatureWhereUniqueInput | CreatureWhereUniqueInput[]
  }

  export type CreatureCreateNestedManyWithoutImmunitiesInput = {
    create?: XOR<CreatureCreateWithoutImmunitiesInput, CreatureUncheckedCreateWithoutImmunitiesInput> | CreatureCreateWithoutImmunitiesInput[] | CreatureUncheckedCreateWithoutImmunitiesInput[]
    connectOrCreate?: CreatureCreateOrConnectWithoutImmunitiesInput | CreatureCreateOrConnectWithoutImmunitiesInput[]
    connect?: CreatureWhereUniqueInput | CreatureWhereUniqueInput[]
  }

  export type CreatureCreateNestedManyWithoutVulnerabilitiesInput = {
    create?: XOR<CreatureCreateWithoutVulnerabilitiesInput, CreatureUncheckedCreateWithoutVulnerabilitiesInput> | CreatureCreateWithoutVulnerabilitiesInput[] | CreatureUncheckedCreateWithoutVulnerabilitiesInput[]
    connectOrCreate?: CreatureCreateOrConnectWithoutVulnerabilitiesInput | CreatureCreateOrConnectWithoutVulnerabilitiesInput[]
    connect?: CreatureWhereUniqueInput | CreatureWhereUniqueInput[]
  }

  export type CreatureUncheckedCreateNestedManyWithoutResistancesInput = {
    create?: XOR<CreatureCreateWithoutResistancesInput, CreatureUncheckedCreateWithoutResistancesInput> | CreatureCreateWithoutResistancesInput[] | CreatureUncheckedCreateWithoutResistancesInput[]
    connectOrCreate?: CreatureCreateOrConnectWithoutResistancesInput | CreatureCreateOrConnectWithoutResistancesInput[]
    connect?: CreatureWhereUniqueInput | CreatureWhereUniqueInput[]
  }

  export type CreatureUncheckedCreateNestedManyWithoutImmunitiesInput = {
    create?: XOR<CreatureCreateWithoutImmunitiesInput, CreatureUncheckedCreateWithoutImmunitiesInput> | CreatureCreateWithoutImmunitiesInput[] | CreatureUncheckedCreateWithoutImmunitiesInput[]
    connectOrCreate?: CreatureCreateOrConnectWithoutImmunitiesInput | CreatureCreateOrConnectWithoutImmunitiesInput[]
    connect?: CreatureWhereUniqueInput | CreatureWhereUniqueInput[]
  }

  export type CreatureUncheckedCreateNestedManyWithoutVulnerabilitiesInput = {
    create?: XOR<CreatureCreateWithoutVulnerabilitiesInput, CreatureUncheckedCreateWithoutVulnerabilitiesInput> | CreatureCreateWithoutVulnerabilitiesInput[] | CreatureUncheckedCreateWithoutVulnerabilitiesInput[]
    connectOrCreate?: CreatureCreateOrConnectWithoutVulnerabilitiesInput | CreatureCreateOrConnectWithoutVulnerabilitiesInput[]
    connect?: CreatureWhereUniqueInput | CreatureWhereUniqueInput[]
  }

  export type CreatureUpdateManyWithoutResistancesNestedInput = {
    create?: XOR<CreatureCreateWithoutResistancesInput, CreatureUncheckedCreateWithoutResistancesInput> | CreatureCreateWithoutResistancesInput[] | CreatureUncheckedCreateWithoutResistancesInput[]
    connectOrCreate?: CreatureCreateOrConnectWithoutResistancesInput | CreatureCreateOrConnectWithoutResistancesInput[]
    upsert?: CreatureUpsertWithWhereUniqueWithoutResistancesInput | CreatureUpsertWithWhereUniqueWithoutResistancesInput[]
    set?: CreatureWhereUniqueInput | CreatureWhereUniqueInput[]
    disconnect?: CreatureWhereUniqueInput | CreatureWhereUniqueInput[]
    delete?: CreatureWhereUniqueInput | CreatureWhereUniqueInput[]
    connect?: CreatureWhereUniqueInput | CreatureWhereUniqueInput[]
    update?: CreatureUpdateWithWhereUniqueWithoutResistancesInput | CreatureUpdateWithWhereUniqueWithoutResistancesInput[]
    updateMany?: CreatureUpdateManyWithWhereWithoutResistancesInput | CreatureUpdateManyWithWhereWithoutResistancesInput[]
    deleteMany?: CreatureScalarWhereInput | CreatureScalarWhereInput[]
  }

  export type CreatureUpdateManyWithoutImmunitiesNestedInput = {
    create?: XOR<CreatureCreateWithoutImmunitiesInput, CreatureUncheckedCreateWithoutImmunitiesInput> | CreatureCreateWithoutImmunitiesInput[] | CreatureUncheckedCreateWithoutImmunitiesInput[]
    connectOrCreate?: CreatureCreateOrConnectWithoutImmunitiesInput | CreatureCreateOrConnectWithoutImmunitiesInput[]
    upsert?: CreatureUpsertWithWhereUniqueWithoutImmunitiesInput | CreatureUpsertWithWhereUniqueWithoutImmunitiesInput[]
    set?: CreatureWhereUniqueInput | CreatureWhereUniqueInput[]
    disconnect?: CreatureWhereUniqueInput | CreatureWhereUniqueInput[]
    delete?: CreatureWhereUniqueInput | CreatureWhereUniqueInput[]
    connect?: CreatureWhereUniqueInput | CreatureWhereUniqueInput[]
    update?: CreatureUpdateWithWhereUniqueWithoutImmunitiesInput | CreatureUpdateWithWhereUniqueWithoutImmunitiesInput[]
    updateMany?: CreatureUpdateManyWithWhereWithoutImmunitiesInput | CreatureUpdateManyWithWhereWithoutImmunitiesInput[]
    deleteMany?: CreatureScalarWhereInput | CreatureScalarWhereInput[]
  }

  export type CreatureUpdateManyWithoutVulnerabilitiesNestedInput = {
    create?: XOR<CreatureCreateWithoutVulnerabilitiesInput, CreatureUncheckedCreateWithoutVulnerabilitiesInput> | CreatureCreateWithoutVulnerabilitiesInput[] | CreatureUncheckedCreateWithoutVulnerabilitiesInput[]
    connectOrCreate?: CreatureCreateOrConnectWithoutVulnerabilitiesInput | CreatureCreateOrConnectWithoutVulnerabilitiesInput[]
    upsert?: CreatureUpsertWithWhereUniqueWithoutVulnerabilitiesInput | CreatureUpsertWithWhereUniqueWithoutVulnerabilitiesInput[]
    set?: CreatureWhereUniqueInput | CreatureWhereUniqueInput[]
    disconnect?: CreatureWhereUniqueInput | CreatureWhereUniqueInput[]
    delete?: CreatureWhereUniqueInput | CreatureWhereUniqueInput[]
    connect?: CreatureWhereUniqueInput | CreatureWhereUniqueInput[]
    update?: CreatureUpdateWithWhereUniqueWithoutVulnerabilitiesInput | CreatureUpdateWithWhereUniqueWithoutVulnerabilitiesInput[]
    updateMany?: CreatureUpdateManyWithWhereWithoutVulnerabilitiesInput | CreatureUpdateManyWithWhereWithoutVulnerabilitiesInput[]
    deleteMany?: CreatureScalarWhereInput | CreatureScalarWhereInput[]
  }

  export type CreatureUncheckedUpdateManyWithoutResistancesNestedInput = {
    create?: XOR<CreatureCreateWithoutResistancesInput, CreatureUncheckedCreateWithoutResistancesInput> | CreatureCreateWithoutResistancesInput[] | CreatureUncheckedCreateWithoutResistancesInput[]
    connectOrCreate?: CreatureCreateOrConnectWithoutResistancesInput | CreatureCreateOrConnectWithoutResistancesInput[]
    upsert?: CreatureUpsertWithWhereUniqueWithoutResistancesInput | CreatureUpsertWithWhereUniqueWithoutResistancesInput[]
    set?: CreatureWhereUniqueInput | CreatureWhereUniqueInput[]
    disconnect?: CreatureWhereUniqueInput | CreatureWhereUniqueInput[]
    delete?: CreatureWhereUniqueInput | CreatureWhereUniqueInput[]
    connect?: CreatureWhereUniqueInput | CreatureWhereUniqueInput[]
    update?: CreatureUpdateWithWhereUniqueWithoutResistancesInput | CreatureUpdateWithWhereUniqueWithoutResistancesInput[]
    updateMany?: CreatureUpdateManyWithWhereWithoutResistancesInput | CreatureUpdateManyWithWhereWithoutResistancesInput[]
    deleteMany?: CreatureScalarWhereInput | CreatureScalarWhereInput[]
  }

  export type CreatureUncheckedUpdateManyWithoutImmunitiesNestedInput = {
    create?: XOR<CreatureCreateWithoutImmunitiesInput, CreatureUncheckedCreateWithoutImmunitiesInput> | CreatureCreateWithoutImmunitiesInput[] | CreatureUncheckedCreateWithoutImmunitiesInput[]
    connectOrCreate?: CreatureCreateOrConnectWithoutImmunitiesInput | CreatureCreateOrConnectWithoutImmunitiesInput[]
    upsert?: CreatureUpsertWithWhereUniqueWithoutImmunitiesInput | CreatureUpsertWithWhereUniqueWithoutImmunitiesInput[]
    set?: CreatureWhereUniqueInput | CreatureWhereUniqueInput[]
    disconnect?: CreatureWhereUniqueInput | CreatureWhereUniqueInput[]
    delete?: CreatureWhereUniqueInput | CreatureWhereUniqueInput[]
    connect?: CreatureWhereUniqueInput | CreatureWhereUniqueInput[]
    update?: CreatureUpdateWithWhereUniqueWithoutImmunitiesInput | CreatureUpdateWithWhereUniqueWithoutImmunitiesInput[]
    updateMany?: CreatureUpdateManyWithWhereWithoutImmunitiesInput | CreatureUpdateManyWithWhereWithoutImmunitiesInput[]
    deleteMany?: CreatureScalarWhereInput | CreatureScalarWhereInput[]
  }

  export type CreatureUncheckedUpdateManyWithoutVulnerabilitiesNestedInput = {
    create?: XOR<CreatureCreateWithoutVulnerabilitiesInput, CreatureUncheckedCreateWithoutVulnerabilitiesInput> | CreatureCreateWithoutVulnerabilitiesInput[] | CreatureUncheckedCreateWithoutVulnerabilitiesInput[]
    connectOrCreate?: CreatureCreateOrConnectWithoutVulnerabilitiesInput | CreatureCreateOrConnectWithoutVulnerabilitiesInput[]
    upsert?: CreatureUpsertWithWhereUniqueWithoutVulnerabilitiesInput | CreatureUpsertWithWhereUniqueWithoutVulnerabilitiesInput[]
    set?: CreatureWhereUniqueInput | CreatureWhereUniqueInput[]
    disconnect?: CreatureWhereUniqueInput | CreatureWhereUniqueInput[]
    delete?: CreatureWhereUniqueInput | CreatureWhereUniqueInput[]
    connect?: CreatureWhereUniqueInput | CreatureWhereUniqueInput[]
    update?: CreatureUpdateWithWhereUniqueWithoutVulnerabilitiesInput | CreatureUpdateWithWhereUniqueWithoutVulnerabilitiesInput[]
    updateMany?: CreatureUpdateManyWithWhereWithoutVulnerabilitiesInput | CreatureUpdateManyWithWhereWithoutVulnerabilitiesInput[]
    deleteMany?: CreatureScalarWhereInput | CreatureScalarWhereInput[]
  }

  export type GPTMessageCreateNestedManyWithoutMessage_historyInput = {
    create?: XOR<GPTMessageCreateWithoutMessage_historyInput, GPTMessageUncheckedCreateWithoutMessage_historyInput> | GPTMessageCreateWithoutMessage_historyInput[] | GPTMessageUncheckedCreateWithoutMessage_historyInput[]
    connectOrCreate?: GPTMessageCreateOrConnectWithoutMessage_historyInput | GPTMessageCreateOrConnectWithoutMessage_historyInput[]
    createMany?: GPTMessageCreateManyMessage_historyInputEnvelope
    connect?: GPTMessageWhereUniqueInput | GPTMessageWhereUniqueInput[]
  }

  export type GPTMessageUncheckedCreateNestedManyWithoutMessage_historyInput = {
    create?: XOR<GPTMessageCreateWithoutMessage_historyInput, GPTMessageUncheckedCreateWithoutMessage_historyInput> | GPTMessageCreateWithoutMessage_historyInput[] | GPTMessageUncheckedCreateWithoutMessage_historyInput[]
    connectOrCreate?: GPTMessageCreateOrConnectWithoutMessage_historyInput | GPTMessageCreateOrConnectWithoutMessage_historyInput[]
    createMany?: GPTMessageCreateManyMessage_historyInputEnvelope
    connect?: GPTMessageWhereUniqueInput | GPTMessageWhereUniqueInput[]
  }

  export type GPTMessageUpdateManyWithoutMessage_historyNestedInput = {
    create?: XOR<GPTMessageCreateWithoutMessage_historyInput, GPTMessageUncheckedCreateWithoutMessage_historyInput> | GPTMessageCreateWithoutMessage_historyInput[] | GPTMessageUncheckedCreateWithoutMessage_historyInput[]
    connectOrCreate?: GPTMessageCreateOrConnectWithoutMessage_historyInput | GPTMessageCreateOrConnectWithoutMessage_historyInput[]
    upsert?: GPTMessageUpsertWithWhereUniqueWithoutMessage_historyInput | GPTMessageUpsertWithWhereUniqueWithoutMessage_historyInput[]
    createMany?: GPTMessageCreateManyMessage_historyInputEnvelope
    set?: GPTMessageWhereUniqueInput | GPTMessageWhereUniqueInput[]
    disconnect?: GPTMessageWhereUniqueInput | GPTMessageWhereUniqueInput[]
    delete?: GPTMessageWhereUniqueInput | GPTMessageWhereUniqueInput[]
    connect?: GPTMessageWhereUniqueInput | GPTMessageWhereUniqueInput[]
    update?: GPTMessageUpdateWithWhereUniqueWithoutMessage_historyInput | GPTMessageUpdateWithWhereUniqueWithoutMessage_historyInput[]
    updateMany?: GPTMessageUpdateManyWithWhereWithoutMessage_historyInput | GPTMessageUpdateManyWithWhereWithoutMessage_historyInput[]
    deleteMany?: GPTMessageScalarWhereInput | GPTMessageScalarWhereInput[]
  }

  export type GPTMessageUncheckedUpdateManyWithoutMessage_historyNestedInput = {
    create?: XOR<GPTMessageCreateWithoutMessage_historyInput, GPTMessageUncheckedCreateWithoutMessage_historyInput> | GPTMessageCreateWithoutMessage_historyInput[] | GPTMessageUncheckedCreateWithoutMessage_historyInput[]
    connectOrCreate?: GPTMessageCreateOrConnectWithoutMessage_historyInput | GPTMessageCreateOrConnectWithoutMessage_historyInput[]
    upsert?: GPTMessageUpsertWithWhereUniqueWithoutMessage_historyInput | GPTMessageUpsertWithWhereUniqueWithoutMessage_historyInput[]
    createMany?: GPTMessageCreateManyMessage_historyInputEnvelope
    set?: GPTMessageWhereUniqueInput | GPTMessageWhereUniqueInput[]
    disconnect?: GPTMessageWhereUniqueInput | GPTMessageWhereUniqueInput[]
    delete?: GPTMessageWhereUniqueInput | GPTMessageWhereUniqueInput[]
    connect?: GPTMessageWhereUniqueInput | GPTMessageWhereUniqueInput[]
    update?: GPTMessageUpdateWithWhereUniqueWithoutMessage_historyInput | GPTMessageUpdateWithWhereUniqueWithoutMessage_historyInput[]
    updateMany?: GPTMessageUpdateManyWithWhereWithoutMessage_historyInput | GPTMessageUpdateManyWithWhereWithoutMessage_historyInput[]
    deleteMany?: GPTMessageScalarWhereInput | GPTMessageScalarWhereInput[]
  }

  export type GPTMessageHistoryCreateNestedOneWithoutMessagesInput = {
    create?: XOR<GPTMessageHistoryCreateWithoutMessagesInput, GPTMessageHistoryUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: GPTMessageHistoryCreateOrConnectWithoutMessagesInput
    connect?: GPTMessageHistoryWhereUniqueInput
  }

  export type GPTMessageHistoryUpdateOneRequiredWithoutMessagesNestedInput = {
    create?: XOR<GPTMessageHistoryCreateWithoutMessagesInput, GPTMessageHistoryUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: GPTMessageHistoryCreateOrConnectWithoutMessagesInput
    upsert?: GPTMessageHistoryUpsertWithoutMessagesInput
    connect?: GPTMessageHistoryWhereUniqueInput
    update?: XOR<XOR<GPTMessageHistoryUpdateToOneWithWhereWithoutMessagesInput, GPTMessageHistoryUpdateWithoutMessagesInput>, GPTMessageHistoryUncheckedUpdateWithoutMessagesInput>
  }

  export type GenreCreateNestedOneWithoutAdventuresInput = {
    create?: XOR<GenreCreateWithoutAdventuresInput, GenreUncheckedCreateWithoutAdventuresInput>
    connectOrCreate?: GenreCreateOrConnectWithoutAdventuresInput
    connect?: GenreWhereUniqueInput
  }

  export type AdventureKeywordCreateNestedManyWithoutAdventureInput = {
    create?: XOR<AdventureKeywordCreateWithoutAdventureInput, AdventureKeywordUncheckedCreateWithoutAdventureInput> | AdventureKeywordCreateWithoutAdventureInput[] | AdventureKeywordUncheckedCreateWithoutAdventureInput[]
    connectOrCreate?: AdventureKeywordCreateOrConnectWithoutAdventureInput | AdventureKeywordCreateOrConnectWithoutAdventureInput[]
    createMany?: AdventureKeywordCreateManyAdventureInputEnvelope
    connect?: AdventureKeywordWhereUniqueInput | AdventureKeywordWhereUniqueInput[]
  }

  export type AdventureKeywordUncheckedCreateNestedManyWithoutAdventureInput = {
    create?: XOR<AdventureKeywordCreateWithoutAdventureInput, AdventureKeywordUncheckedCreateWithoutAdventureInput> | AdventureKeywordCreateWithoutAdventureInput[] | AdventureKeywordUncheckedCreateWithoutAdventureInput[]
    connectOrCreate?: AdventureKeywordCreateOrConnectWithoutAdventureInput | AdventureKeywordCreateOrConnectWithoutAdventureInput[]
    createMany?: AdventureKeywordCreateManyAdventureInputEnvelope
    connect?: AdventureKeywordWhereUniqueInput | AdventureKeywordWhereUniqueInput[]
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type GenreUpdateOneRequiredWithoutAdventuresNestedInput = {
    create?: XOR<GenreCreateWithoutAdventuresInput, GenreUncheckedCreateWithoutAdventuresInput>
    connectOrCreate?: GenreCreateOrConnectWithoutAdventuresInput
    upsert?: GenreUpsertWithoutAdventuresInput
    connect?: GenreWhereUniqueInput
    update?: XOR<XOR<GenreUpdateToOneWithWhereWithoutAdventuresInput, GenreUpdateWithoutAdventuresInput>, GenreUncheckedUpdateWithoutAdventuresInput>
  }

  export type AdventureKeywordUpdateManyWithoutAdventureNestedInput = {
    create?: XOR<AdventureKeywordCreateWithoutAdventureInput, AdventureKeywordUncheckedCreateWithoutAdventureInput> | AdventureKeywordCreateWithoutAdventureInput[] | AdventureKeywordUncheckedCreateWithoutAdventureInput[]
    connectOrCreate?: AdventureKeywordCreateOrConnectWithoutAdventureInput | AdventureKeywordCreateOrConnectWithoutAdventureInput[]
    upsert?: AdventureKeywordUpsertWithWhereUniqueWithoutAdventureInput | AdventureKeywordUpsertWithWhereUniqueWithoutAdventureInput[]
    createMany?: AdventureKeywordCreateManyAdventureInputEnvelope
    set?: AdventureKeywordWhereUniqueInput | AdventureKeywordWhereUniqueInput[]
    disconnect?: AdventureKeywordWhereUniqueInput | AdventureKeywordWhereUniqueInput[]
    delete?: AdventureKeywordWhereUniqueInput | AdventureKeywordWhereUniqueInput[]
    connect?: AdventureKeywordWhereUniqueInput | AdventureKeywordWhereUniqueInput[]
    update?: AdventureKeywordUpdateWithWhereUniqueWithoutAdventureInput | AdventureKeywordUpdateWithWhereUniqueWithoutAdventureInput[]
    updateMany?: AdventureKeywordUpdateManyWithWhereWithoutAdventureInput | AdventureKeywordUpdateManyWithWhereWithoutAdventureInput[]
    deleteMany?: AdventureKeywordScalarWhereInput | AdventureKeywordScalarWhereInput[]
  }

  export type AdventureKeywordUncheckedUpdateManyWithoutAdventureNestedInput = {
    create?: XOR<AdventureKeywordCreateWithoutAdventureInput, AdventureKeywordUncheckedCreateWithoutAdventureInput> | AdventureKeywordCreateWithoutAdventureInput[] | AdventureKeywordUncheckedCreateWithoutAdventureInput[]
    connectOrCreate?: AdventureKeywordCreateOrConnectWithoutAdventureInput | AdventureKeywordCreateOrConnectWithoutAdventureInput[]
    upsert?: AdventureKeywordUpsertWithWhereUniqueWithoutAdventureInput | AdventureKeywordUpsertWithWhereUniqueWithoutAdventureInput[]
    createMany?: AdventureKeywordCreateManyAdventureInputEnvelope
    set?: AdventureKeywordWhereUniqueInput | AdventureKeywordWhereUniqueInput[]
    disconnect?: AdventureKeywordWhereUniqueInput | AdventureKeywordWhereUniqueInput[]
    delete?: AdventureKeywordWhereUniqueInput | AdventureKeywordWhereUniqueInput[]
    connect?: AdventureKeywordWhereUniqueInput | AdventureKeywordWhereUniqueInput[]
    update?: AdventureKeywordUpdateWithWhereUniqueWithoutAdventureInput | AdventureKeywordUpdateWithWhereUniqueWithoutAdventureInput[]
    updateMany?: AdventureKeywordUpdateManyWithWhereWithoutAdventureInput | AdventureKeywordUpdateManyWithWhereWithoutAdventureInput[]
    deleteMany?: AdventureKeywordScalarWhereInput | AdventureKeywordScalarWhereInput[]
  }

  export type KeywordCreateNestedManyWithoutGenreInput = {
    create?: XOR<KeywordCreateWithoutGenreInput, KeywordUncheckedCreateWithoutGenreInput> | KeywordCreateWithoutGenreInput[] | KeywordUncheckedCreateWithoutGenreInput[]
    connectOrCreate?: KeywordCreateOrConnectWithoutGenreInput | KeywordCreateOrConnectWithoutGenreInput[]
    createMany?: KeywordCreateManyGenreInputEnvelope
    connect?: KeywordWhereUniqueInput | KeywordWhereUniqueInput[]
  }

  export type AdventureCreateNestedManyWithoutGenreInput = {
    create?: XOR<AdventureCreateWithoutGenreInput, AdventureUncheckedCreateWithoutGenreInput> | AdventureCreateWithoutGenreInput[] | AdventureUncheckedCreateWithoutGenreInput[]
    connectOrCreate?: AdventureCreateOrConnectWithoutGenreInput | AdventureCreateOrConnectWithoutGenreInput[]
    createMany?: AdventureCreateManyGenreInputEnvelope
    connect?: AdventureWhereUniqueInput | AdventureWhereUniqueInput[]
  }

  export type KeywordUncheckedCreateNestedManyWithoutGenreInput = {
    create?: XOR<KeywordCreateWithoutGenreInput, KeywordUncheckedCreateWithoutGenreInput> | KeywordCreateWithoutGenreInput[] | KeywordUncheckedCreateWithoutGenreInput[]
    connectOrCreate?: KeywordCreateOrConnectWithoutGenreInput | KeywordCreateOrConnectWithoutGenreInput[]
    createMany?: KeywordCreateManyGenreInputEnvelope
    connect?: KeywordWhereUniqueInput | KeywordWhereUniqueInput[]
  }

  export type AdventureUncheckedCreateNestedManyWithoutGenreInput = {
    create?: XOR<AdventureCreateWithoutGenreInput, AdventureUncheckedCreateWithoutGenreInput> | AdventureCreateWithoutGenreInput[] | AdventureUncheckedCreateWithoutGenreInput[]
    connectOrCreate?: AdventureCreateOrConnectWithoutGenreInput | AdventureCreateOrConnectWithoutGenreInput[]
    createMany?: AdventureCreateManyGenreInputEnvelope
    connect?: AdventureWhereUniqueInput | AdventureWhereUniqueInput[]
  }

  export type KeywordUpdateManyWithoutGenreNestedInput = {
    create?: XOR<KeywordCreateWithoutGenreInput, KeywordUncheckedCreateWithoutGenreInput> | KeywordCreateWithoutGenreInput[] | KeywordUncheckedCreateWithoutGenreInput[]
    connectOrCreate?: KeywordCreateOrConnectWithoutGenreInput | KeywordCreateOrConnectWithoutGenreInput[]
    upsert?: KeywordUpsertWithWhereUniqueWithoutGenreInput | KeywordUpsertWithWhereUniqueWithoutGenreInput[]
    createMany?: KeywordCreateManyGenreInputEnvelope
    set?: KeywordWhereUniqueInput | KeywordWhereUniqueInput[]
    disconnect?: KeywordWhereUniqueInput | KeywordWhereUniqueInput[]
    delete?: KeywordWhereUniqueInput | KeywordWhereUniqueInput[]
    connect?: KeywordWhereUniqueInput | KeywordWhereUniqueInput[]
    update?: KeywordUpdateWithWhereUniqueWithoutGenreInput | KeywordUpdateWithWhereUniqueWithoutGenreInput[]
    updateMany?: KeywordUpdateManyWithWhereWithoutGenreInput | KeywordUpdateManyWithWhereWithoutGenreInput[]
    deleteMany?: KeywordScalarWhereInput | KeywordScalarWhereInput[]
  }

  export type AdventureUpdateManyWithoutGenreNestedInput = {
    create?: XOR<AdventureCreateWithoutGenreInput, AdventureUncheckedCreateWithoutGenreInput> | AdventureCreateWithoutGenreInput[] | AdventureUncheckedCreateWithoutGenreInput[]
    connectOrCreate?: AdventureCreateOrConnectWithoutGenreInput | AdventureCreateOrConnectWithoutGenreInput[]
    upsert?: AdventureUpsertWithWhereUniqueWithoutGenreInput | AdventureUpsertWithWhereUniqueWithoutGenreInput[]
    createMany?: AdventureCreateManyGenreInputEnvelope
    set?: AdventureWhereUniqueInput | AdventureWhereUniqueInput[]
    disconnect?: AdventureWhereUniqueInput | AdventureWhereUniqueInput[]
    delete?: AdventureWhereUniqueInput | AdventureWhereUniqueInput[]
    connect?: AdventureWhereUniqueInput | AdventureWhereUniqueInput[]
    update?: AdventureUpdateWithWhereUniqueWithoutGenreInput | AdventureUpdateWithWhereUniqueWithoutGenreInput[]
    updateMany?: AdventureUpdateManyWithWhereWithoutGenreInput | AdventureUpdateManyWithWhereWithoutGenreInput[]
    deleteMany?: AdventureScalarWhereInput | AdventureScalarWhereInput[]
  }

  export type KeywordUncheckedUpdateManyWithoutGenreNestedInput = {
    create?: XOR<KeywordCreateWithoutGenreInput, KeywordUncheckedCreateWithoutGenreInput> | KeywordCreateWithoutGenreInput[] | KeywordUncheckedCreateWithoutGenreInput[]
    connectOrCreate?: KeywordCreateOrConnectWithoutGenreInput | KeywordCreateOrConnectWithoutGenreInput[]
    upsert?: KeywordUpsertWithWhereUniqueWithoutGenreInput | KeywordUpsertWithWhereUniqueWithoutGenreInput[]
    createMany?: KeywordCreateManyGenreInputEnvelope
    set?: KeywordWhereUniqueInput | KeywordWhereUniqueInput[]
    disconnect?: KeywordWhereUniqueInput | KeywordWhereUniqueInput[]
    delete?: KeywordWhereUniqueInput | KeywordWhereUniqueInput[]
    connect?: KeywordWhereUniqueInput | KeywordWhereUniqueInput[]
    update?: KeywordUpdateWithWhereUniqueWithoutGenreInput | KeywordUpdateWithWhereUniqueWithoutGenreInput[]
    updateMany?: KeywordUpdateManyWithWhereWithoutGenreInput | KeywordUpdateManyWithWhereWithoutGenreInput[]
    deleteMany?: KeywordScalarWhereInput | KeywordScalarWhereInput[]
  }

  export type AdventureUncheckedUpdateManyWithoutGenreNestedInput = {
    create?: XOR<AdventureCreateWithoutGenreInput, AdventureUncheckedCreateWithoutGenreInput> | AdventureCreateWithoutGenreInput[] | AdventureUncheckedCreateWithoutGenreInput[]
    connectOrCreate?: AdventureCreateOrConnectWithoutGenreInput | AdventureCreateOrConnectWithoutGenreInput[]
    upsert?: AdventureUpsertWithWhereUniqueWithoutGenreInput | AdventureUpsertWithWhereUniqueWithoutGenreInput[]
    createMany?: AdventureCreateManyGenreInputEnvelope
    set?: AdventureWhereUniqueInput | AdventureWhereUniqueInput[]
    disconnect?: AdventureWhereUniqueInput | AdventureWhereUniqueInput[]
    delete?: AdventureWhereUniqueInput | AdventureWhereUniqueInput[]
    connect?: AdventureWhereUniqueInput | AdventureWhereUniqueInput[]
    update?: AdventureUpdateWithWhereUniqueWithoutGenreInput | AdventureUpdateWithWhereUniqueWithoutGenreInput[]
    updateMany?: AdventureUpdateManyWithWhereWithoutGenreInput | AdventureUpdateManyWithWhereWithoutGenreInput[]
    deleteMany?: AdventureScalarWhereInput | AdventureScalarWhereInput[]
  }

  export type GenreCreateNestedOneWithoutKeywordsInput = {
    create?: XOR<GenreCreateWithoutKeywordsInput, GenreUncheckedCreateWithoutKeywordsInput>
    connectOrCreate?: GenreCreateOrConnectWithoutKeywordsInput
    connect?: GenreWhereUniqueInput
  }

  export type AdventureKeywordCreateNestedManyWithoutKeywordInput = {
    create?: XOR<AdventureKeywordCreateWithoutKeywordInput, AdventureKeywordUncheckedCreateWithoutKeywordInput> | AdventureKeywordCreateWithoutKeywordInput[] | AdventureKeywordUncheckedCreateWithoutKeywordInput[]
    connectOrCreate?: AdventureKeywordCreateOrConnectWithoutKeywordInput | AdventureKeywordCreateOrConnectWithoutKeywordInput[]
    createMany?: AdventureKeywordCreateManyKeywordInputEnvelope
    connect?: AdventureKeywordWhereUniqueInput | AdventureKeywordWhereUniqueInput[]
  }

  export type AdventureKeywordUncheckedCreateNestedManyWithoutKeywordInput = {
    create?: XOR<AdventureKeywordCreateWithoutKeywordInput, AdventureKeywordUncheckedCreateWithoutKeywordInput> | AdventureKeywordCreateWithoutKeywordInput[] | AdventureKeywordUncheckedCreateWithoutKeywordInput[]
    connectOrCreate?: AdventureKeywordCreateOrConnectWithoutKeywordInput | AdventureKeywordCreateOrConnectWithoutKeywordInput[]
    createMany?: AdventureKeywordCreateManyKeywordInputEnvelope
    connect?: AdventureKeywordWhereUniqueInput | AdventureKeywordWhereUniqueInput[]
  }

  export type GenreUpdateOneRequiredWithoutKeywordsNestedInput = {
    create?: XOR<GenreCreateWithoutKeywordsInput, GenreUncheckedCreateWithoutKeywordsInput>
    connectOrCreate?: GenreCreateOrConnectWithoutKeywordsInput
    upsert?: GenreUpsertWithoutKeywordsInput
    connect?: GenreWhereUniqueInput
    update?: XOR<XOR<GenreUpdateToOneWithWhereWithoutKeywordsInput, GenreUpdateWithoutKeywordsInput>, GenreUncheckedUpdateWithoutKeywordsInput>
  }

  export type AdventureKeywordUpdateManyWithoutKeywordNestedInput = {
    create?: XOR<AdventureKeywordCreateWithoutKeywordInput, AdventureKeywordUncheckedCreateWithoutKeywordInput> | AdventureKeywordCreateWithoutKeywordInput[] | AdventureKeywordUncheckedCreateWithoutKeywordInput[]
    connectOrCreate?: AdventureKeywordCreateOrConnectWithoutKeywordInput | AdventureKeywordCreateOrConnectWithoutKeywordInput[]
    upsert?: AdventureKeywordUpsertWithWhereUniqueWithoutKeywordInput | AdventureKeywordUpsertWithWhereUniqueWithoutKeywordInput[]
    createMany?: AdventureKeywordCreateManyKeywordInputEnvelope
    set?: AdventureKeywordWhereUniqueInput | AdventureKeywordWhereUniqueInput[]
    disconnect?: AdventureKeywordWhereUniqueInput | AdventureKeywordWhereUniqueInput[]
    delete?: AdventureKeywordWhereUniqueInput | AdventureKeywordWhereUniqueInput[]
    connect?: AdventureKeywordWhereUniqueInput | AdventureKeywordWhereUniqueInput[]
    update?: AdventureKeywordUpdateWithWhereUniqueWithoutKeywordInput | AdventureKeywordUpdateWithWhereUniqueWithoutKeywordInput[]
    updateMany?: AdventureKeywordUpdateManyWithWhereWithoutKeywordInput | AdventureKeywordUpdateManyWithWhereWithoutKeywordInput[]
    deleteMany?: AdventureKeywordScalarWhereInput | AdventureKeywordScalarWhereInput[]
  }

  export type AdventureKeywordUncheckedUpdateManyWithoutKeywordNestedInput = {
    create?: XOR<AdventureKeywordCreateWithoutKeywordInput, AdventureKeywordUncheckedCreateWithoutKeywordInput> | AdventureKeywordCreateWithoutKeywordInput[] | AdventureKeywordUncheckedCreateWithoutKeywordInput[]
    connectOrCreate?: AdventureKeywordCreateOrConnectWithoutKeywordInput | AdventureKeywordCreateOrConnectWithoutKeywordInput[]
    upsert?: AdventureKeywordUpsertWithWhereUniqueWithoutKeywordInput | AdventureKeywordUpsertWithWhereUniqueWithoutKeywordInput[]
    createMany?: AdventureKeywordCreateManyKeywordInputEnvelope
    set?: AdventureKeywordWhereUniqueInput | AdventureKeywordWhereUniqueInput[]
    disconnect?: AdventureKeywordWhereUniqueInput | AdventureKeywordWhereUniqueInput[]
    delete?: AdventureKeywordWhereUniqueInput | AdventureKeywordWhereUniqueInput[]
    connect?: AdventureKeywordWhereUniqueInput | AdventureKeywordWhereUniqueInput[]
    update?: AdventureKeywordUpdateWithWhereUniqueWithoutKeywordInput | AdventureKeywordUpdateWithWhereUniqueWithoutKeywordInput[]
    updateMany?: AdventureKeywordUpdateManyWithWhereWithoutKeywordInput | AdventureKeywordUpdateManyWithWhereWithoutKeywordInput[]
    deleteMany?: AdventureKeywordScalarWhereInput | AdventureKeywordScalarWhereInput[]
  }

  export type AdventureCreateNestedOneWithoutKeywordsInput = {
    create?: XOR<AdventureCreateWithoutKeywordsInput, AdventureUncheckedCreateWithoutKeywordsInput>
    connectOrCreate?: AdventureCreateOrConnectWithoutKeywordsInput
    connect?: AdventureWhereUniqueInput
  }

  export type KeywordCreateNestedOneWithoutAdventuresInput = {
    create?: XOR<KeywordCreateWithoutAdventuresInput, KeywordUncheckedCreateWithoutAdventuresInput>
    connectOrCreate?: KeywordCreateOrConnectWithoutAdventuresInput
    connect?: KeywordWhereUniqueInput
  }

  export type AdventureUpdateOneRequiredWithoutKeywordsNestedInput = {
    create?: XOR<AdventureCreateWithoutKeywordsInput, AdventureUncheckedCreateWithoutKeywordsInput>
    connectOrCreate?: AdventureCreateOrConnectWithoutKeywordsInput
    upsert?: AdventureUpsertWithoutKeywordsInput
    connect?: AdventureWhereUniqueInput
    update?: XOR<XOR<AdventureUpdateToOneWithWhereWithoutKeywordsInput, AdventureUpdateWithoutKeywordsInput>, AdventureUncheckedUpdateWithoutKeywordsInput>
  }

  export type KeywordUpdateOneRequiredWithoutAdventuresNestedInput = {
    create?: XOR<KeywordCreateWithoutAdventuresInput, KeywordUncheckedCreateWithoutAdventuresInput>
    connectOrCreate?: KeywordCreateOrConnectWithoutAdventuresInput
    upsert?: KeywordUpsertWithoutAdventuresInput
    connect?: KeywordWhereUniqueInput
    update?: XOR<XOR<KeywordUpdateToOneWithWhereWithoutAdventuresInput, KeywordUpdateWithoutAdventuresInput>, KeywordUncheckedUpdateWithoutAdventuresInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedBoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type NestedBoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type CreatureCreateWithoutSize_relationInput = {
    id?: string
    name: string
    creator_id?: string | null
    image_uri?: string | null
    description?: string | null
    armor_class?: number | null
    hit_points?: number | null
    challenge_rating: string
    biomes_ids?: CreatureCreatebiomes_idsInput | number[]
    aSubTypes?: CreatureCreateaSubTypesInput | string[]
    speed?: Speed_statCreateNestedOneWithoutId_relationInput
    stats?: Creature_statsCreateNestedOneWithoutId_relationInput
    skills?: SkillsListCreateNestedOneWithoutId_relationInput
    resistances?: DamageTypeCreateNestedManyWithoutResistant_creaturesInput
    immunities?: DamageTypeCreateNestedManyWithoutImmune_creaturesInput
    vulnerabilities?: DamageTypeCreateNestedManyWithoutVunlerable_creaturesInput
    senses?: SensesCreateNestedOneWithoutCreatureInput
    languages?: LanguageCreateNestedManyWithoutCreaturesInput
    actions?: ActionCreateNestedManyWithoutCreaturesInput
    traits?: TraitCreateNestedManyWithoutCreturesInput
    alignment_relation?: AlignmentCreateNestedOneWithoutCreaturesInput
    race_relation?: CreatureRaceCreateNestedOneWithoutCreaturesInput
    type_relation?: TypeCreateNestedOneWithoutCreaturesInput
    biome_relation?: BiomeCreateNestedManyWithoutCreaturesInput
    source_relation?: SourceCreateNestedOneWithoutCreaturesInput
  }

  export type CreatureUncheckedCreateWithoutSize_relationInput = {
    id?: string
    name: string
    creator_id?: string | null
    image_uri?: string | null
    description?: string | null
    race_id?: number | null
    source_id?: number | null
    alignment_id?: number | null
    armor_class?: number | null
    hit_points?: number | null
    challenge_rating: string
    biomes_ids?: CreatureCreatebiomes_idsInput | number[]
    type_id?: number | null
    aSubTypes?: CreatureCreateaSubTypesInput | string[]
    speed?: Speed_statUncheckedCreateNestedOneWithoutId_relationInput
    stats?: Creature_statsUncheckedCreateNestedOneWithoutId_relationInput
    skills?: SkillsListUncheckedCreateNestedOneWithoutId_relationInput
    resistances?: DamageTypeUncheckedCreateNestedManyWithoutResistant_creaturesInput
    immunities?: DamageTypeUncheckedCreateNestedManyWithoutImmune_creaturesInput
    vulnerabilities?: DamageTypeUncheckedCreateNestedManyWithoutVunlerable_creaturesInput
    senses?: SensesUncheckedCreateNestedOneWithoutCreatureInput
    languages?: LanguageUncheckedCreateNestedManyWithoutCreaturesInput
    actions?: ActionUncheckedCreateNestedManyWithoutCreaturesInput
    traits?: TraitUncheckedCreateNestedManyWithoutCreturesInput
    biome_relation?: BiomeUncheckedCreateNestedManyWithoutCreaturesInput
  }

  export type CreatureCreateOrConnectWithoutSize_relationInput = {
    where: CreatureWhereUniqueInput
    create: XOR<CreatureCreateWithoutSize_relationInput, CreatureUncheckedCreateWithoutSize_relationInput>
  }

  export type CreatureCreateManySize_relationInputEnvelope = {
    data: CreatureCreateManySize_relationInput | CreatureCreateManySize_relationInput[]
    skipDuplicates?: boolean
  }

  export type CreatureUpsertWithWhereUniqueWithoutSize_relationInput = {
    where: CreatureWhereUniqueInput
    update: XOR<CreatureUpdateWithoutSize_relationInput, CreatureUncheckedUpdateWithoutSize_relationInput>
    create: XOR<CreatureCreateWithoutSize_relationInput, CreatureUncheckedCreateWithoutSize_relationInput>
  }

  export type CreatureUpdateWithWhereUniqueWithoutSize_relationInput = {
    where: CreatureWhereUniqueInput
    data: XOR<CreatureUpdateWithoutSize_relationInput, CreatureUncheckedUpdateWithoutSize_relationInput>
  }

  export type CreatureUpdateManyWithWhereWithoutSize_relationInput = {
    where: CreatureScalarWhereInput
    data: XOR<CreatureUpdateManyMutationInput, CreatureUncheckedUpdateManyWithoutSize_relationInput>
  }

  export type CreatureScalarWhereInput = {
    AND?: CreatureScalarWhereInput | CreatureScalarWhereInput[]
    OR?: CreatureScalarWhereInput[]
    NOT?: CreatureScalarWhereInput | CreatureScalarWhereInput[]
    id?: StringFilter<"Creature"> | string
    name?: StringFilter<"Creature"> | string
    creator_id?: StringNullableFilter<"Creature"> | string | null
    image_uri?: StringNullableFilter<"Creature"> | string | null
    description?: StringNullableFilter<"Creature"> | string | null
    size?: StringNullableFilter<"Creature"> | string | null
    race_id?: IntNullableFilter<"Creature"> | number | null
    source_id?: IntNullableFilter<"Creature"> | number | null
    alignment_id?: IntNullableFilter<"Creature"> | number | null
    armor_class?: IntNullableFilter<"Creature"> | number | null
    hit_points?: IntNullableFilter<"Creature"> | number | null
    challenge_rating?: StringFilter<"Creature"> | string
    biomes_ids?: IntNullableListFilter<"Creature">
    type_id?: IntNullableFilter<"Creature"> | number | null
    aSubTypes?: StringNullableListFilter<"Creature">
  }

  export type CreatureCreateWithoutSource_relationInput = {
    id?: string
    name: string
    creator_id?: string | null
    image_uri?: string | null
    description?: string | null
    armor_class?: number | null
    hit_points?: number | null
    challenge_rating: string
    biomes_ids?: CreatureCreatebiomes_idsInput | number[]
    aSubTypes?: CreatureCreateaSubTypesInput | string[]
    speed?: Speed_statCreateNestedOneWithoutId_relationInput
    stats?: Creature_statsCreateNestedOneWithoutId_relationInput
    skills?: SkillsListCreateNestedOneWithoutId_relationInput
    resistances?: DamageTypeCreateNestedManyWithoutResistant_creaturesInput
    immunities?: DamageTypeCreateNestedManyWithoutImmune_creaturesInput
    vulnerabilities?: DamageTypeCreateNestedManyWithoutVunlerable_creaturesInput
    senses?: SensesCreateNestedOneWithoutCreatureInput
    languages?: LanguageCreateNestedManyWithoutCreaturesInput
    actions?: ActionCreateNestedManyWithoutCreaturesInput
    traits?: TraitCreateNestedManyWithoutCreturesInput
    alignment_relation?: AlignmentCreateNestedOneWithoutCreaturesInput
    race_relation?: CreatureRaceCreateNestedOneWithoutCreaturesInput
    type_relation?: TypeCreateNestedOneWithoutCreaturesInput
    size_relation?: SizeCreateNestedOneWithoutCreatureInput
    biome_relation?: BiomeCreateNestedManyWithoutCreaturesInput
  }

  export type CreatureUncheckedCreateWithoutSource_relationInput = {
    id?: string
    name: string
    creator_id?: string | null
    image_uri?: string | null
    description?: string | null
    size?: string | null
    race_id?: number | null
    alignment_id?: number | null
    armor_class?: number | null
    hit_points?: number | null
    challenge_rating: string
    biomes_ids?: CreatureCreatebiomes_idsInput | number[]
    type_id?: number | null
    aSubTypes?: CreatureCreateaSubTypesInput | string[]
    speed?: Speed_statUncheckedCreateNestedOneWithoutId_relationInput
    stats?: Creature_statsUncheckedCreateNestedOneWithoutId_relationInput
    skills?: SkillsListUncheckedCreateNestedOneWithoutId_relationInput
    resistances?: DamageTypeUncheckedCreateNestedManyWithoutResistant_creaturesInput
    immunities?: DamageTypeUncheckedCreateNestedManyWithoutImmune_creaturesInput
    vulnerabilities?: DamageTypeUncheckedCreateNestedManyWithoutVunlerable_creaturesInput
    senses?: SensesUncheckedCreateNestedOneWithoutCreatureInput
    languages?: LanguageUncheckedCreateNestedManyWithoutCreaturesInput
    actions?: ActionUncheckedCreateNestedManyWithoutCreaturesInput
    traits?: TraitUncheckedCreateNestedManyWithoutCreturesInput
    biome_relation?: BiomeUncheckedCreateNestedManyWithoutCreaturesInput
  }

  export type CreatureCreateOrConnectWithoutSource_relationInput = {
    where: CreatureWhereUniqueInput
    create: XOR<CreatureCreateWithoutSource_relationInput, CreatureUncheckedCreateWithoutSource_relationInput>
  }

  export type CreatureCreateManySource_relationInputEnvelope = {
    data: CreatureCreateManySource_relationInput | CreatureCreateManySource_relationInput[]
    skipDuplicates?: boolean
  }

  export type CreatureUpsertWithWhereUniqueWithoutSource_relationInput = {
    where: CreatureWhereUniqueInput
    update: XOR<CreatureUpdateWithoutSource_relationInput, CreatureUncheckedUpdateWithoutSource_relationInput>
    create: XOR<CreatureCreateWithoutSource_relationInput, CreatureUncheckedCreateWithoutSource_relationInput>
  }

  export type CreatureUpdateWithWhereUniqueWithoutSource_relationInput = {
    where: CreatureWhereUniqueInput
    data: XOR<CreatureUpdateWithoutSource_relationInput, CreatureUncheckedUpdateWithoutSource_relationInput>
  }

  export type CreatureUpdateManyWithWhereWithoutSource_relationInput = {
    where: CreatureScalarWhereInput
    data: XOR<CreatureUpdateManyMutationInput, CreatureUncheckedUpdateManyWithoutSource_relationInput>
  }

  export type CreatureCreateWithoutLanguagesInput = {
    id?: string
    name: string
    creator_id?: string | null
    image_uri?: string | null
    description?: string | null
    armor_class?: number | null
    hit_points?: number | null
    challenge_rating: string
    biomes_ids?: CreatureCreatebiomes_idsInput | number[]
    aSubTypes?: CreatureCreateaSubTypesInput | string[]
    speed?: Speed_statCreateNestedOneWithoutId_relationInput
    stats?: Creature_statsCreateNestedOneWithoutId_relationInput
    skills?: SkillsListCreateNestedOneWithoutId_relationInput
    resistances?: DamageTypeCreateNestedManyWithoutResistant_creaturesInput
    immunities?: DamageTypeCreateNestedManyWithoutImmune_creaturesInput
    vulnerabilities?: DamageTypeCreateNestedManyWithoutVunlerable_creaturesInput
    senses?: SensesCreateNestedOneWithoutCreatureInput
    actions?: ActionCreateNestedManyWithoutCreaturesInput
    traits?: TraitCreateNestedManyWithoutCreturesInput
    alignment_relation?: AlignmentCreateNestedOneWithoutCreaturesInput
    race_relation?: CreatureRaceCreateNestedOneWithoutCreaturesInput
    type_relation?: TypeCreateNestedOneWithoutCreaturesInput
    size_relation?: SizeCreateNestedOneWithoutCreatureInput
    biome_relation?: BiomeCreateNestedManyWithoutCreaturesInput
    source_relation?: SourceCreateNestedOneWithoutCreaturesInput
  }

  export type CreatureUncheckedCreateWithoutLanguagesInput = {
    id?: string
    name: string
    creator_id?: string | null
    image_uri?: string | null
    description?: string | null
    size?: string | null
    race_id?: number | null
    source_id?: number | null
    alignment_id?: number | null
    armor_class?: number | null
    hit_points?: number | null
    challenge_rating: string
    biomes_ids?: CreatureCreatebiomes_idsInput | number[]
    type_id?: number | null
    aSubTypes?: CreatureCreateaSubTypesInput | string[]
    speed?: Speed_statUncheckedCreateNestedOneWithoutId_relationInput
    stats?: Creature_statsUncheckedCreateNestedOneWithoutId_relationInput
    skills?: SkillsListUncheckedCreateNestedOneWithoutId_relationInput
    resistances?: DamageTypeUncheckedCreateNestedManyWithoutResistant_creaturesInput
    immunities?: DamageTypeUncheckedCreateNestedManyWithoutImmune_creaturesInput
    vulnerabilities?: DamageTypeUncheckedCreateNestedManyWithoutVunlerable_creaturesInput
    senses?: SensesUncheckedCreateNestedOneWithoutCreatureInput
    actions?: ActionUncheckedCreateNestedManyWithoutCreaturesInput
    traits?: TraitUncheckedCreateNestedManyWithoutCreturesInput
    biome_relation?: BiomeUncheckedCreateNestedManyWithoutCreaturesInput
  }

  export type CreatureCreateOrConnectWithoutLanguagesInput = {
    where: CreatureWhereUniqueInput
    create: XOR<CreatureCreateWithoutLanguagesInput, CreatureUncheckedCreateWithoutLanguagesInput>
  }

  export type CreatureUpsertWithWhereUniqueWithoutLanguagesInput = {
    where: CreatureWhereUniqueInput
    update: XOR<CreatureUpdateWithoutLanguagesInput, CreatureUncheckedUpdateWithoutLanguagesInput>
    create: XOR<CreatureCreateWithoutLanguagesInput, CreatureUncheckedCreateWithoutLanguagesInput>
  }

  export type CreatureUpdateWithWhereUniqueWithoutLanguagesInput = {
    where: CreatureWhereUniqueInput
    data: XOR<CreatureUpdateWithoutLanguagesInput, CreatureUncheckedUpdateWithoutLanguagesInput>
  }

  export type CreatureUpdateManyWithWhereWithoutLanguagesInput = {
    where: CreatureScalarWhereInput
    data: XOR<CreatureUpdateManyMutationInput, CreatureUncheckedUpdateManyWithoutLanguagesInput>
  }

  export type CreatureCreateWithoutBiome_relationInput = {
    id?: string
    name: string
    creator_id?: string | null
    image_uri?: string | null
    description?: string | null
    armor_class?: number | null
    hit_points?: number | null
    challenge_rating: string
    biomes_ids?: CreatureCreatebiomes_idsInput | number[]
    aSubTypes?: CreatureCreateaSubTypesInput | string[]
    speed?: Speed_statCreateNestedOneWithoutId_relationInput
    stats?: Creature_statsCreateNestedOneWithoutId_relationInput
    skills?: SkillsListCreateNestedOneWithoutId_relationInput
    resistances?: DamageTypeCreateNestedManyWithoutResistant_creaturesInput
    immunities?: DamageTypeCreateNestedManyWithoutImmune_creaturesInput
    vulnerabilities?: DamageTypeCreateNestedManyWithoutVunlerable_creaturesInput
    senses?: SensesCreateNestedOneWithoutCreatureInput
    languages?: LanguageCreateNestedManyWithoutCreaturesInput
    actions?: ActionCreateNestedManyWithoutCreaturesInput
    traits?: TraitCreateNestedManyWithoutCreturesInput
    alignment_relation?: AlignmentCreateNestedOneWithoutCreaturesInput
    race_relation?: CreatureRaceCreateNestedOneWithoutCreaturesInput
    type_relation?: TypeCreateNestedOneWithoutCreaturesInput
    size_relation?: SizeCreateNestedOneWithoutCreatureInput
    source_relation?: SourceCreateNestedOneWithoutCreaturesInput
  }

  export type CreatureUncheckedCreateWithoutBiome_relationInput = {
    id?: string
    name: string
    creator_id?: string | null
    image_uri?: string | null
    description?: string | null
    size?: string | null
    race_id?: number | null
    source_id?: number | null
    alignment_id?: number | null
    armor_class?: number | null
    hit_points?: number | null
    challenge_rating: string
    biomes_ids?: CreatureCreatebiomes_idsInput | number[]
    type_id?: number | null
    aSubTypes?: CreatureCreateaSubTypesInput | string[]
    speed?: Speed_statUncheckedCreateNestedOneWithoutId_relationInput
    stats?: Creature_statsUncheckedCreateNestedOneWithoutId_relationInput
    skills?: SkillsListUncheckedCreateNestedOneWithoutId_relationInput
    resistances?: DamageTypeUncheckedCreateNestedManyWithoutResistant_creaturesInput
    immunities?: DamageTypeUncheckedCreateNestedManyWithoutImmune_creaturesInput
    vulnerabilities?: DamageTypeUncheckedCreateNestedManyWithoutVunlerable_creaturesInput
    senses?: SensesUncheckedCreateNestedOneWithoutCreatureInput
    languages?: LanguageUncheckedCreateNestedManyWithoutCreaturesInput
    actions?: ActionUncheckedCreateNestedManyWithoutCreaturesInput
    traits?: TraitUncheckedCreateNestedManyWithoutCreturesInput
  }

  export type CreatureCreateOrConnectWithoutBiome_relationInput = {
    where: CreatureWhereUniqueInput
    create: XOR<CreatureCreateWithoutBiome_relationInput, CreatureUncheckedCreateWithoutBiome_relationInput>
  }

  export type CreatureUpsertWithWhereUniqueWithoutBiome_relationInput = {
    where: CreatureWhereUniqueInput
    update: XOR<CreatureUpdateWithoutBiome_relationInput, CreatureUncheckedUpdateWithoutBiome_relationInput>
    create: XOR<CreatureCreateWithoutBiome_relationInput, CreatureUncheckedCreateWithoutBiome_relationInput>
  }

  export type CreatureUpdateWithWhereUniqueWithoutBiome_relationInput = {
    where: CreatureWhereUniqueInput
    data: XOR<CreatureUpdateWithoutBiome_relationInput, CreatureUncheckedUpdateWithoutBiome_relationInput>
  }

  export type CreatureUpdateManyWithWhereWithoutBiome_relationInput = {
    where: CreatureScalarWhereInput
    data: XOR<CreatureUpdateManyMutationInput, CreatureUncheckedUpdateManyWithoutBiome_relationInput>
  }

  export type CreatureCreateWithoutType_relationInput = {
    id?: string
    name: string
    creator_id?: string | null
    image_uri?: string | null
    description?: string | null
    armor_class?: number | null
    hit_points?: number | null
    challenge_rating: string
    biomes_ids?: CreatureCreatebiomes_idsInput | number[]
    aSubTypes?: CreatureCreateaSubTypesInput | string[]
    speed?: Speed_statCreateNestedOneWithoutId_relationInput
    stats?: Creature_statsCreateNestedOneWithoutId_relationInput
    skills?: SkillsListCreateNestedOneWithoutId_relationInput
    resistances?: DamageTypeCreateNestedManyWithoutResistant_creaturesInput
    immunities?: DamageTypeCreateNestedManyWithoutImmune_creaturesInput
    vulnerabilities?: DamageTypeCreateNestedManyWithoutVunlerable_creaturesInput
    senses?: SensesCreateNestedOneWithoutCreatureInput
    languages?: LanguageCreateNestedManyWithoutCreaturesInput
    actions?: ActionCreateNestedManyWithoutCreaturesInput
    traits?: TraitCreateNestedManyWithoutCreturesInput
    alignment_relation?: AlignmentCreateNestedOneWithoutCreaturesInput
    race_relation?: CreatureRaceCreateNestedOneWithoutCreaturesInput
    size_relation?: SizeCreateNestedOneWithoutCreatureInput
    biome_relation?: BiomeCreateNestedManyWithoutCreaturesInput
    source_relation?: SourceCreateNestedOneWithoutCreaturesInput
  }

  export type CreatureUncheckedCreateWithoutType_relationInput = {
    id?: string
    name: string
    creator_id?: string | null
    image_uri?: string | null
    description?: string | null
    size?: string | null
    race_id?: number | null
    source_id?: number | null
    alignment_id?: number | null
    armor_class?: number | null
    hit_points?: number | null
    challenge_rating: string
    biomes_ids?: CreatureCreatebiomes_idsInput | number[]
    aSubTypes?: CreatureCreateaSubTypesInput | string[]
    speed?: Speed_statUncheckedCreateNestedOneWithoutId_relationInput
    stats?: Creature_statsUncheckedCreateNestedOneWithoutId_relationInput
    skills?: SkillsListUncheckedCreateNestedOneWithoutId_relationInput
    resistances?: DamageTypeUncheckedCreateNestedManyWithoutResistant_creaturesInput
    immunities?: DamageTypeUncheckedCreateNestedManyWithoutImmune_creaturesInput
    vulnerabilities?: DamageTypeUncheckedCreateNestedManyWithoutVunlerable_creaturesInput
    senses?: SensesUncheckedCreateNestedOneWithoutCreatureInput
    languages?: LanguageUncheckedCreateNestedManyWithoutCreaturesInput
    actions?: ActionUncheckedCreateNestedManyWithoutCreaturesInput
    traits?: TraitUncheckedCreateNestedManyWithoutCreturesInput
    biome_relation?: BiomeUncheckedCreateNestedManyWithoutCreaturesInput
  }

  export type CreatureCreateOrConnectWithoutType_relationInput = {
    where: CreatureWhereUniqueInput
    create: XOR<CreatureCreateWithoutType_relationInput, CreatureUncheckedCreateWithoutType_relationInput>
  }

  export type CreatureCreateManyType_relationInputEnvelope = {
    data: CreatureCreateManyType_relationInput | CreatureCreateManyType_relationInput[]
    skipDuplicates?: boolean
  }

  export type CreatureUpsertWithWhereUniqueWithoutType_relationInput = {
    where: CreatureWhereUniqueInput
    update: XOR<CreatureUpdateWithoutType_relationInput, CreatureUncheckedUpdateWithoutType_relationInput>
    create: XOR<CreatureCreateWithoutType_relationInput, CreatureUncheckedCreateWithoutType_relationInput>
  }

  export type CreatureUpdateWithWhereUniqueWithoutType_relationInput = {
    where: CreatureWhereUniqueInput
    data: XOR<CreatureUpdateWithoutType_relationInput, CreatureUncheckedUpdateWithoutType_relationInput>
  }

  export type CreatureUpdateManyWithWhereWithoutType_relationInput = {
    where: CreatureScalarWhereInput
    data: XOR<CreatureUpdateManyMutationInput, CreatureUncheckedUpdateManyWithoutType_relationInput>
  }

  export type CreatureCreateWithoutAlignment_relationInput = {
    id?: string
    name: string
    creator_id?: string | null
    image_uri?: string | null
    description?: string | null
    armor_class?: number | null
    hit_points?: number | null
    challenge_rating: string
    biomes_ids?: CreatureCreatebiomes_idsInput | number[]
    aSubTypes?: CreatureCreateaSubTypesInput | string[]
    speed?: Speed_statCreateNestedOneWithoutId_relationInput
    stats?: Creature_statsCreateNestedOneWithoutId_relationInput
    skills?: SkillsListCreateNestedOneWithoutId_relationInput
    resistances?: DamageTypeCreateNestedManyWithoutResistant_creaturesInput
    immunities?: DamageTypeCreateNestedManyWithoutImmune_creaturesInput
    vulnerabilities?: DamageTypeCreateNestedManyWithoutVunlerable_creaturesInput
    senses?: SensesCreateNestedOneWithoutCreatureInput
    languages?: LanguageCreateNestedManyWithoutCreaturesInput
    actions?: ActionCreateNestedManyWithoutCreaturesInput
    traits?: TraitCreateNestedManyWithoutCreturesInput
    race_relation?: CreatureRaceCreateNestedOneWithoutCreaturesInput
    type_relation?: TypeCreateNestedOneWithoutCreaturesInput
    size_relation?: SizeCreateNestedOneWithoutCreatureInput
    biome_relation?: BiomeCreateNestedManyWithoutCreaturesInput
    source_relation?: SourceCreateNestedOneWithoutCreaturesInput
  }

  export type CreatureUncheckedCreateWithoutAlignment_relationInput = {
    id?: string
    name: string
    creator_id?: string | null
    image_uri?: string | null
    description?: string | null
    size?: string | null
    race_id?: number | null
    source_id?: number | null
    armor_class?: number | null
    hit_points?: number | null
    challenge_rating: string
    biomes_ids?: CreatureCreatebiomes_idsInput | number[]
    type_id?: number | null
    aSubTypes?: CreatureCreateaSubTypesInput | string[]
    speed?: Speed_statUncheckedCreateNestedOneWithoutId_relationInput
    stats?: Creature_statsUncheckedCreateNestedOneWithoutId_relationInput
    skills?: SkillsListUncheckedCreateNestedOneWithoutId_relationInput
    resistances?: DamageTypeUncheckedCreateNestedManyWithoutResistant_creaturesInput
    immunities?: DamageTypeUncheckedCreateNestedManyWithoutImmune_creaturesInput
    vulnerabilities?: DamageTypeUncheckedCreateNestedManyWithoutVunlerable_creaturesInput
    senses?: SensesUncheckedCreateNestedOneWithoutCreatureInput
    languages?: LanguageUncheckedCreateNestedManyWithoutCreaturesInput
    actions?: ActionUncheckedCreateNestedManyWithoutCreaturesInput
    traits?: TraitUncheckedCreateNestedManyWithoutCreturesInput
    biome_relation?: BiomeUncheckedCreateNestedManyWithoutCreaturesInput
  }

  export type CreatureCreateOrConnectWithoutAlignment_relationInput = {
    where: CreatureWhereUniqueInput
    create: XOR<CreatureCreateWithoutAlignment_relationInput, CreatureUncheckedCreateWithoutAlignment_relationInput>
  }

  export type CreatureCreateManyAlignment_relationInputEnvelope = {
    data: CreatureCreateManyAlignment_relationInput | CreatureCreateManyAlignment_relationInput[]
    skipDuplicates?: boolean
  }

  export type CreatureUpsertWithWhereUniqueWithoutAlignment_relationInput = {
    where: CreatureWhereUniqueInput
    update: XOR<CreatureUpdateWithoutAlignment_relationInput, CreatureUncheckedUpdateWithoutAlignment_relationInput>
    create: XOR<CreatureCreateWithoutAlignment_relationInput, CreatureUncheckedCreateWithoutAlignment_relationInput>
  }

  export type CreatureUpdateWithWhereUniqueWithoutAlignment_relationInput = {
    where: CreatureWhereUniqueInput
    data: XOR<CreatureUpdateWithoutAlignment_relationInput, CreatureUncheckedUpdateWithoutAlignment_relationInput>
  }

  export type CreatureUpdateManyWithWhereWithoutAlignment_relationInput = {
    where: CreatureScalarWhereInput
    data: XOR<CreatureUpdateManyMutationInput, CreatureUncheckedUpdateManyWithoutAlignment_relationInput>
  }

  export type CreatureCreateWithoutSpeedInput = {
    id?: string
    name: string
    creator_id?: string | null
    image_uri?: string | null
    description?: string | null
    armor_class?: number | null
    hit_points?: number | null
    challenge_rating: string
    biomes_ids?: CreatureCreatebiomes_idsInput | number[]
    aSubTypes?: CreatureCreateaSubTypesInput | string[]
    stats?: Creature_statsCreateNestedOneWithoutId_relationInput
    skills?: SkillsListCreateNestedOneWithoutId_relationInput
    resistances?: DamageTypeCreateNestedManyWithoutResistant_creaturesInput
    immunities?: DamageTypeCreateNestedManyWithoutImmune_creaturesInput
    vulnerabilities?: DamageTypeCreateNestedManyWithoutVunlerable_creaturesInput
    senses?: SensesCreateNestedOneWithoutCreatureInput
    languages?: LanguageCreateNestedManyWithoutCreaturesInput
    actions?: ActionCreateNestedManyWithoutCreaturesInput
    traits?: TraitCreateNestedManyWithoutCreturesInput
    alignment_relation?: AlignmentCreateNestedOneWithoutCreaturesInput
    race_relation?: CreatureRaceCreateNestedOneWithoutCreaturesInput
    type_relation?: TypeCreateNestedOneWithoutCreaturesInput
    size_relation?: SizeCreateNestedOneWithoutCreatureInput
    biome_relation?: BiomeCreateNestedManyWithoutCreaturesInput
    source_relation?: SourceCreateNestedOneWithoutCreaturesInput
  }

  export type CreatureUncheckedCreateWithoutSpeedInput = {
    id?: string
    name: string
    creator_id?: string | null
    image_uri?: string | null
    description?: string | null
    size?: string | null
    race_id?: number | null
    source_id?: number | null
    alignment_id?: number | null
    armor_class?: number | null
    hit_points?: number | null
    challenge_rating: string
    biomes_ids?: CreatureCreatebiomes_idsInput | number[]
    type_id?: number | null
    aSubTypes?: CreatureCreateaSubTypesInput | string[]
    stats?: Creature_statsUncheckedCreateNestedOneWithoutId_relationInput
    skills?: SkillsListUncheckedCreateNestedOneWithoutId_relationInput
    resistances?: DamageTypeUncheckedCreateNestedManyWithoutResistant_creaturesInput
    immunities?: DamageTypeUncheckedCreateNestedManyWithoutImmune_creaturesInput
    vulnerabilities?: DamageTypeUncheckedCreateNestedManyWithoutVunlerable_creaturesInput
    senses?: SensesUncheckedCreateNestedOneWithoutCreatureInput
    languages?: LanguageUncheckedCreateNestedManyWithoutCreaturesInput
    actions?: ActionUncheckedCreateNestedManyWithoutCreaturesInput
    traits?: TraitUncheckedCreateNestedManyWithoutCreturesInput
    biome_relation?: BiomeUncheckedCreateNestedManyWithoutCreaturesInput
  }

  export type CreatureCreateOrConnectWithoutSpeedInput = {
    where: CreatureWhereUniqueInput
    create: XOR<CreatureCreateWithoutSpeedInput, CreatureUncheckedCreateWithoutSpeedInput>
  }

  export type CreatureUpsertWithoutSpeedInput = {
    update: XOR<CreatureUpdateWithoutSpeedInput, CreatureUncheckedUpdateWithoutSpeedInput>
    create: XOR<CreatureCreateWithoutSpeedInput, CreatureUncheckedCreateWithoutSpeedInput>
    where?: CreatureWhereInput
  }

  export type CreatureUpdateToOneWithWhereWithoutSpeedInput = {
    where?: CreatureWhereInput
    data: XOR<CreatureUpdateWithoutSpeedInput, CreatureUncheckedUpdateWithoutSpeedInput>
  }

  export type CreatureUpdateWithoutSpeedInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    creator_id?: NullableStringFieldUpdateOperationsInput | string | null
    image_uri?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    armor_class?: NullableIntFieldUpdateOperationsInput | number | null
    hit_points?: NullableIntFieldUpdateOperationsInput | number | null
    challenge_rating?: StringFieldUpdateOperationsInput | string
    biomes_ids?: CreatureUpdatebiomes_idsInput | number[]
    aSubTypes?: CreatureUpdateaSubTypesInput | string[]
    stats?: Creature_statsUpdateOneWithoutId_relationNestedInput
    skills?: SkillsListUpdateOneWithoutId_relationNestedInput
    resistances?: DamageTypeUpdateManyWithoutResistant_creaturesNestedInput
    immunities?: DamageTypeUpdateManyWithoutImmune_creaturesNestedInput
    vulnerabilities?: DamageTypeUpdateManyWithoutVunlerable_creaturesNestedInput
    senses?: SensesUpdateOneWithoutCreatureNestedInput
    languages?: LanguageUpdateManyWithoutCreaturesNestedInput
    actions?: ActionUpdateManyWithoutCreaturesNestedInput
    traits?: TraitUpdateManyWithoutCreturesNestedInput
    alignment_relation?: AlignmentUpdateOneWithoutCreaturesNestedInput
    race_relation?: CreatureRaceUpdateOneWithoutCreaturesNestedInput
    type_relation?: TypeUpdateOneWithoutCreaturesNestedInput
    size_relation?: SizeUpdateOneWithoutCreatureNestedInput
    biome_relation?: BiomeUpdateManyWithoutCreaturesNestedInput
    source_relation?: SourceUpdateOneWithoutCreaturesNestedInput
  }

  export type CreatureUncheckedUpdateWithoutSpeedInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    creator_id?: NullableStringFieldUpdateOperationsInput | string | null
    image_uri?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableStringFieldUpdateOperationsInput | string | null
    race_id?: NullableIntFieldUpdateOperationsInput | number | null
    source_id?: NullableIntFieldUpdateOperationsInput | number | null
    alignment_id?: NullableIntFieldUpdateOperationsInput | number | null
    armor_class?: NullableIntFieldUpdateOperationsInput | number | null
    hit_points?: NullableIntFieldUpdateOperationsInput | number | null
    challenge_rating?: StringFieldUpdateOperationsInput | string
    biomes_ids?: CreatureUpdatebiomes_idsInput | number[]
    type_id?: NullableIntFieldUpdateOperationsInput | number | null
    aSubTypes?: CreatureUpdateaSubTypesInput | string[]
    stats?: Creature_statsUncheckedUpdateOneWithoutId_relationNestedInput
    skills?: SkillsListUncheckedUpdateOneWithoutId_relationNestedInput
    resistances?: DamageTypeUncheckedUpdateManyWithoutResistant_creaturesNestedInput
    immunities?: DamageTypeUncheckedUpdateManyWithoutImmune_creaturesNestedInput
    vulnerabilities?: DamageTypeUncheckedUpdateManyWithoutVunlerable_creaturesNestedInput
    senses?: SensesUncheckedUpdateOneWithoutCreatureNestedInput
    languages?: LanguageUncheckedUpdateManyWithoutCreaturesNestedInput
    actions?: ActionUncheckedUpdateManyWithoutCreaturesNestedInput
    traits?: TraitUncheckedUpdateManyWithoutCreturesNestedInput
    biome_relation?: BiomeUncheckedUpdateManyWithoutCreaturesNestedInput
  }

  export type Strength_stat_detailsCreateWithoutCreature_statInput = {
    value: number
    mastery: boolean
  }

  export type Strength_stat_detailsUncheckedCreateWithoutCreature_statInput = {
    value: number
    mastery: boolean
  }

  export type Strength_stat_detailsCreateOrConnectWithoutCreature_statInput = {
    where: Strength_stat_detailsWhereUniqueInput
    create: XOR<Strength_stat_detailsCreateWithoutCreature_statInput, Strength_stat_detailsUncheckedCreateWithoutCreature_statInput>
  }

  export type Dexterity_stat_detailsCreateWithoutCreature_statInput = {
    value: number
    mastery: boolean
  }

  export type Dexterity_stat_detailsUncheckedCreateWithoutCreature_statInput = {
    value: number
    mastery: boolean
  }

  export type Dexterity_stat_detailsCreateOrConnectWithoutCreature_statInput = {
    where: Dexterity_stat_detailsWhereUniqueInput
    create: XOR<Dexterity_stat_detailsCreateWithoutCreature_statInput, Dexterity_stat_detailsUncheckedCreateWithoutCreature_statInput>
  }

  export type Constitution_stat_detailsCreateWithoutCreature_statInput = {
    value: number
    mastery: boolean
  }

  export type Constitution_stat_detailsUncheckedCreateWithoutCreature_statInput = {
    value: number
    mastery: boolean
  }

  export type Constitution_stat_detailsCreateOrConnectWithoutCreature_statInput = {
    where: Constitution_stat_detailsWhereUniqueInput
    create: XOR<Constitution_stat_detailsCreateWithoutCreature_statInput, Constitution_stat_detailsUncheckedCreateWithoutCreature_statInput>
  }

  export type Intelligence_stat_detailsCreateWithoutCreature_statInput = {
    value: number
    mastery: boolean
  }

  export type Intelligence_stat_detailsUncheckedCreateWithoutCreature_statInput = {
    value: number
    mastery: boolean
  }

  export type Intelligence_stat_detailsCreateOrConnectWithoutCreature_statInput = {
    where: Intelligence_stat_detailsWhereUniqueInput
    create: XOR<Intelligence_stat_detailsCreateWithoutCreature_statInput, Intelligence_stat_detailsUncheckedCreateWithoutCreature_statInput>
  }

  export type Wisdom_stat_detailsCreateWithoutCreature_statInput = {
    value: number
    mastery: boolean
  }

  export type Wisdom_stat_detailsUncheckedCreateWithoutCreature_statInput = {
    value: number
    mastery: boolean
  }

  export type Wisdom_stat_detailsCreateOrConnectWithoutCreature_statInput = {
    where: Wisdom_stat_detailsWhereUniqueInput
    create: XOR<Wisdom_stat_detailsCreateWithoutCreature_statInput, Wisdom_stat_detailsUncheckedCreateWithoutCreature_statInput>
  }

  export type Charisma_stat_detailsCreateWithoutCreature_statInput = {
    value: number
    mastery: boolean
  }

  export type Charisma_stat_detailsUncheckedCreateWithoutCreature_statInput = {
    value: number
    mastery: boolean
  }

  export type Charisma_stat_detailsCreateOrConnectWithoutCreature_statInput = {
    where: Charisma_stat_detailsWhereUniqueInput
    create: XOR<Charisma_stat_detailsCreateWithoutCreature_statInput, Charisma_stat_detailsUncheckedCreateWithoutCreature_statInput>
  }

  export type CreatureCreateWithoutStatsInput = {
    id?: string
    name: string
    creator_id?: string | null
    image_uri?: string | null
    description?: string | null
    armor_class?: number | null
    hit_points?: number | null
    challenge_rating: string
    biomes_ids?: CreatureCreatebiomes_idsInput | number[]
    aSubTypes?: CreatureCreateaSubTypesInput | string[]
    speed?: Speed_statCreateNestedOneWithoutId_relationInput
    skills?: SkillsListCreateNestedOneWithoutId_relationInput
    resistances?: DamageTypeCreateNestedManyWithoutResistant_creaturesInput
    immunities?: DamageTypeCreateNestedManyWithoutImmune_creaturesInput
    vulnerabilities?: DamageTypeCreateNestedManyWithoutVunlerable_creaturesInput
    senses?: SensesCreateNestedOneWithoutCreatureInput
    languages?: LanguageCreateNestedManyWithoutCreaturesInput
    actions?: ActionCreateNestedManyWithoutCreaturesInput
    traits?: TraitCreateNestedManyWithoutCreturesInput
    alignment_relation?: AlignmentCreateNestedOneWithoutCreaturesInput
    race_relation?: CreatureRaceCreateNestedOneWithoutCreaturesInput
    type_relation?: TypeCreateNestedOneWithoutCreaturesInput
    size_relation?: SizeCreateNestedOneWithoutCreatureInput
    biome_relation?: BiomeCreateNestedManyWithoutCreaturesInput
    source_relation?: SourceCreateNestedOneWithoutCreaturesInput
  }

  export type CreatureUncheckedCreateWithoutStatsInput = {
    id?: string
    name: string
    creator_id?: string | null
    image_uri?: string | null
    description?: string | null
    size?: string | null
    race_id?: number | null
    source_id?: number | null
    alignment_id?: number | null
    armor_class?: number | null
    hit_points?: number | null
    challenge_rating: string
    biomes_ids?: CreatureCreatebiomes_idsInput | number[]
    type_id?: number | null
    aSubTypes?: CreatureCreateaSubTypesInput | string[]
    speed?: Speed_statUncheckedCreateNestedOneWithoutId_relationInput
    skills?: SkillsListUncheckedCreateNestedOneWithoutId_relationInput
    resistances?: DamageTypeUncheckedCreateNestedManyWithoutResistant_creaturesInput
    immunities?: DamageTypeUncheckedCreateNestedManyWithoutImmune_creaturesInput
    vulnerabilities?: DamageTypeUncheckedCreateNestedManyWithoutVunlerable_creaturesInput
    senses?: SensesUncheckedCreateNestedOneWithoutCreatureInput
    languages?: LanguageUncheckedCreateNestedManyWithoutCreaturesInput
    actions?: ActionUncheckedCreateNestedManyWithoutCreaturesInput
    traits?: TraitUncheckedCreateNestedManyWithoutCreturesInput
    biome_relation?: BiomeUncheckedCreateNestedManyWithoutCreaturesInput
  }

  export type CreatureCreateOrConnectWithoutStatsInput = {
    where: CreatureWhereUniqueInput
    create: XOR<CreatureCreateWithoutStatsInput, CreatureUncheckedCreateWithoutStatsInput>
  }

  export type Strength_stat_detailsUpsertWithoutCreature_statInput = {
    update: XOR<Strength_stat_detailsUpdateWithoutCreature_statInput, Strength_stat_detailsUncheckedUpdateWithoutCreature_statInput>
    create: XOR<Strength_stat_detailsCreateWithoutCreature_statInput, Strength_stat_detailsUncheckedCreateWithoutCreature_statInput>
    where?: Strength_stat_detailsWhereInput
  }

  export type Strength_stat_detailsUpdateToOneWithWhereWithoutCreature_statInput = {
    where?: Strength_stat_detailsWhereInput
    data: XOR<Strength_stat_detailsUpdateWithoutCreature_statInput, Strength_stat_detailsUncheckedUpdateWithoutCreature_statInput>
  }

  export type Strength_stat_detailsUpdateWithoutCreature_statInput = {
    value?: IntFieldUpdateOperationsInput | number
    mastery?: BoolFieldUpdateOperationsInput | boolean
  }

  export type Strength_stat_detailsUncheckedUpdateWithoutCreature_statInput = {
    value?: IntFieldUpdateOperationsInput | number
    mastery?: BoolFieldUpdateOperationsInput | boolean
  }

  export type Dexterity_stat_detailsUpsertWithoutCreature_statInput = {
    update: XOR<Dexterity_stat_detailsUpdateWithoutCreature_statInput, Dexterity_stat_detailsUncheckedUpdateWithoutCreature_statInput>
    create: XOR<Dexterity_stat_detailsCreateWithoutCreature_statInput, Dexterity_stat_detailsUncheckedCreateWithoutCreature_statInput>
    where?: Dexterity_stat_detailsWhereInput
  }

  export type Dexterity_stat_detailsUpdateToOneWithWhereWithoutCreature_statInput = {
    where?: Dexterity_stat_detailsWhereInput
    data: XOR<Dexterity_stat_detailsUpdateWithoutCreature_statInput, Dexterity_stat_detailsUncheckedUpdateWithoutCreature_statInput>
  }

  export type Dexterity_stat_detailsUpdateWithoutCreature_statInput = {
    value?: IntFieldUpdateOperationsInput | number
    mastery?: BoolFieldUpdateOperationsInput | boolean
  }

  export type Dexterity_stat_detailsUncheckedUpdateWithoutCreature_statInput = {
    value?: IntFieldUpdateOperationsInput | number
    mastery?: BoolFieldUpdateOperationsInput | boolean
  }

  export type Constitution_stat_detailsUpsertWithoutCreature_statInput = {
    update: XOR<Constitution_stat_detailsUpdateWithoutCreature_statInput, Constitution_stat_detailsUncheckedUpdateWithoutCreature_statInput>
    create: XOR<Constitution_stat_detailsCreateWithoutCreature_statInput, Constitution_stat_detailsUncheckedCreateWithoutCreature_statInput>
    where?: Constitution_stat_detailsWhereInput
  }

  export type Constitution_stat_detailsUpdateToOneWithWhereWithoutCreature_statInput = {
    where?: Constitution_stat_detailsWhereInput
    data: XOR<Constitution_stat_detailsUpdateWithoutCreature_statInput, Constitution_stat_detailsUncheckedUpdateWithoutCreature_statInput>
  }

  export type Constitution_stat_detailsUpdateWithoutCreature_statInput = {
    value?: IntFieldUpdateOperationsInput | number
    mastery?: BoolFieldUpdateOperationsInput | boolean
  }

  export type Constitution_stat_detailsUncheckedUpdateWithoutCreature_statInput = {
    value?: IntFieldUpdateOperationsInput | number
    mastery?: BoolFieldUpdateOperationsInput | boolean
  }

  export type Intelligence_stat_detailsUpsertWithoutCreature_statInput = {
    update: XOR<Intelligence_stat_detailsUpdateWithoutCreature_statInput, Intelligence_stat_detailsUncheckedUpdateWithoutCreature_statInput>
    create: XOR<Intelligence_stat_detailsCreateWithoutCreature_statInput, Intelligence_stat_detailsUncheckedCreateWithoutCreature_statInput>
    where?: Intelligence_stat_detailsWhereInput
  }

  export type Intelligence_stat_detailsUpdateToOneWithWhereWithoutCreature_statInput = {
    where?: Intelligence_stat_detailsWhereInput
    data: XOR<Intelligence_stat_detailsUpdateWithoutCreature_statInput, Intelligence_stat_detailsUncheckedUpdateWithoutCreature_statInput>
  }

  export type Intelligence_stat_detailsUpdateWithoutCreature_statInput = {
    value?: IntFieldUpdateOperationsInput | number
    mastery?: BoolFieldUpdateOperationsInput | boolean
  }

  export type Intelligence_stat_detailsUncheckedUpdateWithoutCreature_statInput = {
    value?: IntFieldUpdateOperationsInput | number
    mastery?: BoolFieldUpdateOperationsInput | boolean
  }

  export type Wisdom_stat_detailsUpsertWithoutCreature_statInput = {
    update: XOR<Wisdom_stat_detailsUpdateWithoutCreature_statInput, Wisdom_stat_detailsUncheckedUpdateWithoutCreature_statInput>
    create: XOR<Wisdom_stat_detailsCreateWithoutCreature_statInput, Wisdom_stat_detailsUncheckedCreateWithoutCreature_statInput>
    where?: Wisdom_stat_detailsWhereInput
  }

  export type Wisdom_stat_detailsUpdateToOneWithWhereWithoutCreature_statInput = {
    where?: Wisdom_stat_detailsWhereInput
    data: XOR<Wisdom_stat_detailsUpdateWithoutCreature_statInput, Wisdom_stat_detailsUncheckedUpdateWithoutCreature_statInput>
  }

  export type Wisdom_stat_detailsUpdateWithoutCreature_statInput = {
    value?: IntFieldUpdateOperationsInput | number
    mastery?: BoolFieldUpdateOperationsInput | boolean
  }

  export type Wisdom_stat_detailsUncheckedUpdateWithoutCreature_statInput = {
    value?: IntFieldUpdateOperationsInput | number
    mastery?: BoolFieldUpdateOperationsInput | boolean
  }

  export type Charisma_stat_detailsUpsertWithoutCreature_statInput = {
    update: XOR<Charisma_stat_detailsUpdateWithoutCreature_statInput, Charisma_stat_detailsUncheckedUpdateWithoutCreature_statInput>
    create: XOR<Charisma_stat_detailsCreateWithoutCreature_statInput, Charisma_stat_detailsUncheckedCreateWithoutCreature_statInput>
    where?: Charisma_stat_detailsWhereInput
  }

  export type Charisma_stat_detailsUpdateToOneWithWhereWithoutCreature_statInput = {
    where?: Charisma_stat_detailsWhereInput
    data: XOR<Charisma_stat_detailsUpdateWithoutCreature_statInput, Charisma_stat_detailsUncheckedUpdateWithoutCreature_statInput>
  }

  export type Charisma_stat_detailsUpdateWithoutCreature_statInput = {
    value?: IntFieldUpdateOperationsInput | number
    mastery?: BoolFieldUpdateOperationsInput | boolean
  }

  export type Charisma_stat_detailsUncheckedUpdateWithoutCreature_statInput = {
    value?: IntFieldUpdateOperationsInput | number
    mastery?: BoolFieldUpdateOperationsInput | boolean
  }

  export type CreatureUpsertWithoutStatsInput = {
    update: XOR<CreatureUpdateWithoutStatsInput, CreatureUncheckedUpdateWithoutStatsInput>
    create: XOR<CreatureCreateWithoutStatsInput, CreatureUncheckedCreateWithoutStatsInput>
    where?: CreatureWhereInput
  }

  export type CreatureUpdateToOneWithWhereWithoutStatsInput = {
    where?: CreatureWhereInput
    data: XOR<CreatureUpdateWithoutStatsInput, CreatureUncheckedUpdateWithoutStatsInput>
  }

  export type CreatureUpdateWithoutStatsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    creator_id?: NullableStringFieldUpdateOperationsInput | string | null
    image_uri?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    armor_class?: NullableIntFieldUpdateOperationsInput | number | null
    hit_points?: NullableIntFieldUpdateOperationsInput | number | null
    challenge_rating?: StringFieldUpdateOperationsInput | string
    biomes_ids?: CreatureUpdatebiomes_idsInput | number[]
    aSubTypes?: CreatureUpdateaSubTypesInput | string[]
    speed?: Speed_statUpdateOneWithoutId_relationNestedInput
    skills?: SkillsListUpdateOneWithoutId_relationNestedInput
    resistances?: DamageTypeUpdateManyWithoutResistant_creaturesNestedInput
    immunities?: DamageTypeUpdateManyWithoutImmune_creaturesNestedInput
    vulnerabilities?: DamageTypeUpdateManyWithoutVunlerable_creaturesNestedInput
    senses?: SensesUpdateOneWithoutCreatureNestedInput
    languages?: LanguageUpdateManyWithoutCreaturesNestedInput
    actions?: ActionUpdateManyWithoutCreaturesNestedInput
    traits?: TraitUpdateManyWithoutCreturesNestedInput
    alignment_relation?: AlignmentUpdateOneWithoutCreaturesNestedInput
    race_relation?: CreatureRaceUpdateOneWithoutCreaturesNestedInput
    type_relation?: TypeUpdateOneWithoutCreaturesNestedInput
    size_relation?: SizeUpdateOneWithoutCreatureNestedInput
    biome_relation?: BiomeUpdateManyWithoutCreaturesNestedInput
    source_relation?: SourceUpdateOneWithoutCreaturesNestedInput
  }

  export type CreatureUncheckedUpdateWithoutStatsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    creator_id?: NullableStringFieldUpdateOperationsInput | string | null
    image_uri?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableStringFieldUpdateOperationsInput | string | null
    race_id?: NullableIntFieldUpdateOperationsInput | number | null
    source_id?: NullableIntFieldUpdateOperationsInput | number | null
    alignment_id?: NullableIntFieldUpdateOperationsInput | number | null
    armor_class?: NullableIntFieldUpdateOperationsInput | number | null
    hit_points?: NullableIntFieldUpdateOperationsInput | number | null
    challenge_rating?: StringFieldUpdateOperationsInput | string
    biomes_ids?: CreatureUpdatebiomes_idsInput | number[]
    type_id?: NullableIntFieldUpdateOperationsInput | number | null
    aSubTypes?: CreatureUpdateaSubTypesInput | string[]
    speed?: Speed_statUncheckedUpdateOneWithoutId_relationNestedInput
    skills?: SkillsListUncheckedUpdateOneWithoutId_relationNestedInput
    resistances?: DamageTypeUncheckedUpdateManyWithoutResistant_creaturesNestedInput
    immunities?: DamageTypeUncheckedUpdateManyWithoutImmune_creaturesNestedInput
    vulnerabilities?: DamageTypeUncheckedUpdateManyWithoutVunlerable_creaturesNestedInput
    senses?: SensesUncheckedUpdateOneWithoutCreatureNestedInput
    languages?: LanguageUncheckedUpdateManyWithoutCreaturesNestedInput
    actions?: ActionUncheckedUpdateManyWithoutCreaturesNestedInput
    traits?: TraitUncheckedUpdateManyWithoutCreturesNestedInput
    biome_relation?: BiomeUncheckedUpdateManyWithoutCreaturesNestedInput
  }

  export type Creature_statsCreateWithoutStrengthInput = {
    dexterity?: Dexterity_stat_detailsCreateNestedOneWithoutCreature_statInput
    constitution?: Constitution_stat_detailsCreateNestedOneWithoutCreature_statInput
    intelligence?: Intelligence_stat_detailsCreateNestedOneWithoutCreature_statInput
    wisdom?: Wisdom_stat_detailsCreateNestedOneWithoutCreature_statInput
    charisma?: Charisma_stat_detailsCreateNestedOneWithoutCreature_statInput
    id_relation: CreatureCreateNestedOneWithoutStatsInput
  }

  export type Creature_statsUncheckedCreateWithoutStrengthInput = {
    id: string
    dexterity?: Dexterity_stat_detailsUncheckedCreateNestedOneWithoutCreature_statInput
    constitution?: Constitution_stat_detailsUncheckedCreateNestedOneWithoutCreature_statInput
    intelligence?: Intelligence_stat_detailsUncheckedCreateNestedOneWithoutCreature_statInput
    wisdom?: Wisdom_stat_detailsUncheckedCreateNestedOneWithoutCreature_statInput
    charisma?: Charisma_stat_detailsUncheckedCreateNestedOneWithoutCreature_statInput
  }

  export type Creature_statsCreateOrConnectWithoutStrengthInput = {
    where: Creature_statsWhereUniqueInput
    create: XOR<Creature_statsCreateWithoutStrengthInput, Creature_statsUncheckedCreateWithoutStrengthInput>
  }

  export type Creature_statsUpsertWithoutStrengthInput = {
    update: XOR<Creature_statsUpdateWithoutStrengthInput, Creature_statsUncheckedUpdateWithoutStrengthInput>
    create: XOR<Creature_statsCreateWithoutStrengthInput, Creature_statsUncheckedCreateWithoutStrengthInput>
    where?: Creature_statsWhereInput
  }

  export type Creature_statsUpdateToOneWithWhereWithoutStrengthInput = {
    where?: Creature_statsWhereInput
    data: XOR<Creature_statsUpdateWithoutStrengthInput, Creature_statsUncheckedUpdateWithoutStrengthInput>
  }

  export type Creature_statsUpdateWithoutStrengthInput = {
    dexterity?: Dexterity_stat_detailsUpdateOneWithoutCreature_statNestedInput
    constitution?: Constitution_stat_detailsUpdateOneWithoutCreature_statNestedInput
    intelligence?: Intelligence_stat_detailsUpdateOneWithoutCreature_statNestedInput
    wisdom?: Wisdom_stat_detailsUpdateOneWithoutCreature_statNestedInput
    charisma?: Charisma_stat_detailsUpdateOneWithoutCreature_statNestedInput
    id_relation?: CreatureUpdateOneRequiredWithoutStatsNestedInput
  }

  export type Creature_statsUncheckedUpdateWithoutStrengthInput = {
    id?: StringFieldUpdateOperationsInput | string
    dexterity?: Dexterity_stat_detailsUncheckedUpdateOneWithoutCreature_statNestedInput
    constitution?: Constitution_stat_detailsUncheckedUpdateOneWithoutCreature_statNestedInput
    intelligence?: Intelligence_stat_detailsUncheckedUpdateOneWithoutCreature_statNestedInput
    wisdom?: Wisdom_stat_detailsUncheckedUpdateOneWithoutCreature_statNestedInput
    charisma?: Charisma_stat_detailsUncheckedUpdateOneWithoutCreature_statNestedInput
  }

  export type Creature_statsCreateWithoutDexterityInput = {
    strength?: Strength_stat_detailsCreateNestedOneWithoutCreature_statInput
    constitution?: Constitution_stat_detailsCreateNestedOneWithoutCreature_statInput
    intelligence?: Intelligence_stat_detailsCreateNestedOneWithoutCreature_statInput
    wisdom?: Wisdom_stat_detailsCreateNestedOneWithoutCreature_statInput
    charisma?: Charisma_stat_detailsCreateNestedOneWithoutCreature_statInput
    id_relation: CreatureCreateNestedOneWithoutStatsInput
  }

  export type Creature_statsUncheckedCreateWithoutDexterityInput = {
    id: string
    strength?: Strength_stat_detailsUncheckedCreateNestedOneWithoutCreature_statInput
    constitution?: Constitution_stat_detailsUncheckedCreateNestedOneWithoutCreature_statInput
    intelligence?: Intelligence_stat_detailsUncheckedCreateNestedOneWithoutCreature_statInput
    wisdom?: Wisdom_stat_detailsUncheckedCreateNestedOneWithoutCreature_statInput
    charisma?: Charisma_stat_detailsUncheckedCreateNestedOneWithoutCreature_statInput
  }

  export type Creature_statsCreateOrConnectWithoutDexterityInput = {
    where: Creature_statsWhereUniqueInput
    create: XOR<Creature_statsCreateWithoutDexterityInput, Creature_statsUncheckedCreateWithoutDexterityInput>
  }

  export type Creature_statsUpsertWithoutDexterityInput = {
    update: XOR<Creature_statsUpdateWithoutDexterityInput, Creature_statsUncheckedUpdateWithoutDexterityInput>
    create: XOR<Creature_statsCreateWithoutDexterityInput, Creature_statsUncheckedCreateWithoutDexterityInput>
    where?: Creature_statsWhereInput
  }

  export type Creature_statsUpdateToOneWithWhereWithoutDexterityInput = {
    where?: Creature_statsWhereInput
    data: XOR<Creature_statsUpdateWithoutDexterityInput, Creature_statsUncheckedUpdateWithoutDexterityInput>
  }

  export type Creature_statsUpdateWithoutDexterityInput = {
    strength?: Strength_stat_detailsUpdateOneWithoutCreature_statNestedInput
    constitution?: Constitution_stat_detailsUpdateOneWithoutCreature_statNestedInput
    intelligence?: Intelligence_stat_detailsUpdateOneWithoutCreature_statNestedInput
    wisdom?: Wisdom_stat_detailsUpdateOneWithoutCreature_statNestedInput
    charisma?: Charisma_stat_detailsUpdateOneWithoutCreature_statNestedInput
    id_relation?: CreatureUpdateOneRequiredWithoutStatsNestedInput
  }

  export type Creature_statsUncheckedUpdateWithoutDexterityInput = {
    id?: StringFieldUpdateOperationsInput | string
    strength?: Strength_stat_detailsUncheckedUpdateOneWithoutCreature_statNestedInput
    constitution?: Constitution_stat_detailsUncheckedUpdateOneWithoutCreature_statNestedInput
    intelligence?: Intelligence_stat_detailsUncheckedUpdateOneWithoutCreature_statNestedInput
    wisdom?: Wisdom_stat_detailsUncheckedUpdateOneWithoutCreature_statNestedInput
    charisma?: Charisma_stat_detailsUncheckedUpdateOneWithoutCreature_statNestedInput
  }

  export type Creature_statsCreateWithoutConstitutionInput = {
    strength?: Strength_stat_detailsCreateNestedOneWithoutCreature_statInput
    dexterity?: Dexterity_stat_detailsCreateNestedOneWithoutCreature_statInput
    intelligence?: Intelligence_stat_detailsCreateNestedOneWithoutCreature_statInput
    wisdom?: Wisdom_stat_detailsCreateNestedOneWithoutCreature_statInput
    charisma?: Charisma_stat_detailsCreateNestedOneWithoutCreature_statInput
    id_relation: CreatureCreateNestedOneWithoutStatsInput
  }

  export type Creature_statsUncheckedCreateWithoutConstitutionInput = {
    id: string
    strength?: Strength_stat_detailsUncheckedCreateNestedOneWithoutCreature_statInput
    dexterity?: Dexterity_stat_detailsUncheckedCreateNestedOneWithoutCreature_statInput
    intelligence?: Intelligence_stat_detailsUncheckedCreateNestedOneWithoutCreature_statInput
    wisdom?: Wisdom_stat_detailsUncheckedCreateNestedOneWithoutCreature_statInput
    charisma?: Charisma_stat_detailsUncheckedCreateNestedOneWithoutCreature_statInput
  }

  export type Creature_statsCreateOrConnectWithoutConstitutionInput = {
    where: Creature_statsWhereUniqueInput
    create: XOR<Creature_statsCreateWithoutConstitutionInput, Creature_statsUncheckedCreateWithoutConstitutionInput>
  }

  export type Creature_statsUpsertWithoutConstitutionInput = {
    update: XOR<Creature_statsUpdateWithoutConstitutionInput, Creature_statsUncheckedUpdateWithoutConstitutionInput>
    create: XOR<Creature_statsCreateWithoutConstitutionInput, Creature_statsUncheckedCreateWithoutConstitutionInput>
    where?: Creature_statsWhereInput
  }

  export type Creature_statsUpdateToOneWithWhereWithoutConstitutionInput = {
    where?: Creature_statsWhereInput
    data: XOR<Creature_statsUpdateWithoutConstitutionInput, Creature_statsUncheckedUpdateWithoutConstitutionInput>
  }

  export type Creature_statsUpdateWithoutConstitutionInput = {
    strength?: Strength_stat_detailsUpdateOneWithoutCreature_statNestedInput
    dexterity?: Dexterity_stat_detailsUpdateOneWithoutCreature_statNestedInput
    intelligence?: Intelligence_stat_detailsUpdateOneWithoutCreature_statNestedInput
    wisdom?: Wisdom_stat_detailsUpdateOneWithoutCreature_statNestedInput
    charisma?: Charisma_stat_detailsUpdateOneWithoutCreature_statNestedInput
    id_relation?: CreatureUpdateOneRequiredWithoutStatsNestedInput
  }

  export type Creature_statsUncheckedUpdateWithoutConstitutionInput = {
    id?: StringFieldUpdateOperationsInput | string
    strength?: Strength_stat_detailsUncheckedUpdateOneWithoutCreature_statNestedInput
    dexterity?: Dexterity_stat_detailsUncheckedUpdateOneWithoutCreature_statNestedInput
    intelligence?: Intelligence_stat_detailsUncheckedUpdateOneWithoutCreature_statNestedInput
    wisdom?: Wisdom_stat_detailsUncheckedUpdateOneWithoutCreature_statNestedInput
    charisma?: Charisma_stat_detailsUncheckedUpdateOneWithoutCreature_statNestedInput
  }

  export type Creature_statsCreateWithoutIntelligenceInput = {
    strength?: Strength_stat_detailsCreateNestedOneWithoutCreature_statInput
    dexterity?: Dexterity_stat_detailsCreateNestedOneWithoutCreature_statInput
    constitution?: Constitution_stat_detailsCreateNestedOneWithoutCreature_statInput
    wisdom?: Wisdom_stat_detailsCreateNestedOneWithoutCreature_statInput
    charisma?: Charisma_stat_detailsCreateNestedOneWithoutCreature_statInput
    id_relation: CreatureCreateNestedOneWithoutStatsInput
  }

  export type Creature_statsUncheckedCreateWithoutIntelligenceInput = {
    id: string
    strength?: Strength_stat_detailsUncheckedCreateNestedOneWithoutCreature_statInput
    dexterity?: Dexterity_stat_detailsUncheckedCreateNestedOneWithoutCreature_statInput
    constitution?: Constitution_stat_detailsUncheckedCreateNestedOneWithoutCreature_statInput
    wisdom?: Wisdom_stat_detailsUncheckedCreateNestedOneWithoutCreature_statInput
    charisma?: Charisma_stat_detailsUncheckedCreateNestedOneWithoutCreature_statInput
  }

  export type Creature_statsCreateOrConnectWithoutIntelligenceInput = {
    where: Creature_statsWhereUniqueInput
    create: XOR<Creature_statsCreateWithoutIntelligenceInput, Creature_statsUncheckedCreateWithoutIntelligenceInput>
  }

  export type Creature_statsUpsertWithoutIntelligenceInput = {
    update: XOR<Creature_statsUpdateWithoutIntelligenceInput, Creature_statsUncheckedUpdateWithoutIntelligenceInput>
    create: XOR<Creature_statsCreateWithoutIntelligenceInput, Creature_statsUncheckedCreateWithoutIntelligenceInput>
    where?: Creature_statsWhereInput
  }

  export type Creature_statsUpdateToOneWithWhereWithoutIntelligenceInput = {
    where?: Creature_statsWhereInput
    data: XOR<Creature_statsUpdateWithoutIntelligenceInput, Creature_statsUncheckedUpdateWithoutIntelligenceInput>
  }

  export type Creature_statsUpdateWithoutIntelligenceInput = {
    strength?: Strength_stat_detailsUpdateOneWithoutCreature_statNestedInput
    dexterity?: Dexterity_stat_detailsUpdateOneWithoutCreature_statNestedInput
    constitution?: Constitution_stat_detailsUpdateOneWithoutCreature_statNestedInput
    wisdom?: Wisdom_stat_detailsUpdateOneWithoutCreature_statNestedInput
    charisma?: Charisma_stat_detailsUpdateOneWithoutCreature_statNestedInput
    id_relation?: CreatureUpdateOneRequiredWithoutStatsNestedInput
  }

  export type Creature_statsUncheckedUpdateWithoutIntelligenceInput = {
    id?: StringFieldUpdateOperationsInput | string
    strength?: Strength_stat_detailsUncheckedUpdateOneWithoutCreature_statNestedInput
    dexterity?: Dexterity_stat_detailsUncheckedUpdateOneWithoutCreature_statNestedInput
    constitution?: Constitution_stat_detailsUncheckedUpdateOneWithoutCreature_statNestedInput
    wisdom?: Wisdom_stat_detailsUncheckedUpdateOneWithoutCreature_statNestedInput
    charisma?: Charisma_stat_detailsUncheckedUpdateOneWithoutCreature_statNestedInput
  }

  export type Creature_statsCreateWithoutWisdomInput = {
    strength?: Strength_stat_detailsCreateNestedOneWithoutCreature_statInput
    dexterity?: Dexterity_stat_detailsCreateNestedOneWithoutCreature_statInput
    constitution?: Constitution_stat_detailsCreateNestedOneWithoutCreature_statInput
    intelligence?: Intelligence_stat_detailsCreateNestedOneWithoutCreature_statInput
    charisma?: Charisma_stat_detailsCreateNestedOneWithoutCreature_statInput
    id_relation: CreatureCreateNestedOneWithoutStatsInput
  }

  export type Creature_statsUncheckedCreateWithoutWisdomInput = {
    id: string
    strength?: Strength_stat_detailsUncheckedCreateNestedOneWithoutCreature_statInput
    dexterity?: Dexterity_stat_detailsUncheckedCreateNestedOneWithoutCreature_statInput
    constitution?: Constitution_stat_detailsUncheckedCreateNestedOneWithoutCreature_statInput
    intelligence?: Intelligence_stat_detailsUncheckedCreateNestedOneWithoutCreature_statInput
    charisma?: Charisma_stat_detailsUncheckedCreateNestedOneWithoutCreature_statInput
  }

  export type Creature_statsCreateOrConnectWithoutWisdomInput = {
    where: Creature_statsWhereUniqueInput
    create: XOR<Creature_statsCreateWithoutWisdomInput, Creature_statsUncheckedCreateWithoutWisdomInput>
  }

  export type Creature_statsUpsertWithoutWisdomInput = {
    update: XOR<Creature_statsUpdateWithoutWisdomInput, Creature_statsUncheckedUpdateWithoutWisdomInput>
    create: XOR<Creature_statsCreateWithoutWisdomInput, Creature_statsUncheckedCreateWithoutWisdomInput>
    where?: Creature_statsWhereInput
  }

  export type Creature_statsUpdateToOneWithWhereWithoutWisdomInput = {
    where?: Creature_statsWhereInput
    data: XOR<Creature_statsUpdateWithoutWisdomInput, Creature_statsUncheckedUpdateWithoutWisdomInput>
  }

  export type Creature_statsUpdateWithoutWisdomInput = {
    strength?: Strength_stat_detailsUpdateOneWithoutCreature_statNestedInput
    dexterity?: Dexterity_stat_detailsUpdateOneWithoutCreature_statNestedInput
    constitution?: Constitution_stat_detailsUpdateOneWithoutCreature_statNestedInput
    intelligence?: Intelligence_stat_detailsUpdateOneWithoutCreature_statNestedInput
    charisma?: Charisma_stat_detailsUpdateOneWithoutCreature_statNestedInput
    id_relation?: CreatureUpdateOneRequiredWithoutStatsNestedInput
  }

  export type Creature_statsUncheckedUpdateWithoutWisdomInput = {
    id?: StringFieldUpdateOperationsInput | string
    strength?: Strength_stat_detailsUncheckedUpdateOneWithoutCreature_statNestedInput
    dexterity?: Dexterity_stat_detailsUncheckedUpdateOneWithoutCreature_statNestedInput
    constitution?: Constitution_stat_detailsUncheckedUpdateOneWithoutCreature_statNestedInput
    intelligence?: Intelligence_stat_detailsUncheckedUpdateOneWithoutCreature_statNestedInput
    charisma?: Charisma_stat_detailsUncheckedUpdateOneWithoutCreature_statNestedInput
  }

  export type Creature_statsCreateWithoutCharismaInput = {
    strength?: Strength_stat_detailsCreateNestedOneWithoutCreature_statInput
    dexterity?: Dexterity_stat_detailsCreateNestedOneWithoutCreature_statInput
    constitution?: Constitution_stat_detailsCreateNestedOneWithoutCreature_statInput
    intelligence?: Intelligence_stat_detailsCreateNestedOneWithoutCreature_statInput
    wisdom?: Wisdom_stat_detailsCreateNestedOneWithoutCreature_statInput
    id_relation: CreatureCreateNestedOneWithoutStatsInput
  }

  export type Creature_statsUncheckedCreateWithoutCharismaInput = {
    id: string
    strength?: Strength_stat_detailsUncheckedCreateNestedOneWithoutCreature_statInput
    dexterity?: Dexterity_stat_detailsUncheckedCreateNestedOneWithoutCreature_statInput
    constitution?: Constitution_stat_detailsUncheckedCreateNestedOneWithoutCreature_statInput
    intelligence?: Intelligence_stat_detailsUncheckedCreateNestedOneWithoutCreature_statInput
    wisdom?: Wisdom_stat_detailsUncheckedCreateNestedOneWithoutCreature_statInput
  }

  export type Creature_statsCreateOrConnectWithoutCharismaInput = {
    where: Creature_statsWhereUniqueInput
    create: XOR<Creature_statsCreateWithoutCharismaInput, Creature_statsUncheckedCreateWithoutCharismaInput>
  }

  export type Creature_statsUpsertWithoutCharismaInput = {
    update: XOR<Creature_statsUpdateWithoutCharismaInput, Creature_statsUncheckedUpdateWithoutCharismaInput>
    create: XOR<Creature_statsCreateWithoutCharismaInput, Creature_statsUncheckedCreateWithoutCharismaInput>
    where?: Creature_statsWhereInput
  }

  export type Creature_statsUpdateToOneWithWhereWithoutCharismaInput = {
    where?: Creature_statsWhereInput
    data: XOR<Creature_statsUpdateWithoutCharismaInput, Creature_statsUncheckedUpdateWithoutCharismaInput>
  }

  export type Creature_statsUpdateWithoutCharismaInput = {
    strength?: Strength_stat_detailsUpdateOneWithoutCreature_statNestedInput
    dexterity?: Dexterity_stat_detailsUpdateOneWithoutCreature_statNestedInput
    constitution?: Constitution_stat_detailsUpdateOneWithoutCreature_statNestedInput
    intelligence?: Intelligence_stat_detailsUpdateOneWithoutCreature_statNestedInput
    wisdom?: Wisdom_stat_detailsUpdateOneWithoutCreature_statNestedInput
    id_relation?: CreatureUpdateOneRequiredWithoutStatsNestedInput
  }

  export type Creature_statsUncheckedUpdateWithoutCharismaInput = {
    id?: StringFieldUpdateOperationsInput | string
    strength?: Strength_stat_detailsUncheckedUpdateOneWithoutCreature_statNestedInput
    dexterity?: Dexterity_stat_detailsUncheckedUpdateOneWithoutCreature_statNestedInput
    constitution?: Constitution_stat_detailsUncheckedUpdateOneWithoutCreature_statNestedInput
    intelligence?: Intelligence_stat_detailsUncheckedUpdateOneWithoutCreature_statNestedInput
    wisdom?: Wisdom_stat_detailsUncheckedUpdateOneWithoutCreature_statNestedInput
  }

  export type StrengthBasedSkillsCreateWithoutSkills_list_relationInput = {
    athletics?: AthleticsSkillCreateNestedOneWithoutSkill_listInput
  }

  export type StrengthBasedSkillsUncheckedCreateWithoutSkills_list_relationInput = {
    athletics?: AthleticsSkillUncheckedCreateNestedOneWithoutSkill_listInput
  }

  export type StrengthBasedSkillsCreateOrConnectWithoutSkills_list_relationInput = {
    where: StrengthBasedSkillsWhereUniqueInput
    create: XOR<StrengthBasedSkillsCreateWithoutSkills_list_relationInput, StrengthBasedSkillsUncheckedCreateWithoutSkills_list_relationInput>
  }

  export type DexterityBasedSkillsCreateWithoutSkills_list_relationInput = {
    acrobatics?: AcrobaticsSkillCreateNestedOneWithoutSkill_listInput
    sleight_of_hand?: SleightOfHandSkillCreateNestedOneWithoutSkill_listInput
    stealth?: StealthSkillCreateNestedOneWithoutSkill_listInput
  }

  export type DexterityBasedSkillsUncheckedCreateWithoutSkills_list_relationInput = {
    acrobatics?: AcrobaticsSkillUncheckedCreateNestedOneWithoutSkill_listInput
    sleight_of_hand?: SleightOfHandSkillUncheckedCreateNestedOneWithoutSkill_listInput
    stealth?: StealthSkillUncheckedCreateNestedOneWithoutSkill_listInput
  }

  export type DexterityBasedSkillsCreateOrConnectWithoutSkills_list_relationInput = {
    where: DexterityBasedSkillsWhereUniqueInput
    create: XOR<DexterityBasedSkillsCreateWithoutSkills_list_relationInput, DexterityBasedSkillsUncheckedCreateWithoutSkills_list_relationInput>
  }

  export type IntellengenceBasedSkillsCreateWithoutSkills_list_relationInput = {
    arcana?: ArcanaSkillCreateNestedOneWithoutSkill_listInput
    history?: HistorySkillCreateNestedOneWithoutSkill_listInput
    investigation?: InvestigationSkillCreateNestedOneWithoutSkill_listInput
    nature?: NatureSkillCreateNestedOneWithoutSkill_listInput
    religion?: ReligionSkillCreateNestedOneWithoutSkill_listInput
  }

  export type IntellengenceBasedSkillsUncheckedCreateWithoutSkills_list_relationInput = {
    arcana?: ArcanaSkillUncheckedCreateNestedOneWithoutSkill_listInput
    history?: HistorySkillUncheckedCreateNestedOneWithoutSkill_listInput
    investigation?: InvestigationSkillUncheckedCreateNestedOneWithoutSkill_listInput
    nature?: NatureSkillUncheckedCreateNestedOneWithoutSkill_listInput
    religion?: ReligionSkillUncheckedCreateNestedOneWithoutSkill_listInput
  }

  export type IntellengenceBasedSkillsCreateOrConnectWithoutSkills_list_relationInput = {
    where: IntellengenceBasedSkillsWhereUniqueInput
    create: XOR<IntellengenceBasedSkillsCreateWithoutSkills_list_relationInput, IntellengenceBasedSkillsUncheckedCreateWithoutSkills_list_relationInput>
  }

  export type WisdomBasedSkillsCreateWithoutSkills_list_relationInput = {
    animal_handling?: AnimalHandlingSkillCreateNestedOneWithoutSkill_listInput
    insight?: InsightSkillCreateNestedOneWithoutSkill_listInput
    medicine?: MedicineSkillCreateNestedOneWithoutSkill_listInput
    perception?: PerceptionSkillCreateNestedOneWithoutSkill_listInput
    survival?: SurvivalSkillCreateNestedOneWithoutSkill_listInput
  }

  export type WisdomBasedSkillsUncheckedCreateWithoutSkills_list_relationInput = {
    animal_handling?: AnimalHandlingSkillUncheckedCreateNestedOneWithoutSkill_listInput
    insight?: InsightSkillUncheckedCreateNestedOneWithoutSkill_listInput
    medicine?: MedicineSkillUncheckedCreateNestedOneWithoutSkill_listInput
    perception?: PerceptionSkillUncheckedCreateNestedOneWithoutSkill_listInput
    survival?: SurvivalSkillUncheckedCreateNestedOneWithoutSkill_listInput
  }

  export type WisdomBasedSkillsCreateOrConnectWithoutSkills_list_relationInput = {
    where: WisdomBasedSkillsWhereUniqueInput
    create: XOR<WisdomBasedSkillsCreateWithoutSkills_list_relationInput, WisdomBasedSkillsUncheckedCreateWithoutSkills_list_relationInput>
  }

  export type CharismaBasedSkillsCreateWithoutSkills_list_relationInput = {
    deception?: DeceptionSkillCreateNestedOneWithoutSkill_listInput
    intimidation?: IntimidationSkillCreateNestedOneWithoutSkill_listInput
    performance?: PerformanceSkillCreateNestedOneWithoutSkill_listInput
    persuasion?: PersuasionSkillCreateNestedOneWithoutSkill_listInput
  }

  export type CharismaBasedSkillsUncheckedCreateWithoutSkills_list_relationInput = {
    deception?: DeceptionSkillUncheckedCreateNestedOneWithoutSkill_listInput
    intimidation?: IntimidationSkillUncheckedCreateNestedOneWithoutSkill_listInput
    performance?: PerformanceSkillUncheckedCreateNestedOneWithoutSkill_listInput
    persuasion?: PersuasionSkillUncheckedCreateNestedOneWithoutSkill_listInput
  }

  export type CharismaBasedSkillsCreateOrConnectWithoutSkills_list_relationInput = {
    where: CharismaBasedSkillsWhereUniqueInput
    create: XOR<CharismaBasedSkillsCreateWithoutSkills_list_relationInput, CharismaBasedSkillsUncheckedCreateWithoutSkills_list_relationInput>
  }

  export type CreatureCreateWithoutSkillsInput = {
    id?: string
    name: string
    creator_id?: string | null
    image_uri?: string | null
    description?: string | null
    armor_class?: number | null
    hit_points?: number | null
    challenge_rating: string
    biomes_ids?: CreatureCreatebiomes_idsInput | number[]
    aSubTypes?: CreatureCreateaSubTypesInput | string[]
    speed?: Speed_statCreateNestedOneWithoutId_relationInput
    stats?: Creature_statsCreateNestedOneWithoutId_relationInput
    resistances?: DamageTypeCreateNestedManyWithoutResistant_creaturesInput
    immunities?: DamageTypeCreateNestedManyWithoutImmune_creaturesInput
    vulnerabilities?: DamageTypeCreateNestedManyWithoutVunlerable_creaturesInput
    senses?: SensesCreateNestedOneWithoutCreatureInput
    languages?: LanguageCreateNestedManyWithoutCreaturesInput
    actions?: ActionCreateNestedManyWithoutCreaturesInput
    traits?: TraitCreateNestedManyWithoutCreturesInput
    alignment_relation?: AlignmentCreateNestedOneWithoutCreaturesInput
    race_relation?: CreatureRaceCreateNestedOneWithoutCreaturesInput
    type_relation?: TypeCreateNestedOneWithoutCreaturesInput
    size_relation?: SizeCreateNestedOneWithoutCreatureInput
    biome_relation?: BiomeCreateNestedManyWithoutCreaturesInput
    source_relation?: SourceCreateNestedOneWithoutCreaturesInput
  }

  export type CreatureUncheckedCreateWithoutSkillsInput = {
    id?: string
    name: string
    creator_id?: string | null
    image_uri?: string | null
    description?: string | null
    size?: string | null
    race_id?: number | null
    source_id?: number | null
    alignment_id?: number | null
    armor_class?: number | null
    hit_points?: number | null
    challenge_rating: string
    biomes_ids?: CreatureCreatebiomes_idsInput | number[]
    type_id?: number | null
    aSubTypes?: CreatureCreateaSubTypesInput | string[]
    speed?: Speed_statUncheckedCreateNestedOneWithoutId_relationInput
    stats?: Creature_statsUncheckedCreateNestedOneWithoutId_relationInput
    resistances?: DamageTypeUncheckedCreateNestedManyWithoutResistant_creaturesInput
    immunities?: DamageTypeUncheckedCreateNestedManyWithoutImmune_creaturesInput
    vulnerabilities?: DamageTypeUncheckedCreateNestedManyWithoutVunlerable_creaturesInput
    senses?: SensesUncheckedCreateNestedOneWithoutCreatureInput
    languages?: LanguageUncheckedCreateNestedManyWithoutCreaturesInput
    actions?: ActionUncheckedCreateNestedManyWithoutCreaturesInput
    traits?: TraitUncheckedCreateNestedManyWithoutCreturesInput
    biome_relation?: BiomeUncheckedCreateNestedManyWithoutCreaturesInput
  }

  export type CreatureCreateOrConnectWithoutSkillsInput = {
    where: CreatureWhereUniqueInput
    create: XOR<CreatureCreateWithoutSkillsInput, CreatureUncheckedCreateWithoutSkillsInput>
  }

  export type StrengthBasedSkillsUpsertWithoutSkills_list_relationInput = {
    update: XOR<StrengthBasedSkillsUpdateWithoutSkills_list_relationInput, StrengthBasedSkillsUncheckedUpdateWithoutSkills_list_relationInput>
    create: XOR<StrengthBasedSkillsCreateWithoutSkills_list_relationInput, StrengthBasedSkillsUncheckedCreateWithoutSkills_list_relationInput>
    where?: StrengthBasedSkillsWhereInput
  }

  export type StrengthBasedSkillsUpdateToOneWithWhereWithoutSkills_list_relationInput = {
    where?: StrengthBasedSkillsWhereInput
    data: XOR<StrengthBasedSkillsUpdateWithoutSkills_list_relationInput, StrengthBasedSkillsUncheckedUpdateWithoutSkills_list_relationInput>
  }

  export type StrengthBasedSkillsUpdateWithoutSkills_list_relationInput = {
    athletics?: AthleticsSkillUpdateOneWithoutSkill_listNestedInput
  }

  export type StrengthBasedSkillsUncheckedUpdateWithoutSkills_list_relationInput = {
    athletics?: AthleticsSkillUncheckedUpdateOneWithoutSkill_listNestedInput
  }

  export type DexterityBasedSkillsUpsertWithoutSkills_list_relationInput = {
    update: XOR<DexterityBasedSkillsUpdateWithoutSkills_list_relationInput, DexterityBasedSkillsUncheckedUpdateWithoutSkills_list_relationInput>
    create: XOR<DexterityBasedSkillsCreateWithoutSkills_list_relationInput, DexterityBasedSkillsUncheckedCreateWithoutSkills_list_relationInput>
    where?: DexterityBasedSkillsWhereInput
  }

  export type DexterityBasedSkillsUpdateToOneWithWhereWithoutSkills_list_relationInput = {
    where?: DexterityBasedSkillsWhereInput
    data: XOR<DexterityBasedSkillsUpdateWithoutSkills_list_relationInput, DexterityBasedSkillsUncheckedUpdateWithoutSkills_list_relationInput>
  }

  export type DexterityBasedSkillsUpdateWithoutSkills_list_relationInput = {
    acrobatics?: AcrobaticsSkillUpdateOneWithoutSkill_listNestedInput
    sleight_of_hand?: SleightOfHandSkillUpdateOneWithoutSkill_listNestedInput
    stealth?: StealthSkillUpdateOneWithoutSkill_listNestedInput
  }

  export type DexterityBasedSkillsUncheckedUpdateWithoutSkills_list_relationInput = {
    acrobatics?: AcrobaticsSkillUncheckedUpdateOneWithoutSkill_listNestedInput
    sleight_of_hand?: SleightOfHandSkillUncheckedUpdateOneWithoutSkill_listNestedInput
    stealth?: StealthSkillUncheckedUpdateOneWithoutSkill_listNestedInput
  }

  export type IntellengenceBasedSkillsUpsertWithoutSkills_list_relationInput = {
    update: XOR<IntellengenceBasedSkillsUpdateWithoutSkills_list_relationInput, IntellengenceBasedSkillsUncheckedUpdateWithoutSkills_list_relationInput>
    create: XOR<IntellengenceBasedSkillsCreateWithoutSkills_list_relationInput, IntellengenceBasedSkillsUncheckedCreateWithoutSkills_list_relationInput>
    where?: IntellengenceBasedSkillsWhereInput
  }

  export type IntellengenceBasedSkillsUpdateToOneWithWhereWithoutSkills_list_relationInput = {
    where?: IntellengenceBasedSkillsWhereInput
    data: XOR<IntellengenceBasedSkillsUpdateWithoutSkills_list_relationInput, IntellengenceBasedSkillsUncheckedUpdateWithoutSkills_list_relationInput>
  }

  export type IntellengenceBasedSkillsUpdateWithoutSkills_list_relationInput = {
    arcana?: ArcanaSkillUpdateOneWithoutSkill_listNestedInput
    history?: HistorySkillUpdateOneWithoutSkill_listNestedInput
    investigation?: InvestigationSkillUpdateOneWithoutSkill_listNestedInput
    nature?: NatureSkillUpdateOneWithoutSkill_listNestedInput
    religion?: ReligionSkillUpdateOneWithoutSkill_listNestedInput
  }

  export type IntellengenceBasedSkillsUncheckedUpdateWithoutSkills_list_relationInput = {
    arcana?: ArcanaSkillUncheckedUpdateOneWithoutSkill_listNestedInput
    history?: HistorySkillUncheckedUpdateOneWithoutSkill_listNestedInput
    investigation?: InvestigationSkillUncheckedUpdateOneWithoutSkill_listNestedInput
    nature?: NatureSkillUncheckedUpdateOneWithoutSkill_listNestedInput
    religion?: ReligionSkillUncheckedUpdateOneWithoutSkill_listNestedInput
  }

  export type WisdomBasedSkillsUpsertWithoutSkills_list_relationInput = {
    update: XOR<WisdomBasedSkillsUpdateWithoutSkills_list_relationInput, WisdomBasedSkillsUncheckedUpdateWithoutSkills_list_relationInput>
    create: XOR<WisdomBasedSkillsCreateWithoutSkills_list_relationInput, WisdomBasedSkillsUncheckedCreateWithoutSkills_list_relationInput>
    where?: WisdomBasedSkillsWhereInput
  }

  export type WisdomBasedSkillsUpdateToOneWithWhereWithoutSkills_list_relationInput = {
    where?: WisdomBasedSkillsWhereInput
    data: XOR<WisdomBasedSkillsUpdateWithoutSkills_list_relationInput, WisdomBasedSkillsUncheckedUpdateWithoutSkills_list_relationInput>
  }

  export type WisdomBasedSkillsUpdateWithoutSkills_list_relationInput = {
    animal_handling?: AnimalHandlingSkillUpdateOneWithoutSkill_listNestedInput
    insight?: InsightSkillUpdateOneWithoutSkill_listNestedInput
    medicine?: MedicineSkillUpdateOneWithoutSkill_listNestedInput
    perception?: PerceptionSkillUpdateOneWithoutSkill_listNestedInput
    survival?: SurvivalSkillUpdateOneWithoutSkill_listNestedInput
  }

  export type WisdomBasedSkillsUncheckedUpdateWithoutSkills_list_relationInput = {
    animal_handling?: AnimalHandlingSkillUncheckedUpdateOneWithoutSkill_listNestedInput
    insight?: InsightSkillUncheckedUpdateOneWithoutSkill_listNestedInput
    medicine?: MedicineSkillUncheckedUpdateOneWithoutSkill_listNestedInput
    perception?: PerceptionSkillUncheckedUpdateOneWithoutSkill_listNestedInput
    survival?: SurvivalSkillUncheckedUpdateOneWithoutSkill_listNestedInput
  }

  export type CharismaBasedSkillsUpsertWithoutSkills_list_relationInput = {
    update: XOR<CharismaBasedSkillsUpdateWithoutSkills_list_relationInput, CharismaBasedSkillsUncheckedUpdateWithoutSkills_list_relationInput>
    create: XOR<CharismaBasedSkillsCreateWithoutSkills_list_relationInput, CharismaBasedSkillsUncheckedCreateWithoutSkills_list_relationInput>
    where?: CharismaBasedSkillsWhereInput
  }

  export type CharismaBasedSkillsUpdateToOneWithWhereWithoutSkills_list_relationInput = {
    where?: CharismaBasedSkillsWhereInput
    data: XOR<CharismaBasedSkillsUpdateWithoutSkills_list_relationInput, CharismaBasedSkillsUncheckedUpdateWithoutSkills_list_relationInput>
  }

  export type CharismaBasedSkillsUpdateWithoutSkills_list_relationInput = {
    deception?: DeceptionSkillUpdateOneWithoutSkill_listNestedInput
    intimidation?: IntimidationSkillUpdateOneWithoutSkill_listNestedInput
    performance?: PerformanceSkillUpdateOneWithoutSkill_listNestedInput
    persuasion?: PersuasionSkillUpdateOneWithoutSkill_listNestedInput
  }

  export type CharismaBasedSkillsUncheckedUpdateWithoutSkills_list_relationInput = {
    deception?: DeceptionSkillUncheckedUpdateOneWithoutSkill_listNestedInput
    intimidation?: IntimidationSkillUncheckedUpdateOneWithoutSkill_listNestedInput
    performance?: PerformanceSkillUncheckedUpdateOneWithoutSkill_listNestedInput
    persuasion?: PersuasionSkillUncheckedUpdateOneWithoutSkill_listNestedInput
  }

  export type CreatureUpsertWithoutSkillsInput = {
    update: XOR<CreatureUpdateWithoutSkillsInput, CreatureUncheckedUpdateWithoutSkillsInput>
    create: XOR<CreatureCreateWithoutSkillsInput, CreatureUncheckedCreateWithoutSkillsInput>
    where?: CreatureWhereInput
  }

  export type CreatureUpdateToOneWithWhereWithoutSkillsInput = {
    where?: CreatureWhereInput
    data: XOR<CreatureUpdateWithoutSkillsInput, CreatureUncheckedUpdateWithoutSkillsInput>
  }

  export type CreatureUpdateWithoutSkillsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    creator_id?: NullableStringFieldUpdateOperationsInput | string | null
    image_uri?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    armor_class?: NullableIntFieldUpdateOperationsInput | number | null
    hit_points?: NullableIntFieldUpdateOperationsInput | number | null
    challenge_rating?: StringFieldUpdateOperationsInput | string
    biomes_ids?: CreatureUpdatebiomes_idsInput | number[]
    aSubTypes?: CreatureUpdateaSubTypesInput | string[]
    speed?: Speed_statUpdateOneWithoutId_relationNestedInput
    stats?: Creature_statsUpdateOneWithoutId_relationNestedInput
    resistances?: DamageTypeUpdateManyWithoutResistant_creaturesNestedInput
    immunities?: DamageTypeUpdateManyWithoutImmune_creaturesNestedInput
    vulnerabilities?: DamageTypeUpdateManyWithoutVunlerable_creaturesNestedInput
    senses?: SensesUpdateOneWithoutCreatureNestedInput
    languages?: LanguageUpdateManyWithoutCreaturesNestedInput
    actions?: ActionUpdateManyWithoutCreaturesNestedInput
    traits?: TraitUpdateManyWithoutCreturesNestedInput
    alignment_relation?: AlignmentUpdateOneWithoutCreaturesNestedInput
    race_relation?: CreatureRaceUpdateOneWithoutCreaturesNestedInput
    type_relation?: TypeUpdateOneWithoutCreaturesNestedInput
    size_relation?: SizeUpdateOneWithoutCreatureNestedInput
    biome_relation?: BiomeUpdateManyWithoutCreaturesNestedInput
    source_relation?: SourceUpdateOneWithoutCreaturesNestedInput
  }

  export type CreatureUncheckedUpdateWithoutSkillsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    creator_id?: NullableStringFieldUpdateOperationsInput | string | null
    image_uri?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableStringFieldUpdateOperationsInput | string | null
    race_id?: NullableIntFieldUpdateOperationsInput | number | null
    source_id?: NullableIntFieldUpdateOperationsInput | number | null
    alignment_id?: NullableIntFieldUpdateOperationsInput | number | null
    armor_class?: NullableIntFieldUpdateOperationsInput | number | null
    hit_points?: NullableIntFieldUpdateOperationsInput | number | null
    challenge_rating?: StringFieldUpdateOperationsInput | string
    biomes_ids?: CreatureUpdatebiomes_idsInput | number[]
    type_id?: NullableIntFieldUpdateOperationsInput | number | null
    aSubTypes?: CreatureUpdateaSubTypesInput | string[]
    speed?: Speed_statUncheckedUpdateOneWithoutId_relationNestedInput
    stats?: Creature_statsUncheckedUpdateOneWithoutId_relationNestedInput
    resistances?: DamageTypeUncheckedUpdateManyWithoutResistant_creaturesNestedInput
    immunities?: DamageTypeUncheckedUpdateManyWithoutImmune_creaturesNestedInput
    vulnerabilities?: DamageTypeUncheckedUpdateManyWithoutVunlerable_creaturesNestedInput
    senses?: SensesUncheckedUpdateOneWithoutCreatureNestedInput
    languages?: LanguageUncheckedUpdateManyWithoutCreaturesNestedInput
    actions?: ActionUncheckedUpdateManyWithoutCreaturesNestedInput
    traits?: TraitUncheckedUpdateManyWithoutCreturesNestedInput
    biome_relation?: BiomeUncheckedUpdateManyWithoutCreaturesNestedInput
  }

  export type AthleticsSkillCreateWithoutSkill_listInput = {
    value?: number | null
    mastery: boolean
    name?: string
  }

  export type AthleticsSkillUncheckedCreateWithoutSkill_listInput = {
    value?: number | null
    mastery: boolean
    name?: string
  }

  export type AthleticsSkillCreateOrConnectWithoutSkill_listInput = {
    where: AthleticsSkillWhereUniqueInput
    create: XOR<AthleticsSkillCreateWithoutSkill_listInput, AthleticsSkillUncheckedCreateWithoutSkill_listInput>
  }

  export type SkillsListCreateWithoutStrengthInput = {
    dexterity?: DexterityBasedSkillsCreateNestedOneWithoutSkills_list_relationInput
    intelligence?: IntellengenceBasedSkillsCreateNestedOneWithoutSkills_list_relationInput
    wisdom?: WisdomBasedSkillsCreateNestedOneWithoutSkills_list_relationInput
    charisma?: CharismaBasedSkillsCreateNestedOneWithoutSkills_list_relationInput
    id_relation: CreatureCreateNestedOneWithoutSkillsInput
  }

  export type SkillsListUncheckedCreateWithoutStrengthInput = {
    id: string
    dexterity?: DexterityBasedSkillsUncheckedCreateNestedOneWithoutSkills_list_relationInput
    intelligence?: IntellengenceBasedSkillsUncheckedCreateNestedOneWithoutSkills_list_relationInput
    wisdom?: WisdomBasedSkillsUncheckedCreateNestedOneWithoutSkills_list_relationInput
    charisma?: CharismaBasedSkillsUncheckedCreateNestedOneWithoutSkills_list_relationInput
  }

  export type SkillsListCreateOrConnectWithoutStrengthInput = {
    where: SkillsListWhereUniqueInput
    create: XOR<SkillsListCreateWithoutStrengthInput, SkillsListUncheckedCreateWithoutStrengthInput>
  }

  export type AthleticsSkillUpsertWithoutSkill_listInput = {
    update: XOR<AthleticsSkillUpdateWithoutSkill_listInput, AthleticsSkillUncheckedUpdateWithoutSkill_listInput>
    create: XOR<AthleticsSkillCreateWithoutSkill_listInput, AthleticsSkillUncheckedCreateWithoutSkill_listInput>
    where?: AthleticsSkillWhereInput
  }

  export type AthleticsSkillUpdateToOneWithWhereWithoutSkill_listInput = {
    where?: AthleticsSkillWhereInput
    data: XOR<AthleticsSkillUpdateWithoutSkill_listInput, AthleticsSkillUncheckedUpdateWithoutSkill_listInput>
  }

  export type AthleticsSkillUpdateWithoutSkill_listInput = {
    value?: NullableIntFieldUpdateOperationsInput | number | null
    mastery?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
  }

  export type AthleticsSkillUncheckedUpdateWithoutSkill_listInput = {
    value?: NullableIntFieldUpdateOperationsInput | number | null
    mastery?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
  }

  export type SkillsListUpsertWithoutStrengthInput = {
    update: XOR<SkillsListUpdateWithoutStrengthInput, SkillsListUncheckedUpdateWithoutStrengthInput>
    create: XOR<SkillsListCreateWithoutStrengthInput, SkillsListUncheckedCreateWithoutStrengthInput>
    where?: SkillsListWhereInput
  }

  export type SkillsListUpdateToOneWithWhereWithoutStrengthInput = {
    where?: SkillsListWhereInput
    data: XOR<SkillsListUpdateWithoutStrengthInput, SkillsListUncheckedUpdateWithoutStrengthInput>
  }

  export type SkillsListUpdateWithoutStrengthInput = {
    dexterity?: DexterityBasedSkillsUpdateOneWithoutSkills_list_relationNestedInput
    intelligence?: IntellengenceBasedSkillsUpdateOneWithoutSkills_list_relationNestedInput
    wisdom?: WisdomBasedSkillsUpdateOneWithoutSkills_list_relationNestedInput
    charisma?: CharismaBasedSkillsUpdateOneWithoutSkills_list_relationNestedInput
    id_relation?: CreatureUpdateOneRequiredWithoutSkillsNestedInput
  }

  export type SkillsListUncheckedUpdateWithoutStrengthInput = {
    id?: StringFieldUpdateOperationsInput | string
    dexterity?: DexterityBasedSkillsUncheckedUpdateOneWithoutSkills_list_relationNestedInput
    intelligence?: IntellengenceBasedSkillsUncheckedUpdateOneWithoutSkills_list_relationNestedInput
    wisdom?: WisdomBasedSkillsUncheckedUpdateOneWithoutSkills_list_relationNestedInput
    charisma?: CharismaBasedSkillsUncheckedUpdateOneWithoutSkills_list_relationNestedInput
  }

  export type AcrobaticsSkillCreateWithoutSkill_listInput = {
    value?: number | null
    mastery: boolean
    name?: string
  }

  export type AcrobaticsSkillUncheckedCreateWithoutSkill_listInput = {
    value?: number | null
    mastery: boolean
    name?: string
  }

  export type AcrobaticsSkillCreateOrConnectWithoutSkill_listInput = {
    where: AcrobaticsSkillWhereUniqueInput
    create: XOR<AcrobaticsSkillCreateWithoutSkill_listInput, AcrobaticsSkillUncheckedCreateWithoutSkill_listInput>
  }

  export type SleightOfHandSkillCreateWithoutSkill_listInput = {
    value?: number | null
    mastery: boolean
    name?: string
  }

  export type SleightOfHandSkillUncheckedCreateWithoutSkill_listInput = {
    value?: number | null
    mastery: boolean
    name?: string
  }

  export type SleightOfHandSkillCreateOrConnectWithoutSkill_listInput = {
    where: SleightOfHandSkillWhereUniqueInput
    create: XOR<SleightOfHandSkillCreateWithoutSkill_listInput, SleightOfHandSkillUncheckedCreateWithoutSkill_listInput>
  }

  export type StealthSkillCreateWithoutSkill_listInput = {
    value?: number | null
    mastery: boolean
    name?: string
  }

  export type StealthSkillUncheckedCreateWithoutSkill_listInput = {
    value?: number | null
    mastery: boolean
    name?: string
  }

  export type StealthSkillCreateOrConnectWithoutSkill_listInput = {
    where: StealthSkillWhereUniqueInput
    create: XOR<StealthSkillCreateWithoutSkill_listInput, StealthSkillUncheckedCreateWithoutSkill_listInput>
  }

  export type SkillsListCreateWithoutDexterityInput = {
    strength?: StrengthBasedSkillsCreateNestedOneWithoutSkills_list_relationInput
    intelligence?: IntellengenceBasedSkillsCreateNestedOneWithoutSkills_list_relationInput
    wisdom?: WisdomBasedSkillsCreateNestedOneWithoutSkills_list_relationInput
    charisma?: CharismaBasedSkillsCreateNestedOneWithoutSkills_list_relationInput
    id_relation: CreatureCreateNestedOneWithoutSkillsInput
  }

  export type SkillsListUncheckedCreateWithoutDexterityInput = {
    id: string
    strength?: StrengthBasedSkillsUncheckedCreateNestedOneWithoutSkills_list_relationInput
    intelligence?: IntellengenceBasedSkillsUncheckedCreateNestedOneWithoutSkills_list_relationInput
    wisdom?: WisdomBasedSkillsUncheckedCreateNestedOneWithoutSkills_list_relationInput
    charisma?: CharismaBasedSkillsUncheckedCreateNestedOneWithoutSkills_list_relationInput
  }

  export type SkillsListCreateOrConnectWithoutDexterityInput = {
    where: SkillsListWhereUniqueInput
    create: XOR<SkillsListCreateWithoutDexterityInput, SkillsListUncheckedCreateWithoutDexterityInput>
  }

  export type AcrobaticsSkillUpsertWithoutSkill_listInput = {
    update: XOR<AcrobaticsSkillUpdateWithoutSkill_listInput, AcrobaticsSkillUncheckedUpdateWithoutSkill_listInput>
    create: XOR<AcrobaticsSkillCreateWithoutSkill_listInput, AcrobaticsSkillUncheckedCreateWithoutSkill_listInput>
    where?: AcrobaticsSkillWhereInput
  }

  export type AcrobaticsSkillUpdateToOneWithWhereWithoutSkill_listInput = {
    where?: AcrobaticsSkillWhereInput
    data: XOR<AcrobaticsSkillUpdateWithoutSkill_listInput, AcrobaticsSkillUncheckedUpdateWithoutSkill_listInput>
  }

  export type AcrobaticsSkillUpdateWithoutSkill_listInput = {
    value?: NullableIntFieldUpdateOperationsInput | number | null
    mastery?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
  }

  export type AcrobaticsSkillUncheckedUpdateWithoutSkill_listInput = {
    value?: NullableIntFieldUpdateOperationsInput | number | null
    mastery?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
  }

  export type SleightOfHandSkillUpsertWithoutSkill_listInput = {
    update: XOR<SleightOfHandSkillUpdateWithoutSkill_listInput, SleightOfHandSkillUncheckedUpdateWithoutSkill_listInput>
    create: XOR<SleightOfHandSkillCreateWithoutSkill_listInput, SleightOfHandSkillUncheckedCreateWithoutSkill_listInput>
    where?: SleightOfHandSkillWhereInput
  }

  export type SleightOfHandSkillUpdateToOneWithWhereWithoutSkill_listInput = {
    where?: SleightOfHandSkillWhereInput
    data: XOR<SleightOfHandSkillUpdateWithoutSkill_listInput, SleightOfHandSkillUncheckedUpdateWithoutSkill_listInput>
  }

  export type SleightOfHandSkillUpdateWithoutSkill_listInput = {
    value?: NullableIntFieldUpdateOperationsInput | number | null
    mastery?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
  }

  export type SleightOfHandSkillUncheckedUpdateWithoutSkill_listInput = {
    value?: NullableIntFieldUpdateOperationsInput | number | null
    mastery?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
  }

  export type StealthSkillUpsertWithoutSkill_listInput = {
    update: XOR<StealthSkillUpdateWithoutSkill_listInput, StealthSkillUncheckedUpdateWithoutSkill_listInput>
    create: XOR<StealthSkillCreateWithoutSkill_listInput, StealthSkillUncheckedCreateWithoutSkill_listInput>
    where?: StealthSkillWhereInput
  }

  export type StealthSkillUpdateToOneWithWhereWithoutSkill_listInput = {
    where?: StealthSkillWhereInput
    data: XOR<StealthSkillUpdateWithoutSkill_listInput, StealthSkillUncheckedUpdateWithoutSkill_listInput>
  }

  export type StealthSkillUpdateWithoutSkill_listInput = {
    value?: NullableIntFieldUpdateOperationsInput | number | null
    mastery?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
  }

  export type StealthSkillUncheckedUpdateWithoutSkill_listInput = {
    value?: NullableIntFieldUpdateOperationsInput | number | null
    mastery?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
  }

  export type SkillsListUpsertWithoutDexterityInput = {
    update: XOR<SkillsListUpdateWithoutDexterityInput, SkillsListUncheckedUpdateWithoutDexterityInput>
    create: XOR<SkillsListCreateWithoutDexterityInput, SkillsListUncheckedCreateWithoutDexterityInput>
    where?: SkillsListWhereInput
  }

  export type SkillsListUpdateToOneWithWhereWithoutDexterityInput = {
    where?: SkillsListWhereInput
    data: XOR<SkillsListUpdateWithoutDexterityInput, SkillsListUncheckedUpdateWithoutDexterityInput>
  }

  export type SkillsListUpdateWithoutDexterityInput = {
    strength?: StrengthBasedSkillsUpdateOneWithoutSkills_list_relationNestedInput
    intelligence?: IntellengenceBasedSkillsUpdateOneWithoutSkills_list_relationNestedInput
    wisdom?: WisdomBasedSkillsUpdateOneWithoutSkills_list_relationNestedInput
    charisma?: CharismaBasedSkillsUpdateOneWithoutSkills_list_relationNestedInput
    id_relation?: CreatureUpdateOneRequiredWithoutSkillsNestedInput
  }

  export type SkillsListUncheckedUpdateWithoutDexterityInput = {
    id?: StringFieldUpdateOperationsInput | string
    strength?: StrengthBasedSkillsUncheckedUpdateOneWithoutSkills_list_relationNestedInput
    intelligence?: IntellengenceBasedSkillsUncheckedUpdateOneWithoutSkills_list_relationNestedInput
    wisdom?: WisdomBasedSkillsUncheckedUpdateOneWithoutSkills_list_relationNestedInput
    charisma?: CharismaBasedSkillsUncheckedUpdateOneWithoutSkills_list_relationNestedInput
  }

  export type ArcanaSkillCreateWithoutSkill_listInput = {
    value?: number | null
    mastery: boolean
    name?: string
  }

  export type ArcanaSkillUncheckedCreateWithoutSkill_listInput = {
    value?: number | null
    mastery: boolean
    name?: string
  }

  export type ArcanaSkillCreateOrConnectWithoutSkill_listInput = {
    where: ArcanaSkillWhereUniqueInput
    create: XOR<ArcanaSkillCreateWithoutSkill_listInput, ArcanaSkillUncheckedCreateWithoutSkill_listInput>
  }

  export type HistorySkillCreateWithoutSkill_listInput = {
    value?: number | null
    mastery: boolean
    name?: string
  }

  export type HistorySkillUncheckedCreateWithoutSkill_listInput = {
    value?: number | null
    mastery: boolean
    name?: string
  }

  export type HistorySkillCreateOrConnectWithoutSkill_listInput = {
    where: HistorySkillWhereUniqueInput
    create: XOR<HistorySkillCreateWithoutSkill_listInput, HistorySkillUncheckedCreateWithoutSkill_listInput>
  }

  export type InvestigationSkillCreateWithoutSkill_listInput = {
    value?: number | null
    mastery: boolean
    name?: string
  }

  export type InvestigationSkillUncheckedCreateWithoutSkill_listInput = {
    value?: number | null
    mastery: boolean
    name?: string
  }

  export type InvestigationSkillCreateOrConnectWithoutSkill_listInput = {
    where: InvestigationSkillWhereUniqueInput
    create: XOR<InvestigationSkillCreateWithoutSkill_listInput, InvestigationSkillUncheckedCreateWithoutSkill_listInput>
  }

  export type NatureSkillCreateWithoutSkill_listInput = {
    value?: number | null
    mastery: boolean
    name?: string
  }

  export type NatureSkillUncheckedCreateWithoutSkill_listInput = {
    value?: number | null
    mastery: boolean
    name?: string
  }

  export type NatureSkillCreateOrConnectWithoutSkill_listInput = {
    where: NatureSkillWhereUniqueInput
    create: XOR<NatureSkillCreateWithoutSkill_listInput, NatureSkillUncheckedCreateWithoutSkill_listInput>
  }

  export type ReligionSkillCreateWithoutSkill_listInput = {
    value?: number | null
    mastery: boolean
    name?: string
  }

  export type ReligionSkillUncheckedCreateWithoutSkill_listInput = {
    value?: number | null
    mastery: boolean
    name?: string
  }

  export type ReligionSkillCreateOrConnectWithoutSkill_listInput = {
    where: ReligionSkillWhereUniqueInput
    create: XOR<ReligionSkillCreateWithoutSkill_listInput, ReligionSkillUncheckedCreateWithoutSkill_listInput>
  }

  export type SkillsListCreateWithoutIntelligenceInput = {
    strength?: StrengthBasedSkillsCreateNestedOneWithoutSkills_list_relationInput
    dexterity?: DexterityBasedSkillsCreateNestedOneWithoutSkills_list_relationInput
    wisdom?: WisdomBasedSkillsCreateNestedOneWithoutSkills_list_relationInput
    charisma?: CharismaBasedSkillsCreateNestedOneWithoutSkills_list_relationInput
    id_relation: CreatureCreateNestedOneWithoutSkillsInput
  }

  export type SkillsListUncheckedCreateWithoutIntelligenceInput = {
    id: string
    strength?: StrengthBasedSkillsUncheckedCreateNestedOneWithoutSkills_list_relationInput
    dexterity?: DexterityBasedSkillsUncheckedCreateNestedOneWithoutSkills_list_relationInput
    wisdom?: WisdomBasedSkillsUncheckedCreateNestedOneWithoutSkills_list_relationInput
    charisma?: CharismaBasedSkillsUncheckedCreateNestedOneWithoutSkills_list_relationInput
  }

  export type SkillsListCreateOrConnectWithoutIntelligenceInput = {
    where: SkillsListWhereUniqueInput
    create: XOR<SkillsListCreateWithoutIntelligenceInput, SkillsListUncheckedCreateWithoutIntelligenceInput>
  }

  export type ArcanaSkillUpsertWithoutSkill_listInput = {
    update: XOR<ArcanaSkillUpdateWithoutSkill_listInput, ArcanaSkillUncheckedUpdateWithoutSkill_listInput>
    create: XOR<ArcanaSkillCreateWithoutSkill_listInput, ArcanaSkillUncheckedCreateWithoutSkill_listInput>
    where?: ArcanaSkillWhereInput
  }

  export type ArcanaSkillUpdateToOneWithWhereWithoutSkill_listInput = {
    where?: ArcanaSkillWhereInput
    data: XOR<ArcanaSkillUpdateWithoutSkill_listInput, ArcanaSkillUncheckedUpdateWithoutSkill_listInput>
  }

  export type ArcanaSkillUpdateWithoutSkill_listInput = {
    value?: NullableIntFieldUpdateOperationsInput | number | null
    mastery?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
  }

  export type ArcanaSkillUncheckedUpdateWithoutSkill_listInput = {
    value?: NullableIntFieldUpdateOperationsInput | number | null
    mastery?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
  }

  export type HistorySkillUpsertWithoutSkill_listInput = {
    update: XOR<HistorySkillUpdateWithoutSkill_listInput, HistorySkillUncheckedUpdateWithoutSkill_listInput>
    create: XOR<HistorySkillCreateWithoutSkill_listInput, HistorySkillUncheckedCreateWithoutSkill_listInput>
    where?: HistorySkillWhereInput
  }

  export type HistorySkillUpdateToOneWithWhereWithoutSkill_listInput = {
    where?: HistorySkillWhereInput
    data: XOR<HistorySkillUpdateWithoutSkill_listInput, HistorySkillUncheckedUpdateWithoutSkill_listInput>
  }

  export type HistorySkillUpdateWithoutSkill_listInput = {
    value?: NullableIntFieldUpdateOperationsInput | number | null
    mastery?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
  }

  export type HistorySkillUncheckedUpdateWithoutSkill_listInput = {
    value?: NullableIntFieldUpdateOperationsInput | number | null
    mastery?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
  }

  export type InvestigationSkillUpsertWithoutSkill_listInput = {
    update: XOR<InvestigationSkillUpdateWithoutSkill_listInput, InvestigationSkillUncheckedUpdateWithoutSkill_listInput>
    create: XOR<InvestigationSkillCreateWithoutSkill_listInput, InvestigationSkillUncheckedCreateWithoutSkill_listInput>
    where?: InvestigationSkillWhereInput
  }

  export type InvestigationSkillUpdateToOneWithWhereWithoutSkill_listInput = {
    where?: InvestigationSkillWhereInput
    data: XOR<InvestigationSkillUpdateWithoutSkill_listInput, InvestigationSkillUncheckedUpdateWithoutSkill_listInput>
  }

  export type InvestigationSkillUpdateWithoutSkill_listInput = {
    value?: NullableIntFieldUpdateOperationsInput | number | null
    mastery?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
  }

  export type InvestigationSkillUncheckedUpdateWithoutSkill_listInput = {
    value?: NullableIntFieldUpdateOperationsInput | number | null
    mastery?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
  }

  export type NatureSkillUpsertWithoutSkill_listInput = {
    update: XOR<NatureSkillUpdateWithoutSkill_listInput, NatureSkillUncheckedUpdateWithoutSkill_listInput>
    create: XOR<NatureSkillCreateWithoutSkill_listInput, NatureSkillUncheckedCreateWithoutSkill_listInput>
    where?: NatureSkillWhereInput
  }

  export type NatureSkillUpdateToOneWithWhereWithoutSkill_listInput = {
    where?: NatureSkillWhereInput
    data: XOR<NatureSkillUpdateWithoutSkill_listInput, NatureSkillUncheckedUpdateWithoutSkill_listInput>
  }

  export type NatureSkillUpdateWithoutSkill_listInput = {
    value?: NullableIntFieldUpdateOperationsInput | number | null
    mastery?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
  }

  export type NatureSkillUncheckedUpdateWithoutSkill_listInput = {
    value?: NullableIntFieldUpdateOperationsInput | number | null
    mastery?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
  }

  export type ReligionSkillUpsertWithoutSkill_listInput = {
    update: XOR<ReligionSkillUpdateWithoutSkill_listInput, ReligionSkillUncheckedUpdateWithoutSkill_listInput>
    create: XOR<ReligionSkillCreateWithoutSkill_listInput, ReligionSkillUncheckedCreateWithoutSkill_listInput>
    where?: ReligionSkillWhereInput
  }

  export type ReligionSkillUpdateToOneWithWhereWithoutSkill_listInput = {
    where?: ReligionSkillWhereInput
    data: XOR<ReligionSkillUpdateWithoutSkill_listInput, ReligionSkillUncheckedUpdateWithoutSkill_listInput>
  }

  export type ReligionSkillUpdateWithoutSkill_listInput = {
    value?: NullableIntFieldUpdateOperationsInput | number | null
    mastery?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
  }

  export type ReligionSkillUncheckedUpdateWithoutSkill_listInput = {
    value?: NullableIntFieldUpdateOperationsInput | number | null
    mastery?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
  }

  export type SkillsListUpsertWithoutIntelligenceInput = {
    update: XOR<SkillsListUpdateWithoutIntelligenceInput, SkillsListUncheckedUpdateWithoutIntelligenceInput>
    create: XOR<SkillsListCreateWithoutIntelligenceInput, SkillsListUncheckedCreateWithoutIntelligenceInput>
    where?: SkillsListWhereInput
  }

  export type SkillsListUpdateToOneWithWhereWithoutIntelligenceInput = {
    where?: SkillsListWhereInput
    data: XOR<SkillsListUpdateWithoutIntelligenceInput, SkillsListUncheckedUpdateWithoutIntelligenceInput>
  }

  export type SkillsListUpdateWithoutIntelligenceInput = {
    strength?: StrengthBasedSkillsUpdateOneWithoutSkills_list_relationNestedInput
    dexterity?: DexterityBasedSkillsUpdateOneWithoutSkills_list_relationNestedInput
    wisdom?: WisdomBasedSkillsUpdateOneWithoutSkills_list_relationNestedInput
    charisma?: CharismaBasedSkillsUpdateOneWithoutSkills_list_relationNestedInput
    id_relation?: CreatureUpdateOneRequiredWithoutSkillsNestedInput
  }

  export type SkillsListUncheckedUpdateWithoutIntelligenceInput = {
    id?: StringFieldUpdateOperationsInput | string
    strength?: StrengthBasedSkillsUncheckedUpdateOneWithoutSkills_list_relationNestedInput
    dexterity?: DexterityBasedSkillsUncheckedUpdateOneWithoutSkills_list_relationNestedInput
    wisdom?: WisdomBasedSkillsUncheckedUpdateOneWithoutSkills_list_relationNestedInput
    charisma?: CharismaBasedSkillsUncheckedUpdateOneWithoutSkills_list_relationNestedInput
  }

  export type AnimalHandlingSkillCreateWithoutSkill_listInput = {
    value?: number | null
    mastery: boolean
    name?: string
  }

  export type AnimalHandlingSkillUncheckedCreateWithoutSkill_listInput = {
    value?: number | null
    mastery: boolean
    name?: string
  }

  export type AnimalHandlingSkillCreateOrConnectWithoutSkill_listInput = {
    where: AnimalHandlingSkillWhereUniqueInput
    create: XOR<AnimalHandlingSkillCreateWithoutSkill_listInput, AnimalHandlingSkillUncheckedCreateWithoutSkill_listInput>
  }

  export type InsightSkillCreateWithoutSkill_listInput = {
    value?: number | null
    mastery: boolean
    name?: string
  }

  export type InsightSkillUncheckedCreateWithoutSkill_listInput = {
    value?: number | null
    mastery: boolean
    name?: string
  }

  export type InsightSkillCreateOrConnectWithoutSkill_listInput = {
    where: InsightSkillWhereUniqueInput
    create: XOR<InsightSkillCreateWithoutSkill_listInput, InsightSkillUncheckedCreateWithoutSkill_listInput>
  }

  export type MedicineSkillCreateWithoutSkill_listInput = {
    value?: number | null
    mastery: boolean
    name?: string
  }

  export type MedicineSkillUncheckedCreateWithoutSkill_listInput = {
    value?: number | null
    mastery: boolean
    name?: string
  }

  export type MedicineSkillCreateOrConnectWithoutSkill_listInput = {
    where: MedicineSkillWhereUniqueInput
    create: XOR<MedicineSkillCreateWithoutSkill_listInput, MedicineSkillUncheckedCreateWithoutSkill_listInput>
  }

  export type PerceptionSkillCreateWithoutSkill_listInput = {
    value?: number | null
    mastery: boolean
    name?: string
  }

  export type PerceptionSkillUncheckedCreateWithoutSkill_listInput = {
    value?: number | null
    mastery: boolean
    name?: string
  }

  export type PerceptionSkillCreateOrConnectWithoutSkill_listInput = {
    where: PerceptionSkillWhereUniqueInput
    create: XOR<PerceptionSkillCreateWithoutSkill_listInput, PerceptionSkillUncheckedCreateWithoutSkill_listInput>
  }

  export type SurvivalSkillCreateWithoutSkill_listInput = {
    value?: number | null
    mastery: boolean
    name?: string
  }

  export type SurvivalSkillUncheckedCreateWithoutSkill_listInput = {
    value?: number | null
    mastery: boolean
    name?: string
  }

  export type SurvivalSkillCreateOrConnectWithoutSkill_listInput = {
    where: SurvivalSkillWhereUniqueInput
    create: XOR<SurvivalSkillCreateWithoutSkill_listInput, SurvivalSkillUncheckedCreateWithoutSkill_listInput>
  }

  export type SkillsListCreateWithoutWisdomInput = {
    strength?: StrengthBasedSkillsCreateNestedOneWithoutSkills_list_relationInput
    dexterity?: DexterityBasedSkillsCreateNestedOneWithoutSkills_list_relationInput
    intelligence?: IntellengenceBasedSkillsCreateNestedOneWithoutSkills_list_relationInput
    charisma?: CharismaBasedSkillsCreateNestedOneWithoutSkills_list_relationInput
    id_relation: CreatureCreateNestedOneWithoutSkillsInput
  }

  export type SkillsListUncheckedCreateWithoutWisdomInput = {
    id: string
    strength?: StrengthBasedSkillsUncheckedCreateNestedOneWithoutSkills_list_relationInput
    dexterity?: DexterityBasedSkillsUncheckedCreateNestedOneWithoutSkills_list_relationInput
    intelligence?: IntellengenceBasedSkillsUncheckedCreateNestedOneWithoutSkills_list_relationInput
    charisma?: CharismaBasedSkillsUncheckedCreateNestedOneWithoutSkills_list_relationInput
  }

  export type SkillsListCreateOrConnectWithoutWisdomInput = {
    where: SkillsListWhereUniqueInput
    create: XOR<SkillsListCreateWithoutWisdomInput, SkillsListUncheckedCreateWithoutWisdomInput>
  }

  export type AnimalHandlingSkillUpsertWithoutSkill_listInput = {
    update: XOR<AnimalHandlingSkillUpdateWithoutSkill_listInput, AnimalHandlingSkillUncheckedUpdateWithoutSkill_listInput>
    create: XOR<AnimalHandlingSkillCreateWithoutSkill_listInput, AnimalHandlingSkillUncheckedCreateWithoutSkill_listInput>
    where?: AnimalHandlingSkillWhereInput
  }

  export type AnimalHandlingSkillUpdateToOneWithWhereWithoutSkill_listInput = {
    where?: AnimalHandlingSkillWhereInput
    data: XOR<AnimalHandlingSkillUpdateWithoutSkill_listInput, AnimalHandlingSkillUncheckedUpdateWithoutSkill_listInput>
  }

  export type AnimalHandlingSkillUpdateWithoutSkill_listInput = {
    value?: NullableIntFieldUpdateOperationsInput | number | null
    mastery?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
  }

  export type AnimalHandlingSkillUncheckedUpdateWithoutSkill_listInput = {
    value?: NullableIntFieldUpdateOperationsInput | number | null
    mastery?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
  }

  export type InsightSkillUpsertWithoutSkill_listInput = {
    update: XOR<InsightSkillUpdateWithoutSkill_listInput, InsightSkillUncheckedUpdateWithoutSkill_listInput>
    create: XOR<InsightSkillCreateWithoutSkill_listInput, InsightSkillUncheckedCreateWithoutSkill_listInput>
    where?: InsightSkillWhereInput
  }

  export type InsightSkillUpdateToOneWithWhereWithoutSkill_listInput = {
    where?: InsightSkillWhereInput
    data: XOR<InsightSkillUpdateWithoutSkill_listInput, InsightSkillUncheckedUpdateWithoutSkill_listInput>
  }

  export type InsightSkillUpdateWithoutSkill_listInput = {
    value?: NullableIntFieldUpdateOperationsInput | number | null
    mastery?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
  }

  export type InsightSkillUncheckedUpdateWithoutSkill_listInput = {
    value?: NullableIntFieldUpdateOperationsInput | number | null
    mastery?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
  }

  export type MedicineSkillUpsertWithoutSkill_listInput = {
    update: XOR<MedicineSkillUpdateWithoutSkill_listInput, MedicineSkillUncheckedUpdateWithoutSkill_listInput>
    create: XOR<MedicineSkillCreateWithoutSkill_listInput, MedicineSkillUncheckedCreateWithoutSkill_listInput>
    where?: MedicineSkillWhereInput
  }

  export type MedicineSkillUpdateToOneWithWhereWithoutSkill_listInput = {
    where?: MedicineSkillWhereInput
    data: XOR<MedicineSkillUpdateWithoutSkill_listInput, MedicineSkillUncheckedUpdateWithoutSkill_listInput>
  }

  export type MedicineSkillUpdateWithoutSkill_listInput = {
    value?: NullableIntFieldUpdateOperationsInput | number | null
    mastery?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
  }

  export type MedicineSkillUncheckedUpdateWithoutSkill_listInput = {
    value?: NullableIntFieldUpdateOperationsInput | number | null
    mastery?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
  }

  export type PerceptionSkillUpsertWithoutSkill_listInput = {
    update: XOR<PerceptionSkillUpdateWithoutSkill_listInput, PerceptionSkillUncheckedUpdateWithoutSkill_listInput>
    create: XOR<PerceptionSkillCreateWithoutSkill_listInput, PerceptionSkillUncheckedCreateWithoutSkill_listInput>
    where?: PerceptionSkillWhereInput
  }

  export type PerceptionSkillUpdateToOneWithWhereWithoutSkill_listInput = {
    where?: PerceptionSkillWhereInput
    data: XOR<PerceptionSkillUpdateWithoutSkill_listInput, PerceptionSkillUncheckedUpdateWithoutSkill_listInput>
  }

  export type PerceptionSkillUpdateWithoutSkill_listInput = {
    value?: NullableIntFieldUpdateOperationsInput | number | null
    mastery?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
  }

  export type PerceptionSkillUncheckedUpdateWithoutSkill_listInput = {
    value?: NullableIntFieldUpdateOperationsInput | number | null
    mastery?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
  }

  export type SurvivalSkillUpsertWithoutSkill_listInput = {
    update: XOR<SurvivalSkillUpdateWithoutSkill_listInput, SurvivalSkillUncheckedUpdateWithoutSkill_listInput>
    create: XOR<SurvivalSkillCreateWithoutSkill_listInput, SurvivalSkillUncheckedCreateWithoutSkill_listInput>
    where?: SurvivalSkillWhereInput
  }

  export type SurvivalSkillUpdateToOneWithWhereWithoutSkill_listInput = {
    where?: SurvivalSkillWhereInput
    data: XOR<SurvivalSkillUpdateWithoutSkill_listInput, SurvivalSkillUncheckedUpdateWithoutSkill_listInput>
  }

  export type SurvivalSkillUpdateWithoutSkill_listInput = {
    value?: NullableIntFieldUpdateOperationsInput | number | null
    mastery?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
  }

  export type SurvivalSkillUncheckedUpdateWithoutSkill_listInput = {
    value?: NullableIntFieldUpdateOperationsInput | number | null
    mastery?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
  }

  export type SkillsListUpsertWithoutWisdomInput = {
    update: XOR<SkillsListUpdateWithoutWisdomInput, SkillsListUncheckedUpdateWithoutWisdomInput>
    create: XOR<SkillsListCreateWithoutWisdomInput, SkillsListUncheckedCreateWithoutWisdomInput>
    where?: SkillsListWhereInput
  }

  export type SkillsListUpdateToOneWithWhereWithoutWisdomInput = {
    where?: SkillsListWhereInput
    data: XOR<SkillsListUpdateWithoutWisdomInput, SkillsListUncheckedUpdateWithoutWisdomInput>
  }

  export type SkillsListUpdateWithoutWisdomInput = {
    strength?: StrengthBasedSkillsUpdateOneWithoutSkills_list_relationNestedInput
    dexterity?: DexterityBasedSkillsUpdateOneWithoutSkills_list_relationNestedInput
    intelligence?: IntellengenceBasedSkillsUpdateOneWithoutSkills_list_relationNestedInput
    charisma?: CharismaBasedSkillsUpdateOneWithoutSkills_list_relationNestedInput
    id_relation?: CreatureUpdateOneRequiredWithoutSkillsNestedInput
  }

  export type SkillsListUncheckedUpdateWithoutWisdomInput = {
    id?: StringFieldUpdateOperationsInput | string
    strength?: StrengthBasedSkillsUncheckedUpdateOneWithoutSkills_list_relationNestedInput
    dexterity?: DexterityBasedSkillsUncheckedUpdateOneWithoutSkills_list_relationNestedInput
    intelligence?: IntellengenceBasedSkillsUncheckedUpdateOneWithoutSkills_list_relationNestedInput
    charisma?: CharismaBasedSkillsUncheckedUpdateOneWithoutSkills_list_relationNestedInput
  }

  export type DeceptionSkillCreateWithoutSkill_listInput = {
    value?: number | null
    mastery: boolean
    name?: string
  }

  export type DeceptionSkillUncheckedCreateWithoutSkill_listInput = {
    value?: number | null
    mastery: boolean
    name?: string
  }

  export type DeceptionSkillCreateOrConnectWithoutSkill_listInput = {
    where: DeceptionSkillWhereUniqueInput
    create: XOR<DeceptionSkillCreateWithoutSkill_listInput, DeceptionSkillUncheckedCreateWithoutSkill_listInput>
  }

  export type IntimidationSkillCreateWithoutSkill_listInput = {
    value?: number | null
    mastery: boolean
    name?: string
  }

  export type IntimidationSkillUncheckedCreateWithoutSkill_listInput = {
    value?: number | null
    mastery: boolean
    name?: string
  }

  export type IntimidationSkillCreateOrConnectWithoutSkill_listInput = {
    where: IntimidationSkillWhereUniqueInput
    create: XOR<IntimidationSkillCreateWithoutSkill_listInput, IntimidationSkillUncheckedCreateWithoutSkill_listInput>
  }

  export type PerformanceSkillCreateWithoutSkill_listInput = {
    value?: number | null
    mastery: boolean
    name?: string
  }

  export type PerformanceSkillUncheckedCreateWithoutSkill_listInput = {
    value?: number | null
    mastery: boolean
    name?: string
  }

  export type PerformanceSkillCreateOrConnectWithoutSkill_listInput = {
    where: PerformanceSkillWhereUniqueInput
    create: XOR<PerformanceSkillCreateWithoutSkill_listInput, PerformanceSkillUncheckedCreateWithoutSkill_listInput>
  }

  export type PersuasionSkillCreateWithoutSkill_listInput = {
    value?: number | null
    mastery: boolean
    name?: string
  }

  export type PersuasionSkillUncheckedCreateWithoutSkill_listInput = {
    value?: number | null
    mastery: boolean
    name?: string
  }

  export type PersuasionSkillCreateOrConnectWithoutSkill_listInput = {
    where: PersuasionSkillWhereUniqueInput
    create: XOR<PersuasionSkillCreateWithoutSkill_listInput, PersuasionSkillUncheckedCreateWithoutSkill_listInput>
  }

  export type SkillsListCreateWithoutCharismaInput = {
    strength?: StrengthBasedSkillsCreateNestedOneWithoutSkills_list_relationInput
    dexterity?: DexterityBasedSkillsCreateNestedOneWithoutSkills_list_relationInput
    intelligence?: IntellengenceBasedSkillsCreateNestedOneWithoutSkills_list_relationInput
    wisdom?: WisdomBasedSkillsCreateNestedOneWithoutSkills_list_relationInput
    id_relation: CreatureCreateNestedOneWithoutSkillsInput
  }

  export type SkillsListUncheckedCreateWithoutCharismaInput = {
    id: string
    strength?: StrengthBasedSkillsUncheckedCreateNestedOneWithoutSkills_list_relationInput
    dexterity?: DexterityBasedSkillsUncheckedCreateNestedOneWithoutSkills_list_relationInput
    intelligence?: IntellengenceBasedSkillsUncheckedCreateNestedOneWithoutSkills_list_relationInput
    wisdom?: WisdomBasedSkillsUncheckedCreateNestedOneWithoutSkills_list_relationInput
  }

  export type SkillsListCreateOrConnectWithoutCharismaInput = {
    where: SkillsListWhereUniqueInput
    create: XOR<SkillsListCreateWithoutCharismaInput, SkillsListUncheckedCreateWithoutCharismaInput>
  }

  export type DeceptionSkillUpsertWithoutSkill_listInput = {
    update: XOR<DeceptionSkillUpdateWithoutSkill_listInput, DeceptionSkillUncheckedUpdateWithoutSkill_listInput>
    create: XOR<DeceptionSkillCreateWithoutSkill_listInput, DeceptionSkillUncheckedCreateWithoutSkill_listInput>
    where?: DeceptionSkillWhereInput
  }

  export type DeceptionSkillUpdateToOneWithWhereWithoutSkill_listInput = {
    where?: DeceptionSkillWhereInput
    data: XOR<DeceptionSkillUpdateWithoutSkill_listInput, DeceptionSkillUncheckedUpdateWithoutSkill_listInput>
  }

  export type DeceptionSkillUpdateWithoutSkill_listInput = {
    value?: NullableIntFieldUpdateOperationsInput | number | null
    mastery?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
  }

  export type DeceptionSkillUncheckedUpdateWithoutSkill_listInput = {
    value?: NullableIntFieldUpdateOperationsInput | number | null
    mastery?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
  }

  export type IntimidationSkillUpsertWithoutSkill_listInput = {
    update: XOR<IntimidationSkillUpdateWithoutSkill_listInput, IntimidationSkillUncheckedUpdateWithoutSkill_listInput>
    create: XOR<IntimidationSkillCreateWithoutSkill_listInput, IntimidationSkillUncheckedCreateWithoutSkill_listInput>
    where?: IntimidationSkillWhereInput
  }

  export type IntimidationSkillUpdateToOneWithWhereWithoutSkill_listInput = {
    where?: IntimidationSkillWhereInput
    data: XOR<IntimidationSkillUpdateWithoutSkill_listInput, IntimidationSkillUncheckedUpdateWithoutSkill_listInput>
  }

  export type IntimidationSkillUpdateWithoutSkill_listInput = {
    value?: NullableIntFieldUpdateOperationsInput | number | null
    mastery?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
  }

  export type IntimidationSkillUncheckedUpdateWithoutSkill_listInput = {
    value?: NullableIntFieldUpdateOperationsInput | number | null
    mastery?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
  }

  export type PerformanceSkillUpsertWithoutSkill_listInput = {
    update: XOR<PerformanceSkillUpdateWithoutSkill_listInput, PerformanceSkillUncheckedUpdateWithoutSkill_listInput>
    create: XOR<PerformanceSkillCreateWithoutSkill_listInput, PerformanceSkillUncheckedCreateWithoutSkill_listInput>
    where?: PerformanceSkillWhereInput
  }

  export type PerformanceSkillUpdateToOneWithWhereWithoutSkill_listInput = {
    where?: PerformanceSkillWhereInput
    data: XOR<PerformanceSkillUpdateWithoutSkill_listInput, PerformanceSkillUncheckedUpdateWithoutSkill_listInput>
  }

  export type PerformanceSkillUpdateWithoutSkill_listInput = {
    value?: NullableIntFieldUpdateOperationsInput | number | null
    mastery?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
  }

  export type PerformanceSkillUncheckedUpdateWithoutSkill_listInput = {
    value?: NullableIntFieldUpdateOperationsInput | number | null
    mastery?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
  }

  export type PersuasionSkillUpsertWithoutSkill_listInput = {
    update: XOR<PersuasionSkillUpdateWithoutSkill_listInput, PersuasionSkillUncheckedUpdateWithoutSkill_listInput>
    create: XOR<PersuasionSkillCreateWithoutSkill_listInput, PersuasionSkillUncheckedCreateWithoutSkill_listInput>
    where?: PersuasionSkillWhereInput
  }

  export type PersuasionSkillUpdateToOneWithWhereWithoutSkill_listInput = {
    where?: PersuasionSkillWhereInput
    data: XOR<PersuasionSkillUpdateWithoutSkill_listInput, PersuasionSkillUncheckedUpdateWithoutSkill_listInput>
  }

  export type PersuasionSkillUpdateWithoutSkill_listInput = {
    value?: NullableIntFieldUpdateOperationsInput | number | null
    mastery?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
  }

  export type PersuasionSkillUncheckedUpdateWithoutSkill_listInput = {
    value?: NullableIntFieldUpdateOperationsInput | number | null
    mastery?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
  }

  export type SkillsListUpsertWithoutCharismaInput = {
    update: XOR<SkillsListUpdateWithoutCharismaInput, SkillsListUncheckedUpdateWithoutCharismaInput>
    create: XOR<SkillsListCreateWithoutCharismaInput, SkillsListUncheckedCreateWithoutCharismaInput>
    where?: SkillsListWhereInput
  }

  export type SkillsListUpdateToOneWithWhereWithoutCharismaInput = {
    where?: SkillsListWhereInput
    data: XOR<SkillsListUpdateWithoutCharismaInput, SkillsListUncheckedUpdateWithoutCharismaInput>
  }

  export type SkillsListUpdateWithoutCharismaInput = {
    strength?: StrengthBasedSkillsUpdateOneWithoutSkills_list_relationNestedInput
    dexterity?: DexterityBasedSkillsUpdateOneWithoutSkills_list_relationNestedInput
    intelligence?: IntellengenceBasedSkillsUpdateOneWithoutSkills_list_relationNestedInput
    wisdom?: WisdomBasedSkillsUpdateOneWithoutSkills_list_relationNestedInput
    id_relation?: CreatureUpdateOneRequiredWithoutSkillsNestedInput
  }

  export type SkillsListUncheckedUpdateWithoutCharismaInput = {
    id?: StringFieldUpdateOperationsInput | string
    strength?: StrengthBasedSkillsUncheckedUpdateOneWithoutSkills_list_relationNestedInput
    dexterity?: DexterityBasedSkillsUncheckedUpdateOneWithoutSkills_list_relationNestedInput
    intelligence?: IntellengenceBasedSkillsUncheckedUpdateOneWithoutSkills_list_relationNestedInput
    wisdom?: WisdomBasedSkillsUncheckedUpdateOneWithoutSkills_list_relationNestedInput
  }

  export type StrengthBasedSkillsCreateWithoutAthleticsInput = {
    skills_list_relation: SkillsListCreateNestedOneWithoutStrengthInput
  }

  export type StrengthBasedSkillsUncheckedCreateWithoutAthleticsInput = {
    id: string
  }

  export type StrengthBasedSkillsCreateOrConnectWithoutAthleticsInput = {
    where: StrengthBasedSkillsWhereUniqueInput
    create: XOR<StrengthBasedSkillsCreateWithoutAthleticsInput, StrengthBasedSkillsUncheckedCreateWithoutAthleticsInput>
  }

  export type StrengthBasedSkillsUpsertWithoutAthleticsInput = {
    update: XOR<StrengthBasedSkillsUpdateWithoutAthleticsInput, StrengthBasedSkillsUncheckedUpdateWithoutAthleticsInput>
    create: XOR<StrengthBasedSkillsCreateWithoutAthleticsInput, StrengthBasedSkillsUncheckedCreateWithoutAthleticsInput>
    where?: StrengthBasedSkillsWhereInput
  }

  export type StrengthBasedSkillsUpdateToOneWithWhereWithoutAthleticsInput = {
    where?: StrengthBasedSkillsWhereInput
    data: XOR<StrengthBasedSkillsUpdateWithoutAthleticsInput, StrengthBasedSkillsUncheckedUpdateWithoutAthleticsInput>
  }

  export type StrengthBasedSkillsUpdateWithoutAthleticsInput = {
    skills_list_relation?: SkillsListUpdateOneRequiredWithoutStrengthNestedInput
  }

  export type StrengthBasedSkillsUncheckedUpdateWithoutAthleticsInput = {
    id?: StringFieldUpdateOperationsInput | string
  }

  export type DexterityBasedSkillsCreateWithoutAcrobaticsInput = {
    sleight_of_hand?: SleightOfHandSkillCreateNestedOneWithoutSkill_listInput
    stealth?: StealthSkillCreateNestedOneWithoutSkill_listInput
    skills_list_relation: SkillsListCreateNestedOneWithoutDexterityInput
  }

  export type DexterityBasedSkillsUncheckedCreateWithoutAcrobaticsInput = {
    id: string
    sleight_of_hand?: SleightOfHandSkillUncheckedCreateNestedOneWithoutSkill_listInput
    stealth?: StealthSkillUncheckedCreateNestedOneWithoutSkill_listInput
  }

  export type DexterityBasedSkillsCreateOrConnectWithoutAcrobaticsInput = {
    where: DexterityBasedSkillsWhereUniqueInput
    create: XOR<DexterityBasedSkillsCreateWithoutAcrobaticsInput, DexterityBasedSkillsUncheckedCreateWithoutAcrobaticsInput>
  }

  export type DexterityBasedSkillsUpsertWithoutAcrobaticsInput = {
    update: XOR<DexterityBasedSkillsUpdateWithoutAcrobaticsInput, DexterityBasedSkillsUncheckedUpdateWithoutAcrobaticsInput>
    create: XOR<DexterityBasedSkillsCreateWithoutAcrobaticsInput, DexterityBasedSkillsUncheckedCreateWithoutAcrobaticsInput>
    where?: DexterityBasedSkillsWhereInput
  }

  export type DexterityBasedSkillsUpdateToOneWithWhereWithoutAcrobaticsInput = {
    where?: DexterityBasedSkillsWhereInput
    data: XOR<DexterityBasedSkillsUpdateWithoutAcrobaticsInput, DexterityBasedSkillsUncheckedUpdateWithoutAcrobaticsInput>
  }

  export type DexterityBasedSkillsUpdateWithoutAcrobaticsInput = {
    sleight_of_hand?: SleightOfHandSkillUpdateOneWithoutSkill_listNestedInput
    stealth?: StealthSkillUpdateOneWithoutSkill_listNestedInput
    skills_list_relation?: SkillsListUpdateOneRequiredWithoutDexterityNestedInput
  }

  export type DexterityBasedSkillsUncheckedUpdateWithoutAcrobaticsInput = {
    id?: StringFieldUpdateOperationsInput | string
    sleight_of_hand?: SleightOfHandSkillUncheckedUpdateOneWithoutSkill_listNestedInput
    stealth?: StealthSkillUncheckedUpdateOneWithoutSkill_listNestedInput
  }

  export type DexterityBasedSkillsCreateWithoutSleight_of_handInput = {
    acrobatics?: AcrobaticsSkillCreateNestedOneWithoutSkill_listInput
    stealth?: StealthSkillCreateNestedOneWithoutSkill_listInput
    skills_list_relation: SkillsListCreateNestedOneWithoutDexterityInput
  }

  export type DexterityBasedSkillsUncheckedCreateWithoutSleight_of_handInput = {
    id: string
    acrobatics?: AcrobaticsSkillUncheckedCreateNestedOneWithoutSkill_listInput
    stealth?: StealthSkillUncheckedCreateNestedOneWithoutSkill_listInput
  }

  export type DexterityBasedSkillsCreateOrConnectWithoutSleight_of_handInput = {
    where: DexterityBasedSkillsWhereUniqueInput
    create: XOR<DexterityBasedSkillsCreateWithoutSleight_of_handInput, DexterityBasedSkillsUncheckedCreateWithoutSleight_of_handInput>
  }

  export type DexterityBasedSkillsUpsertWithoutSleight_of_handInput = {
    update: XOR<DexterityBasedSkillsUpdateWithoutSleight_of_handInput, DexterityBasedSkillsUncheckedUpdateWithoutSleight_of_handInput>
    create: XOR<DexterityBasedSkillsCreateWithoutSleight_of_handInput, DexterityBasedSkillsUncheckedCreateWithoutSleight_of_handInput>
    where?: DexterityBasedSkillsWhereInput
  }

  export type DexterityBasedSkillsUpdateToOneWithWhereWithoutSleight_of_handInput = {
    where?: DexterityBasedSkillsWhereInput
    data: XOR<DexterityBasedSkillsUpdateWithoutSleight_of_handInput, DexterityBasedSkillsUncheckedUpdateWithoutSleight_of_handInput>
  }

  export type DexterityBasedSkillsUpdateWithoutSleight_of_handInput = {
    acrobatics?: AcrobaticsSkillUpdateOneWithoutSkill_listNestedInput
    stealth?: StealthSkillUpdateOneWithoutSkill_listNestedInput
    skills_list_relation?: SkillsListUpdateOneRequiredWithoutDexterityNestedInput
  }

  export type DexterityBasedSkillsUncheckedUpdateWithoutSleight_of_handInput = {
    id?: StringFieldUpdateOperationsInput | string
    acrobatics?: AcrobaticsSkillUncheckedUpdateOneWithoutSkill_listNestedInput
    stealth?: StealthSkillUncheckedUpdateOneWithoutSkill_listNestedInput
  }

  export type DexterityBasedSkillsCreateWithoutStealthInput = {
    acrobatics?: AcrobaticsSkillCreateNestedOneWithoutSkill_listInput
    sleight_of_hand?: SleightOfHandSkillCreateNestedOneWithoutSkill_listInput
    skills_list_relation: SkillsListCreateNestedOneWithoutDexterityInput
  }

  export type DexterityBasedSkillsUncheckedCreateWithoutStealthInput = {
    id: string
    acrobatics?: AcrobaticsSkillUncheckedCreateNestedOneWithoutSkill_listInput
    sleight_of_hand?: SleightOfHandSkillUncheckedCreateNestedOneWithoutSkill_listInput
  }

  export type DexterityBasedSkillsCreateOrConnectWithoutStealthInput = {
    where: DexterityBasedSkillsWhereUniqueInput
    create: XOR<DexterityBasedSkillsCreateWithoutStealthInput, DexterityBasedSkillsUncheckedCreateWithoutStealthInput>
  }

  export type DexterityBasedSkillsUpsertWithoutStealthInput = {
    update: XOR<DexterityBasedSkillsUpdateWithoutStealthInput, DexterityBasedSkillsUncheckedUpdateWithoutStealthInput>
    create: XOR<DexterityBasedSkillsCreateWithoutStealthInput, DexterityBasedSkillsUncheckedCreateWithoutStealthInput>
    where?: DexterityBasedSkillsWhereInput
  }

  export type DexterityBasedSkillsUpdateToOneWithWhereWithoutStealthInput = {
    where?: DexterityBasedSkillsWhereInput
    data: XOR<DexterityBasedSkillsUpdateWithoutStealthInput, DexterityBasedSkillsUncheckedUpdateWithoutStealthInput>
  }

  export type DexterityBasedSkillsUpdateWithoutStealthInput = {
    acrobatics?: AcrobaticsSkillUpdateOneWithoutSkill_listNestedInput
    sleight_of_hand?: SleightOfHandSkillUpdateOneWithoutSkill_listNestedInput
    skills_list_relation?: SkillsListUpdateOneRequiredWithoutDexterityNestedInput
  }

  export type DexterityBasedSkillsUncheckedUpdateWithoutStealthInput = {
    id?: StringFieldUpdateOperationsInput | string
    acrobatics?: AcrobaticsSkillUncheckedUpdateOneWithoutSkill_listNestedInput
    sleight_of_hand?: SleightOfHandSkillUncheckedUpdateOneWithoutSkill_listNestedInput
  }

  export type IntellengenceBasedSkillsCreateWithoutArcanaInput = {
    history?: HistorySkillCreateNestedOneWithoutSkill_listInput
    investigation?: InvestigationSkillCreateNestedOneWithoutSkill_listInput
    nature?: NatureSkillCreateNestedOneWithoutSkill_listInput
    religion?: ReligionSkillCreateNestedOneWithoutSkill_listInput
    skills_list_relation: SkillsListCreateNestedOneWithoutIntelligenceInput
  }

  export type IntellengenceBasedSkillsUncheckedCreateWithoutArcanaInput = {
    id: string
    history?: HistorySkillUncheckedCreateNestedOneWithoutSkill_listInput
    investigation?: InvestigationSkillUncheckedCreateNestedOneWithoutSkill_listInput
    nature?: NatureSkillUncheckedCreateNestedOneWithoutSkill_listInput
    religion?: ReligionSkillUncheckedCreateNestedOneWithoutSkill_listInput
  }

  export type IntellengenceBasedSkillsCreateOrConnectWithoutArcanaInput = {
    where: IntellengenceBasedSkillsWhereUniqueInput
    create: XOR<IntellengenceBasedSkillsCreateWithoutArcanaInput, IntellengenceBasedSkillsUncheckedCreateWithoutArcanaInput>
  }

  export type IntellengenceBasedSkillsUpsertWithoutArcanaInput = {
    update: XOR<IntellengenceBasedSkillsUpdateWithoutArcanaInput, IntellengenceBasedSkillsUncheckedUpdateWithoutArcanaInput>
    create: XOR<IntellengenceBasedSkillsCreateWithoutArcanaInput, IntellengenceBasedSkillsUncheckedCreateWithoutArcanaInput>
    where?: IntellengenceBasedSkillsWhereInput
  }

  export type IntellengenceBasedSkillsUpdateToOneWithWhereWithoutArcanaInput = {
    where?: IntellengenceBasedSkillsWhereInput
    data: XOR<IntellengenceBasedSkillsUpdateWithoutArcanaInput, IntellengenceBasedSkillsUncheckedUpdateWithoutArcanaInput>
  }

  export type IntellengenceBasedSkillsUpdateWithoutArcanaInput = {
    history?: HistorySkillUpdateOneWithoutSkill_listNestedInput
    investigation?: InvestigationSkillUpdateOneWithoutSkill_listNestedInput
    nature?: NatureSkillUpdateOneWithoutSkill_listNestedInput
    religion?: ReligionSkillUpdateOneWithoutSkill_listNestedInput
    skills_list_relation?: SkillsListUpdateOneRequiredWithoutIntelligenceNestedInput
  }

  export type IntellengenceBasedSkillsUncheckedUpdateWithoutArcanaInput = {
    id?: StringFieldUpdateOperationsInput | string
    history?: HistorySkillUncheckedUpdateOneWithoutSkill_listNestedInput
    investigation?: InvestigationSkillUncheckedUpdateOneWithoutSkill_listNestedInput
    nature?: NatureSkillUncheckedUpdateOneWithoutSkill_listNestedInput
    religion?: ReligionSkillUncheckedUpdateOneWithoutSkill_listNestedInput
  }

  export type IntellengenceBasedSkillsCreateWithoutHistoryInput = {
    arcana?: ArcanaSkillCreateNestedOneWithoutSkill_listInput
    investigation?: InvestigationSkillCreateNestedOneWithoutSkill_listInput
    nature?: NatureSkillCreateNestedOneWithoutSkill_listInput
    religion?: ReligionSkillCreateNestedOneWithoutSkill_listInput
    skills_list_relation: SkillsListCreateNestedOneWithoutIntelligenceInput
  }

  export type IntellengenceBasedSkillsUncheckedCreateWithoutHistoryInput = {
    id: string
    arcana?: ArcanaSkillUncheckedCreateNestedOneWithoutSkill_listInput
    investigation?: InvestigationSkillUncheckedCreateNestedOneWithoutSkill_listInput
    nature?: NatureSkillUncheckedCreateNestedOneWithoutSkill_listInput
    religion?: ReligionSkillUncheckedCreateNestedOneWithoutSkill_listInput
  }

  export type IntellengenceBasedSkillsCreateOrConnectWithoutHistoryInput = {
    where: IntellengenceBasedSkillsWhereUniqueInput
    create: XOR<IntellengenceBasedSkillsCreateWithoutHistoryInput, IntellengenceBasedSkillsUncheckedCreateWithoutHistoryInput>
  }

  export type IntellengenceBasedSkillsUpsertWithoutHistoryInput = {
    update: XOR<IntellengenceBasedSkillsUpdateWithoutHistoryInput, IntellengenceBasedSkillsUncheckedUpdateWithoutHistoryInput>
    create: XOR<IntellengenceBasedSkillsCreateWithoutHistoryInput, IntellengenceBasedSkillsUncheckedCreateWithoutHistoryInput>
    where?: IntellengenceBasedSkillsWhereInput
  }

  export type IntellengenceBasedSkillsUpdateToOneWithWhereWithoutHistoryInput = {
    where?: IntellengenceBasedSkillsWhereInput
    data: XOR<IntellengenceBasedSkillsUpdateWithoutHistoryInput, IntellengenceBasedSkillsUncheckedUpdateWithoutHistoryInput>
  }

  export type IntellengenceBasedSkillsUpdateWithoutHistoryInput = {
    arcana?: ArcanaSkillUpdateOneWithoutSkill_listNestedInput
    investigation?: InvestigationSkillUpdateOneWithoutSkill_listNestedInput
    nature?: NatureSkillUpdateOneWithoutSkill_listNestedInput
    religion?: ReligionSkillUpdateOneWithoutSkill_listNestedInput
    skills_list_relation?: SkillsListUpdateOneRequiredWithoutIntelligenceNestedInput
  }

  export type IntellengenceBasedSkillsUncheckedUpdateWithoutHistoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    arcana?: ArcanaSkillUncheckedUpdateOneWithoutSkill_listNestedInput
    investigation?: InvestigationSkillUncheckedUpdateOneWithoutSkill_listNestedInput
    nature?: NatureSkillUncheckedUpdateOneWithoutSkill_listNestedInput
    religion?: ReligionSkillUncheckedUpdateOneWithoutSkill_listNestedInput
  }

  export type IntellengenceBasedSkillsCreateWithoutInvestigationInput = {
    arcana?: ArcanaSkillCreateNestedOneWithoutSkill_listInput
    history?: HistorySkillCreateNestedOneWithoutSkill_listInput
    nature?: NatureSkillCreateNestedOneWithoutSkill_listInput
    religion?: ReligionSkillCreateNestedOneWithoutSkill_listInput
    skills_list_relation: SkillsListCreateNestedOneWithoutIntelligenceInput
  }

  export type IntellengenceBasedSkillsUncheckedCreateWithoutInvestigationInput = {
    id: string
    arcana?: ArcanaSkillUncheckedCreateNestedOneWithoutSkill_listInput
    history?: HistorySkillUncheckedCreateNestedOneWithoutSkill_listInput
    nature?: NatureSkillUncheckedCreateNestedOneWithoutSkill_listInput
    religion?: ReligionSkillUncheckedCreateNestedOneWithoutSkill_listInput
  }

  export type IntellengenceBasedSkillsCreateOrConnectWithoutInvestigationInput = {
    where: IntellengenceBasedSkillsWhereUniqueInput
    create: XOR<IntellengenceBasedSkillsCreateWithoutInvestigationInput, IntellengenceBasedSkillsUncheckedCreateWithoutInvestigationInput>
  }

  export type IntellengenceBasedSkillsUpsertWithoutInvestigationInput = {
    update: XOR<IntellengenceBasedSkillsUpdateWithoutInvestigationInput, IntellengenceBasedSkillsUncheckedUpdateWithoutInvestigationInput>
    create: XOR<IntellengenceBasedSkillsCreateWithoutInvestigationInput, IntellengenceBasedSkillsUncheckedCreateWithoutInvestigationInput>
    where?: IntellengenceBasedSkillsWhereInput
  }

  export type IntellengenceBasedSkillsUpdateToOneWithWhereWithoutInvestigationInput = {
    where?: IntellengenceBasedSkillsWhereInput
    data: XOR<IntellengenceBasedSkillsUpdateWithoutInvestigationInput, IntellengenceBasedSkillsUncheckedUpdateWithoutInvestigationInput>
  }

  export type IntellengenceBasedSkillsUpdateWithoutInvestigationInput = {
    arcana?: ArcanaSkillUpdateOneWithoutSkill_listNestedInput
    history?: HistorySkillUpdateOneWithoutSkill_listNestedInput
    nature?: NatureSkillUpdateOneWithoutSkill_listNestedInput
    religion?: ReligionSkillUpdateOneWithoutSkill_listNestedInput
    skills_list_relation?: SkillsListUpdateOneRequiredWithoutIntelligenceNestedInput
  }

  export type IntellengenceBasedSkillsUncheckedUpdateWithoutInvestigationInput = {
    id?: StringFieldUpdateOperationsInput | string
    arcana?: ArcanaSkillUncheckedUpdateOneWithoutSkill_listNestedInput
    history?: HistorySkillUncheckedUpdateOneWithoutSkill_listNestedInput
    nature?: NatureSkillUncheckedUpdateOneWithoutSkill_listNestedInput
    religion?: ReligionSkillUncheckedUpdateOneWithoutSkill_listNestedInput
  }

  export type IntellengenceBasedSkillsCreateWithoutNatureInput = {
    arcana?: ArcanaSkillCreateNestedOneWithoutSkill_listInput
    history?: HistorySkillCreateNestedOneWithoutSkill_listInput
    investigation?: InvestigationSkillCreateNestedOneWithoutSkill_listInput
    religion?: ReligionSkillCreateNestedOneWithoutSkill_listInput
    skills_list_relation: SkillsListCreateNestedOneWithoutIntelligenceInput
  }

  export type IntellengenceBasedSkillsUncheckedCreateWithoutNatureInput = {
    id: string
    arcana?: ArcanaSkillUncheckedCreateNestedOneWithoutSkill_listInput
    history?: HistorySkillUncheckedCreateNestedOneWithoutSkill_listInput
    investigation?: InvestigationSkillUncheckedCreateNestedOneWithoutSkill_listInput
    religion?: ReligionSkillUncheckedCreateNestedOneWithoutSkill_listInput
  }

  export type IntellengenceBasedSkillsCreateOrConnectWithoutNatureInput = {
    where: IntellengenceBasedSkillsWhereUniqueInput
    create: XOR<IntellengenceBasedSkillsCreateWithoutNatureInput, IntellengenceBasedSkillsUncheckedCreateWithoutNatureInput>
  }

  export type IntellengenceBasedSkillsUpsertWithoutNatureInput = {
    update: XOR<IntellengenceBasedSkillsUpdateWithoutNatureInput, IntellengenceBasedSkillsUncheckedUpdateWithoutNatureInput>
    create: XOR<IntellengenceBasedSkillsCreateWithoutNatureInput, IntellengenceBasedSkillsUncheckedCreateWithoutNatureInput>
    where?: IntellengenceBasedSkillsWhereInput
  }

  export type IntellengenceBasedSkillsUpdateToOneWithWhereWithoutNatureInput = {
    where?: IntellengenceBasedSkillsWhereInput
    data: XOR<IntellengenceBasedSkillsUpdateWithoutNatureInput, IntellengenceBasedSkillsUncheckedUpdateWithoutNatureInput>
  }

  export type IntellengenceBasedSkillsUpdateWithoutNatureInput = {
    arcana?: ArcanaSkillUpdateOneWithoutSkill_listNestedInput
    history?: HistorySkillUpdateOneWithoutSkill_listNestedInput
    investigation?: InvestigationSkillUpdateOneWithoutSkill_listNestedInput
    religion?: ReligionSkillUpdateOneWithoutSkill_listNestedInput
    skills_list_relation?: SkillsListUpdateOneRequiredWithoutIntelligenceNestedInput
  }

  export type IntellengenceBasedSkillsUncheckedUpdateWithoutNatureInput = {
    id?: StringFieldUpdateOperationsInput | string
    arcana?: ArcanaSkillUncheckedUpdateOneWithoutSkill_listNestedInput
    history?: HistorySkillUncheckedUpdateOneWithoutSkill_listNestedInput
    investigation?: InvestigationSkillUncheckedUpdateOneWithoutSkill_listNestedInput
    religion?: ReligionSkillUncheckedUpdateOneWithoutSkill_listNestedInput
  }

  export type IntellengenceBasedSkillsCreateWithoutReligionInput = {
    arcana?: ArcanaSkillCreateNestedOneWithoutSkill_listInput
    history?: HistorySkillCreateNestedOneWithoutSkill_listInput
    investigation?: InvestigationSkillCreateNestedOneWithoutSkill_listInput
    nature?: NatureSkillCreateNestedOneWithoutSkill_listInput
    skills_list_relation: SkillsListCreateNestedOneWithoutIntelligenceInput
  }

  export type IntellengenceBasedSkillsUncheckedCreateWithoutReligionInput = {
    id: string
    arcana?: ArcanaSkillUncheckedCreateNestedOneWithoutSkill_listInput
    history?: HistorySkillUncheckedCreateNestedOneWithoutSkill_listInput
    investigation?: InvestigationSkillUncheckedCreateNestedOneWithoutSkill_listInput
    nature?: NatureSkillUncheckedCreateNestedOneWithoutSkill_listInput
  }

  export type IntellengenceBasedSkillsCreateOrConnectWithoutReligionInput = {
    where: IntellengenceBasedSkillsWhereUniqueInput
    create: XOR<IntellengenceBasedSkillsCreateWithoutReligionInput, IntellengenceBasedSkillsUncheckedCreateWithoutReligionInput>
  }

  export type IntellengenceBasedSkillsUpsertWithoutReligionInput = {
    update: XOR<IntellengenceBasedSkillsUpdateWithoutReligionInput, IntellengenceBasedSkillsUncheckedUpdateWithoutReligionInput>
    create: XOR<IntellengenceBasedSkillsCreateWithoutReligionInput, IntellengenceBasedSkillsUncheckedCreateWithoutReligionInput>
    where?: IntellengenceBasedSkillsWhereInput
  }

  export type IntellengenceBasedSkillsUpdateToOneWithWhereWithoutReligionInput = {
    where?: IntellengenceBasedSkillsWhereInput
    data: XOR<IntellengenceBasedSkillsUpdateWithoutReligionInput, IntellengenceBasedSkillsUncheckedUpdateWithoutReligionInput>
  }

  export type IntellengenceBasedSkillsUpdateWithoutReligionInput = {
    arcana?: ArcanaSkillUpdateOneWithoutSkill_listNestedInput
    history?: HistorySkillUpdateOneWithoutSkill_listNestedInput
    investigation?: InvestigationSkillUpdateOneWithoutSkill_listNestedInput
    nature?: NatureSkillUpdateOneWithoutSkill_listNestedInput
    skills_list_relation?: SkillsListUpdateOneRequiredWithoutIntelligenceNestedInput
  }

  export type IntellengenceBasedSkillsUncheckedUpdateWithoutReligionInput = {
    id?: StringFieldUpdateOperationsInput | string
    arcana?: ArcanaSkillUncheckedUpdateOneWithoutSkill_listNestedInput
    history?: HistorySkillUncheckedUpdateOneWithoutSkill_listNestedInput
    investigation?: InvestigationSkillUncheckedUpdateOneWithoutSkill_listNestedInput
    nature?: NatureSkillUncheckedUpdateOneWithoutSkill_listNestedInput
  }

  export type WisdomBasedSkillsCreateWithoutAnimal_handlingInput = {
    insight?: InsightSkillCreateNestedOneWithoutSkill_listInput
    medicine?: MedicineSkillCreateNestedOneWithoutSkill_listInput
    perception?: PerceptionSkillCreateNestedOneWithoutSkill_listInput
    survival?: SurvivalSkillCreateNestedOneWithoutSkill_listInput
    skills_list_relation: SkillsListCreateNestedOneWithoutWisdomInput
  }

  export type WisdomBasedSkillsUncheckedCreateWithoutAnimal_handlingInput = {
    id: string
    insight?: InsightSkillUncheckedCreateNestedOneWithoutSkill_listInput
    medicine?: MedicineSkillUncheckedCreateNestedOneWithoutSkill_listInput
    perception?: PerceptionSkillUncheckedCreateNestedOneWithoutSkill_listInput
    survival?: SurvivalSkillUncheckedCreateNestedOneWithoutSkill_listInput
  }

  export type WisdomBasedSkillsCreateOrConnectWithoutAnimal_handlingInput = {
    where: WisdomBasedSkillsWhereUniqueInput
    create: XOR<WisdomBasedSkillsCreateWithoutAnimal_handlingInput, WisdomBasedSkillsUncheckedCreateWithoutAnimal_handlingInput>
  }

  export type WisdomBasedSkillsUpsertWithoutAnimal_handlingInput = {
    update: XOR<WisdomBasedSkillsUpdateWithoutAnimal_handlingInput, WisdomBasedSkillsUncheckedUpdateWithoutAnimal_handlingInput>
    create: XOR<WisdomBasedSkillsCreateWithoutAnimal_handlingInput, WisdomBasedSkillsUncheckedCreateWithoutAnimal_handlingInput>
    where?: WisdomBasedSkillsWhereInput
  }

  export type WisdomBasedSkillsUpdateToOneWithWhereWithoutAnimal_handlingInput = {
    where?: WisdomBasedSkillsWhereInput
    data: XOR<WisdomBasedSkillsUpdateWithoutAnimal_handlingInput, WisdomBasedSkillsUncheckedUpdateWithoutAnimal_handlingInput>
  }

  export type WisdomBasedSkillsUpdateWithoutAnimal_handlingInput = {
    insight?: InsightSkillUpdateOneWithoutSkill_listNestedInput
    medicine?: MedicineSkillUpdateOneWithoutSkill_listNestedInput
    perception?: PerceptionSkillUpdateOneWithoutSkill_listNestedInput
    survival?: SurvivalSkillUpdateOneWithoutSkill_listNestedInput
    skills_list_relation?: SkillsListUpdateOneRequiredWithoutWisdomNestedInput
  }

  export type WisdomBasedSkillsUncheckedUpdateWithoutAnimal_handlingInput = {
    id?: StringFieldUpdateOperationsInput | string
    insight?: InsightSkillUncheckedUpdateOneWithoutSkill_listNestedInput
    medicine?: MedicineSkillUncheckedUpdateOneWithoutSkill_listNestedInput
    perception?: PerceptionSkillUncheckedUpdateOneWithoutSkill_listNestedInput
    survival?: SurvivalSkillUncheckedUpdateOneWithoutSkill_listNestedInput
  }

  export type WisdomBasedSkillsCreateWithoutInsightInput = {
    animal_handling?: AnimalHandlingSkillCreateNestedOneWithoutSkill_listInput
    medicine?: MedicineSkillCreateNestedOneWithoutSkill_listInput
    perception?: PerceptionSkillCreateNestedOneWithoutSkill_listInput
    survival?: SurvivalSkillCreateNestedOneWithoutSkill_listInput
    skills_list_relation: SkillsListCreateNestedOneWithoutWisdomInput
  }

  export type WisdomBasedSkillsUncheckedCreateWithoutInsightInput = {
    id: string
    animal_handling?: AnimalHandlingSkillUncheckedCreateNestedOneWithoutSkill_listInput
    medicine?: MedicineSkillUncheckedCreateNestedOneWithoutSkill_listInput
    perception?: PerceptionSkillUncheckedCreateNestedOneWithoutSkill_listInput
    survival?: SurvivalSkillUncheckedCreateNestedOneWithoutSkill_listInput
  }

  export type WisdomBasedSkillsCreateOrConnectWithoutInsightInput = {
    where: WisdomBasedSkillsWhereUniqueInput
    create: XOR<WisdomBasedSkillsCreateWithoutInsightInput, WisdomBasedSkillsUncheckedCreateWithoutInsightInput>
  }

  export type WisdomBasedSkillsUpsertWithoutInsightInput = {
    update: XOR<WisdomBasedSkillsUpdateWithoutInsightInput, WisdomBasedSkillsUncheckedUpdateWithoutInsightInput>
    create: XOR<WisdomBasedSkillsCreateWithoutInsightInput, WisdomBasedSkillsUncheckedCreateWithoutInsightInput>
    where?: WisdomBasedSkillsWhereInput
  }

  export type WisdomBasedSkillsUpdateToOneWithWhereWithoutInsightInput = {
    where?: WisdomBasedSkillsWhereInput
    data: XOR<WisdomBasedSkillsUpdateWithoutInsightInput, WisdomBasedSkillsUncheckedUpdateWithoutInsightInput>
  }

  export type WisdomBasedSkillsUpdateWithoutInsightInput = {
    animal_handling?: AnimalHandlingSkillUpdateOneWithoutSkill_listNestedInput
    medicine?: MedicineSkillUpdateOneWithoutSkill_listNestedInput
    perception?: PerceptionSkillUpdateOneWithoutSkill_listNestedInput
    survival?: SurvivalSkillUpdateOneWithoutSkill_listNestedInput
    skills_list_relation?: SkillsListUpdateOneRequiredWithoutWisdomNestedInput
  }

  export type WisdomBasedSkillsUncheckedUpdateWithoutInsightInput = {
    id?: StringFieldUpdateOperationsInput | string
    animal_handling?: AnimalHandlingSkillUncheckedUpdateOneWithoutSkill_listNestedInput
    medicine?: MedicineSkillUncheckedUpdateOneWithoutSkill_listNestedInput
    perception?: PerceptionSkillUncheckedUpdateOneWithoutSkill_listNestedInput
    survival?: SurvivalSkillUncheckedUpdateOneWithoutSkill_listNestedInput
  }

  export type WisdomBasedSkillsCreateWithoutMedicineInput = {
    animal_handling?: AnimalHandlingSkillCreateNestedOneWithoutSkill_listInput
    insight?: InsightSkillCreateNestedOneWithoutSkill_listInput
    perception?: PerceptionSkillCreateNestedOneWithoutSkill_listInput
    survival?: SurvivalSkillCreateNestedOneWithoutSkill_listInput
    skills_list_relation: SkillsListCreateNestedOneWithoutWisdomInput
  }

  export type WisdomBasedSkillsUncheckedCreateWithoutMedicineInput = {
    id: string
    animal_handling?: AnimalHandlingSkillUncheckedCreateNestedOneWithoutSkill_listInput
    insight?: InsightSkillUncheckedCreateNestedOneWithoutSkill_listInput
    perception?: PerceptionSkillUncheckedCreateNestedOneWithoutSkill_listInput
    survival?: SurvivalSkillUncheckedCreateNestedOneWithoutSkill_listInput
  }

  export type WisdomBasedSkillsCreateOrConnectWithoutMedicineInput = {
    where: WisdomBasedSkillsWhereUniqueInput
    create: XOR<WisdomBasedSkillsCreateWithoutMedicineInput, WisdomBasedSkillsUncheckedCreateWithoutMedicineInput>
  }

  export type WisdomBasedSkillsUpsertWithoutMedicineInput = {
    update: XOR<WisdomBasedSkillsUpdateWithoutMedicineInput, WisdomBasedSkillsUncheckedUpdateWithoutMedicineInput>
    create: XOR<WisdomBasedSkillsCreateWithoutMedicineInput, WisdomBasedSkillsUncheckedCreateWithoutMedicineInput>
    where?: WisdomBasedSkillsWhereInput
  }

  export type WisdomBasedSkillsUpdateToOneWithWhereWithoutMedicineInput = {
    where?: WisdomBasedSkillsWhereInput
    data: XOR<WisdomBasedSkillsUpdateWithoutMedicineInput, WisdomBasedSkillsUncheckedUpdateWithoutMedicineInput>
  }

  export type WisdomBasedSkillsUpdateWithoutMedicineInput = {
    animal_handling?: AnimalHandlingSkillUpdateOneWithoutSkill_listNestedInput
    insight?: InsightSkillUpdateOneWithoutSkill_listNestedInput
    perception?: PerceptionSkillUpdateOneWithoutSkill_listNestedInput
    survival?: SurvivalSkillUpdateOneWithoutSkill_listNestedInput
    skills_list_relation?: SkillsListUpdateOneRequiredWithoutWisdomNestedInput
  }

  export type WisdomBasedSkillsUncheckedUpdateWithoutMedicineInput = {
    id?: StringFieldUpdateOperationsInput | string
    animal_handling?: AnimalHandlingSkillUncheckedUpdateOneWithoutSkill_listNestedInput
    insight?: InsightSkillUncheckedUpdateOneWithoutSkill_listNestedInput
    perception?: PerceptionSkillUncheckedUpdateOneWithoutSkill_listNestedInput
    survival?: SurvivalSkillUncheckedUpdateOneWithoutSkill_listNestedInput
  }

  export type WisdomBasedSkillsCreateWithoutPerceptionInput = {
    animal_handling?: AnimalHandlingSkillCreateNestedOneWithoutSkill_listInput
    insight?: InsightSkillCreateNestedOneWithoutSkill_listInput
    medicine?: MedicineSkillCreateNestedOneWithoutSkill_listInput
    survival?: SurvivalSkillCreateNestedOneWithoutSkill_listInput
    skills_list_relation: SkillsListCreateNestedOneWithoutWisdomInput
  }

  export type WisdomBasedSkillsUncheckedCreateWithoutPerceptionInput = {
    id: string
    animal_handling?: AnimalHandlingSkillUncheckedCreateNestedOneWithoutSkill_listInput
    insight?: InsightSkillUncheckedCreateNestedOneWithoutSkill_listInput
    medicine?: MedicineSkillUncheckedCreateNestedOneWithoutSkill_listInput
    survival?: SurvivalSkillUncheckedCreateNestedOneWithoutSkill_listInput
  }

  export type WisdomBasedSkillsCreateOrConnectWithoutPerceptionInput = {
    where: WisdomBasedSkillsWhereUniqueInput
    create: XOR<WisdomBasedSkillsCreateWithoutPerceptionInput, WisdomBasedSkillsUncheckedCreateWithoutPerceptionInput>
  }

  export type WisdomBasedSkillsUpsertWithoutPerceptionInput = {
    update: XOR<WisdomBasedSkillsUpdateWithoutPerceptionInput, WisdomBasedSkillsUncheckedUpdateWithoutPerceptionInput>
    create: XOR<WisdomBasedSkillsCreateWithoutPerceptionInput, WisdomBasedSkillsUncheckedCreateWithoutPerceptionInput>
    where?: WisdomBasedSkillsWhereInput
  }

  export type WisdomBasedSkillsUpdateToOneWithWhereWithoutPerceptionInput = {
    where?: WisdomBasedSkillsWhereInput
    data: XOR<WisdomBasedSkillsUpdateWithoutPerceptionInput, WisdomBasedSkillsUncheckedUpdateWithoutPerceptionInput>
  }

  export type WisdomBasedSkillsUpdateWithoutPerceptionInput = {
    animal_handling?: AnimalHandlingSkillUpdateOneWithoutSkill_listNestedInput
    insight?: InsightSkillUpdateOneWithoutSkill_listNestedInput
    medicine?: MedicineSkillUpdateOneWithoutSkill_listNestedInput
    survival?: SurvivalSkillUpdateOneWithoutSkill_listNestedInput
    skills_list_relation?: SkillsListUpdateOneRequiredWithoutWisdomNestedInput
  }

  export type WisdomBasedSkillsUncheckedUpdateWithoutPerceptionInput = {
    id?: StringFieldUpdateOperationsInput | string
    animal_handling?: AnimalHandlingSkillUncheckedUpdateOneWithoutSkill_listNestedInput
    insight?: InsightSkillUncheckedUpdateOneWithoutSkill_listNestedInput
    medicine?: MedicineSkillUncheckedUpdateOneWithoutSkill_listNestedInput
    survival?: SurvivalSkillUncheckedUpdateOneWithoutSkill_listNestedInput
  }

  export type WisdomBasedSkillsCreateWithoutSurvivalInput = {
    animal_handling?: AnimalHandlingSkillCreateNestedOneWithoutSkill_listInput
    insight?: InsightSkillCreateNestedOneWithoutSkill_listInput
    medicine?: MedicineSkillCreateNestedOneWithoutSkill_listInput
    perception?: PerceptionSkillCreateNestedOneWithoutSkill_listInput
    skills_list_relation: SkillsListCreateNestedOneWithoutWisdomInput
  }

  export type WisdomBasedSkillsUncheckedCreateWithoutSurvivalInput = {
    id: string
    animal_handling?: AnimalHandlingSkillUncheckedCreateNestedOneWithoutSkill_listInput
    insight?: InsightSkillUncheckedCreateNestedOneWithoutSkill_listInput
    medicine?: MedicineSkillUncheckedCreateNestedOneWithoutSkill_listInput
    perception?: PerceptionSkillUncheckedCreateNestedOneWithoutSkill_listInput
  }

  export type WisdomBasedSkillsCreateOrConnectWithoutSurvivalInput = {
    where: WisdomBasedSkillsWhereUniqueInput
    create: XOR<WisdomBasedSkillsCreateWithoutSurvivalInput, WisdomBasedSkillsUncheckedCreateWithoutSurvivalInput>
  }

  export type WisdomBasedSkillsUpsertWithoutSurvivalInput = {
    update: XOR<WisdomBasedSkillsUpdateWithoutSurvivalInput, WisdomBasedSkillsUncheckedUpdateWithoutSurvivalInput>
    create: XOR<WisdomBasedSkillsCreateWithoutSurvivalInput, WisdomBasedSkillsUncheckedCreateWithoutSurvivalInput>
    where?: WisdomBasedSkillsWhereInput
  }

  export type WisdomBasedSkillsUpdateToOneWithWhereWithoutSurvivalInput = {
    where?: WisdomBasedSkillsWhereInput
    data: XOR<WisdomBasedSkillsUpdateWithoutSurvivalInput, WisdomBasedSkillsUncheckedUpdateWithoutSurvivalInput>
  }

  export type WisdomBasedSkillsUpdateWithoutSurvivalInput = {
    animal_handling?: AnimalHandlingSkillUpdateOneWithoutSkill_listNestedInput
    insight?: InsightSkillUpdateOneWithoutSkill_listNestedInput
    medicine?: MedicineSkillUpdateOneWithoutSkill_listNestedInput
    perception?: PerceptionSkillUpdateOneWithoutSkill_listNestedInput
    skills_list_relation?: SkillsListUpdateOneRequiredWithoutWisdomNestedInput
  }

  export type WisdomBasedSkillsUncheckedUpdateWithoutSurvivalInput = {
    id?: StringFieldUpdateOperationsInput | string
    animal_handling?: AnimalHandlingSkillUncheckedUpdateOneWithoutSkill_listNestedInput
    insight?: InsightSkillUncheckedUpdateOneWithoutSkill_listNestedInput
    medicine?: MedicineSkillUncheckedUpdateOneWithoutSkill_listNestedInput
    perception?: PerceptionSkillUncheckedUpdateOneWithoutSkill_listNestedInput
  }

  export type CharismaBasedSkillsCreateWithoutDeceptionInput = {
    intimidation?: IntimidationSkillCreateNestedOneWithoutSkill_listInput
    performance?: PerformanceSkillCreateNestedOneWithoutSkill_listInput
    persuasion?: PersuasionSkillCreateNestedOneWithoutSkill_listInput
    skills_list_relation: SkillsListCreateNestedOneWithoutCharismaInput
  }

  export type CharismaBasedSkillsUncheckedCreateWithoutDeceptionInput = {
    id: string
    intimidation?: IntimidationSkillUncheckedCreateNestedOneWithoutSkill_listInput
    performance?: PerformanceSkillUncheckedCreateNestedOneWithoutSkill_listInput
    persuasion?: PersuasionSkillUncheckedCreateNestedOneWithoutSkill_listInput
  }

  export type CharismaBasedSkillsCreateOrConnectWithoutDeceptionInput = {
    where: CharismaBasedSkillsWhereUniqueInput
    create: XOR<CharismaBasedSkillsCreateWithoutDeceptionInput, CharismaBasedSkillsUncheckedCreateWithoutDeceptionInput>
  }

  export type CharismaBasedSkillsUpsertWithoutDeceptionInput = {
    update: XOR<CharismaBasedSkillsUpdateWithoutDeceptionInput, CharismaBasedSkillsUncheckedUpdateWithoutDeceptionInput>
    create: XOR<CharismaBasedSkillsCreateWithoutDeceptionInput, CharismaBasedSkillsUncheckedCreateWithoutDeceptionInput>
    where?: CharismaBasedSkillsWhereInput
  }

  export type CharismaBasedSkillsUpdateToOneWithWhereWithoutDeceptionInput = {
    where?: CharismaBasedSkillsWhereInput
    data: XOR<CharismaBasedSkillsUpdateWithoutDeceptionInput, CharismaBasedSkillsUncheckedUpdateWithoutDeceptionInput>
  }

  export type CharismaBasedSkillsUpdateWithoutDeceptionInput = {
    intimidation?: IntimidationSkillUpdateOneWithoutSkill_listNestedInput
    performance?: PerformanceSkillUpdateOneWithoutSkill_listNestedInput
    persuasion?: PersuasionSkillUpdateOneWithoutSkill_listNestedInput
    skills_list_relation?: SkillsListUpdateOneRequiredWithoutCharismaNestedInput
  }

  export type CharismaBasedSkillsUncheckedUpdateWithoutDeceptionInput = {
    id?: StringFieldUpdateOperationsInput | string
    intimidation?: IntimidationSkillUncheckedUpdateOneWithoutSkill_listNestedInput
    performance?: PerformanceSkillUncheckedUpdateOneWithoutSkill_listNestedInput
    persuasion?: PersuasionSkillUncheckedUpdateOneWithoutSkill_listNestedInput
  }

  export type CharismaBasedSkillsCreateWithoutIntimidationInput = {
    deception?: DeceptionSkillCreateNestedOneWithoutSkill_listInput
    performance?: PerformanceSkillCreateNestedOneWithoutSkill_listInput
    persuasion?: PersuasionSkillCreateNestedOneWithoutSkill_listInput
    skills_list_relation: SkillsListCreateNestedOneWithoutCharismaInput
  }

  export type CharismaBasedSkillsUncheckedCreateWithoutIntimidationInput = {
    id: string
    deception?: DeceptionSkillUncheckedCreateNestedOneWithoutSkill_listInput
    performance?: PerformanceSkillUncheckedCreateNestedOneWithoutSkill_listInput
    persuasion?: PersuasionSkillUncheckedCreateNestedOneWithoutSkill_listInput
  }

  export type CharismaBasedSkillsCreateOrConnectWithoutIntimidationInput = {
    where: CharismaBasedSkillsWhereUniqueInput
    create: XOR<CharismaBasedSkillsCreateWithoutIntimidationInput, CharismaBasedSkillsUncheckedCreateWithoutIntimidationInput>
  }

  export type CharismaBasedSkillsUpsertWithoutIntimidationInput = {
    update: XOR<CharismaBasedSkillsUpdateWithoutIntimidationInput, CharismaBasedSkillsUncheckedUpdateWithoutIntimidationInput>
    create: XOR<CharismaBasedSkillsCreateWithoutIntimidationInput, CharismaBasedSkillsUncheckedCreateWithoutIntimidationInput>
    where?: CharismaBasedSkillsWhereInput
  }

  export type CharismaBasedSkillsUpdateToOneWithWhereWithoutIntimidationInput = {
    where?: CharismaBasedSkillsWhereInput
    data: XOR<CharismaBasedSkillsUpdateWithoutIntimidationInput, CharismaBasedSkillsUncheckedUpdateWithoutIntimidationInput>
  }

  export type CharismaBasedSkillsUpdateWithoutIntimidationInput = {
    deception?: DeceptionSkillUpdateOneWithoutSkill_listNestedInput
    performance?: PerformanceSkillUpdateOneWithoutSkill_listNestedInput
    persuasion?: PersuasionSkillUpdateOneWithoutSkill_listNestedInput
    skills_list_relation?: SkillsListUpdateOneRequiredWithoutCharismaNestedInput
  }

  export type CharismaBasedSkillsUncheckedUpdateWithoutIntimidationInput = {
    id?: StringFieldUpdateOperationsInput | string
    deception?: DeceptionSkillUncheckedUpdateOneWithoutSkill_listNestedInput
    performance?: PerformanceSkillUncheckedUpdateOneWithoutSkill_listNestedInput
    persuasion?: PersuasionSkillUncheckedUpdateOneWithoutSkill_listNestedInput
  }

  export type CharismaBasedSkillsCreateWithoutPerformanceInput = {
    deception?: DeceptionSkillCreateNestedOneWithoutSkill_listInput
    intimidation?: IntimidationSkillCreateNestedOneWithoutSkill_listInput
    persuasion?: PersuasionSkillCreateNestedOneWithoutSkill_listInput
    skills_list_relation: SkillsListCreateNestedOneWithoutCharismaInput
  }

  export type CharismaBasedSkillsUncheckedCreateWithoutPerformanceInput = {
    id: string
    deception?: DeceptionSkillUncheckedCreateNestedOneWithoutSkill_listInput
    intimidation?: IntimidationSkillUncheckedCreateNestedOneWithoutSkill_listInput
    persuasion?: PersuasionSkillUncheckedCreateNestedOneWithoutSkill_listInput
  }

  export type CharismaBasedSkillsCreateOrConnectWithoutPerformanceInput = {
    where: CharismaBasedSkillsWhereUniqueInput
    create: XOR<CharismaBasedSkillsCreateWithoutPerformanceInput, CharismaBasedSkillsUncheckedCreateWithoutPerformanceInput>
  }

  export type CharismaBasedSkillsUpsertWithoutPerformanceInput = {
    update: XOR<CharismaBasedSkillsUpdateWithoutPerformanceInput, CharismaBasedSkillsUncheckedUpdateWithoutPerformanceInput>
    create: XOR<CharismaBasedSkillsCreateWithoutPerformanceInput, CharismaBasedSkillsUncheckedCreateWithoutPerformanceInput>
    where?: CharismaBasedSkillsWhereInput
  }

  export type CharismaBasedSkillsUpdateToOneWithWhereWithoutPerformanceInput = {
    where?: CharismaBasedSkillsWhereInput
    data: XOR<CharismaBasedSkillsUpdateWithoutPerformanceInput, CharismaBasedSkillsUncheckedUpdateWithoutPerformanceInput>
  }

  export type CharismaBasedSkillsUpdateWithoutPerformanceInput = {
    deception?: DeceptionSkillUpdateOneWithoutSkill_listNestedInput
    intimidation?: IntimidationSkillUpdateOneWithoutSkill_listNestedInput
    persuasion?: PersuasionSkillUpdateOneWithoutSkill_listNestedInput
    skills_list_relation?: SkillsListUpdateOneRequiredWithoutCharismaNestedInput
  }

  export type CharismaBasedSkillsUncheckedUpdateWithoutPerformanceInput = {
    id?: StringFieldUpdateOperationsInput | string
    deception?: DeceptionSkillUncheckedUpdateOneWithoutSkill_listNestedInput
    intimidation?: IntimidationSkillUncheckedUpdateOneWithoutSkill_listNestedInput
    persuasion?: PersuasionSkillUncheckedUpdateOneWithoutSkill_listNestedInput
  }

  export type CharismaBasedSkillsCreateWithoutPersuasionInput = {
    deception?: DeceptionSkillCreateNestedOneWithoutSkill_listInput
    intimidation?: IntimidationSkillCreateNestedOneWithoutSkill_listInput
    performance?: PerformanceSkillCreateNestedOneWithoutSkill_listInput
    skills_list_relation: SkillsListCreateNestedOneWithoutCharismaInput
  }

  export type CharismaBasedSkillsUncheckedCreateWithoutPersuasionInput = {
    id: string
    deception?: DeceptionSkillUncheckedCreateNestedOneWithoutSkill_listInput
    intimidation?: IntimidationSkillUncheckedCreateNestedOneWithoutSkill_listInput
    performance?: PerformanceSkillUncheckedCreateNestedOneWithoutSkill_listInput
  }

  export type CharismaBasedSkillsCreateOrConnectWithoutPersuasionInput = {
    where: CharismaBasedSkillsWhereUniqueInput
    create: XOR<CharismaBasedSkillsCreateWithoutPersuasionInput, CharismaBasedSkillsUncheckedCreateWithoutPersuasionInput>
  }

  export type CharismaBasedSkillsUpsertWithoutPersuasionInput = {
    update: XOR<CharismaBasedSkillsUpdateWithoutPersuasionInput, CharismaBasedSkillsUncheckedUpdateWithoutPersuasionInput>
    create: XOR<CharismaBasedSkillsCreateWithoutPersuasionInput, CharismaBasedSkillsUncheckedCreateWithoutPersuasionInput>
    where?: CharismaBasedSkillsWhereInput
  }

  export type CharismaBasedSkillsUpdateToOneWithWhereWithoutPersuasionInput = {
    where?: CharismaBasedSkillsWhereInput
    data: XOR<CharismaBasedSkillsUpdateWithoutPersuasionInput, CharismaBasedSkillsUncheckedUpdateWithoutPersuasionInput>
  }

  export type CharismaBasedSkillsUpdateWithoutPersuasionInput = {
    deception?: DeceptionSkillUpdateOneWithoutSkill_listNestedInput
    intimidation?: IntimidationSkillUpdateOneWithoutSkill_listNestedInput
    performance?: PerformanceSkillUpdateOneWithoutSkill_listNestedInput
    skills_list_relation?: SkillsListUpdateOneRequiredWithoutCharismaNestedInput
  }

  export type CharismaBasedSkillsUncheckedUpdateWithoutPersuasionInput = {
    id?: StringFieldUpdateOperationsInput | string
    deception?: DeceptionSkillUncheckedUpdateOneWithoutSkill_listNestedInput
    intimidation?: IntimidationSkillUncheckedUpdateOneWithoutSkill_listNestedInput
    performance?: PerformanceSkillUncheckedUpdateOneWithoutSkill_listNestedInput
  }

  export type Speed_statCreateWithoutId_relationInput = {
    walk?: number | null
    fly?: number | null
    swim?: number | null
    burrow?: number | null
    climb?: number | null
  }

  export type Speed_statUncheckedCreateWithoutId_relationInput = {
    walk?: number | null
    fly?: number | null
    swim?: number | null
    burrow?: number | null
    climb?: number | null
  }

  export type Speed_statCreateOrConnectWithoutId_relationInput = {
    where: Speed_statWhereUniqueInput
    create: XOR<Speed_statCreateWithoutId_relationInput, Speed_statUncheckedCreateWithoutId_relationInput>
  }

  export type Creature_statsCreateWithoutId_relationInput = {
    strength?: Strength_stat_detailsCreateNestedOneWithoutCreature_statInput
    dexterity?: Dexterity_stat_detailsCreateNestedOneWithoutCreature_statInput
    constitution?: Constitution_stat_detailsCreateNestedOneWithoutCreature_statInput
    intelligence?: Intelligence_stat_detailsCreateNestedOneWithoutCreature_statInput
    wisdom?: Wisdom_stat_detailsCreateNestedOneWithoutCreature_statInput
    charisma?: Charisma_stat_detailsCreateNestedOneWithoutCreature_statInput
  }

  export type Creature_statsUncheckedCreateWithoutId_relationInput = {
    strength?: Strength_stat_detailsUncheckedCreateNestedOneWithoutCreature_statInput
    dexterity?: Dexterity_stat_detailsUncheckedCreateNestedOneWithoutCreature_statInput
    constitution?: Constitution_stat_detailsUncheckedCreateNestedOneWithoutCreature_statInput
    intelligence?: Intelligence_stat_detailsUncheckedCreateNestedOneWithoutCreature_statInput
    wisdom?: Wisdom_stat_detailsUncheckedCreateNestedOneWithoutCreature_statInput
    charisma?: Charisma_stat_detailsUncheckedCreateNestedOneWithoutCreature_statInput
  }

  export type Creature_statsCreateOrConnectWithoutId_relationInput = {
    where: Creature_statsWhereUniqueInput
    create: XOR<Creature_statsCreateWithoutId_relationInput, Creature_statsUncheckedCreateWithoutId_relationInput>
  }

  export type SkillsListCreateWithoutId_relationInput = {
    strength?: StrengthBasedSkillsCreateNestedOneWithoutSkills_list_relationInput
    dexterity?: DexterityBasedSkillsCreateNestedOneWithoutSkills_list_relationInput
    intelligence?: IntellengenceBasedSkillsCreateNestedOneWithoutSkills_list_relationInput
    wisdom?: WisdomBasedSkillsCreateNestedOneWithoutSkills_list_relationInput
    charisma?: CharismaBasedSkillsCreateNestedOneWithoutSkills_list_relationInput
  }

  export type SkillsListUncheckedCreateWithoutId_relationInput = {
    strength?: StrengthBasedSkillsUncheckedCreateNestedOneWithoutSkills_list_relationInput
    dexterity?: DexterityBasedSkillsUncheckedCreateNestedOneWithoutSkills_list_relationInput
    intelligence?: IntellengenceBasedSkillsUncheckedCreateNestedOneWithoutSkills_list_relationInput
    wisdom?: WisdomBasedSkillsUncheckedCreateNestedOneWithoutSkills_list_relationInput
    charisma?: CharismaBasedSkillsUncheckedCreateNestedOneWithoutSkills_list_relationInput
  }

  export type SkillsListCreateOrConnectWithoutId_relationInput = {
    where: SkillsListWhereUniqueInput
    create: XOR<SkillsListCreateWithoutId_relationInput, SkillsListUncheckedCreateWithoutId_relationInput>
  }

  export type DamageTypeCreateWithoutResistant_creaturesInput = {
    id: string
    name: string
    immune_creatures?: CreatureCreateNestedManyWithoutImmunitiesInput
    vunlerable_creatures?: CreatureCreateNestedManyWithoutVulnerabilitiesInput
  }

  export type DamageTypeUncheckedCreateWithoutResistant_creaturesInput = {
    id: string
    name: string
    immune_creatures?: CreatureUncheckedCreateNestedManyWithoutImmunitiesInput
    vunlerable_creatures?: CreatureUncheckedCreateNestedManyWithoutVulnerabilitiesInput
  }

  export type DamageTypeCreateOrConnectWithoutResistant_creaturesInput = {
    where: DamageTypeWhereUniqueInput
    create: XOR<DamageTypeCreateWithoutResistant_creaturesInput, DamageTypeUncheckedCreateWithoutResistant_creaturesInput>
  }

  export type DamageTypeCreateWithoutImmune_creaturesInput = {
    id: string
    name: string
    resistant_creatures?: CreatureCreateNestedManyWithoutResistancesInput
    vunlerable_creatures?: CreatureCreateNestedManyWithoutVulnerabilitiesInput
  }

  export type DamageTypeUncheckedCreateWithoutImmune_creaturesInput = {
    id: string
    name: string
    resistant_creatures?: CreatureUncheckedCreateNestedManyWithoutResistancesInput
    vunlerable_creatures?: CreatureUncheckedCreateNestedManyWithoutVulnerabilitiesInput
  }

  export type DamageTypeCreateOrConnectWithoutImmune_creaturesInput = {
    where: DamageTypeWhereUniqueInput
    create: XOR<DamageTypeCreateWithoutImmune_creaturesInput, DamageTypeUncheckedCreateWithoutImmune_creaturesInput>
  }

  export type DamageTypeCreateWithoutVunlerable_creaturesInput = {
    id: string
    name: string
    resistant_creatures?: CreatureCreateNestedManyWithoutResistancesInput
    immune_creatures?: CreatureCreateNestedManyWithoutImmunitiesInput
  }

  export type DamageTypeUncheckedCreateWithoutVunlerable_creaturesInput = {
    id: string
    name: string
    resistant_creatures?: CreatureUncheckedCreateNestedManyWithoutResistancesInput
    immune_creatures?: CreatureUncheckedCreateNestedManyWithoutImmunitiesInput
  }

  export type DamageTypeCreateOrConnectWithoutVunlerable_creaturesInput = {
    where: DamageTypeWhereUniqueInput
    create: XOR<DamageTypeCreateWithoutVunlerable_creaturesInput, DamageTypeUncheckedCreateWithoutVunlerable_creaturesInput>
  }

  export type SensesCreateWithoutCreatureInput = {
    passive_perception?: number | null
  }

  export type SensesUncheckedCreateWithoutCreatureInput = {
    passive_perception?: number | null
  }

  export type SensesCreateOrConnectWithoutCreatureInput = {
    where: SensesWhereUniqueInput
    create: XOR<SensesCreateWithoutCreatureInput, SensesUncheckedCreateWithoutCreatureInput>
  }

  export type LanguageCreateWithoutCreaturesInput = {
    name: string
  }

  export type LanguageUncheckedCreateWithoutCreaturesInput = {
    id?: number
    name: string
  }

  export type LanguageCreateOrConnectWithoutCreaturesInput = {
    where: LanguageWhereUniqueInput
    create: XOR<LanguageCreateWithoutCreaturesInput, LanguageUncheckedCreateWithoutCreaturesInput>
  }

  export type ActionCreateWithoutCreaturesInput = {
    name: string
    description: string
    attack?: string | null
    is_template?: boolean | null
    creatureTypes?: CreatureRaceCreateNestedManyWithoutActionsInput
  }

  export type ActionUncheckedCreateWithoutCreaturesInput = {
    id?: number
    name: string
    description: string
    attack?: string | null
    is_template?: boolean | null
    creatureTypes?: CreatureRaceUncheckedCreateNestedManyWithoutActionsInput
  }

  export type ActionCreateOrConnectWithoutCreaturesInput = {
    where: ActionWhereUniqueInput
    create: XOR<ActionCreateWithoutCreaturesInput, ActionUncheckedCreateWithoutCreaturesInput>
  }

  export type TraitCreateWithoutCreturesInput = {
    name: string
    description: string
    attack?: string | null
    is_template?: boolean | null
    creatureTypes?: CreatureRaceCreateNestedManyWithoutTraitsInput
  }

  export type TraitUncheckedCreateWithoutCreturesInput = {
    id?: number
    name: string
    description: string
    attack?: string | null
    is_template?: boolean | null
    creatureTypes?: CreatureRaceUncheckedCreateNestedManyWithoutTraitsInput
  }

  export type TraitCreateOrConnectWithoutCreturesInput = {
    where: TraitWhereUniqueInput
    create: XOR<TraitCreateWithoutCreturesInput, TraitUncheckedCreateWithoutCreturesInput>
  }

  export type AlignmentCreateWithoutCreaturesInput = {
    name: string
  }

  export type AlignmentUncheckedCreateWithoutCreaturesInput = {
    id?: number
    name: string
  }

  export type AlignmentCreateOrConnectWithoutCreaturesInput = {
    where: AlignmentWhereUniqueInput
    create: XOR<AlignmentCreateWithoutCreaturesInput, AlignmentUncheckedCreateWithoutCreaturesInput>
  }

  export type CreatureRaceCreateWithoutCreaturesInput = {
    name: string
    description: string
    traits?: TraitCreateNestedManyWithoutCreatureTypesInput
    actions?: ActionCreateNestedManyWithoutCreatureTypesInput
  }

  export type CreatureRaceUncheckedCreateWithoutCreaturesInput = {
    id?: number
    name: string
    description: string
    traits?: TraitUncheckedCreateNestedManyWithoutCreatureTypesInput
    actions?: ActionUncheckedCreateNestedManyWithoutCreatureTypesInput
  }

  export type CreatureRaceCreateOrConnectWithoutCreaturesInput = {
    where: CreatureRaceWhereUniqueInput
    create: XOR<CreatureRaceCreateWithoutCreaturesInput, CreatureRaceUncheckedCreateWithoutCreaturesInput>
  }

  export type TypeCreateWithoutCreaturesInput = {
    name: string
  }

  export type TypeUncheckedCreateWithoutCreaturesInput = {
    id?: number
    name: string
  }

  export type TypeCreateOrConnectWithoutCreaturesInput = {
    where: TypeWhereUniqueInput
    create: XOR<TypeCreateWithoutCreaturesInput, TypeUncheckedCreateWithoutCreaturesInput>
  }

  export type SizeCreateWithoutCreatureInput = {
    id: string
    name: string
  }

  export type SizeUncheckedCreateWithoutCreatureInput = {
    id: string
    name: string
  }

  export type SizeCreateOrConnectWithoutCreatureInput = {
    where: SizeWhereUniqueInput
    create: XOR<SizeCreateWithoutCreatureInput, SizeUncheckedCreateWithoutCreatureInput>
  }

  export type BiomeCreateWithoutCreaturesInput = {
    key: string
    name: string
  }

  export type BiomeUncheckedCreateWithoutCreaturesInput = {
    id?: number
    key: string
    name: string
  }

  export type BiomeCreateOrConnectWithoutCreaturesInput = {
    where: BiomeWhereUniqueInput
    create: XOR<BiomeCreateWithoutCreaturesInput, BiomeUncheckedCreateWithoutCreaturesInput>
  }

  export type SourceCreateWithoutCreaturesInput = {
    shortName: string
    name: string
  }

  export type SourceUncheckedCreateWithoutCreaturesInput = {
    id?: number
    shortName: string
    name: string
  }

  export type SourceCreateOrConnectWithoutCreaturesInput = {
    where: SourceWhereUniqueInput
    create: XOR<SourceCreateWithoutCreaturesInput, SourceUncheckedCreateWithoutCreaturesInput>
  }

  export type Speed_statUpsertWithoutId_relationInput = {
    update: XOR<Speed_statUpdateWithoutId_relationInput, Speed_statUncheckedUpdateWithoutId_relationInput>
    create: XOR<Speed_statCreateWithoutId_relationInput, Speed_statUncheckedCreateWithoutId_relationInput>
    where?: Speed_statWhereInput
  }

  export type Speed_statUpdateToOneWithWhereWithoutId_relationInput = {
    where?: Speed_statWhereInput
    data: XOR<Speed_statUpdateWithoutId_relationInput, Speed_statUncheckedUpdateWithoutId_relationInput>
  }

  export type Speed_statUpdateWithoutId_relationInput = {
    walk?: NullableIntFieldUpdateOperationsInput | number | null
    fly?: NullableIntFieldUpdateOperationsInput | number | null
    swim?: NullableIntFieldUpdateOperationsInput | number | null
    burrow?: NullableIntFieldUpdateOperationsInput | number | null
    climb?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type Speed_statUncheckedUpdateWithoutId_relationInput = {
    walk?: NullableIntFieldUpdateOperationsInput | number | null
    fly?: NullableIntFieldUpdateOperationsInput | number | null
    swim?: NullableIntFieldUpdateOperationsInput | number | null
    burrow?: NullableIntFieldUpdateOperationsInput | number | null
    climb?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type Creature_statsUpsertWithoutId_relationInput = {
    update: XOR<Creature_statsUpdateWithoutId_relationInput, Creature_statsUncheckedUpdateWithoutId_relationInput>
    create: XOR<Creature_statsCreateWithoutId_relationInput, Creature_statsUncheckedCreateWithoutId_relationInput>
    where?: Creature_statsWhereInput
  }

  export type Creature_statsUpdateToOneWithWhereWithoutId_relationInput = {
    where?: Creature_statsWhereInput
    data: XOR<Creature_statsUpdateWithoutId_relationInput, Creature_statsUncheckedUpdateWithoutId_relationInput>
  }

  export type Creature_statsUpdateWithoutId_relationInput = {
    strength?: Strength_stat_detailsUpdateOneWithoutCreature_statNestedInput
    dexterity?: Dexterity_stat_detailsUpdateOneWithoutCreature_statNestedInput
    constitution?: Constitution_stat_detailsUpdateOneWithoutCreature_statNestedInput
    intelligence?: Intelligence_stat_detailsUpdateOneWithoutCreature_statNestedInput
    wisdom?: Wisdom_stat_detailsUpdateOneWithoutCreature_statNestedInput
    charisma?: Charisma_stat_detailsUpdateOneWithoutCreature_statNestedInput
  }

  export type Creature_statsUncheckedUpdateWithoutId_relationInput = {
    strength?: Strength_stat_detailsUncheckedUpdateOneWithoutCreature_statNestedInput
    dexterity?: Dexterity_stat_detailsUncheckedUpdateOneWithoutCreature_statNestedInput
    constitution?: Constitution_stat_detailsUncheckedUpdateOneWithoutCreature_statNestedInput
    intelligence?: Intelligence_stat_detailsUncheckedUpdateOneWithoutCreature_statNestedInput
    wisdom?: Wisdom_stat_detailsUncheckedUpdateOneWithoutCreature_statNestedInput
    charisma?: Charisma_stat_detailsUncheckedUpdateOneWithoutCreature_statNestedInput
  }

  export type SkillsListUpsertWithoutId_relationInput = {
    update: XOR<SkillsListUpdateWithoutId_relationInput, SkillsListUncheckedUpdateWithoutId_relationInput>
    create: XOR<SkillsListCreateWithoutId_relationInput, SkillsListUncheckedCreateWithoutId_relationInput>
    where?: SkillsListWhereInput
  }

  export type SkillsListUpdateToOneWithWhereWithoutId_relationInput = {
    where?: SkillsListWhereInput
    data: XOR<SkillsListUpdateWithoutId_relationInput, SkillsListUncheckedUpdateWithoutId_relationInput>
  }

  export type SkillsListUpdateWithoutId_relationInput = {
    strength?: StrengthBasedSkillsUpdateOneWithoutSkills_list_relationNestedInput
    dexterity?: DexterityBasedSkillsUpdateOneWithoutSkills_list_relationNestedInput
    intelligence?: IntellengenceBasedSkillsUpdateOneWithoutSkills_list_relationNestedInput
    wisdom?: WisdomBasedSkillsUpdateOneWithoutSkills_list_relationNestedInput
    charisma?: CharismaBasedSkillsUpdateOneWithoutSkills_list_relationNestedInput
  }

  export type SkillsListUncheckedUpdateWithoutId_relationInput = {
    strength?: StrengthBasedSkillsUncheckedUpdateOneWithoutSkills_list_relationNestedInput
    dexterity?: DexterityBasedSkillsUncheckedUpdateOneWithoutSkills_list_relationNestedInput
    intelligence?: IntellengenceBasedSkillsUncheckedUpdateOneWithoutSkills_list_relationNestedInput
    wisdom?: WisdomBasedSkillsUncheckedUpdateOneWithoutSkills_list_relationNestedInput
    charisma?: CharismaBasedSkillsUncheckedUpdateOneWithoutSkills_list_relationNestedInput
  }

  export type DamageTypeUpsertWithWhereUniqueWithoutResistant_creaturesInput = {
    where: DamageTypeWhereUniqueInput
    update: XOR<DamageTypeUpdateWithoutResistant_creaturesInput, DamageTypeUncheckedUpdateWithoutResistant_creaturesInput>
    create: XOR<DamageTypeCreateWithoutResistant_creaturesInput, DamageTypeUncheckedCreateWithoutResistant_creaturesInput>
  }

  export type DamageTypeUpdateWithWhereUniqueWithoutResistant_creaturesInput = {
    where: DamageTypeWhereUniqueInput
    data: XOR<DamageTypeUpdateWithoutResistant_creaturesInput, DamageTypeUncheckedUpdateWithoutResistant_creaturesInput>
  }

  export type DamageTypeUpdateManyWithWhereWithoutResistant_creaturesInput = {
    where: DamageTypeScalarWhereInput
    data: XOR<DamageTypeUpdateManyMutationInput, DamageTypeUncheckedUpdateManyWithoutResistant_creaturesInput>
  }

  export type DamageTypeScalarWhereInput = {
    AND?: DamageTypeScalarWhereInput | DamageTypeScalarWhereInput[]
    OR?: DamageTypeScalarWhereInput[]
    NOT?: DamageTypeScalarWhereInput | DamageTypeScalarWhereInput[]
    id?: StringFilter<"DamageType"> | string
    name?: StringFilter<"DamageType"> | string
  }

  export type DamageTypeUpsertWithWhereUniqueWithoutImmune_creaturesInput = {
    where: DamageTypeWhereUniqueInput
    update: XOR<DamageTypeUpdateWithoutImmune_creaturesInput, DamageTypeUncheckedUpdateWithoutImmune_creaturesInput>
    create: XOR<DamageTypeCreateWithoutImmune_creaturesInput, DamageTypeUncheckedCreateWithoutImmune_creaturesInput>
  }

  export type DamageTypeUpdateWithWhereUniqueWithoutImmune_creaturesInput = {
    where: DamageTypeWhereUniqueInput
    data: XOR<DamageTypeUpdateWithoutImmune_creaturesInput, DamageTypeUncheckedUpdateWithoutImmune_creaturesInput>
  }

  export type DamageTypeUpdateManyWithWhereWithoutImmune_creaturesInput = {
    where: DamageTypeScalarWhereInput
    data: XOR<DamageTypeUpdateManyMutationInput, DamageTypeUncheckedUpdateManyWithoutImmune_creaturesInput>
  }

  export type DamageTypeUpsertWithWhereUniqueWithoutVunlerable_creaturesInput = {
    where: DamageTypeWhereUniqueInput
    update: XOR<DamageTypeUpdateWithoutVunlerable_creaturesInput, DamageTypeUncheckedUpdateWithoutVunlerable_creaturesInput>
    create: XOR<DamageTypeCreateWithoutVunlerable_creaturesInput, DamageTypeUncheckedCreateWithoutVunlerable_creaturesInput>
  }

  export type DamageTypeUpdateWithWhereUniqueWithoutVunlerable_creaturesInput = {
    where: DamageTypeWhereUniqueInput
    data: XOR<DamageTypeUpdateWithoutVunlerable_creaturesInput, DamageTypeUncheckedUpdateWithoutVunlerable_creaturesInput>
  }

  export type DamageTypeUpdateManyWithWhereWithoutVunlerable_creaturesInput = {
    where: DamageTypeScalarWhereInput
    data: XOR<DamageTypeUpdateManyMutationInput, DamageTypeUncheckedUpdateManyWithoutVunlerable_creaturesInput>
  }

  export type SensesUpsertWithoutCreatureInput = {
    update: XOR<SensesUpdateWithoutCreatureInput, SensesUncheckedUpdateWithoutCreatureInput>
    create: XOR<SensesCreateWithoutCreatureInput, SensesUncheckedCreateWithoutCreatureInput>
    where?: SensesWhereInput
  }

  export type SensesUpdateToOneWithWhereWithoutCreatureInput = {
    where?: SensesWhereInput
    data: XOR<SensesUpdateWithoutCreatureInput, SensesUncheckedUpdateWithoutCreatureInput>
  }

  export type SensesUpdateWithoutCreatureInput = {
    passive_perception?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type SensesUncheckedUpdateWithoutCreatureInput = {
    passive_perception?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type LanguageUpsertWithWhereUniqueWithoutCreaturesInput = {
    where: LanguageWhereUniqueInput
    update: XOR<LanguageUpdateWithoutCreaturesInput, LanguageUncheckedUpdateWithoutCreaturesInput>
    create: XOR<LanguageCreateWithoutCreaturesInput, LanguageUncheckedCreateWithoutCreaturesInput>
  }

  export type LanguageUpdateWithWhereUniqueWithoutCreaturesInput = {
    where: LanguageWhereUniqueInput
    data: XOR<LanguageUpdateWithoutCreaturesInput, LanguageUncheckedUpdateWithoutCreaturesInput>
  }

  export type LanguageUpdateManyWithWhereWithoutCreaturesInput = {
    where: LanguageScalarWhereInput
    data: XOR<LanguageUpdateManyMutationInput, LanguageUncheckedUpdateManyWithoutCreaturesInput>
  }

  export type LanguageScalarWhereInput = {
    AND?: LanguageScalarWhereInput | LanguageScalarWhereInput[]
    OR?: LanguageScalarWhereInput[]
    NOT?: LanguageScalarWhereInput | LanguageScalarWhereInput[]
    id?: IntFilter<"Language"> | number
    name?: StringFilter<"Language"> | string
  }

  export type ActionUpsertWithWhereUniqueWithoutCreaturesInput = {
    where: ActionWhereUniqueInput
    update: XOR<ActionUpdateWithoutCreaturesInput, ActionUncheckedUpdateWithoutCreaturesInput>
    create: XOR<ActionCreateWithoutCreaturesInput, ActionUncheckedCreateWithoutCreaturesInput>
  }

  export type ActionUpdateWithWhereUniqueWithoutCreaturesInput = {
    where: ActionWhereUniqueInput
    data: XOR<ActionUpdateWithoutCreaturesInput, ActionUncheckedUpdateWithoutCreaturesInput>
  }

  export type ActionUpdateManyWithWhereWithoutCreaturesInput = {
    where: ActionScalarWhereInput
    data: XOR<ActionUpdateManyMutationInput, ActionUncheckedUpdateManyWithoutCreaturesInput>
  }

  export type ActionScalarWhereInput = {
    AND?: ActionScalarWhereInput | ActionScalarWhereInput[]
    OR?: ActionScalarWhereInput[]
    NOT?: ActionScalarWhereInput | ActionScalarWhereInput[]
    id?: IntFilter<"Action"> | number
    name?: StringFilter<"Action"> | string
    description?: StringFilter<"Action"> | string
    attack?: StringNullableFilter<"Action"> | string | null
    is_template?: BoolNullableFilter<"Action"> | boolean | null
  }

  export type TraitUpsertWithWhereUniqueWithoutCreturesInput = {
    where: TraitWhereUniqueInput
    update: XOR<TraitUpdateWithoutCreturesInput, TraitUncheckedUpdateWithoutCreturesInput>
    create: XOR<TraitCreateWithoutCreturesInput, TraitUncheckedCreateWithoutCreturesInput>
  }

  export type TraitUpdateWithWhereUniqueWithoutCreturesInput = {
    where: TraitWhereUniqueInput
    data: XOR<TraitUpdateWithoutCreturesInput, TraitUncheckedUpdateWithoutCreturesInput>
  }

  export type TraitUpdateManyWithWhereWithoutCreturesInput = {
    where: TraitScalarWhereInput
    data: XOR<TraitUpdateManyMutationInput, TraitUncheckedUpdateManyWithoutCreturesInput>
  }

  export type TraitScalarWhereInput = {
    AND?: TraitScalarWhereInput | TraitScalarWhereInput[]
    OR?: TraitScalarWhereInput[]
    NOT?: TraitScalarWhereInput | TraitScalarWhereInput[]
    id?: IntFilter<"Trait"> | number
    name?: StringFilter<"Trait"> | string
    description?: StringFilter<"Trait"> | string
    attack?: StringNullableFilter<"Trait"> | string | null
    is_template?: BoolNullableFilter<"Trait"> | boolean | null
  }

  export type AlignmentUpsertWithoutCreaturesInput = {
    update: XOR<AlignmentUpdateWithoutCreaturesInput, AlignmentUncheckedUpdateWithoutCreaturesInput>
    create: XOR<AlignmentCreateWithoutCreaturesInput, AlignmentUncheckedCreateWithoutCreaturesInput>
    where?: AlignmentWhereInput
  }

  export type AlignmentUpdateToOneWithWhereWithoutCreaturesInput = {
    where?: AlignmentWhereInput
    data: XOR<AlignmentUpdateWithoutCreaturesInput, AlignmentUncheckedUpdateWithoutCreaturesInput>
  }

  export type AlignmentUpdateWithoutCreaturesInput = {
    name?: StringFieldUpdateOperationsInput | string
  }

  export type AlignmentUncheckedUpdateWithoutCreaturesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type CreatureRaceUpsertWithoutCreaturesInput = {
    update: XOR<CreatureRaceUpdateWithoutCreaturesInput, CreatureRaceUncheckedUpdateWithoutCreaturesInput>
    create: XOR<CreatureRaceCreateWithoutCreaturesInput, CreatureRaceUncheckedCreateWithoutCreaturesInput>
    where?: CreatureRaceWhereInput
  }

  export type CreatureRaceUpdateToOneWithWhereWithoutCreaturesInput = {
    where?: CreatureRaceWhereInput
    data: XOR<CreatureRaceUpdateWithoutCreaturesInput, CreatureRaceUncheckedUpdateWithoutCreaturesInput>
  }

  export type CreatureRaceUpdateWithoutCreaturesInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    traits?: TraitUpdateManyWithoutCreatureTypesNestedInput
    actions?: ActionUpdateManyWithoutCreatureTypesNestedInput
  }

  export type CreatureRaceUncheckedUpdateWithoutCreaturesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    traits?: TraitUncheckedUpdateManyWithoutCreatureTypesNestedInput
    actions?: ActionUncheckedUpdateManyWithoutCreatureTypesNestedInput
  }

  export type TypeUpsertWithoutCreaturesInput = {
    update: XOR<TypeUpdateWithoutCreaturesInput, TypeUncheckedUpdateWithoutCreaturesInput>
    create: XOR<TypeCreateWithoutCreaturesInput, TypeUncheckedCreateWithoutCreaturesInput>
    where?: TypeWhereInput
  }

  export type TypeUpdateToOneWithWhereWithoutCreaturesInput = {
    where?: TypeWhereInput
    data: XOR<TypeUpdateWithoutCreaturesInput, TypeUncheckedUpdateWithoutCreaturesInput>
  }

  export type TypeUpdateWithoutCreaturesInput = {
    name?: StringFieldUpdateOperationsInput | string
  }

  export type TypeUncheckedUpdateWithoutCreaturesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type SizeUpsertWithoutCreatureInput = {
    update: XOR<SizeUpdateWithoutCreatureInput, SizeUncheckedUpdateWithoutCreatureInput>
    create: XOR<SizeCreateWithoutCreatureInput, SizeUncheckedCreateWithoutCreatureInput>
    where?: SizeWhereInput
  }

  export type SizeUpdateToOneWithWhereWithoutCreatureInput = {
    where?: SizeWhereInput
    data: XOR<SizeUpdateWithoutCreatureInput, SizeUncheckedUpdateWithoutCreatureInput>
  }

  export type SizeUpdateWithoutCreatureInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type SizeUncheckedUpdateWithoutCreatureInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type BiomeUpsertWithWhereUniqueWithoutCreaturesInput = {
    where: BiomeWhereUniqueInput
    update: XOR<BiomeUpdateWithoutCreaturesInput, BiomeUncheckedUpdateWithoutCreaturesInput>
    create: XOR<BiomeCreateWithoutCreaturesInput, BiomeUncheckedCreateWithoutCreaturesInput>
  }

  export type BiomeUpdateWithWhereUniqueWithoutCreaturesInput = {
    where: BiomeWhereUniqueInput
    data: XOR<BiomeUpdateWithoutCreaturesInput, BiomeUncheckedUpdateWithoutCreaturesInput>
  }

  export type BiomeUpdateManyWithWhereWithoutCreaturesInput = {
    where: BiomeScalarWhereInput
    data: XOR<BiomeUpdateManyMutationInput, BiomeUncheckedUpdateManyWithoutCreaturesInput>
  }

  export type BiomeScalarWhereInput = {
    AND?: BiomeScalarWhereInput | BiomeScalarWhereInput[]
    OR?: BiomeScalarWhereInput[]
    NOT?: BiomeScalarWhereInput | BiomeScalarWhereInput[]
    id?: IntFilter<"Biome"> | number
    key?: StringFilter<"Biome"> | string
    name?: StringFilter<"Biome"> | string
  }

  export type SourceUpsertWithoutCreaturesInput = {
    update: XOR<SourceUpdateWithoutCreaturesInput, SourceUncheckedUpdateWithoutCreaturesInput>
    create: XOR<SourceCreateWithoutCreaturesInput, SourceUncheckedCreateWithoutCreaturesInput>
    where?: SourceWhereInput
  }

  export type SourceUpdateToOneWithWhereWithoutCreaturesInput = {
    where?: SourceWhereInput
    data: XOR<SourceUpdateWithoutCreaturesInput, SourceUncheckedUpdateWithoutCreaturesInput>
  }

  export type SourceUpdateWithoutCreaturesInput = {
    shortName?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type SourceUncheckedUpdateWithoutCreaturesInput = {
    id?: IntFieldUpdateOperationsInput | number
    shortName?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type CreatureCreateWithoutSensesInput = {
    id?: string
    name: string
    creator_id?: string | null
    image_uri?: string | null
    description?: string | null
    armor_class?: number | null
    hit_points?: number | null
    challenge_rating: string
    biomes_ids?: CreatureCreatebiomes_idsInput | number[]
    aSubTypes?: CreatureCreateaSubTypesInput | string[]
    speed?: Speed_statCreateNestedOneWithoutId_relationInput
    stats?: Creature_statsCreateNestedOneWithoutId_relationInput
    skills?: SkillsListCreateNestedOneWithoutId_relationInput
    resistances?: DamageTypeCreateNestedManyWithoutResistant_creaturesInput
    immunities?: DamageTypeCreateNestedManyWithoutImmune_creaturesInput
    vulnerabilities?: DamageTypeCreateNestedManyWithoutVunlerable_creaturesInput
    languages?: LanguageCreateNestedManyWithoutCreaturesInput
    actions?: ActionCreateNestedManyWithoutCreaturesInput
    traits?: TraitCreateNestedManyWithoutCreturesInput
    alignment_relation?: AlignmentCreateNestedOneWithoutCreaturesInput
    race_relation?: CreatureRaceCreateNestedOneWithoutCreaturesInput
    type_relation?: TypeCreateNestedOneWithoutCreaturesInput
    size_relation?: SizeCreateNestedOneWithoutCreatureInput
    biome_relation?: BiomeCreateNestedManyWithoutCreaturesInput
    source_relation?: SourceCreateNestedOneWithoutCreaturesInput
  }

  export type CreatureUncheckedCreateWithoutSensesInput = {
    id?: string
    name: string
    creator_id?: string | null
    image_uri?: string | null
    description?: string | null
    size?: string | null
    race_id?: number | null
    source_id?: number | null
    alignment_id?: number | null
    armor_class?: number | null
    hit_points?: number | null
    challenge_rating: string
    biomes_ids?: CreatureCreatebiomes_idsInput | number[]
    type_id?: number | null
    aSubTypes?: CreatureCreateaSubTypesInput | string[]
    speed?: Speed_statUncheckedCreateNestedOneWithoutId_relationInput
    stats?: Creature_statsUncheckedCreateNestedOneWithoutId_relationInput
    skills?: SkillsListUncheckedCreateNestedOneWithoutId_relationInput
    resistances?: DamageTypeUncheckedCreateNestedManyWithoutResistant_creaturesInput
    immunities?: DamageTypeUncheckedCreateNestedManyWithoutImmune_creaturesInput
    vulnerabilities?: DamageTypeUncheckedCreateNestedManyWithoutVunlerable_creaturesInput
    languages?: LanguageUncheckedCreateNestedManyWithoutCreaturesInput
    actions?: ActionUncheckedCreateNestedManyWithoutCreaturesInput
    traits?: TraitUncheckedCreateNestedManyWithoutCreturesInput
    biome_relation?: BiomeUncheckedCreateNestedManyWithoutCreaturesInput
  }

  export type CreatureCreateOrConnectWithoutSensesInput = {
    where: CreatureWhereUniqueInput
    create: XOR<CreatureCreateWithoutSensesInput, CreatureUncheckedCreateWithoutSensesInput>
  }

  export type CreatureUpsertWithoutSensesInput = {
    update: XOR<CreatureUpdateWithoutSensesInput, CreatureUncheckedUpdateWithoutSensesInput>
    create: XOR<CreatureCreateWithoutSensesInput, CreatureUncheckedCreateWithoutSensesInput>
    where?: CreatureWhereInput
  }

  export type CreatureUpdateToOneWithWhereWithoutSensesInput = {
    where?: CreatureWhereInput
    data: XOR<CreatureUpdateWithoutSensesInput, CreatureUncheckedUpdateWithoutSensesInput>
  }

  export type CreatureUpdateWithoutSensesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    creator_id?: NullableStringFieldUpdateOperationsInput | string | null
    image_uri?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    armor_class?: NullableIntFieldUpdateOperationsInput | number | null
    hit_points?: NullableIntFieldUpdateOperationsInput | number | null
    challenge_rating?: StringFieldUpdateOperationsInput | string
    biomes_ids?: CreatureUpdatebiomes_idsInput | number[]
    aSubTypes?: CreatureUpdateaSubTypesInput | string[]
    speed?: Speed_statUpdateOneWithoutId_relationNestedInput
    stats?: Creature_statsUpdateOneWithoutId_relationNestedInput
    skills?: SkillsListUpdateOneWithoutId_relationNestedInput
    resistances?: DamageTypeUpdateManyWithoutResistant_creaturesNestedInput
    immunities?: DamageTypeUpdateManyWithoutImmune_creaturesNestedInput
    vulnerabilities?: DamageTypeUpdateManyWithoutVunlerable_creaturesNestedInput
    languages?: LanguageUpdateManyWithoutCreaturesNestedInput
    actions?: ActionUpdateManyWithoutCreaturesNestedInput
    traits?: TraitUpdateManyWithoutCreturesNestedInput
    alignment_relation?: AlignmentUpdateOneWithoutCreaturesNestedInput
    race_relation?: CreatureRaceUpdateOneWithoutCreaturesNestedInput
    type_relation?: TypeUpdateOneWithoutCreaturesNestedInput
    size_relation?: SizeUpdateOneWithoutCreatureNestedInput
    biome_relation?: BiomeUpdateManyWithoutCreaturesNestedInput
    source_relation?: SourceUpdateOneWithoutCreaturesNestedInput
  }

  export type CreatureUncheckedUpdateWithoutSensesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    creator_id?: NullableStringFieldUpdateOperationsInput | string | null
    image_uri?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableStringFieldUpdateOperationsInput | string | null
    race_id?: NullableIntFieldUpdateOperationsInput | number | null
    source_id?: NullableIntFieldUpdateOperationsInput | number | null
    alignment_id?: NullableIntFieldUpdateOperationsInput | number | null
    armor_class?: NullableIntFieldUpdateOperationsInput | number | null
    hit_points?: NullableIntFieldUpdateOperationsInput | number | null
    challenge_rating?: StringFieldUpdateOperationsInput | string
    biomes_ids?: CreatureUpdatebiomes_idsInput | number[]
    type_id?: NullableIntFieldUpdateOperationsInput | number | null
    aSubTypes?: CreatureUpdateaSubTypesInput | string[]
    speed?: Speed_statUncheckedUpdateOneWithoutId_relationNestedInput
    stats?: Creature_statsUncheckedUpdateOneWithoutId_relationNestedInput
    skills?: SkillsListUncheckedUpdateOneWithoutId_relationNestedInput
    resistances?: DamageTypeUncheckedUpdateManyWithoutResistant_creaturesNestedInput
    immunities?: DamageTypeUncheckedUpdateManyWithoutImmune_creaturesNestedInput
    vulnerabilities?: DamageTypeUncheckedUpdateManyWithoutVunlerable_creaturesNestedInput
    languages?: LanguageUncheckedUpdateManyWithoutCreaturesNestedInput
    actions?: ActionUncheckedUpdateManyWithoutCreaturesNestedInput
    traits?: TraitUncheckedUpdateManyWithoutCreturesNestedInput
    biome_relation?: BiomeUncheckedUpdateManyWithoutCreaturesNestedInput
  }

  export type CreatureCreateWithoutActionsInput = {
    id?: string
    name: string
    creator_id?: string | null
    image_uri?: string | null
    description?: string | null
    armor_class?: number | null
    hit_points?: number | null
    challenge_rating: string
    biomes_ids?: CreatureCreatebiomes_idsInput | number[]
    aSubTypes?: CreatureCreateaSubTypesInput | string[]
    speed?: Speed_statCreateNestedOneWithoutId_relationInput
    stats?: Creature_statsCreateNestedOneWithoutId_relationInput
    skills?: SkillsListCreateNestedOneWithoutId_relationInput
    resistances?: DamageTypeCreateNestedManyWithoutResistant_creaturesInput
    immunities?: DamageTypeCreateNestedManyWithoutImmune_creaturesInput
    vulnerabilities?: DamageTypeCreateNestedManyWithoutVunlerable_creaturesInput
    senses?: SensesCreateNestedOneWithoutCreatureInput
    languages?: LanguageCreateNestedManyWithoutCreaturesInput
    traits?: TraitCreateNestedManyWithoutCreturesInput
    alignment_relation?: AlignmentCreateNestedOneWithoutCreaturesInput
    race_relation?: CreatureRaceCreateNestedOneWithoutCreaturesInput
    type_relation?: TypeCreateNestedOneWithoutCreaturesInput
    size_relation?: SizeCreateNestedOneWithoutCreatureInput
    biome_relation?: BiomeCreateNestedManyWithoutCreaturesInput
    source_relation?: SourceCreateNestedOneWithoutCreaturesInput
  }

  export type CreatureUncheckedCreateWithoutActionsInput = {
    id?: string
    name: string
    creator_id?: string | null
    image_uri?: string | null
    description?: string | null
    size?: string | null
    race_id?: number | null
    source_id?: number | null
    alignment_id?: number | null
    armor_class?: number | null
    hit_points?: number | null
    challenge_rating: string
    biomes_ids?: CreatureCreatebiomes_idsInput | number[]
    type_id?: number | null
    aSubTypes?: CreatureCreateaSubTypesInput | string[]
    speed?: Speed_statUncheckedCreateNestedOneWithoutId_relationInput
    stats?: Creature_statsUncheckedCreateNestedOneWithoutId_relationInput
    skills?: SkillsListUncheckedCreateNestedOneWithoutId_relationInput
    resistances?: DamageTypeUncheckedCreateNestedManyWithoutResistant_creaturesInput
    immunities?: DamageTypeUncheckedCreateNestedManyWithoutImmune_creaturesInput
    vulnerabilities?: DamageTypeUncheckedCreateNestedManyWithoutVunlerable_creaturesInput
    senses?: SensesUncheckedCreateNestedOneWithoutCreatureInput
    languages?: LanguageUncheckedCreateNestedManyWithoutCreaturesInput
    traits?: TraitUncheckedCreateNestedManyWithoutCreturesInput
    biome_relation?: BiomeUncheckedCreateNestedManyWithoutCreaturesInput
  }

  export type CreatureCreateOrConnectWithoutActionsInput = {
    where: CreatureWhereUniqueInput
    create: XOR<CreatureCreateWithoutActionsInput, CreatureUncheckedCreateWithoutActionsInput>
  }

  export type CreatureRaceCreateWithoutActionsInput = {
    name: string
    description: string
    traits?: TraitCreateNestedManyWithoutCreatureTypesInput
    creatures?: CreatureCreateNestedManyWithoutRace_relationInput
  }

  export type CreatureRaceUncheckedCreateWithoutActionsInput = {
    id?: number
    name: string
    description: string
    traits?: TraitUncheckedCreateNestedManyWithoutCreatureTypesInput
    creatures?: CreatureUncheckedCreateNestedManyWithoutRace_relationInput
  }

  export type CreatureRaceCreateOrConnectWithoutActionsInput = {
    where: CreatureRaceWhereUniqueInput
    create: XOR<CreatureRaceCreateWithoutActionsInput, CreatureRaceUncheckedCreateWithoutActionsInput>
  }

  export type CreatureUpsertWithWhereUniqueWithoutActionsInput = {
    where: CreatureWhereUniqueInput
    update: XOR<CreatureUpdateWithoutActionsInput, CreatureUncheckedUpdateWithoutActionsInput>
    create: XOR<CreatureCreateWithoutActionsInput, CreatureUncheckedCreateWithoutActionsInput>
  }

  export type CreatureUpdateWithWhereUniqueWithoutActionsInput = {
    where: CreatureWhereUniqueInput
    data: XOR<CreatureUpdateWithoutActionsInput, CreatureUncheckedUpdateWithoutActionsInput>
  }

  export type CreatureUpdateManyWithWhereWithoutActionsInput = {
    where: CreatureScalarWhereInput
    data: XOR<CreatureUpdateManyMutationInput, CreatureUncheckedUpdateManyWithoutActionsInput>
  }

  export type CreatureRaceUpsertWithWhereUniqueWithoutActionsInput = {
    where: CreatureRaceWhereUniqueInput
    update: XOR<CreatureRaceUpdateWithoutActionsInput, CreatureRaceUncheckedUpdateWithoutActionsInput>
    create: XOR<CreatureRaceCreateWithoutActionsInput, CreatureRaceUncheckedCreateWithoutActionsInput>
  }

  export type CreatureRaceUpdateWithWhereUniqueWithoutActionsInput = {
    where: CreatureRaceWhereUniqueInput
    data: XOR<CreatureRaceUpdateWithoutActionsInput, CreatureRaceUncheckedUpdateWithoutActionsInput>
  }

  export type CreatureRaceUpdateManyWithWhereWithoutActionsInput = {
    where: CreatureRaceScalarWhereInput
    data: XOR<CreatureRaceUpdateManyMutationInput, CreatureRaceUncheckedUpdateManyWithoutActionsInput>
  }

  export type CreatureRaceScalarWhereInput = {
    AND?: CreatureRaceScalarWhereInput | CreatureRaceScalarWhereInput[]
    OR?: CreatureRaceScalarWhereInput[]
    NOT?: CreatureRaceScalarWhereInput | CreatureRaceScalarWhereInput[]
    id?: IntFilter<"CreatureRace"> | number
    name?: StringFilter<"CreatureRace"> | string
    description?: StringFilter<"CreatureRace"> | string
  }

  export type CreatureCreateWithoutTraitsInput = {
    id?: string
    name: string
    creator_id?: string | null
    image_uri?: string | null
    description?: string | null
    armor_class?: number | null
    hit_points?: number | null
    challenge_rating: string
    biomes_ids?: CreatureCreatebiomes_idsInput | number[]
    aSubTypes?: CreatureCreateaSubTypesInput | string[]
    speed?: Speed_statCreateNestedOneWithoutId_relationInput
    stats?: Creature_statsCreateNestedOneWithoutId_relationInput
    skills?: SkillsListCreateNestedOneWithoutId_relationInput
    resistances?: DamageTypeCreateNestedManyWithoutResistant_creaturesInput
    immunities?: DamageTypeCreateNestedManyWithoutImmune_creaturesInput
    vulnerabilities?: DamageTypeCreateNestedManyWithoutVunlerable_creaturesInput
    senses?: SensesCreateNestedOneWithoutCreatureInput
    languages?: LanguageCreateNestedManyWithoutCreaturesInput
    actions?: ActionCreateNestedManyWithoutCreaturesInput
    alignment_relation?: AlignmentCreateNestedOneWithoutCreaturesInput
    race_relation?: CreatureRaceCreateNestedOneWithoutCreaturesInput
    type_relation?: TypeCreateNestedOneWithoutCreaturesInput
    size_relation?: SizeCreateNestedOneWithoutCreatureInput
    biome_relation?: BiomeCreateNestedManyWithoutCreaturesInput
    source_relation?: SourceCreateNestedOneWithoutCreaturesInput
  }

  export type CreatureUncheckedCreateWithoutTraitsInput = {
    id?: string
    name: string
    creator_id?: string | null
    image_uri?: string | null
    description?: string | null
    size?: string | null
    race_id?: number | null
    source_id?: number | null
    alignment_id?: number | null
    armor_class?: number | null
    hit_points?: number | null
    challenge_rating: string
    biomes_ids?: CreatureCreatebiomes_idsInput | number[]
    type_id?: number | null
    aSubTypes?: CreatureCreateaSubTypesInput | string[]
    speed?: Speed_statUncheckedCreateNestedOneWithoutId_relationInput
    stats?: Creature_statsUncheckedCreateNestedOneWithoutId_relationInput
    skills?: SkillsListUncheckedCreateNestedOneWithoutId_relationInput
    resistances?: DamageTypeUncheckedCreateNestedManyWithoutResistant_creaturesInput
    immunities?: DamageTypeUncheckedCreateNestedManyWithoutImmune_creaturesInput
    vulnerabilities?: DamageTypeUncheckedCreateNestedManyWithoutVunlerable_creaturesInput
    senses?: SensesUncheckedCreateNestedOneWithoutCreatureInput
    languages?: LanguageUncheckedCreateNestedManyWithoutCreaturesInput
    actions?: ActionUncheckedCreateNestedManyWithoutCreaturesInput
    biome_relation?: BiomeUncheckedCreateNestedManyWithoutCreaturesInput
  }

  export type CreatureCreateOrConnectWithoutTraitsInput = {
    where: CreatureWhereUniqueInput
    create: XOR<CreatureCreateWithoutTraitsInput, CreatureUncheckedCreateWithoutTraitsInput>
  }

  export type CreatureRaceCreateWithoutTraitsInput = {
    name: string
    description: string
    actions?: ActionCreateNestedManyWithoutCreatureTypesInput
    creatures?: CreatureCreateNestedManyWithoutRace_relationInput
  }

  export type CreatureRaceUncheckedCreateWithoutTraitsInput = {
    id?: number
    name: string
    description: string
    actions?: ActionUncheckedCreateNestedManyWithoutCreatureTypesInput
    creatures?: CreatureUncheckedCreateNestedManyWithoutRace_relationInput
  }

  export type CreatureRaceCreateOrConnectWithoutTraitsInput = {
    where: CreatureRaceWhereUniqueInput
    create: XOR<CreatureRaceCreateWithoutTraitsInput, CreatureRaceUncheckedCreateWithoutTraitsInput>
  }

  export type CreatureUpsertWithWhereUniqueWithoutTraitsInput = {
    where: CreatureWhereUniqueInput
    update: XOR<CreatureUpdateWithoutTraitsInput, CreatureUncheckedUpdateWithoutTraitsInput>
    create: XOR<CreatureCreateWithoutTraitsInput, CreatureUncheckedCreateWithoutTraitsInput>
  }

  export type CreatureUpdateWithWhereUniqueWithoutTraitsInput = {
    where: CreatureWhereUniqueInput
    data: XOR<CreatureUpdateWithoutTraitsInput, CreatureUncheckedUpdateWithoutTraitsInput>
  }

  export type CreatureUpdateManyWithWhereWithoutTraitsInput = {
    where: CreatureScalarWhereInput
    data: XOR<CreatureUpdateManyMutationInput, CreatureUncheckedUpdateManyWithoutTraitsInput>
  }

  export type CreatureRaceUpsertWithWhereUniqueWithoutTraitsInput = {
    where: CreatureRaceWhereUniqueInput
    update: XOR<CreatureRaceUpdateWithoutTraitsInput, CreatureRaceUncheckedUpdateWithoutTraitsInput>
    create: XOR<CreatureRaceCreateWithoutTraitsInput, CreatureRaceUncheckedCreateWithoutTraitsInput>
  }

  export type CreatureRaceUpdateWithWhereUniqueWithoutTraitsInput = {
    where: CreatureRaceWhereUniqueInput
    data: XOR<CreatureRaceUpdateWithoutTraitsInput, CreatureRaceUncheckedUpdateWithoutTraitsInput>
  }

  export type CreatureRaceUpdateManyWithWhereWithoutTraitsInput = {
    where: CreatureRaceScalarWhereInput
    data: XOR<CreatureRaceUpdateManyMutationInput, CreatureRaceUncheckedUpdateManyWithoutTraitsInput>
  }

  export type TraitCreateWithoutCreatureTypesInput = {
    name: string
    description: string
    attack?: string | null
    is_template?: boolean | null
    cretures?: CreatureCreateNestedManyWithoutTraitsInput
  }

  export type TraitUncheckedCreateWithoutCreatureTypesInput = {
    id?: number
    name: string
    description: string
    attack?: string | null
    is_template?: boolean | null
    cretures?: CreatureUncheckedCreateNestedManyWithoutTraitsInput
  }

  export type TraitCreateOrConnectWithoutCreatureTypesInput = {
    where: TraitWhereUniqueInput
    create: XOR<TraitCreateWithoutCreatureTypesInput, TraitUncheckedCreateWithoutCreatureTypesInput>
  }

  export type ActionCreateWithoutCreatureTypesInput = {
    name: string
    description: string
    attack?: string | null
    is_template?: boolean | null
    creatures?: CreatureCreateNestedManyWithoutActionsInput
  }

  export type ActionUncheckedCreateWithoutCreatureTypesInput = {
    id?: number
    name: string
    description: string
    attack?: string | null
    is_template?: boolean | null
    creatures?: CreatureUncheckedCreateNestedManyWithoutActionsInput
  }

  export type ActionCreateOrConnectWithoutCreatureTypesInput = {
    where: ActionWhereUniqueInput
    create: XOR<ActionCreateWithoutCreatureTypesInput, ActionUncheckedCreateWithoutCreatureTypesInput>
  }

  export type CreatureCreateWithoutRace_relationInput = {
    id?: string
    name: string
    creator_id?: string | null
    image_uri?: string | null
    description?: string | null
    armor_class?: number | null
    hit_points?: number | null
    challenge_rating: string
    biomes_ids?: CreatureCreatebiomes_idsInput | number[]
    aSubTypes?: CreatureCreateaSubTypesInput | string[]
    speed?: Speed_statCreateNestedOneWithoutId_relationInput
    stats?: Creature_statsCreateNestedOneWithoutId_relationInput
    skills?: SkillsListCreateNestedOneWithoutId_relationInput
    resistances?: DamageTypeCreateNestedManyWithoutResistant_creaturesInput
    immunities?: DamageTypeCreateNestedManyWithoutImmune_creaturesInput
    vulnerabilities?: DamageTypeCreateNestedManyWithoutVunlerable_creaturesInput
    senses?: SensesCreateNestedOneWithoutCreatureInput
    languages?: LanguageCreateNestedManyWithoutCreaturesInput
    actions?: ActionCreateNestedManyWithoutCreaturesInput
    traits?: TraitCreateNestedManyWithoutCreturesInput
    alignment_relation?: AlignmentCreateNestedOneWithoutCreaturesInput
    type_relation?: TypeCreateNestedOneWithoutCreaturesInput
    size_relation?: SizeCreateNestedOneWithoutCreatureInput
    biome_relation?: BiomeCreateNestedManyWithoutCreaturesInput
    source_relation?: SourceCreateNestedOneWithoutCreaturesInput
  }

  export type CreatureUncheckedCreateWithoutRace_relationInput = {
    id?: string
    name: string
    creator_id?: string | null
    image_uri?: string | null
    description?: string | null
    size?: string | null
    source_id?: number | null
    alignment_id?: number | null
    armor_class?: number | null
    hit_points?: number | null
    challenge_rating: string
    biomes_ids?: CreatureCreatebiomes_idsInput | number[]
    type_id?: number | null
    aSubTypes?: CreatureCreateaSubTypesInput | string[]
    speed?: Speed_statUncheckedCreateNestedOneWithoutId_relationInput
    stats?: Creature_statsUncheckedCreateNestedOneWithoutId_relationInput
    skills?: SkillsListUncheckedCreateNestedOneWithoutId_relationInput
    resistances?: DamageTypeUncheckedCreateNestedManyWithoutResistant_creaturesInput
    immunities?: DamageTypeUncheckedCreateNestedManyWithoutImmune_creaturesInput
    vulnerabilities?: DamageTypeUncheckedCreateNestedManyWithoutVunlerable_creaturesInput
    senses?: SensesUncheckedCreateNestedOneWithoutCreatureInput
    languages?: LanguageUncheckedCreateNestedManyWithoutCreaturesInput
    actions?: ActionUncheckedCreateNestedManyWithoutCreaturesInput
    traits?: TraitUncheckedCreateNestedManyWithoutCreturesInput
    biome_relation?: BiomeUncheckedCreateNestedManyWithoutCreaturesInput
  }

  export type CreatureCreateOrConnectWithoutRace_relationInput = {
    where: CreatureWhereUniqueInput
    create: XOR<CreatureCreateWithoutRace_relationInput, CreatureUncheckedCreateWithoutRace_relationInput>
  }

  export type CreatureCreateManyRace_relationInputEnvelope = {
    data: CreatureCreateManyRace_relationInput | CreatureCreateManyRace_relationInput[]
    skipDuplicates?: boolean
  }

  export type TraitUpsertWithWhereUniqueWithoutCreatureTypesInput = {
    where: TraitWhereUniqueInput
    update: XOR<TraitUpdateWithoutCreatureTypesInput, TraitUncheckedUpdateWithoutCreatureTypesInput>
    create: XOR<TraitCreateWithoutCreatureTypesInput, TraitUncheckedCreateWithoutCreatureTypesInput>
  }

  export type TraitUpdateWithWhereUniqueWithoutCreatureTypesInput = {
    where: TraitWhereUniqueInput
    data: XOR<TraitUpdateWithoutCreatureTypesInput, TraitUncheckedUpdateWithoutCreatureTypesInput>
  }

  export type TraitUpdateManyWithWhereWithoutCreatureTypesInput = {
    where: TraitScalarWhereInput
    data: XOR<TraitUpdateManyMutationInput, TraitUncheckedUpdateManyWithoutCreatureTypesInput>
  }

  export type ActionUpsertWithWhereUniqueWithoutCreatureTypesInput = {
    where: ActionWhereUniqueInput
    update: XOR<ActionUpdateWithoutCreatureTypesInput, ActionUncheckedUpdateWithoutCreatureTypesInput>
    create: XOR<ActionCreateWithoutCreatureTypesInput, ActionUncheckedCreateWithoutCreatureTypesInput>
  }

  export type ActionUpdateWithWhereUniqueWithoutCreatureTypesInput = {
    where: ActionWhereUniqueInput
    data: XOR<ActionUpdateWithoutCreatureTypesInput, ActionUncheckedUpdateWithoutCreatureTypesInput>
  }

  export type ActionUpdateManyWithWhereWithoutCreatureTypesInput = {
    where: ActionScalarWhereInput
    data: XOR<ActionUpdateManyMutationInput, ActionUncheckedUpdateManyWithoutCreatureTypesInput>
  }

  export type CreatureUpsertWithWhereUniqueWithoutRace_relationInput = {
    where: CreatureWhereUniqueInput
    update: XOR<CreatureUpdateWithoutRace_relationInput, CreatureUncheckedUpdateWithoutRace_relationInput>
    create: XOR<CreatureCreateWithoutRace_relationInput, CreatureUncheckedCreateWithoutRace_relationInput>
  }

  export type CreatureUpdateWithWhereUniqueWithoutRace_relationInput = {
    where: CreatureWhereUniqueInput
    data: XOR<CreatureUpdateWithoutRace_relationInput, CreatureUncheckedUpdateWithoutRace_relationInput>
  }

  export type CreatureUpdateManyWithWhereWithoutRace_relationInput = {
    where: CreatureScalarWhereInput
    data: XOR<CreatureUpdateManyMutationInput, CreatureUncheckedUpdateManyWithoutRace_relationInput>
  }

  export type CreatureCreateWithoutResistancesInput = {
    id?: string
    name: string
    creator_id?: string | null
    image_uri?: string | null
    description?: string | null
    armor_class?: number | null
    hit_points?: number | null
    challenge_rating: string
    biomes_ids?: CreatureCreatebiomes_idsInput | number[]
    aSubTypes?: CreatureCreateaSubTypesInput | string[]
    speed?: Speed_statCreateNestedOneWithoutId_relationInput
    stats?: Creature_statsCreateNestedOneWithoutId_relationInput
    skills?: SkillsListCreateNestedOneWithoutId_relationInput
    immunities?: DamageTypeCreateNestedManyWithoutImmune_creaturesInput
    vulnerabilities?: DamageTypeCreateNestedManyWithoutVunlerable_creaturesInput
    senses?: SensesCreateNestedOneWithoutCreatureInput
    languages?: LanguageCreateNestedManyWithoutCreaturesInput
    actions?: ActionCreateNestedManyWithoutCreaturesInput
    traits?: TraitCreateNestedManyWithoutCreturesInput
    alignment_relation?: AlignmentCreateNestedOneWithoutCreaturesInput
    race_relation?: CreatureRaceCreateNestedOneWithoutCreaturesInput
    type_relation?: TypeCreateNestedOneWithoutCreaturesInput
    size_relation?: SizeCreateNestedOneWithoutCreatureInput
    biome_relation?: BiomeCreateNestedManyWithoutCreaturesInput
    source_relation?: SourceCreateNestedOneWithoutCreaturesInput
  }

  export type CreatureUncheckedCreateWithoutResistancesInput = {
    id?: string
    name: string
    creator_id?: string | null
    image_uri?: string | null
    description?: string | null
    size?: string | null
    race_id?: number | null
    source_id?: number | null
    alignment_id?: number | null
    armor_class?: number | null
    hit_points?: number | null
    challenge_rating: string
    biomes_ids?: CreatureCreatebiomes_idsInput | number[]
    type_id?: number | null
    aSubTypes?: CreatureCreateaSubTypesInput | string[]
    speed?: Speed_statUncheckedCreateNestedOneWithoutId_relationInput
    stats?: Creature_statsUncheckedCreateNestedOneWithoutId_relationInput
    skills?: SkillsListUncheckedCreateNestedOneWithoutId_relationInput
    immunities?: DamageTypeUncheckedCreateNestedManyWithoutImmune_creaturesInput
    vulnerabilities?: DamageTypeUncheckedCreateNestedManyWithoutVunlerable_creaturesInput
    senses?: SensesUncheckedCreateNestedOneWithoutCreatureInput
    languages?: LanguageUncheckedCreateNestedManyWithoutCreaturesInput
    actions?: ActionUncheckedCreateNestedManyWithoutCreaturesInput
    traits?: TraitUncheckedCreateNestedManyWithoutCreturesInput
    biome_relation?: BiomeUncheckedCreateNestedManyWithoutCreaturesInput
  }

  export type CreatureCreateOrConnectWithoutResistancesInput = {
    where: CreatureWhereUniqueInput
    create: XOR<CreatureCreateWithoutResistancesInput, CreatureUncheckedCreateWithoutResistancesInput>
  }

  export type CreatureCreateWithoutImmunitiesInput = {
    id?: string
    name: string
    creator_id?: string | null
    image_uri?: string | null
    description?: string | null
    armor_class?: number | null
    hit_points?: number | null
    challenge_rating: string
    biomes_ids?: CreatureCreatebiomes_idsInput | number[]
    aSubTypes?: CreatureCreateaSubTypesInput | string[]
    speed?: Speed_statCreateNestedOneWithoutId_relationInput
    stats?: Creature_statsCreateNestedOneWithoutId_relationInput
    skills?: SkillsListCreateNestedOneWithoutId_relationInput
    resistances?: DamageTypeCreateNestedManyWithoutResistant_creaturesInput
    vulnerabilities?: DamageTypeCreateNestedManyWithoutVunlerable_creaturesInput
    senses?: SensesCreateNestedOneWithoutCreatureInput
    languages?: LanguageCreateNestedManyWithoutCreaturesInput
    actions?: ActionCreateNestedManyWithoutCreaturesInput
    traits?: TraitCreateNestedManyWithoutCreturesInput
    alignment_relation?: AlignmentCreateNestedOneWithoutCreaturesInput
    race_relation?: CreatureRaceCreateNestedOneWithoutCreaturesInput
    type_relation?: TypeCreateNestedOneWithoutCreaturesInput
    size_relation?: SizeCreateNestedOneWithoutCreatureInput
    biome_relation?: BiomeCreateNestedManyWithoutCreaturesInput
    source_relation?: SourceCreateNestedOneWithoutCreaturesInput
  }

  export type CreatureUncheckedCreateWithoutImmunitiesInput = {
    id?: string
    name: string
    creator_id?: string | null
    image_uri?: string | null
    description?: string | null
    size?: string | null
    race_id?: number | null
    source_id?: number | null
    alignment_id?: number | null
    armor_class?: number | null
    hit_points?: number | null
    challenge_rating: string
    biomes_ids?: CreatureCreatebiomes_idsInput | number[]
    type_id?: number | null
    aSubTypes?: CreatureCreateaSubTypesInput | string[]
    speed?: Speed_statUncheckedCreateNestedOneWithoutId_relationInput
    stats?: Creature_statsUncheckedCreateNestedOneWithoutId_relationInput
    skills?: SkillsListUncheckedCreateNestedOneWithoutId_relationInput
    resistances?: DamageTypeUncheckedCreateNestedManyWithoutResistant_creaturesInput
    vulnerabilities?: DamageTypeUncheckedCreateNestedManyWithoutVunlerable_creaturesInput
    senses?: SensesUncheckedCreateNestedOneWithoutCreatureInput
    languages?: LanguageUncheckedCreateNestedManyWithoutCreaturesInput
    actions?: ActionUncheckedCreateNestedManyWithoutCreaturesInput
    traits?: TraitUncheckedCreateNestedManyWithoutCreturesInput
    biome_relation?: BiomeUncheckedCreateNestedManyWithoutCreaturesInput
  }

  export type CreatureCreateOrConnectWithoutImmunitiesInput = {
    where: CreatureWhereUniqueInput
    create: XOR<CreatureCreateWithoutImmunitiesInput, CreatureUncheckedCreateWithoutImmunitiesInput>
  }

  export type CreatureCreateWithoutVulnerabilitiesInput = {
    id?: string
    name: string
    creator_id?: string | null
    image_uri?: string | null
    description?: string | null
    armor_class?: number | null
    hit_points?: number | null
    challenge_rating: string
    biomes_ids?: CreatureCreatebiomes_idsInput | number[]
    aSubTypes?: CreatureCreateaSubTypesInput | string[]
    speed?: Speed_statCreateNestedOneWithoutId_relationInput
    stats?: Creature_statsCreateNestedOneWithoutId_relationInput
    skills?: SkillsListCreateNestedOneWithoutId_relationInput
    resistances?: DamageTypeCreateNestedManyWithoutResistant_creaturesInput
    immunities?: DamageTypeCreateNestedManyWithoutImmune_creaturesInput
    senses?: SensesCreateNestedOneWithoutCreatureInput
    languages?: LanguageCreateNestedManyWithoutCreaturesInput
    actions?: ActionCreateNestedManyWithoutCreaturesInput
    traits?: TraitCreateNestedManyWithoutCreturesInput
    alignment_relation?: AlignmentCreateNestedOneWithoutCreaturesInput
    race_relation?: CreatureRaceCreateNestedOneWithoutCreaturesInput
    type_relation?: TypeCreateNestedOneWithoutCreaturesInput
    size_relation?: SizeCreateNestedOneWithoutCreatureInput
    biome_relation?: BiomeCreateNestedManyWithoutCreaturesInput
    source_relation?: SourceCreateNestedOneWithoutCreaturesInput
  }

  export type CreatureUncheckedCreateWithoutVulnerabilitiesInput = {
    id?: string
    name: string
    creator_id?: string | null
    image_uri?: string | null
    description?: string | null
    size?: string | null
    race_id?: number | null
    source_id?: number | null
    alignment_id?: number | null
    armor_class?: number | null
    hit_points?: number | null
    challenge_rating: string
    biomes_ids?: CreatureCreatebiomes_idsInput | number[]
    type_id?: number | null
    aSubTypes?: CreatureCreateaSubTypesInput | string[]
    speed?: Speed_statUncheckedCreateNestedOneWithoutId_relationInput
    stats?: Creature_statsUncheckedCreateNestedOneWithoutId_relationInput
    skills?: SkillsListUncheckedCreateNestedOneWithoutId_relationInput
    resistances?: DamageTypeUncheckedCreateNestedManyWithoutResistant_creaturesInput
    immunities?: DamageTypeUncheckedCreateNestedManyWithoutImmune_creaturesInput
    senses?: SensesUncheckedCreateNestedOneWithoutCreatureInput
    languages?: LanguageUncheckedCreateNestedManyWithoutCreaturesInput
    actions?: ActionUncheckedCreateNestedManyWithoutCreaturesInput
    traits?: TraitUncheckedCreateNestedManyWithoutCreturesInput
    biome_relation?: BiomeUncheckedCreateNestedManyWithoutCreaturesInput
  }

  export type CreatureCreateOrConnectWithoutVulnerabilitiesInput = {
    where: CreatureWhereUniqueInput
    create: XOR<CreatureCreateWithoutVulnerabilitiesInput, CreatureUncheckedCreateWithoutVulnerabilitiesInput>
  }

  export type CreatureUpsertWithWhereUniqueWithoutResistancesInput = {
    where: CreatureWhereUniqueInput
    update: XOR<CreatureUpdateWithoutResistancesInput, CreatureUncheckedUpdateWithoutResistancesInput>
    create: XOR<CreatureCreateWithoutResistancesInput, CreatureUncheckedCreateWithoutResistancesInput>
  }

  export type CreatureUpdateWithWhereUniqueWithoutResistancesInput = {
    where: CreatureWhereUniqueInput
    data: XOR<CreatureUpdateWithoutResistancesInput, CreatureUncheckedUpdateWithoutResistancesInput>
  }

  export type CreatureUpdateManyWithWhereWithoutResistancesInput = {
    where: CreatureScalarWhereInput
    data: XOR<CreatureUpdateManyMutationInput, CreatureUncheckedUpdateManyWithoutResistancesInput>
  }

  export type CreatureUpsertWithWhereUniqueWithoutImmunitiesInput = {
    where: CreatureWhereUniqueInput
    update: XOR<CreatureUpdateWithoutImmunitiesInput, CreatureUncheckedUpdateWithoutImmunitiesInput>
    create: XOR<CreatureCreateWithoutImmunitiesInput, CreatureUncheckedCreateWithoutImmunitiesInput>
  }

  export type CreatureUpdateWithWhereUniqueWithoutImmunitiesInput = {
    where: CreatureWhereUniqueInput
    data: XOR<CreatureUpdateWithoutImmunitiesInput, CreatureUncheckedUpdateWithoutImmunitiesInput>
  }

  export type CreatureUpdateManyWithWhereWithoutImmunitiesInput = {
    where: CreatureScalarWhereInput
    data: XOR<CreatureUpdateManyMutationInput, CreatureUncheckedUpdateManyWithoutImmunitiesInput>
  }

  export type CreatureUpsertWithWhereUniqueWithoutVulnerabilitiesInput = {
    where: CreatureWhereUniqueInput
    update: XOR<CreatureUpdateWithoutVulnerabilitiesInput, CreatureUncheckedUpdateWithoutVulnerabilitiesInput>
    create: XOR<CreatureCreateWithoutVulnerabilitiesInput, CreatureUncheckedCreateWithoutVulnerabilitiesInput>
  }

  export type CreatureUpdateWithWhereUniqueWithoutVulnerabilitiesInput = {
    where: CreatureWhereUniqueInput
    data: XOR<CreatureUpdateWithoutVulnerabilitiesInput, CreatureUncheckedUpdateWithoutVulnerabilitiesInput>
  }

  export type CreatureUpdateManyWithWhereWithoutVulnerabilitiesInput = {
    where: CreatureScalarWhereInput
    data: XOR<CreatureUpdateManyMutationInput, CreatureUncheckedUpdateManyWithoutVulnerabilitiesInput>
  }

  export type GPTMessageCreateWithoutMessage_historyInput = {
    number: number
    text: string
    role: string
  }

  export type GPTMessageUncheckedCreateWithoutMessage_historyInput = {
    number: number
    text: string
    role: string
  }

  export type GPTMessageCreateOrConnectWithoutMessage_historyInput = {
    where: GPTMessageWhereUniqueInput
    create: XOR<GPTMessageCreateWithoutMessage_historyInput, GPTMessageUncheckedCreateWithoutMessage_historyInput>
  }

  export type GPTMessageCreateManyMessage_historyInputEnvelope = {
    data: GPTMessageCreateManyMessage_historyInput | GPTMessageCreateManyMessage_historyInput[]
    skipDuplicates?: boolean
  }

  export type GPTMessageUpsertWithWhereUniqueWithoutMessage_historyInput = {
    where: GPTMessageWhereUniqueInput
    update: XOR<GPTMessageUpdateWithoutMessage_historyInput, GPTMessageUncheckedUpdateWithoutMessage_historyInput>
    create: XOR<GPTMessageCreateWithoutMessage_historyInput, GPTMessageUncheckedCreateWithoutMessage_historyInput>
  }

  export type GPTMessageUpdateWithWhereUniqueWithoutMessage_historyInput = {
    where: GPTMessageWhereUniqueInput
    data: XOR<GPTMessageUpdateWithoutMessage_historyInput, GPTMessageUncheckedUpdateWithoutMessage_historyInput>
  }

  export type GPTMessageUpdateManyWithWhereWithoutMessage_historyInput = {
    where: GPTMessageScalarWhereInput
    data: XOR<GPTMessageUpdateManyMutationInput, GPTMessageUncheckedUpdateManyWithoutMessage_historyInput>
  }

  export type GPTMessageScalarWhereInput = {
    AND?: GPTMessageScalarWhereInput | GPTMessageScalarWhereInput[]
    OR?: GPTMessageScalarWhereInput[]
    NOT?: GPTMessageScalarWhereInput | GPTMessageScalarWhereInput[]
    number?: IntFilter<"GPTMessage"> | number
    message_history_id?: StringFilter<"GPTMessage"> | string
    text?: StringFilter<"GPTMessage"> | string
    role?: StringFilter<"GPTMessage"> | string
  }

  export type GPTMessageHistoryCreateWithoutMessagesInput = {
    id?: string
    type: string
  }

  export type GPTMessageHistoryUncheckedCreateWithoutMessagesInput = {
    id?: string
    type: string
  }

  export type GPTMessageHistoryCreateOrConnectWithoutMessagesInput = {
    where: GPTMessageHistoryWhereUniqueInput
    create: XOR<GPTMessageHistoryCreateWithoutMessagesInput, GPTMessageHistoryUncheckedCreateWithoutMessagesInput>
  }

  export type GPTMessageHistoryUpsertWithoutMessagesInput = {
    update: XOR<GPTMessageHistoryUpdateWithoutMessagesInput, GPTMessageHistoryUncheckedUpdateWithoutMessagesInput>
    create: XOR<GPTMessageHistoryCreateWithoutMessagesInput, GPTMessageHistoryUncheckedCreateWithoutMessagesInput>
    where?: GPTMessageHistoryWhereInput
  }

  export type GPTMessageHistoryUpdateToOneWithWhereWithoutMessagesInput = {
    where?: GPTMessageHistoryWhereInput
    data: XOR<GPTMessageHistoryUpdateWithoutMessagesInput, GPTMessageHistoryUncheckedUpdateWithoutMessagesInput>
  }

  export type GPTMessageHistoryUpdateWithoutMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
  }

  export type GPTMessageHistoryUncheckedUpdateWithoutMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
  }

  export type GenreCreateWithoutAdventuresInput = {
    id?: string
    name: string
    keywords?: KeywordCreateNestedManyWithoutGenreInput
  }

  export type GenreUncheckedCreateWithoutAdventuresInput = {
    id?: string
    name: string
    keywords?: KeywordUncheckedCreateNestedManyWithoutGenreInput
  }

  export type GenreCreateOrConnectWithoutAdventuresInput = {
    where: GenreWhereUniqueInput
    create: XOR<GenreCreateWithoutAdventuresInput, GenreUncheckedCreateWithoutAdventuresInput>
  }

  export type AdventureKeywordCreateWithoutAdventureInput = {
    keyword: KeywordCreateNestedOneWithoutAdventuresInput
  }

  export type AdventureKeywordUncheckedCreateWithoutAdventureInput = {
    keyword_id: string
  }

  export type AdventureKeywordCreateOrConnectWithoutAdventureInput = {
    where: AdventureKeywordWhereUniqueInput
    create: XOR<AdventureKeywordCreateWithoutAdventureInput, AdventureKeywordUncheckedCreateWithoutAdventureInput>
  }

  export type AdventureKeywordCreateManyAdventureInputEnvelope = {
    data: AdventureKeywordCreateManyAdventureInput | AdventureKeywordCreateManyAdventureInput[]
    skipDuplicates?: boolean
  }

  export type GenreUpsertWithoutAdventuresInput = {
    update: XOR<GenreUpdateWithoutAdventuresInput, GenreUncheckedUpdateWithoutAdventuresInput>
    create: XOR<GenreCreateWithoutAdventuresInput, GenreUncheckedCreateWithoutAdventuresInput>
    where?: GenreWhereInput
  }

  export type GenreUpdateToOneWithWhereWithoutAdventuresInput = {
    where?: GenreWhereInput
    data: XOR<GenreUpdateWithoutAdventuresInput, GenreUncheckedUpdateWithoutAdventuresInput>
  }

  export type GenreUpdateWithoutAdventuresInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    keywords?: KeywordUpdateManyWithoutGenreNestedInput
  }

  export type GenreUncheckedUpdateWithoutAdventuresInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    keywords?: KeywordUncheckedUpdateManyWithoutGenreNestedInput
  }

  export type AdventureKeywordUpsertWithWhereUniqueWithoutAdventureInput = {
    where: AdventureKeywordWhereUniqueInput
    update: XOR<AdventureKeywordUpdateWithoutAdventureInput, AdventureKeywordUncheckedUpdateWithoutAdventureInput>
    create: XOR<AdventureKeywordCreateWithoutAdventureInput, AdventureKeywordUncheckedCreateWithoutAdventureInput>
  }

  export type AdventureKeywordUpdateWithWhereUniqueWithoutAdventureInput = {
    where: AdventureKeywordWhereUniqueInput
    data: XOR<AdventureKeywordUpdateWithoutAdventureInput, AdventureKeywordUncheckedUpdateWithoutAdventureInput>
  }

  export type AdventureKeywordUpdateManyWithWhereWithoutAdventureInput = {
    where: AdventureKeywordScalarWhereInput
    data: XOR<AdventureKeywordUpdateManyMutationInput, AdventureKeywordUncheckedUpdateManyWithoutAdventureInput>
  }

  export type AdventureKeywordScalarWhereInput = {
    AND?: AdventureKeywordScalarWhereInput | AdventureKeywordScalarWhereInput[]
    OR?: AdventureKeywordScalarWhereInput[]
    NOT?: AdventureKeywordScalarWhereInput | AdventureKeywordScalarWhereInput[]
    adventure_id?: StringFilter<"AdventureKeyword"> | string
    keyword_id?: StringFilter<"AdventureKeyword"> | string
  }

  export type KeywordCreateWithoutGenreInput = {
    id?: string
    name: string
    adventures?: AdventureKeywordCreateNestedManyWithoutKeywordInput
  }

  export type KeywordUncheckedCreateWithoutGenreInput = {
    id?: string
    name: string
    adventures?: AdventureKeywordUncheckedCreateNestedManyWithoutKeywordInput
  }

  export type KeywordCreateOrConnectWithoutGenreInput = {
    where: KeywordWhereUniqueInput
    create: XOR<KeywordCreateWithoutGenreInput, KeywordUncheckedCreateWithoutGenreInput>
  }

  export type KeywordCreateManyGenreInputEnvelope = {
    data: KeywordCreateManyGenreInput | KeywordCreateManyGenreInput[]
    skipDuplicates?: boolean
  }

  export type AdventureCreateWithoutGenreInput = {
    id?: string
    title: string
    planned_parties: number
    creator_id: string
    created_at?: Date | string
    updated_at?: Date | string
    keywords?: AdventureKeywordCreateNestedManyWithoutAdventureInput
  }

  export type AdventureUncheckedCreateWithoutGenreInput = {
    id?: string
    title: string
    planned_parties: number
    creator_id: string
    created_at?: Date | string
    updated_at?: Date | string
    keywords?: AdventureKeywordUncheckedCreateNestedManyWithoutAdventureInput
  }

  export type AdventureCreateOrConnectWithoutGenreInput = {
    where: AdventureWhereUniqueInput
    create: XOR<AdventureCreateWithoutGenreInput, AdventureUncheckedCreateWithoutGenreInput>
  }

  export type AdventureCreateManyGenreInputEnvelope = {
    data: AdventureCreateManyGenreInput | AdventureCreateManyGenreInput[]
    skipDuplicates?: boolean
  }

  export type KeywordUpsertWithWhereUniqueWithoutGenreInput = {
    where: KeywordWhereUniqueInput
    update: XOR<KeywordUpdateWithoutGenreInput, KeywordUncheckedUpdateWithoutGenreInput>
    create: XOR<KeywordCreateWithoutGenreInput, KeywordUncheckedCreateWithoutGenreInput>
  }

  export type KeywordUpdateWithWhereUniqueWithoutGenreInput = {
    where: KeywordWhereUniqueInput
    data: XOR<KeywordUpdateWithoutGenreInput, KeywordUncheckedUpdateWithoutGenreInput>
  }

  export type KeywordUpdateManyWithWhereWithoutGenreInput = {
    where: KeywordScalarWhereInput
    data: XOR<KeywordUpdateManyMutationInput, KeywordUncheckedUpdateManyWithoutGenreInput>
  }

  export type KeywordScalarWhereInput = {
    AND?: KeywordScalarWhereInput | KeywordScalarWhereInput[]
    OR?: KeywordScalarWhereInput[]
    NOT?: KeywordScalarWhereInput | KeywordScalarWhereInput[]
    id?: StringFilter<"Keyword"> | string
    name?: StringFilter<"Keyword"> | string
    genre_id?: StringFilter<"Keyword"> | string
  }

  export type AdventureUpsertWithWhereUniqueWithoutGenreInput = {
    where: AdventureWhereUniqueInput
    update: XOR<AdventureUpdateWithoutGenreInput, AdventureUncheckedUpdateWithoutGenreInput>
    create: XOR<AdventureCreateWithoutGenreInput, AdventureUncheckedCreateWithoutGenreInput>
  }

  export type AdventureUpdateWithWhereUniqueWithoutGenreInput = {
    where: AdventureWhereUniqueInput
    data: XOR<AdventureUpdateWithoutGenreInput, AdventureUncheckedUpdateWithoutGenreInput>
  }

  export type AdventureUpdateManyWithWhereWithoutGenreInput = {
    where: AdventureScalarWhereInput
    data: XOR<AdventureUpdateManyMutationInput, AdventureUncheckedUpdateManyWithoutGenreInput>
  }

  export type AdventureScalarWhereInput = {
    AND?: AdventureScalarWhereInput | AdventureScalarWhereInput[]
    OR?: AdventureScalarWhereInput[]
    NOT?: AdventureScalarWhereInput | AdventureScalarWhereInput[]
    id?: StringFilter<"Adventure"> | string
    title?: StringFilter<"Adventure"> | string
    planned_parties?: IntFilter<"Adventure"> | number
    genre_id?: StringFilter<"Adventure"> | string
    creator_id?: StringFilter<"Adventure"> | string
    created_at?: DateTimeFilter<"Adventure"> | Date | string
    updated_at?: DateTimeFilter<"Adventure"> | Date | string
  }

  export type GenreCreateWithoutKeywordsInput = {
    id?: string
    name: string
    adventures?: AdventureCreateNestedManyWithoutGenreInput
  }

  export type GenreUncheckedCreateWithoutKeywordsInput = {
    id?: string
    name: string
    adventures?: AdventureUncheckedCreateNestedManyWithoutGenreInput
  }

  export type GenreCreateOrConnectWithoutKeywordsInput = {
    where: GenreWhereUniqueInput
    create: XOR<GenreCreateWithoutKeywordsInput, GenreUncheckedCreateWithoutKeywordsInput>
  }

  export type AdventureKeywordCreateWithoutKeywordInput = {
    adventure: AdventureCreateNestedOneWithoutKeywordsInput
  }

  export type AdventureKeywordUncheckedCreateWithoutKeywordInput = {
    adventure_id: string
  }

  export type AdventureKeywordCreateOrConnectWithoutKeywordInput = {
    where: AdventureKeywordWhereUniqueInput
    create: XOR<AdventureKeywordCreateWithoutKeywordInput, AdventureKeywordUncheckedCreateWithoutKeywordInput>
  }

  export type AdventureKeywordCreateManyKeywordInputEnvelope = {
    data: AdventureKeywordCreateManyKeywordInput | AdventureKeywordCreateManyKeywordInput[]
    skipDuplicates?: boolean
  }

  export type GenreUpsertWithoutKeywordsInput = {
    update: XOR<GenreUpdateWithoutKeywordsInput, GenreUncheckedUpdateWithoutKeywordsInput>
    create: XOR<GenreCreateWithoutKeywordsInput, GenreUncheckedCreateWithoutKeywordsInput>
    where?: GenreWhereInput
  }

  export type GenreUpdateToOneWithWhereWithoutKeywordsInput = {
    where?: GenreWhereInput
    data: XOR<GenreUpdateWithoutKeywordsInput, GenreUncheckedUpdateWithoutKeywordsInput>
  }

  export type GenreUpdateWithoutKeywordsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    adventures?: AdventureUpdateManyWithoutGenreNestedInput
  }

  export type GenreUncheckedUpdateWithoutKeywordsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    adventures?: AdventureUncheckedUpdateManyWithoutGenreNestedInput
  }

  export type AdventureKeywordUpsertWithWhereUniqueWithoutKeywordInput = {
    where: AdventureKeywordWhereUniqueInput
    update: XOR<AdventureKeywordUpdateWithoutKeywordInput, AdventureKeywordUncheckedUpdateWithoutKeywordInput>
    create: XOR<AdventureKeywordCreateWithoutKeywordInput, AdventureKeywordUncheckedCreateWithoutKeywordInput>
  }

  export type AdventureKeywordUpdateWithWhereUniqueWithoutKeywordInput = {
    where: AdventureKeywordWhereUniqueInput
    data: XOR<AdventureKeywordUpdateWithoutKeywordInput, AdventureKeywordUncheckedUpdateWithoutKeywordInput>
  }

  export type AdventureKeywordUpdateManyWithWhereWithoutKeywordInput = {
    where: AdventureKeywordScalarWhereInput
    data: XOR<AdventureKeywordUpdateManyMutationInput, AdventureKeywordUncheckedUpdateManyWithoutKeywordInput>
  }

  export type AdventureCreateWithoutKeywordsInput = {
    id?: string
    title: string
    planned_parties: number
    creator_id: string
    created_at?: Date | string
    updated_at?: Date | string
    genre: GenreCreateNestedOneWithoutAdventuresInput
  }

  export type AdventureUncheckedCreateWithoutKeywordsInput = {
    id?: string
    title: string
    planned_parties: number
    genre_id: string
    creator_id: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type AdventureCreateOrConnectWithoutKeywordsInput = {
    where: AdventureWhereUniqueInput
    create: XOR<AdventureCreateWithoutKeywordsInput, AdventureUncheckedCreateWithoutKeywordsInput>
  }

  export type KeywordCreateWithoutAdventuresInput = {
    id?: string
    name: string
    genre: GenreCreateNestedOneWithoutKeywordsInput
  }

  export type KeywordUncheckedCreateWithoutAdventuresInput = {
    id?: string
    name: string
    genre_id: string
  }

  export type KeywordCreateOrConnectWithoutAdventuresInput = {
    where: KeywordWhereUniqueInput
    create: XOR<KeywordCreateWithoutAdventuresInput, KeywordUncheckedCreateWithoutAdventuresInput>
  }

  export type AdventureUpsertWithoutKeywordsInput = {
    update: XOR<AdventureUpdateWithoutKeywordsInput, AdventureUncheckedUpdateWithoutKeywordsInput>
    create: XOR<AdventureCreateWithoutKeywordsInput, AdventureUncheckedCreateWithoutKeywordsInput>
    where?: AdventureWhereInput
  }

  export type AdventureUpdateToOneWithWhereWithoutKeywordsInput = {
    where?: AdventureWhereInput
    data: XOR<AdventureUpdateWithoutKeywordsInput, AdventureUncheckedUpdateWithoutKeywordsInput>
  }

  export type AdventureUpdateWithoutKeywordsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    planned_parties?: IntFieldUpdateOperationsInput | number
    creator_id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    genre?: GenreUpdateOneRequiredWithoutAdventuresNestedInput
  }

  export type AdventureUncheckedUpdateWithoutKeywordsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    planned_parties?: IntFieldUpdateOperationsInput | number
    genre_id?: StringFieldUpdateOperationsInput | string
    creator_id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type KeywordUpsertWithoutAdventuresInput = {
    update: XOR<KeywordUpdateWithoutAdventuresInput, KeywordUncheckedUpdateWithoutAdventuresInput>
    create: XOR<KeywordCreateWithoutAdventuresInput, KeywordUncheckedCreateWithoutAdventuresInput>
    where?: KeywordWhereInput
  }

  export type KeywordUpdateToOneWithWhereWithoutAdventuresInput = {
    where?: KeywordWhereInput
    data: XOR<KeywordUpdateWithoutAdventuresInput, KeywordUncheckedUpdateWithoutAdventuresInput>
  }

  export type KeywordUpdateWithoutAdventuresInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    genre?: GenreUpdateOneRequiredWithoutKeywordsNestedInput
  }

  export type KeywordUncheckedUpdateWithoutAdventuresInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    genre_id?: StringFieldUpdateOperationsInput | string
  }

  export type CreatureCreateManySize_relationInput = {
    id?: string
    name: string
    creator_id?: string | null
    image_uri?: string | null
    description?: string | null
    race_id?: number | null
    source_id?: number | null
    alignment_id?: number | null
    armor_class?: number | null
    hit_points?: number | null
    challenge_rating: string
    biomes_ids?: CreatureCreatebiomes_idsInput | number[]
    type_id?: number | null
    aSubTypes?: CreatureCreateaSubTypesInput | string[]
  }

  export type CreatureUpdateWithoutSize_relationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    creator_id?: NullableStringFieldUpdateOperationsInput | string | null
    image_uri?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    armor_class?: NullableIntFieldUpdateOperationsInput | number | null
    hit_points?: NullableIntFieldUpdateOperationsInput | number | null
    challenge_rating?: StringFieldUpdateOperationsInput | string
    biomes_ids?: CreatureUpdatebiomes_idsInput | number[]
    aSubTypes?: CreatureUpdateaSubTypesInput | string[]
    speed?: Speed_statUpdateOneWithoutId_relationNestedInput
    stats?: Creature_statsUpdateOneWithoutId_relationNestedInput
    skills?: SkillsListUpdateOneWithoutId_relationNestedInput
    resistances?: DamageTypeUpdateManyWithoutResistant_creaturesNestedInput
    immunities?: DamageTypeUpdateManyWithoutImmune_creaturesNestedInput
    vulnerabilities?: DamageTypeUpdateManyWithoutVunlerable_creaturesNestedInput
    senses?: SensesUpdateOneWithoutCreatureNestedInput
    languages?: LanguageUpdateManyWithoutCreaturesNestedInput
    actions?: ActionUpdateManyWithoutCreaturesNestedInput
    traits?: TraitUpdateManyWithoutCreturesNestedInput
    alignment_relation?: AlignmentUpdateOneWithoutCreaturesNestedInput
    race_relation?: CreatureRaceUpdateOneWithoutCreaturesNestedInput
    type_relation?: TypeUpdateOneWithoutCreaturesNestedInput
    biome_relation?: BiomeUpdateManyWithoutCreaturesNestedInput
    source_relation?: SourceUpdateOneWithoutCreaturesNestedInput
  }

  export type CreatureUncheckedUpdateWithoutSize_relationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    creator_id?: NullableStringFieldUpdateOperationsInput | string | null
    image_uri?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    race_id?: NullableIntFieldUpdateOperationsInput | number | null
    source_id?: NullableIntFieldUpdateOperationsInput | number | null
    alignment_id?: NullableIntFieldUpdateOperationsInput | number | null
    armor_class?: NullableIntFieldUpdateOperationsInput | number | null
    hit_points?: NullableIntFieldUpdateOperationsInput | number | null
    challenge_rating?: StringFieldUpdateOperationsInput | string
    biomes_ids?: CreatureUpdatebiomes_idsInput | number[]
    type_id?: NullableIntFieldUpdateOperationsInput | number | null
    aSubTypes?: CreatureUpdateaSubTypesInput | string[]
    speed?: Speed_statUncheckedUpdateOneWithoutId_relationNestedInput
    stats?: Creature_statsUncheckedUpdateOneWithoutId_relationNestedInput
    skills?: SkillsListUncheckedUpdateOneWithoutId_relationNestedInput
    resistances?: DamageTypeUncheckedUpdateManyWithoutResistant_creaturesNestedInput
    immunities?: DamageTypeUncheckedUpdateManyWithoutImmune_creaturesNestedInput
    vulnerabilities?: DamageTypeUncheckedUpdateManyWithoutVunlerable_creaturesNestedInput
    senses?: SensesUncheckedUpdateOneWithoutCreatureNestedInput
    languages?: LanguageUncheckedUpdateManyWithoutCreaturesNestedInput
    actions?: ActionUncheckedUpdateManyWithoutCreaturesNestedInput
    traits?: TraitUncheckedUpdateManyWithoutCreturesNestedInput
    biome_relation?: BiomeUncheckedUpdateManyWithoutCreaturesNestedInput
  }

  export type CreatureUncheckedUpdateManyWithoutSize_relationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    creator_id?: NullableStringFieldUpdateOperationsInput | string | null
    image_uri?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    race_id?: NullableIntFieldUpdateOperationsInput | number | null
    source_id?: NullableIntFieldUpdateOperationsInput | number | null
    alignment_id?: NullableIntFieldUpdateOperationsInput | number | null
    armor_class?: NullableIntFieldUpdateOperationsInput | number | null
    hit_points?: NullableIntFieldUpdateOperationsInput | number | null
    challenge_rating?: StringFieldUpdateOperationsInput | string
    biomes_ids?: CreatureUpdatebiomes_idsInput | number[]
    type_id?: NullableIntFieldUpdateOperationsInput | number | null
    aSubTypes?: CreatureUpdateaSubTypesInput | string[]
  }

  export type CreatureCreateManySource_relationInput = {
    id?: string
    name: string
    creator_id?: string | null
    image_uri?: string | null
    description?: string | null
    size?: string | null
    race_id?: number | null
    alignment_id?: number | null
    armor_class?: number | null
    hit_points?: number | null
    challenge_rating: string
    biomes_ids?: CreatureCreatebiomes_idsInput | number[]
    type_id?: number | null
    aSubTypes?: CreatureCreateaSubTypesInput | string[]
  }

  export type CreatureUpdateWithoutSource_relationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    creator_id?: NullableStringFieldUpdateOperationsInput | string | null
    image_uri?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    armor_class?: NullableIntFieldUpdateOperationsInput | number | null
    hit_points?: NullableIntFieldUpdateOperationsInput | number | null
    challenge_rating?: StringFieldUpdateOperationsInput | string
    biomes_ids?: CreatureUpdatebiomes_idsInput | number[]
    aSubTypes?: CreatureUpdateaSubTypesInput | string[]
    speed?: Speed_statUpdateOneWithoutId_relationNestedInput
    stats?: Creature_statsUpdateOneWithoutId_relationNestedInput
    skills?: SkillsListUpdateOneWithoutId_relationNestedInput
    resistances?: DamageTypeUpdateManyWithoutResistant_creaturesNestedInput
    immunities?: DamageTypeUpdateManyWithoutImmune_creaturesNestedInput
    vulnerabilities?: DamageTypeUpdateManyWithoutVunlerable_creaturesNestedInput
    senses?: SensesUpdateOneWithoutCreatureNestedInput
    languages?: LanguageUpdateManyWithoutCreaturesNestedInput
    actions?: ActionUpdateManyWithoutCreaturesNestedInput
    traits?: TraitUpdateManyWithoutCreturesNestedInput
    alignment_relation?: AlignmentUpdateOneWithoutCreaturesNestedInput
    race_relation?: CreatureRaceUpdateOneWithoutCreaturesNestedInput
    type_relation?: TypeUpdateOneWithoutCreaturesNestedInput
    size_relation?: SizeUpdateOneWithoutCreatureNestedInput
    biome_relation?: BiomeUpdateManyWithoutCreaturesNestedInput
  }

  export type CreatureUncheckedUpdateWithoutSource_relationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    creator_id?: NullableStringFieldUpdateOperationsInput | string | null
    image_uri?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableStringFieldUpdateOperationsInput | string | null
    race_id?: NullableIntFieldUpdateOperationsInput | number | null
    alignment_id?: NullableIntFieldUpdateOperationsInput | number | null
    armor_class?: NullableIntFieldUpdateOperationsInput | number | null
    hit_points?: NullableIntFieldUpdateOperationsInput | number | null
    challenge_rating?: StringFieldUpdateOperationsInput | string
    biomes_ids?: CreatureUpdatebiomes_idsInput | number[]
    type_id?: NullableIntFieldUpdateOperationsInput | number | null
    aSubTypes?: CreatureUpdateaSubTypesInput | string[]
    speed?: Speed_statUncheckedUpdateOneWithoutId_relationNestedInput
    stats?: Creature_statsUncheckedUpdateOneWithoutId_relationNestedInput
    skills?: SkillsListUncheckedUpdateOneWithoutId_relationNestedInput
    resistances?: DamageTypeUncheckedUpdateManyWithoutResistant_creaturesNestedInput
    immunities?: DamageTypeUncheckedUpdateManyWithoutImmune_creaturesNestedInput
    vulnerabilities?: DamageTypeUncheckedUpdateManyWithoutVunlerable_creaturesNestedInput
    senses?: SensesUncheckedUpdateOneWithoutCreatureNestedInput
    languages?: LanguageUncheckedUpdateManyWithoutCreaturesNestedInput
    actions?: ActionUncheckedUpdateManyWithoutCreaturesNestedInput
    traits?: TraitUncheckedUpdateManyWithoutCreturesNestedInput
    biome_relation?: BiomeUncheckedUpdateManyWithoutCreaturesNestedInput
  }

  export type CreatureUncheckedUpdateManyWithoutSource_relationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    creator_id?: NullableStringFieldUpdateOperationsInput | string | null
    image_uri?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableStringFieldUpdateOperationsInput | string | null
    race_id?: NullableIntFieldUpdateOperationsInput | number | null
    alignment_id?: NullableIntFieldUpdateOperationsInput | number | null
    armor_class?: NullableIntFieldUpdateOperationsInput | number | null
    hit_points?: NullableIntFieldUpdateOperationsInput | number | null
    challenge_rating?: StringFieldUpdateOperationsInput | string
    biomes_ids?: CreatureUpdatebiomes_idsInput | number[]
    type_id?: NullableIntFieldUpdateOperationsInput | number | null
    aSubTypes?: CreatureUpdateaSubTypesInput | string[]
  }

  export type CreatureUpdateWithoutLanguagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    creator_id?: NullableStringFieldUpdateOperationsInput | string | null
    image_uri?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    armor_class?: NullableIntFieldUpdateOperationsInput | number | null
    hit_points?: NullableIntFieldUpdateOperationsInput | number | null
    challenge_rating?: StringFieldUpdateOperationsInput | string
    biomes_ids?: CreatureUpdatebiomes_idsInput | number[]
    aSubTypes?: CreatureUpdateaSubTypesInput | string[]
    speed?: Speed_statUpdateOneWithoutId_relationNestedInput
    stats?: Creature_statsUpdateOneWithoutId_relationNestedInput
    skills?: SkillsListUpdateOneWithoutId_relationNestedInput
    resistances?: DamageTypeUpdateManyWithoutResistant_creaturesNestedInput
    immunities?: DamageTypeUpdateManyWithoutImmune_creaturesNestedInput
    vulnerabilities?: DamageTypeUpdateManyWithoutVunlerable_creaturesNestedInput
    senses?: SensesUpdateOneWithoutCreatureNestedInput
    actions?: ActionUpdateManyWithoutCreaturesNestedInput
    traits?: TraitUpdateManyWithoutCreturesNestedInput
    alignment_relation?: AlignmentUpdateOneWithoutCreaturesNestedInput
    race_relation?: CreatureRaceUpdateOneWithoutCreaturesNestedInput
    type_relation?: TypeUpdateOneWithoutCreaturesNestedInput
    size_relation?: SizeUpdateOneWithoutCreatureNestedInput
    biome_relation?: BiomeUpdateManyWithoutCreaturesNestedInput
    source_relation?: SourceUpdateOneWithoutCreaturesNestedInput
  }

  export type CreatureUncheckedUpdateWithoutLanguagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    creator_id?: NullableStringFieldUpdateOperationsInput | string | null
    image_uri?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableStringFieldUpdateOperationsInput | string | null
    race_id?: NullableIntFieldUpdateOperationsInput | number | null
    source_id?: NullableIntFieldUpdateOperationsInput | number | null
    alignment_id?: NullableIntFieldUpdateOperationsInput | number | null
    armor_class?: NullableIntFieldUpdateOperationsInput | number | null
    hit_points?: NullableIntFieldUpdateOperationsInput | number | null
    challenge_rating?: StringFieldUpdateOperationsInput | string
    biomes_ids?: CreatureUpdatebiomes_idsInput | number[]
    type_id?: NullableIntFieldUpdateOperationsInput | number | null
    aSubTypes?: CreatureUpdateaSubTypesInput | string[]
    speed?: Speed_statUncheckedUpdateOneWithoutId_relationNestedInput
    stats?: Creature_statsUncheckedUpdateOneWithoutId_relationNestedInput
    skills?: SkillsListUncheckedUpdateOneWithoutId_relationNestedInput
    resistances?: DamageTypeUncheckedUpdateManyWithoutResistant_creaturesNestedInput
    immunities?: DamageTypeUncheckedUpdateManyWithoutImmune_creaturesNestedInput
    vulnerabilities?: DamageTypeUncheckedUpdateManyWithoutVunlerable_creaturesNestedInput
    senses?: SensesUncheckedUpdateOneWithoutCreatureNestedInput
    actions?: ActionUncheckedUpdateManyWithoutCreaturesNestedInput
    traits?: TraitUncheckedUpdateManyWithoutCreturesNestedInput
    biome_relation?: BiomeUncheckedUpdateManyWithoutCreaturesNestedInput
  }

  export type CreatureUncheckedUpdateManyWithoutLanguagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    creator_id?: NullableStringFieldUpdateOperationsInput | string | null
    image_uri?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableStringFieldUpdateOperationsInput | string | null
    race_id?: NullableIntFieldUpdateOperationsInput | number | null
    source_id?: NullableIntFieldUpdateOperationsInput | number | null
    alignment_id?: NullableIntFieldUpdateOperationsInput | number | null
    armor_class?: NullableIntFieldUpdateOperationsInput | number | null
    hit_points?: NullableIntFieldUpdateOperationsInput | number | null
    challenge_rating?: StringFieldUpdateOperationsInput | string
    biomes_ids?: CreatureUpdatebiomes_idsInput | number[]
    type_id?: NullableIntFieldUpdateOperationsInput | number | null
    aSubTypes?: CreatureUpdateaSubTypesInput | string[]
  }

  export type CreatureUpdateWithoutBiome_relationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    creator_id?: NullableStringFieldUpdateOperationsInput | string | null
    image_uri?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    armor_class?: NullableIntFieldUpdateOperationsInput | number | null
    hit_points?: NullableIntFieldUpdateOperationsInput | number | null
    challenge_rating?: StringFieldUpdateOperationsInput | string
    biomes_ids?: CreatureUpdatebiomes_idsInput | number[]
    aSubTypes?: CreatureUpdateaSubTypesInput | string[]
    speed?: Speed_statUpdateOneWithoutId_relationNestedInput
    stats?: Creature_statsUpdateOneWithoutId_relationNestedInput
    skills?: SkillsListUpdateOneWithoutId_relationNestedInput
    resistances?: DamageTypeUpdateManyWithoutResistant_creaturesNestedInput
    immunities?: DamageTypeUpdateManyWithoutImmune_creaturesNestedInput
    vulnerabilities?: DamageTypeUpdateManyWithoutVunlerable_creaturesNestedInput
    senses?: SensesUpdateOneWithoutCreatureNestedInput
    languages?: LanguageUpdateManyWithoutCreaturesNestedInput
    actions?: ActionUpdateManyWithoutCreaturesNestedInput
    traits?: TraitUpdateManyWithoutCreturesNestedInput
    alignment_relation?: AlignmentUpdateOneWithoutCreaturesNestedInput
    race_relation?: CreatureRaceUpdateOneWithoutCreaturesNestedInput
    type_relation?: TypeUpdateOneWithoutCreaturesNestedInput
    size_relation?: SizeUpdateOneWithoutCreatureNestedInput
    source_relation?: SourceUpdateOneWithoutCreaturesNestedInput
  }

  export type CreatureUncheckedUpdateWithoutBiome_relationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    creator_id?: NullableStringFieldUpdateOperationsInput | string | null
    image_uri?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableStringFieldUpdateOperationsInput | string | null
    race_id?: NullableIntFieldUpdateOperationsInput | number | null
    source_id?: NullableIntFieldUpdateOperationsInput | number | null
    alignment_id?: NullableIntFieldUpdateOperationsInput | number | null
    armor_class?: NullableIntFieldUpdateOperationsInput | number | null
    hit_points?: NullableIntFieldUpdateOperationsInput | number | null
    challenge_rating?: StringFieldUpdateOperationsInput | string
    biomes_ids?: CreatureUpdatebiomes_idsInput | number[]
    type_id?: NullableIntFieldUpdateOperationsInput | number | null
    aSubTypes?: CreatureUpdateaSubTypesInput | string[]
    speed?: Speed_statUncheckedUpdateOneWithoutId_relationNestedInput
    stats?: Creature_statsUncheckedUpdateOneWithoutId_relationNestedInput
    skills?: SkillsListUncheckedUpdateOneWithoutId_relationNestedInput
    resistances?: DamageTypeUncheckedUpdateManyWithoutResistant_creaturesNestedInput
    immunities?: DamageTypeUncheckedUpdateManyWithoutImmune_creaturesNestedInput
    vulnerabilities?: DamageTypeUncheckedUpdateManyWithoutVunlerable_creaturesNestedInput
    senses?: SensesUncheckedUpdateOneWithoutCreatureNestedInput
    languages?: LanguageUncheckedUpdateManyWithoutCreaturesNestedInput
    actions?: ActionUncheckedUpdateManyWithoutCreaturesNestedInput
    traits?: TraitUncheckedUpdateManyWithoutCreturesNestedInput
  }

  export type CreatureUncheckedUpdateManyWithoutBiome_relationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    creator_id?: NullableStringFieldUpdateOperationsInput | string | null
    image_uri?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableStringFieldUpdateOperationsInput | string | null
    race_id?: NullableIntFieldUpdateOperationsInput | number | null
    source_id?: NullableIntFieldUpdateOperationsInput | number | null
    alignment_id?: NullableIntFieldUpdateOperationsInput | number | null
    armor_class?: NullableIntFieldUpdateOperationsInput | number | null
    hit_points?: NullableIntFieldUpdateOperationsInput | number | null
    challenge_rating?: StringFieldUpdateOperationsInput | string
    biomes_ids?: CreatureUpdatebiomes_idsInput | number[]
    type_id?: NullableIntFieldUpdateOperationsInput | number | null
    aSubTypes?: CreatureUpdateaSubTypesInput | string[]
  }

  export type CreatureCreateManyType_relationInput = {
    id?: string
    name: string
    creator_id?: string | null
    image_uri?: string | null
    description?: string | null
    size?: string | null
    race_id?: number | null
    source_id?: number | null
    alignment_id?: number | null
    armor_class?: number | null
    hit_points?: number | null
    challenge_rating: string
    biomes_ids?: CreatureCreatebiomes_idsInput | number[]
    aSubTypes?: CreatureCreateaSubTypesInput | string[]
  }

  export type CreatureUpdateWithoutType_relationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    creator_id?: NullableStringFieldUpdateOperationsInput | string | null
    image_uri?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    armor_class?: NullableIntFieldUpdateOperationsInput | number | null
    hit_points?: NullableIntFieldUpdateOperationsInput | number | null
    challenge_rating?: StringFieldUpdateOperationsInput | string
    biomes_ids?: CreatureUpdatebiomes_idsInput | number[]
    aSubTypes?: CreatureUpdateaSubTypesInput | string[]
    speed?: Speed_statUpdateOneWithoutId_relationNestedInput
    stats?: Creature_statsUpdateOneWithoutId_relationNestedInput
    skills?: SkillsListUpdateOneWithoutId_relationNestedInput
    resistances?: DamageTypeUpdateManyWithoutResistant_creaturesNestedInput
    immunities?: DamageTypeUpdateManyWithoutImmune_creaturesNestedInput
    vulnerabilities?: DamageTypeUpdateManyWithoutVunlerable_creaturesNestedInput
    senses?: SensesUpdateOneWithoutCreatureNestedInput
    languages?: LanguageUpdateManyWithoutCreaturesNestedInput
    actions?: ActionUpdateManyWithoutCreaturesNestedInput
    traits?: TraitUpdateManyWithoutCreturesNestedInput
    alignment_relation?: AlignmentUpdateOneWithoutCreaturesNestedInput
    race_relation?: CreatureRaceUpdateOneWithoutCreaturesNestedInput
    size_relation?: SizeUpdateOneWithoutCreatureNestedInput
    biome_relation?: BiomeUpdateManyWithoutCreaturesNestedInput
    source_relation?: SourceUpdateOneWithoutCreaturesNestedInput
  }

  export type CreatureUncheckedUpdateWithoutType_relationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    creator_id?: NullableStringFieldUpdateOperationsInput | string | null
    image_uri?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableStringFieldUpdateOperationsInput | string | null
    race_id?: NullableIntFieldUpdateOperationsInput | number | null
    source_id?: NullableIntFieldUpdateOperationsInput | number | null
    alignment_id?: NullableIntFieldUpdateOperationsInput | number | null
    armor_class?: NullableIntFieldUpdateOperationsInput | number | null
    hit_points?: NullableIntFieldUpdateOperationsInput | number | null
    challenge_rating?: StringFieldUpdateOperationsInput | string
    biomes_ids?: CreatureUpdatebiomes_idsInput | number[]
    aSubTypes?: CreatureUpdateaSubTypesInput | string[]
    speed?: Speed_statUncheckedUpdateOneWithoutId_relationNestedInput
    stats?: Creature_statsUncheckedUpdateOneWithoutId_relationNestedInput
    skills?: SkillsListUncheckedUpdateOneWithoutId_relationNestedInput
    resistances?: DamageTypeUncheckedUpdateManyWithoutResistant_creaturesNestedInput
    immunities?: DamageTypeUncheckedUpdateManyWithoutImmune_creaturesNestedInput
    vulnerabilities?: DamageTypeUncheckedUpdateManyWithoutVunlerable_creaturesNestedInput
    senses?: SensesUncheckedUpdateOneWithoutCreatureNestedInput
    languages?: LanguageUncheckedUpdateManyWithoutCreaturesNestedInput
    actions?: ActionUncheckedUpdateManyWithoutCreaturesNestedInput
    traits?: TraitUncheckedUpdateManyWithoutCreturesNestedInput
    biome_relation?: BiomeUncheckedUpdateManyWithoutCreaturesNestedInput
  }

  export type CreatureUncheckedUpdateManyWithoutType_relationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    creator_id?: NullableStringFieldUpdateOperationsInput | string | null
    image_uri?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableStringFieldUpdateOperationsInput | string | null
    race_id?: NullableIntFieldUpdateOperationsInput | number | null
    source_id?: NullableIntFieldUpdateOperationsInput | number | null
    alignment_id?: NullableIntFieldUpdateOperationsInput | number | null
    armor_class?: NullableIntFieldUpdateOperationsInput | number | null
    hit_points?: NullableIntFieldUpdateOperationsInput | number | null
    challenge_rating?: StringFieldUpdateOperationsInput | string
    biomes_ids?: CreatureUpdatebiomes_idsInput | number[]
    aSubTypes?: CreatureUpdateaSubTypesInput | string[]
  }

  export type CreatureCreateManyAlignment_relationInput = {
    id?: string
    name: string
    creator_id?: string | null
    image_uri?: string | null
    description?: string | null
    size?: string | null
    race_id?: number | null
    source_id?: number | null
    armor_class?: number | null
    hit_points?: number | null
    challenge_rating: string
    biomes_ids?: CreatureCreatebiomes_idsInput | number[]
    type_id?: number | null
    aSubTypes?: CreatureCreateaSubTypesInput | string[]
  }

  export type CreatureUpdateWithoutAlignment_relationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    creator_id?: NullableStringFieldUpdateOperationsInput | string | null
    image_uri?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    armor_class?: NullableIntFieldUpdateOperationsInput | number | null
    hit_points?: NullableIntFieldUpdateOperationsInput | number | null
    challenge_rating?: StringFieldUpdateOperationsInput | string
    biomes_ids?: CreatureUpdatebiomes_idsInput | number[]
    aSubTypes?: CreatureUpdateaSubTypesInput | string[]
    speed?: Speed_statUpdateOneWithoutId_relationNestedInput
    stats?: Creature_statsUpdateOneWithoutId_relationNestedInput
    skills?: SkillsListUpdateOneWithoutId_relationNestedInput
    resistances?: DamageTypeUpdateManyWithoutResistant_creaturesNestedInput
    immunities?: DamageTypeUpdateManyWithoutImmune_creaturesNestedInput
    vulnerabilities?: DamageTypeUpdateManyWithoutVunlerable_creaturesNestedInput
    senses?: SensesUpdateOneWithoutCreatureNestedInput
    languages?: LanguageUpdateManyWithoutCreaturesNestedInput
    actions?: ActionUpdateManyWithoutCreaturesNestedInput
    traits?: TraitUpdateManyWithoutCreturesNestedInput
    race_relation?: CreatureRaceUpdateOneWithoutCreaturesNestedInput
    type_relation?: TypeUpdateOneWithoutCreaturesNestedInput
    size_relation?: SizeUpdateOneWithoutCreatureNestedInput
    biome_relation?: BiomeUpdateManyWithoutCreaturesNestedInput
    source_relation?: SourceUpdateOneWithoutCreaturesNestedInput
  }

  export type CreatureUncheckedUpdateWithoutAlignment_relationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    creator_id?: NullableStringFieldUpdateOperationsInput | string | null
    image_uri?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableStringFieldUpdateOperationsInput | string | null
    race_id?: NullableIntFieldUpdateOperationsInput | number | null
    source_id?: NullableIntFieldUpdateOperationsInput | number | null
    armor_class?: NullableIntFieldUpdateOperationsInput | number | null
    hit_points?: NullableIntFieldUpdateOperationsInput | number | null
    challenge_rating?: StringFieldUpdateOperationsInput | string
    biomes_ids?: CreatureUpdatebiomes_idsInput | number[]
    type_id?: NullableIntFieldUpdateOperationsInput | number | null
    aSubTypes?: CreatureUpdateaSubTypesInput | string[]
    speed?: Speed_statUncheckedUpdateOneWithoutId_relationNestedInput
    stats?: Creature_statsUncheckedUpdateOneWithoutId_relationNestedInput
    skills?: SkillsListUncheckedUpdateOneWithoutId_relationNestedInput
    resistances?: DamageTypeUncheckedUpdateManyWithoutResistant_creaturesNestedInput
    immunities?: DamageTypeUncheckedUpdateManyWithoutImmune_creaturesNestedInput
    vulnerabilities?: DamageTypeUncheckedUpdateManyWithoutVunlerable_creaturesNestedInput
    senses?: SensesUncheckedUpdateOneWithoutCreatureNestedInput
    languages?: LanguageUncheckedUpdateManyWithoutCreaturesNestedInput
    actions?: ActionUncheckedUpdateManyWithoutCreaturesNestedInput
    traits?: TraitUncheckedUpdateManyWithoutCreturesNestedInput
    biome_relation?: BiomeUncheckedUpdateManyWithoutCreaturesNestedInput
  }

  export type CreatureUncheckedUpdateManyWithoutAlignment_relationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    creator_id?: NullableStringFieldUpdateOperationsInput | string | null
    image_uri?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableStringFieldUpdateOperationsInput | string | null
    race_id?: NullableIntFieldUpdateOperationsInput | number | null
    source_id?: NullableIntFieldUpdateOperationsInput | number | null
    armor_class?: NullableIntFieldUpdateOperationsInput | number | null
    hit_points?: NullableIntFieldUpdateOperationsInput | number | null
    challenge_rating?: StringFieldUpdateOperationsInput | string
    biomes_ids?: CreatureUpdatebiomes_idsInput | number[]
    type_id?: NullableIntFieldUpdateOperationsInput | number | null
    aSubTypes?: CreatureUpdateaSubTypesInput | string[]
  }

  export type DamageTypeUpdateWithoutResistant_creaturesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    immune_creatures?: CreatureUpdateManyWithoutImmunitiesNestedInput
    vunlerable_creatures?: CreatureUpdateManyWithoutVulnerabilitiesNestedInput
  }

  export type DamageTypeUncheckedUpdateWithoutResistant_creaturesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    immune_creatures?: CreatureUncheckedUpdateManyWithoutImmunitiesNestedInput
    vunlerable_creatures?: CreatureUncheckedUpdateManyWithoutVulnerabilitiesNestedInput
  }

  export type DamageTypeUncheckedUpdateManyWithoutResistant_creaturesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type DamageTypeUpdateWithoutImmune_creaturesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    resistant_creatures?: CreatureUpdateManyWithoutResistancesNestedInput
    vunlerable_creatures?: CreatureUpdateManyWithoutVulnerabilitiesNestedInput
  }

  export type DamageTypeUncheckedUpdateWithoutImmune_creaturesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    resistant_creatures?: CreatureUncheckedUpdateManyWithoutResistancesNestedInput
    vunlerable_creatures?: CreatureUncheckedUpdateManyWithoutVulnerabilitiesNestedInput
  }

  export type DamageTypeUncheckedUpdateManyWithoutImmune_creaturesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type DamageTypeUpdateWithoutVunlerable_creaturesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    resistant_creatures?: CreatureUpdateManyWithoutResistancesNestedInput
    immune_creatures?: CreatureUpdateManyWithoutImmunitiesNestedInput
  }

  export type DamageTypeUncheckedUpdateWithoutVunlerable_creaturesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    resistant_creatures?: CreatureUncheckedUpdateManyWithoutResistancesNestedInput
    immune_creatures?: CreatureUncheckedUpdateManyWithoutImmunitiesNestedInput
  }

  export type DamageTypeUncheckedUpdateManyWithoutVunlerable_creaturesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type LanguageUpdateWithoutCreaturesInput = {
    name?: StringFieldUpdateOperationsInput | string
  }

  export type LanguageUncheckedUpdateWithoutCreaturesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type LanguageUncheckedUpdateManyWithoutCreaturesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type ActionUpdateWithoutCreaturesInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    attack?: NullableStringFieldUpdateOperationsInput | string | null
    is_template?: NullableBoolFieldUpdateOperationsInput | boolean | null
    creatureTypes?: CreatureRaceUpdateManyWithoutActionsNestedInput
  }

  export type ActionUncheckedUpdateWithoutCreaturesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    attack?: NullableStringFieldUpdateOperationsInput | string | null
    is_template?: NullableBoolFieldUpdateOperationsInput | boolean | null
    creatureTypes?: CreatureRaceUncheckedUpdateManyWithoutActionsNestedInput
  }

  export type ActionUncheckedUpdateManyWithoutCreaturesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    attack?: NullableStringFieldUpdateOperationsInput | string | null
    is_template?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type TraitUpdateWithoutCreturesInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    attack?: NullableStringFieldUpdateOperationsInput | string | null
    is_template?: NullableBoolFieldUpdateOperationsInput | boolean | null
    creatureTypes?: CreatureRaceUpdateManyWithoutTraitsNestedInput
  }

  export type TraitUncheckedUpdateWithoutCreturesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    attack?: NullableStringFieldUpdateOperationsInput | string | null
    is_template?: NullableBoolFieldUpdateOperationsInput | boolean | null
    creatureTypes?: CreatureRaceUncheckedUpdateManyWithoutTraitsNestedInput
  }

  export type TraitUncheckedUpdateManyWithoutCreturesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    attack?: NullableStringFieldUpdateOperationsInput | string | null
    is_template?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type BiomeUpdateWithoutCreaturesInput = {
    key?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type BiomeUncheckedUpdateWithoutCreaturesInput = {
    id?: IntFieldUpdateOperationsInput | number
    key?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type BiomeUncheckedUpdateManyWithoutCreaturesInput = {
    id?: IntFieldUpdateOperationsInput | number
    key?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type CreatureUpdateWithoutActionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    creator_id?: NullableStringFieldUpdateOperationsInput | string | null
    image_uri?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    armor_class?: NullableIntFieldUpdateOperationsInput | number | null
    hit_points?: NullableIntFieldUpdateOperationsInput | number | null
    challenge_rating?: StringFieldUpdateOperationsInput | string
    biomes_ids?: CreatureUpdatebiomes_idsInput | number[]
    aSubTypes?: CreatureUpdateaSubTypesInput | string[]
    speed?: Speed_statUpdateOneWithoutId_relationNestedInput
    stats?: Creature_statsUpdateOneWithoutId_relationNestedInput
    skills?: SkillsListUpdateOneWithoutId_relationNestedInput
    resistances?: DamageTypeUpdateManyWithoutResistant_creaturesNestedInput
    immunities?: DamageTypeUpdateManyWithoutImmune_creaturesNestedInput
    vulnerabilities?: DamageTypeUpdateManyWithoutVunlerable_creaturesNestedInput
    senses?: SensesUpdateOneWithoutCreatureNestedInput
    languages?: LanguageUpdateManyWithoutCreaturesNestedInput
    traits?: TraitUpdateManyWithoutCreturesNestedInput
    alignment_relation?: AlignmentUpdateOneWithoutCreaturesNestedInput
    race_relation?: CreatureRaceUpdateOneWithoutCreaturesNestedInput
    type_relation?: TypeUpdateOneWithoutCreaturesNestedInput
    size_relation?: SizeUpdateOneWithoutCreatureNestedInput
    biome_relation?: BiomeUpdateManyWithoutCreaturesNestedInput
    source_relation?: SourceUpdateOneWithoutCreaturesNestedInput
  }

  export type CreatureUncheckedUpdateWithoutActionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    creator_id?: NullableStringFieldUpdateOperationsInput | string | null
    image_uri?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableStringFieldUpdateOperationsInput | string | null
    race_id?: NullableIntFieldUpdateOperationsInput | number | null
    source_id?: NullableIntFieldUpdateOperationsInput | number | null
    alignment_id?: NullableIntFieldUpdateOperationsInput | number | null
    armor_class?: NullableIntFieldUpdateOperationsInput | number | null
    hit_points?: NullableIntFieldUpdateOperationsInput | number | null
    challenge_rating?: StringFieldUpdateOperationsInput | string
    biomes_ids?: CreatureUpdatebiomes_idsInput | number[]
    type_id?: NullableIntFieldUpdateOperationsInput | number | null
    aSubTypes?: CreatureUpdateaSubTypesInput | string[]
    speed?: Speed_statUncheckedUpdateOneWithoutId_relationNestedInput
    stats?: Creature_statsUncheckedUpdateOneWithoutId_relationNestedInput
    skills?: SkillsListUncheckedUpdateOneWithoutId_relationNestedInput
    resistances?: DamageTypeUncheckedUpdateManyWithoutResistant_creaturesNestedInput
    immunities?: DamageTypeUncheckedUpdateManyWithoutImmune_creaturesNestedInput
    vulnerabilities?: DamageTypeUncheckedUpdateManyWithoutVunlerable_creaturesNestedInput
    senses?: SensesUncheckedUpdateOneWithoutCreatureNestedInput
    languages?: LanguageUncheckedUpdateManyWithoutCreaturesNestedInput
    traits?: TraitUncheckedUpdateManyWithoutCreturesNestedInput
    biome_relation?: BiomeUncheckedUpdateManyWithoutCreaturesNestedInput
  }

  export type CreatureUncheckedUpdateManyWithoutActionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    creator_id?: NullableStringFieldUpdateOperationsInput | string | null
    image_uri?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableStringFieldUpdateOperationsInput | string | null
    race_id?: NullableIntFieldUpdateOperationsInput | number | null
    source_id?: NullableIntFieldUpdateOperationsInput | number | null
    alignment_id?: NullableIntFieldUpdateOperationsInput | number | null
    armor_class?: NullableIntFieldUpdateOperationsInput | number | null
    hit_points?: NullableIntFieldUpdateOperationsInput | number | null
    challenge_rating?: StringFieldUpdateOperationsInput | string
    biomes_ids?: CreatureUpdatebiomes_idsInput | number[]
    type_id?: NullableIntFieldUpdateOperationsInput | number | null
    aSubTypes?: CreatureUpdateaSubTypesInput | string[]
  }

  export type CreatureRaceUpdateWithoutActionsInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    traits?: TraitUpdateManyWithoutCreatureTypesNestedInput
    creatures?: CreatureUpdateManyWithoutRace_relationNestedInput
  }

  export type CreatureRaceUncheckedUpdateWithoutActionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    traits?: TraitUncheckedUpdateManyWithoutCreatureTypesNestedInput
    creatures?: CreatureUncheckedUpdateManyWithoutRace_relationNestedInput
  }

  export type CreatureRaceUncheckedUpdateManyWithoutActionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
  }

  export type CreatureUpdateWithoutTraitsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    creator_id?: NullableStringFieldUpdateOperationsInput | string | null
    image_uri?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    armor_class?: NullableIntFieldUpdateOperationsInput | number | null
    hit_points?: NullableIntFieldUpdateOperationsInput | number | null
    challenge_rating?: StringFieldUpdateOperationsInput | string
    biomes_ids?: CreatureUpdatebiomes_idsInput | number[]
    aSubTypes?: CreatureUpdateaSubTypesInput | string[]
    speed?: Speed_statUpdateOneWithoutId_relationNestedInput
    stats?: Creature_statsUpdateOneWithoutId_relationNestedInput
    skills?: SkillsListUpdateOneWithoutId_relationNestedInput
    resistances?: DamageTypeUpdateManyWithoutResistant_creaturesNestedInput
    immunities?: DamageTypeUpdateManyWithoutImmune_creaturesNestedInput
    vulnerabilities?: DamageTypeUpdateManyWithoutVunlerable_creaturesNestedInput
    senses?: SensesUpdateOneWithoutCreatureNestedInput
    languages?: LanguageUpdateManyWithoutCreaturesNestedInput
    actions?: ActionUpdateManyWithoutCreaturesNestedInput
    alignment_relation?: AlignmentUpdateOneWithoutCreaturesNestedInput
    race_relation?: CreatureRaceUpdateOneWithoutCreaturesNestedInput
    type_relation?: TypeUpdateOneWithoutCreaturesNestedInput
    size_relation?: SizeUpdateOneWithoutCreatureNestedInput
    biome_relation?: BiomeUpdateManyWithoutCreaturesNestedInput
    source_relation?: SourceUpdateOneWithoutCreaturesNestedInput
  }

  export type CreatureUncheckedUpdateWithoutTraitsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    creator_id?: NullableStringFieldUpdateOperationsInput | string | null
    image_uri?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableStringFieldUpdateOperationsInput | string | null
    race_id?: NullableIntFieldUpdateOperationsInput | number | null
    source_id?: NullableIntFieldUpdateOperationsInput | number | null
    alignment_id?: NullableIntFieldUpdateOperationsInput | number | null
    armor_class?: NullableIntFieldUpdateOperationsInput | number | null
    hit_points?: NullableIntFieldUpdateOperationsInput | number | null
    challenge_rating?: StringFieldUpdateOperationsInput | string
    biomes_ids?: CreatureUpdatebiomes_idsInput | number[]
    type_id?: NullableIntFieldUpdateOperationsInput | number | null
    aSubTypes?: CreatureUpdateaSubTypesInput | string[]
    speed?: Speed_statUncheckedUpdateOneWithoutId_relationNestedInput
    stats?: Creature_statsUncheckedUpdateOneWithoutId_relationNestedInput
    skills?: SkillsListUncheckedUpdateOneWithoutId_relationNestedInput
    resistances?: DamageTypeUncheckedUpdateManyWithoutResistant_creaturesNestedInput
    immunities?: DamageTypeUncheckedUpdateManyWithoutImmune_creaturesNestedInput
    vulnerabilities?: DamageTypeUncheckedUpdateManyWithoutVunlerable_creaturesNestedInput
    senses?: SensesUncheckedUpdateOneWithoutCreatureNestedInput
    languages?: LanguageUncheckedUpdateManyWithoutCreaturesNestedInput
    actions?: ActionUncheckedUpdateManyWithoutCreaturesNestedInput
    biome_relation?: BiomeUncheckedUpdateManyWithoutCreaturesNestedInput
  }

  export type CreatureUncheckedUpdateManyWithoutTraitsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    creator_id?: NullableStringFieldUpdateOperationsInput | string | null
    image_uri?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableStringFieldUpdateOperationsInput | string | null
    race_id?: NullableIntFieldUpdateOperationsInput | number | null
    source_id?: NullableIntFieldUpdateOperationsInput | number | null
    alignment_id?: NullableIntFieldUpdateOperationsInput | number | null
    armor_class?: NullableIntFieldUpdateOperationsInput | number | null
    hit_points?: NullableIntFieldUpdateOperationsInput | number | null
    challenge_rating?: StringFieldUpdateOperationsInput | string
    biomes_ids?: CreatureUpdatebiomes_idsInput | number[]
    type_id?: NullableIntFieldUpdateOperationsInput | number | null
    aSubTypes?: CreatureUpdateaSubTypesInput | string[]
  }

  export type CreatureRaceUpdateWithoutTraitsInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    actions?: ActionUpdateManyWithoutCreatureTypesNestedInput
    creatures?: CreatureUpdateManyWithoutRace_relationNestedInput
  }

  export type CreatureRaceUncheckedUpdateWithoutTraitsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    actions?: ActionUncheckedUpdateManyWithoutCreatureTypesNestedInput
    creatures?: CreatureUncheckedUpdateManyWithoutRace_relationNestedInput
  }

  export type CreatureRaceUncheckedUpdateManyWithoutTraitsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
  }

  export type CreatureCreateManyRace_relationInput = {
    id?: string
    name: string
    creator_id?: string | null
    image_uri?: string | null
    description?: string | null
    size?: string | null
    source_id?: number | null
    alignment_id?: number | null
    armor_class?: number | null
    hit_points?: number | null
    challenge_rating: string
    biomes_ids?: CreatureCreatebiomes_idsInput | number[]
    type_id?: number | null
    aSubTypes?: CreatureCreateaSubTypesInput | string[]
  }

  export type TraitUpdateWithoutCreatureTypesInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    attack?: NullableStringFieldUpdateOperationsInput | string | null
    is_template?: NullableBoolFieldUpdateOperationsInput | boolean | null
    cretures?: CreatureUpdateManyWithoutTraitsNestedInput
  }

  export type TraitUncheckedUpdateWithoutCreatureTypesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    attack?: NullableStringFieldUpdateOperationsInput | string | null
    is_template?: NullableBoolFieldUpdateOperationsInput | boolean | null
    cretures?: CreatureUncheckedUpdateManyWithoutTraitsNestedInput
  }

  export type TraitUncheckedUpdateManyWithoutCreatureTypesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    attack?: NullableStringFieldUpdateOperationsInput | string | null
    is_template?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type ActionUpdateWithoutCreatureTypesInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    attack?: NullableStringFieldUpdateOperationsInput | string | null
    is_template?: NullableBoolFieldUpdateOperationsInput | boolean | null
    creatures?: CreatureUpdateManyWithoutActionsNestedInput
  }

  export type ActionUncheckedUpdateWithoutCreatureTypesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    attack?: NullableStringFieldUpdateOperationsInput | string | null
    is_template?: NullableBoolFieldUpdateOperationsInput | boolean | null
    creatures?: CreatureUncheckedUpdateManyWithoutActionsNestedInput
  }

  export type ActionUncheckedUpdateManyWithoutCreatureTypesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    attack?: NullableStringFieldUpdateOperationsInput | string | null
    is_template?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type CreatureUpdateWithoutRace_relationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    creator_id?: NullableStringFieldUpdateOperationsInput | string | null
    image_uri?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    armor_class?: NullableIntFieldUpdateOperationsInput | number | null
    hit_points?: NullableIntFieldUpdateOperationsInput | number | null
    challenge_rating?: StringFieldUpdateOperationsInput | string
    biomes_ids?: CreatureUpdatebiomes_idsInput | number[]
    aSubTypes?: CreatureUpdateaSubTypesInput | string[]
    speed?: Speed_statUpdateOneWithoutId_relationNestedInput
    stats?: Creature_statsUpdateOneWithoutId_relationNestedInput
    skills?: SkillsListUpdateOneWithoutId_relationNestedInput
    resistances?: DamageTypeUpdateManyWithoutResistant_creaturesNestedInput
    immunities?: DamageTypeUpdateManyWithoutImmune_creaturesNestedInput
    vulnerabilities?: DamageTypeUpdateManyWithoutVunlerable_creaturesNestedInput
    senses?: SensesUpdateOneWithoutCreatureNestedInput
    languages?: LanguageUpdateManyWithoutCreaturesNestedInput
    actions?: ActionUpdateManyWithoutCreaturesNestedInput
    traits?: TraitUpdateManyWithoutCreturesNestedInput
    alignment_relation?: AlignmentUpdateOneWithoutCreaturesNestedInput
    type_relation?: TypeUpdateOneWithoutCreaturesNestedInput
    size_relation?: SizeUpdateOneWithoutCreatureNestedInput
    biome_relation?: BiomeUpdateManyWithoutCreaturesNestedInput
    source_relation?: SourceUpdateOneWithoutCreaturesNestedInput
  }

  export type CreatureUncheckedUpdateWithoutRace_relationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    creator_id?: NullableStringFieldUpdateOperationsInput | string | null
    image_uri?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableStringFieldUpdateOperationsInput | string | null
    source_id?: NullableIntFieldUpdateOperationsInput | number | null
    alignment_id?: NullableIntFieldUpdateOperationsInput | number | null
    armor_class?: NullableIntFieldUpdateOperationsInput | number | null
    hit_points?: NullableIntFieldUpdateOperationsInput | number | null
    challenge_rating?: StringFieldUpdateOperationsInput | string
    biomes_ids?: CreatureUpdatebiomes_idsInput | number[]
    type_id?: NullableIntFieldUpdateOperationsInput | number | null
    aSubTypes?: CreatureUpdateaSubTypesInput | string[]
    speed?: Speed_statUncheckedUpdateOneWithoutId_relationNestedInput
    stats?: Creature_statsUncheckedUpdateOneWithoutId_relationNestedInput
    skills?: SkillsListUncheckedUpdateOneWithoutId_relationNestedInput
    resistances?: DamageTypeUncheckedUpdateManyWithoutResistant_creaturesNestedInput
    immunities?: DamageTypeUncheckedUpdateManyWithoutImmune_creaturesNestedInput
    vulnerabilities?: DamageTypeUncheckedUpdateManyWithoutVunlerable_creaturesNestedInput
    senses?: SensesUncheckedUpdateOneWithoutCreatureNestedInput
    languages?: LanguageUncheckedUpdateManyWithoutCreaturesNestedInput
    actions?: ActionUncheckedUpdateManyWithoutCreaturesNestedInput
    traits?: TraitUncheckedUpdateManyWithoutCreturesNestedInput
    biome_relation?: BiomeUncheckedUpdateManyWithoutCreaturesNestedInput
  }

  export type CreatureUncheckedUpdateManyWithoutRace_relationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    creator_id?: NullableStringFieldUpdateOperationsInput | string | null
    image_uri?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableStringFieldUpdateOperationsInput | string | null
    source_id?: NullableIntFieldUpdateOperationsInput | number | null
    alignment_id?: NullableIntFieldUpdateOperationsInput | number | null
    armor_class?: NullableIntFieldUpdateOperationsInput | number | null
    hit_points?: NullableIntFieldUpdateOperationsInput | number | null
    challenge_rating?: StringFieldUpdateOperationsInput | string
    biomes_ids?: CreatureUpdatebiomes_idsInput | number[]
    type_id?: NullableIntFieldUpdateOperationsInput | number | null
    aSubTypes?: CreatureUpdateaSubTypesInput | string[]
  }

  export type CreatureUpdateWithoutResistancesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    creator_id?: NullableStringFieldUpdateOperationsInput | string | null
    image_uri?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    armor_class?: NullableIntFieldUpdateOperationsInput | number | null
    hit_points?: NullableIntFieldUpdateOperationsInput | number | null
    challenge_rating?: StringFieldUpdateOperationsInput | string
    biomes_ids?: CreatureUpdatebiomes_idsInput | number[]
    aSubTypes?: CreatureUpdateaSubTypesInput | string[]
    speed?: Speed_statUpdateOneWithoutId_relationNestedInput
    stats?: Creature_statsUpdateOneWithoutId_relationNestedInput
    skills?: SkillsListUpdateOneWithoutId_relationNestedInput
    immunities?: DamageTypeUpdateManyWithoutImmune_creaturesNestedInput
    vulnerabilities?: DamageTypeUpdateManyWithoutVunlerable_creaturesNestedInput
    senses?: SensesUpdateOneWithoutCreatureNestedInput
    languages?: LanguageUpdateManyWithoutCreaturesNestedInput
    actions?: ActionUpdateManyWithoutCreaturesNestedInput
    traits?: TraitUpdateManyWithoutCreturesNestedInput
    alignment_relation?: AlignmentUpdateOneWithoutCreaturesNestedInput
    race_relation?: CreatureRaceUpdateOneWithoutCreaturesNestedInput
    type_relation?: TypeUpdateOneWithoutCreaturesNestedInput
    size_relation?: SizeUpdateOneWithoutCreatureNestedInput
    biome_relation?: BiomeUpdateManyWithoutCreaturesNestedInput
    source_relation?: SourceUpdateOneWithoutCreaturesNestedInput
  }

  export type CreatureUncheckedUpdateWithoutResistancesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    creator_id?: NullableStringFieldUpdateOperationsInput | string | null
    image_uri?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableStringFieldUpdateOperationsInput | string | null
    race_id?: NullableIntFieldUpdateOperationsInput | number | null
    source_id?: NullableIntFieldUpdateOperationsInput | number | null
    alignment_id?: NullableIntFieldUpdateOperationsInput | number | null
    armor_class?: NullableIntFieldUpdateOperationsInput | number | null
    hit_points?: NullableIntFieldUpdateOperationsInput | number | null
    challenge_rating?: StringFieldUpdateOperationsInput | string
    biomes_ids?: CreatureUpdatebiomes_idsInput | number[]
    type_id?: NullableIntFieldUpdateOperationsInput | number | null
    aSubTypes?: CreatureUpdateaSubTypesInput | string[]
    speed?: Speed_statUncheckedUpdateOneWithoutId_relationNestedInput
    stats?: Creature_statsUncheckedUpdateOneWithoutId_relationNestedInput
    skills?: SkillsListUncheckedUpdateOneWithoutId_relationNestedInput
    immunities?: DamageTypeUncheckedUpdateManyWithoutImmune_creaturesNestedInput
    vulnerabilities?: DamageTypeUncheckedUpdateManyWithoutVunlerable_creaturesNestedInput
    senses?: SensesUncheckedUpdateOneWithoutCreatureNestedInput
    languages?: LanguageUncheckedUpdateManyWithoutCreaturesNestedInput
    actions?: ActionUncheckedUpdateManyWithoutCreaturesNestedInput
    traits?: TraitUncheckedUpdateManyWithoutCreturesNestedInput
    biome_relation?: BiomeUncheckedUpdateManyWithoutCreaturesNestedInput
  }

  export type CreatureUncheckedUpdateManyWithoutResistancesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    creator_id?: NullableStringFieldUpdateOperationsInput | string | null
    image_uri?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableStringFieldUpdateOperationsInput | string | null
    race_id?: NullableIntFieldUpdateOperationsInput | number | null
    source_id?: NullableIntFieldUpdateOperationsInput | number | null
    alignment_id?: NullableIntFieldUpdateOperationsInput | number | null
    armor_class?: NullableIntFieldUpdateOperationsInput | number | null
    hit_points?: NullableIntFieldUpdateOperationsInput | number | null
    challenge_rating?: StringFieldUpdateOperationsInput | string
    biomes_ids?: CreatureUpdatebiomes_idsInput | number[]
    type_id?: NullableIntFieldUpdateOperationsInput | number | null
    aSubTypes?: CreatureUpdateaSubTypesInput | string[]
  }

  export type CreatureUpdateWithoutImmunitiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    creator_id?: NullableStringFieldUpdateOperationsInput | string | null
    image_uri?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    armor_class?: NullableIntFieldUpdateOperationsInput | number | null
    hit_points?: NullableIntFieldUpdateOperationsInput | number | null
    challenge_rating?: StringFieldUpdateOperationsInput | string
    biomes_ids?: CreatureUpdatebiomes_idsInput | number[]
    aSubTypes?: CreatureUpdateaSubTypesInput | string[]
    speed?: Speed_statUpdateOneWithoutId_relationNestedInput
    stats?: Creature_statsUpdateOneWithoutId_relationNestedInput
    skills?: SkillsListUpdateOneWithoutId_relationNestedInput
    resistances?: DamageTypeUpdateManyWithoutResistant_creaturesNestedInput
    vulnerabilities?: DamageTypeUpdateManyWithoutVunlerable_creaturesNestedInput
    senses?: SensesUpdateOneWithoutCreatureNestedInput
    languages?: LanguageUpdateManyWithoutCreaturesNestedInput
    actions?: ActionUpdateManyWithoutCreaturesNestedInput
    traits?: TraitUpdateManyWithoutCreturesNestedInput
    alignment_relation?: AlignmentUpdateOneWithoutCreaturesNestedInput
    race_relation?: CreatureRaceUpdateOneWithoutCreaturesNestedInput
    type_relation?: TypeUpdateOneWithoutCreaturesNestedInput
    size_relation?: SizeUpdateOneWithoutCreatureNestedInput
    biome_relation?: BiomeUpdateManyWithoutCreaturesNestedInput
    source_relation?: SourceUpdateOneWithoutCreaturesNestedInput
  }

  export type CreatureUncheckedUpdateWithoutImmunitiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    creator_id?: NullableStringFieldUpdateOperationsInput | string | null
    image_uri?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableStringFieldUpdateOperationsInput | string | null
    race_id?: NullableIntFieldUpdateOperationsInput | number | null
    source_id?: NullableIntFieldUpdateOperationsInput | number | null
    alignment_id?: NullableIntFieldUpdateOperationsInput | number | null
    armor_class?: NullableIntFieldUpdateOperationsInput | number | null
    hit_points?: NullableIntFieldUpdateOperationsInput | number | null
    challenge_rating?: StringFieldUpdateOperationsInput | string
    biomes_ids?: CreatureUpdatebiomes_idsInput | number[]
    type_id?: NullableIntFieldUpdateOperationsInput | number | null
    aSubTypes?: CreatureUpdateaSubTypesInput | string[]
    speed?: Speed_statUncheckedUpdateOneWithoutId_relationNestedInput
    stats?: Creature_statsUncheckedUpdateOneWithoutId_relationNestedInput
    skills?: SkillsListUncheckedUpdateOneWithoutId_relationNestedInput
    resistances?: DamageTypeUncheckedUpdateManyWithoutResistant_creaturesNestedInput
    vulnerabilities?: DamageTypeUncheckedUpdateManyWithoutVunlerable_creaturesNestedInput
    senses?: SensesUncheckedUpdateOneWithoutCreatureNestedInput
    languages?: LanguageUncheckedUpdateManyWithoutCreaturesNestedInput
    actions?: ActionUncheckedUpdateManyWithoutCreaturesNestedInput
    traits?: TraitUncheckedUpdateManyWithoutCreturesNestedInput
    biome_relation?: BiomeUncheckedUpdateManyWithoutCreaturesNestedInput
  }

  export type CreatureUncheckedUpdateManyWithoutImmunitiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    creator_id?: NullableStringFieldUpdateOperationsInput | string | null
    image_uri?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableStringFieldUpdateOperationsInput | string | null
    race_id?: NullableIntFieldUpdateOperationsInput | number | null
    source_id?: NullableIntFieldUpdateOperationsInput | number | null
    alignment_id?: NullableIntFieldUpdateOperationsInput | number | null
    armor_class?: NullableIntFieldUpdateOperationsInput | number | null
    hit_points?: NullableIntFieldUpdateOperationsInput | number | null
    challenge_rating?: StringFieldUpdateOperationsInput | string
    biomes_ids?: CreatureUpdatebiomes_idsInput | number[]
    type_id?: NullableIntFieldUpdateOperationsInput | number | null
    aSubTypes?: CreatureUpdateaSubTypesInput | string[]
  }

  export type CreatureUpdateWithoutVulnerabilitiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    creator_id?: NullableStringFieldUpdateOperationsInput | string | null
    image_uri?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    armor_class?: NullableIntFieldUpdateOperationsInput | number | null
    hit_points?: NullableIntFieldUpdateOperationsInput | number | null
    challenge_rating?: StringFieldUpdateOperationsInput | string
    biomes_ids?: CreatureUpdatebiomes_idsInput | number[]
    aSubTypes?: CreatureUpdateaSubTypesInput | string[]
    speed?: Speed_statUpdateOneWithoutId_relationNestedInput
    stats?: Creature_statsUpdateOneWithoutId_relationNestedInput
    skills?: SkillsListUpdateOneWithoutId_relationNestedInput
    resistances?: DamageTypeUpdateManyWithoutResistant_creaturesNestedInput
    immunities?: DamageTypeUpdateManyWithoutImmune_creaturesNestedInput
    senses?: SensesUpdateOneWithoutCreatureNestedInput
    languages?: LanguageUpdateManyWithoutCreaturesNestedInput
    actions?: ActionUpdateManyWithoutCreaturesNestedInput
    traits?: TraitUpdateManyWithoutCreturesNestedInput
    alignment_relation?: AlignmentUpdateOneWithoutCreaturesNestedInput
    race_relation?: CreatureRaceUpdateOneWithoutCreaturesNestedInput
    type_relation?: TypeUpdateOneWithoutCreaturesNestedInput
    size_relation?: SizeUpdateOneWithoutCreatureNestedInput
    biome_relation?: BiomeUpdateManyWithoutCreaturesNestedInput
    source_relation?: SourceUpdateOneWithoutCreaturesNestedInput
  }

  export type CreatureUncheckedUpdateWithoutVulnerabilitiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    creator_id?: NullableStringFieldUpdateOperationsInput | string | null
    image_uri?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableStringFieldUpdateOperationsInput | string | null
    race_id?: NullableIntFieldUpdateOperationsInput | number | null
    source_id?: NullableIntFieldUpdateOperationsInput | number | null
    alignment_id?: NullableIntFieldUpdateOperationsInput | number | null
    armor_class?: NullableIntFieldUpdateOperationsInput | number | null
    hit_points?: NullableIntFieldUpdateOperationsInput | number | null
    challenge_rating?: StringFieldUpdateOperationsInput | string
    biomes_ids?: CreatureUpdatebiomes_idsInput | number[]
    type_id?: NullableIntFieldUpdateOperationsInput | number | null
    aSubTypes?: CreatureUpdateaSubTypesInput | string[]
    speed?: Speed_statUncheckedUpdateOneWithoutId_relationNestedInput
    stats?: Creature_statsUncheckedUpdateOneWithoutId_relationNestedInput
    skills?: SkillsListUncheckedUpdateOneWithoutId_relationNestedInput
    resistances?: DamageTypeUncheckedUpdateManyWithoutResistant_creaturesNestedInput
    immunities?: DamageTypeUncheckedUpdateManyWithoutImmune_creaturesNestedInput
    senses?: SensesUncheckedUpdateOneWithoutCreatureNestedInput
    languages?: LanguageUncheckedUpdateManyWithoutCreaturesNestedInput
    actions?: ActionUncheckedUpdateManyWithoutCreaturesNestedInput
    traits?: TraitUncheckedUpdateManyWithoutCreturesNestedInput
    biome_relation?: BiomeUncheckedUpdateManyWithoutCreaturesNestedInput
  }

  export type CreatureUncheckedUpdateManyWithoutVulnerabilitiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    creator_id?: NullableStringFieldUpdateOperationsInput | string | null
    image_uri?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableStringFieldUpdateOperationsInput | string | null
    race_id?: NullableIntFieldUpdateOperationsInput | number | null
    source_id?: NullableIntFieldUpdateOperationsInput | number | null
    alignment_id?: NullableIntFieldUpdateOperationsInput | number | null
    armor_class?: NullableIntFieldUpdateOperationsInput | number | null
    hit_points?: NullableIntFieldUpdateOperationsInput | number | null
    challenge_rating?: StringFieldUpdateOperationsInput | string
    biomes_ids?: CreatureUpdatebiomes_idsInput | number[]
    type_id?: NullableIntFieldUpdateOperationsInput | number | null
    aSubTypes?: CreatureUpdateaSubTypesInput | string[]
  }

  export type GPTMessageCreateManyMessage_historyInput = {
    number: number
    text: string
    role: string
  }

  export type GPTMessageUpdateWithoutMessage_historyInput = {
    number?: IntFieldUpdateOperationsInput | number
    text?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
  }

  export type GPTMessageUncheckedUpdateWithoutMessage_historyInput = {
    number?: IntFieldUpdateOperationsInput | number
    text?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
  }

  export type GPTMessageUncheckedUpdateManyWithoutMessage_historyInput = {
    number?: IntFieldUpdateOperationsInput | number
    text?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
  }

  export type AdventureKeywordCreateManyAdventureInput = {
    keyword_id: string
  }

  export type AdventureKeywordUpdateWithoutAdventureInput = {
    keyword?: KeywordUpdateOneRequiredWithoutAdventuresNestedInput
  }

  export type AdventureKeywordUncheckedUpdateWithoutAdventureInput = {
    keyword_id?: StringFieldUpdateOperationsInput | string
  }

  export type AdventureKeywordUncheckedUpdateManyWithoutAdventureInput = {
    keyword_id?: StringFieldUpdateOperationsInput | string
  }

  export type KeywordCreateManyGenreInput = {
    id?: string
    name: string
  }

  export type AdventureCreateManyGenreInput = {
    id?: string
    title: string
    planned_parties: number
    creator_id: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type KeywordUpdateWithoutGenreInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    adventures?: AdventureKeywordUpdateManyWithoutKeywordNestedInput
  }

  export type KeywordUncheckedUpdateWithoutGenreInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    adventures?: AdventureKeywordUncheckedUpdateManyWithoutKeywordNestedInput
  }

  export type KeywordUncheckedUpdateManyWithoutGenreInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type AdventureUpdateWithoutGenreInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    planned_parties?: IntFieldUpdateOperationsInput | number
    creator_id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    keywords?: AdventureKeywordUpdateManyWithoutAdventureNestedInput
  }

  export type AdventureUncheckedUpdateWithoutGenreInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    planned_parties?: IntFieldUpdateOperationsInput | number
    creator_id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    keywords?: AdventureKeywordUncheckedUpdateManyWithoutAdventureNestedInput
  }

  export type AdventureUncheckedUpdateManyWithoutGenreInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    planned_parties?: IntFieldUpdateOperationsInput | number
    creator_id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdventureKeywordCreateManyKeywordInput = {
    adventure_id: string
  }

  export type AdventureKeywordUpdateWithoutKeywordInput = {
    adventure?: AdventureUpdateOneRequiredWithoutKeywordsNestedInput
  }

  export type AdventureKeywordUncheckedUpdateWithoutKeywordInput = {
    adventure_id?: StringFieldUpdateOperationsInput | string
  }

  export type AdventureKeywordUncheckedUpdateManyWithoutKeywordInput = {
    adventure_id?: StringFieldUpdateOperationsInput | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}